<!-- manpage 3vmusb -->
            <!--  adc command reference -->
            
<refentry id="vmusb3-adc">
     <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle>adc</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>adc</refname>
     <refpurpose>Create/configure CAEN V775, V785, V792, V862 modules.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
adc create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
	<command>
caenv965 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
adc config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
caenv956 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
adc cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
caenv956 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	This command creates, configures and retrieves the configuration of
        CAEN V775, V785, V792, and V862, V965 digitizer modules.
     </para>
     <para>
         Use the <command>create</command> subcommand to create a new adc
         providing it with a unique <parameter>name</parameter> that will
         be used to identify it in future commands.  The <parameter>base</parameter>
         parameter is the base address of the module as set in the module rotary
         switches.
     </para>
      <para>
         Use the <command>config</command> subcommand to configure
         a module named <parameter>name</parameter>  the <parameter>option</parameter>
         options and legal values are described in the section OPTIONS below.
      </para>
      <para>
         The <command>cget</command> subcommand returns as its value the configuration
         of the module <parameter>name</parameter>.  The configuration is
         returned as a list of two element sublists where each sublist
         contains, in order, an option from OPTIONS below, and its value.
         Note that some values may themselves be lists.
      </para>
      <para>
        When used with the CAEN V965 or other dual range digitizers via the
	caenv956 command, each parameter specified in the <varname>adcChannels</varname>
	array will result in two SpecTcl channels and corresponding raw spectra.
	The first will have
	<literal>.h</literal> appended to the name and will be the high range
	conversion while the second will have <literal>.l</literal> appended to the
	name and will be the low range value.
      </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><command>-base</command> <replaceable>value</replaceable></term>
	    <listitem>
		<para>
                  Allows you to reconfigure the base address of a module.
		</para>
	    </listitem>
	 </varlistentry>
         <varlistentry>
            <term><command>-commonstop</command> <replaceable>value</replaceable></term>
            <listitem>
                <para>
                    This is only usable with a V775.  <parameter>value</parameter>
                    is a boolean value which, if true runs the module in common
                    stop mode.  If false (the default), the module is run in common
                    start mode.
                </para>
            </listitem>
        </varlistentry>
         <varlistentry>
            <term><command>-thresholds</command> <replaceable>values</replaceable></term>
            <listitem>
               <para>
                  The value is a list of 32 values that are the module 
                  thresholds.  Unless <option>-smallthresholds</option> has been
                  configured to be <literal>true</literal>, these values
                  are multiplied by 16 before being applied as the channel
                  threshold values.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-smallthresholds</command> <replaceable>bool</replaceable></term>
            <listitem>
               <para>
                  The value is a boolean (e.g. <emphasis>on</emphasis> or
                  <emphasis>off</emphasis>).
                  A true boolean means that the threshold is applied as is
                  a false boolean means the threshold value is multiplied by 16
                  and then applied.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-ipl</command> <replaceable>0-7</replaceable></term>
            <listitem>
               <para>
                  The interrupt priority level the module should use to request
                  a VME bus interrupt.  This defaults to 6 and should be set to
                  zero to disable interrupts.  Normally interrupts will be used
                  to trigger an interrupt triggered stack.  The default of 6
                  is historical in nature, in most cases for,
                  the default should be overridden to zero.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-vector</command> <replaceable>0-255</replaceable></term>
            <listitem>
               <para>
                  The interrupt vector the module should use. This is an integer
                  and defaults to 0x80.  The vector value is ignored if the
                  module interrupts are disabled.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-highwater</command> <replaceable>0-31</replaceable></term>
            <listitem>
               <para>
                  Defines how many events the module should accumulate before
                  it interrutps.  A value of zero also disables interrupts.
                  The default value is 24 evetns.  This is best suited for
                  singles applications where allowing the module to accumulate
                  a few events before being read is a good thing.
                  This value will be ignored if the <option>-ipl</option> option
                  has been configured to zero as that also disables module interrupts.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-geo</command> <replaceable>0-31</replaceable></term>
            <listitem>
               <para>
                  Defines the geographical address that will be set in the module.
                  If the module has a PAUX connector, this must be set to be
                  the module's physical location in the crate.  This option must
                  be correctly programmed in order to help SpecTcl form a mapping
                  between data values and parameter names.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-fastclear</command> <replaceable>value</replaceable></term>
            <listitem>
               <para>
                  Defines the fast clear window for the module.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-supressrange</command> <replaceable>bool</replaceable></term>
            <listitem>
               <para>
                  If <literal>true</literal> the module will supress overflows
                  and underthreshold conversions.  If not all channels will
                  supply data for an event.  In most cases, this should be set to
                  <literal>false</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-timescale</command> <replaceable>ns</replaceable></term>
            <listitem>
               <para>
                  Sets the full scale range of the module if it is a V775.
                  If the module is not a V775 TDC, this configuration parameter
                  is silently ignored (the hardware allows the software to
                  determine the module type).  <parameter>ns</parameter> is the
                  range of the TDC in nanoseconds and must be between
                  <literal>140</literal> and <literal>1200</literal>.
               </para>
            </listitem>
         </varlistentry>
	 <varlistentry>
	   <term><command>-iped</command> <replaceable>value</replaceable></term>
	   <listitem>
	      <para>
                 Sets the Iped register.  See section 4.34 of e.g. the
		 CAEN V965 manual.   This register controls the amount of charge
		 initially injected into the conversion circuit and is used to
		 compensate for leakage current that may lower the conversion of
		 a signal during the gate.  The default value is
		 <literal>180</literal>.  Valid values
		 are <literal>0 - 255</literal>, however see the description of
		 the Iped register and pedestal injections in the manual.
	      </para>
            </listitem>
         </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Sample ADC commands</title>
         <programlisting>
adc create adc1    0x04000000
adc config adc1    -geo 12 -supressrange off  -ipl 0 -vector 0
         </programlisting>
      </example>
      <para>
         Defines a module with base address 0x04000000 to be in geographical
         address 12.  Range supression and interrupts are disabled.
      </para>
  </refsect1>
  <refsect1>
      <title>NOTES</title>
      <para>
         This command can actually initialize/configure V775 TDCs and
         V792, V862 QDCs in addition to the V785 ADC.
      </para>
  </refsect1>
</refentry>
   <!-- caenchain command - aggregate 785's into CBLT chains -->
            
   <refentry id="vmusb3-caenchain">
     <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
     <refmeta>
        <refentrytitle>caenchain</refentrytitle>
        <manvolnum>3vmusb</manvolnum>
        <refmiscinfo class='empty'></refmiscinfo>
     </refmeta>
     <refnamediv>
        <refname>caenchain</refname>
        <refpurpose>Aggregate adc modules into CBLT readout chains.</refpurpose>
     </refnamediv>
     
     <refsynopsisdiv>
       <cmdsynopsis>
   	<command>
caenchain create <replaceable>name</replaceable>
   	</command>
       </cmdsynopsis>
           <cmdsynopsis>
               <command>
caenchain config <replaceable>name option value...</replaceable>
               </command>
         </cmdsynopsis>
             <cmdsynopsis>
                 <command>
caenchain cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         
     </refsynopsisdiv>
     <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The CAEN family of 32 channel digitizers (V775, V785, V792, V862)
            can be aggreaged into CBLT readout chains.  A CBLT readout chain can
            then be read at high performance using a single block read operation.
        </para>
        <para>
            A CBLT chain consists of a set of at least two modules in consecutive
            VME bus slots.  From the point of view of defining the crate the
            left most and right most modules are special.  (See OPTIONS below,
            the <option>-module</option> option). 
        </para>
        <para>
            CBLT chains require an additional base address that is used to read
            the modules.  This address is also used as a multicast address to
            do a simultaneous clear of all modules in the chain as the readout
            is initialized (at the beginning of a run). 
        </para>
     </refsect1>
     <refsect1>
        <title>
   	OPTIONS
        </title>
        <variablelist>
   	<varlistentry>
   	    <term><option>-base</option> <replaceable>integer</replaceable></term>
   	    <listitem>
   		<para>
                  Provides the base address to be used to program the CBLT
                  address of the module.  Only the top two hexadecimal digits
                  of an 8 digit hexadecimal address should be non zero. e.g.
                  <literal>0x12000000</literal> is ok, but
                  <literal>0x12340000</literal> is not.
   		</para>
   	    </listitem>
   	</varlistentry>
        <varlistentry>
            <term><option>-modules</option> <replaceable>module-names</replaceable></term>
            <listitem>
            <para>
               Supplies the list of modules that should make up the chain. The
               firs module must be the left most in the chain, the last module the
               right most.  Other than that order is unimportant, however note that
               CBLT readouts always will go from left to right in VME crate. I therefore
               suggest that you supply the modules in left to right order.
               The modules must be a valid TCL list, e.g.:
               <literal>-modules [list adc1 adc2 adc3]</literal> is ok,
               <literal>-modules adc1 adc2 adc3</literal> is not.
            </para>
            </listitem>
         </varlistentry>
        </variablelist>
     </refsect1>

     <refsect1>
        <title>EXAMPLES</title>
        <para>
            The example below takes three ADC modules and aggregates them
            into a chain for readout.
            <example>
               <title>Using the <command>caenchain</command> command.</title>
               <programlisting>
adc create adc1    0x04000000
adc config adc1    -geo 12 -supressrange off  -ipl 0 -vector 0

adc create adc2    0x05000000
adc config adc2    -geo 13 -supressrange off  -ipl 0 -vector 0

adc create adc3    0x06000000
adc config adc3    -geo 14 -supressrange off -ipl 0 -vector 0


caenchain create chain

caenchain config chain -base 0x10000000 -modules [list adc1 adc2 adc3]
               </programlisting>
            </example>
        </para>
     </refsect1>

   </refentry>
   <!-- VM USB control and scaler readout -->
   
         <refentry id="vmusb3_vmusb">
            <refentryinfo>
                <author>
                    <personname>
                        <firstname>Ron</firstname>
                        <surname>Fox</surname>
                    </personname>
                </author>
                <productname>NSCLDAQ</productname>
                <productnumber></productnumber>
              </refentryinfo>
           <refmeta>
              <refentrytitle id='vmusb3_vmusb_title'>vmusb</refentrytitle>
              <manvolnum>3vmusb</manvolnum>
              <refmiscinfo class='empty'></refmiscinfo>
           </refmeta>
           <refnamediv>
              <refname>vmusb</refname>
              <refpurpose>Control VM-USB resources and read internal scalers</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
                <command>
vmusb create name ?options?
                </command>
             </cmdsynopsis>
            <cmdsynopsis>
                <command>
vmusb config name ?options?
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vmusb cget name
                </command>
            </cmdsynopsis>

           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
                The <command>vmusb</command> command can be used in the
                <filename>daqconfig</filename> configuration file to control
                the internal reasources of the VM-USB as well as to enable
                the readout of its pair of scalers.  The VM-USB provides two outputs
                named O1 and O2 as well as a pair of gate and delay generators
                (DGGA and DGGB), and scalers A and B. Four LEDs round out the
                resources controlled by this command.
              </para>
              <para>
                In order to use a vmusb module to configure the controller, you
                must include it in a stack, even if you are not using reading the
                scalers in the VM-USB.  This is because it is the inclusion of
                a module in a stack that causes its initialization methods to
                be invoked, and it is there that teh vmusb module configures
                its resources.
              </para>
              <para>
                More information about the VM-USB and its resources can be found
                in sections 3.4.4 through 3.4.8 and section 1 of the VM-USB manual.
              </para>
              <para>
                The configuration options are described in the OPTIONS section
                below.
              </para>
           </refsect1>
           <refsect1>
              <title>
                 OPTIONS
              </title>
              <variablelist>
                <!-- NIM output configuration  -->
                <varlistentry>
                    <term><option>-nimo1</option></term>
                    <listitem>
                        <para>
                            Determines, along with the options
                            <option>-inverto1</option> and
                            <option>-latcho1</option> the behavior of NIM
                            output O1.  This can be any of the following values:
                            <literal>busy, trigger, busrequest, eventdatatobuvffer,
                            dgga, endevent</literal> or <literal>usbtrigger</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-inverto1</option></term>
                    <listitem>
                        <para>
                            Inverts the sense of the O1 nim output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latcho1</option></term>
                    <listitem>
                        <para>
                            Latches the O1 asserted when the condition that asserts
                            it is met.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-nimo2</option></term>
                    <listitem>
                        <para>
                            Along with the options
                            <option>-inverto2</option> and
                            <option>-latcho2</option>, controls when the NIM
                            O2 output is asserted.  This can be any of:
                            <literal>usbtrigger, vmecommand, vmeas,
                            eventdataobuffer, dgga, dggb,</literal> or
                            <literal>endevent</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-inverto2</option></term>
                    <listitem>
                        <para>
                            Inverts the sense of the NIM O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latcho2</option></term>
                    <listitem>
                        <para>
                            Latches the state of the O2 NIM output when the
                            condition that would assert it is met.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-topyellow</option></term>
                    <listitem>
                        <para>
                            Together with <option>-inverttopyellow</option>
                            and <option>-latchtopyellow</option> determines
                            when the top Yellow LED of the VM-USB is lit.
                            This can be any of the following values:
                            <literal>ofifonotempty, infifonotempy, scaler
                            infifofull, berr, vmebr,</literal> or
                            <literal>vmebg</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-inverttopyellow</option></term>
                    <listitem>
                        <para>
                            Inverts the sense of the top yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchtopyellow</option></term>
                    <listitem>
                        <para>
                            Latches the top yellow LED in the on state when the
                            condition is met that would light it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-red</option></term>
                    <listitem>
                        <para>
                            Together with the <option>-invertred</option> and
                            <option>-latchred</option> options controls the
                            when the red LED on the VM-USB front panel is lit.
                            This can be one of the following value:
                            <literal>trigger, nimi1, nimi2, busy, dtack, berr, vmebr</literal>
                            or <literal>vmebg</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-invertred</option></term>
                    <listitem>
                        <para>
                            Inverts the state of the red LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchred</option></term>
                    <listitem>
                        <para>
                            Latches the red led on when the condition to light
                            it has been met.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-green</option></term>
                    <listitem>
                        <para>
                            Together with the <option>-invertgreen</option>
                            and <option>-latchgreen</option>, determines when
                            the green LED is lit.  This can be one of the following
                            values:
                            <literal>acquire, stacknotempty, eventready,
                            trigger, dtack, berr, vmebr</literal> or
                            <literal>vmebg</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-invertgreen</option></term>
                    <listitem>
                        <para>
                            Inverts the condition that lights the green LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchgreen</option></term>
                    <listitem>
                        <para>
                            If true, the green LED is latched in the on state
                            once the condition that would light it is met.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-bottomyellow</option></term>
                    <listitem>
                        <para>
                            Together with <option>-invertbottomyellow</option>
                            and <option>-latchbottomyellow</option> determines
                            when the bottom yellow LED is lit.  The value of this
                            option can be any of the following values:
                            <literal>notslot1, usbtrigger, usbreset, berr, dtack, vmebr</literal>
                            or <literal>vmebg</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-invertbottomyellow</option></term>
                    <listitem>
                        <para>
                            Inverts the condition that lights the bottom yellow
                            LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchbottomyellow</option></term>
                    <listitem>
                        <para>
                            Latches the bottom yellow LED in the lit state
                            once the condition is met to light it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-readscalers</option></term>
                    <listitem>
                        <para>
                            If this is true the two scalers A and B will
                            be read by the stack in which the vmusb is
                            module is put.  The A scaler is read first followed
                            by the B scaler.  See <option>-scalera</option>
                            and <option>-scalerb</option> below which define
                            when each scaler increments.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-incremental</option></term>
                    <listitem>
                        <para>
                            This option is ignored unless <option>-readscalers</option>
                            is true.  If <option>-incremental</option> is true,
                            scalers are cleared after they are read.
                            Note that since the VM-USB has no mechanism to
                            atomically read and clear scalers, counts can be lost
                            between the read and clear.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-scalera</option></term>
                    <listitem>
                        <para>
                            Determines the condition that increments scaler A.
                            This can be one of the following values:
                            <literal>dgga, nimi1, nimi2</literal> or <literal>event</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-scalerb</option></term>
                    <listitem>
                        <para>
                            Determines the condition that increments scaler B.
                            This can be one of the following values:
                            <literal>carry,, nimi1, nimi2</literal> or
                            <literal>event</literal>.
                            The <literal>carry</literal> value means that
                            scaler B is incremented when scaler A overflows.
                            This allows both scalers to be combined into a single
                            64 bit scaler that is incremented by the condition
                            defined in the <option>-scalera</option> option.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-dgga</option></term>
                    <listitem>
                        <para>
                            Determines the condition that causes the signal to be
                            generated by the DGGA device. Options are:
                            <literal>off</literal>, <literal>nimi1</literal>,
                            <literal>nimi2</literal>,<literal>trigger</literal>,
                            <literal>endofevent</literal>,<literal>usbtrigger</literal>, 
                            and <literal>pulser</literal>. The default option is <literal>pulser</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-dggb</option></term>
                    <listitem>
                        <para>
                            Determines the condition that causes the signal to be
                            generated by the DGGB device. Options are:
                            <literal>off</literal>, <literal>nimi1</literal>,
                            <literal>nimi2</literal>,<literal>trigger</literal>,
                            <literal>endofevent</literal>,<literal>usbtrigger</literal>, 
                            and <literal>pulser</literal>. The default option is <literal>nimi2</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-widtha</option></term>
                    <listitem>
                        <para>
                            Determines the width of the gate produced by dgga in units of 12.5 ns.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-delaya</option></term>
                    <listitem>
                        <para>
                            Determines the amount of time in units of 12.5 ns to delay the gate
                            output of dgga once it has been triggered.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-widthb</option></term>
                    <listitem>
                        <para>
                            Determines the width of the gate produced by dggb in units of 12.5 ns.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-delayb</option></term>
                    <listitem>
                        <para>
                            Determines the amount of time in units of 12.5 ns to delay the gate
                            output of dggb once it has been triggered.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-mixedbuffers</option></term>
                    <listitem>
                        <para>
                            Sets whether scaler and event data can coexist in the same buffer.
                            The default is false.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-spanbuffers</option></term>
                    <listitem>
                        <para>
                            Sets whether event data can span buffer boundaries. Default is false. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-forcescalerdump</option></term>
                    <listitem>
                        <para>
                            If set to true, the VM-USB will immediately output scaler data 
                            once a scaler stack is executed. Default is false.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-busreqlevel</option></term>
                    <listitem>
                        <para>
                            Determines the bus request level that the VMUSB will use for itself
                            when it requests ownership of the bus. The valid values are any in
                            the range [0,7] and the default value is 4.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-optionalheader</option></term>
                    <listitem>
                        <para>
                            Determines whether a second optional header word will follow the first
                            buffer header word. When present, this extra header specifies the number
                            of words in the buffer. The default value is false.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-bufferlength</option></term>
                    <listitem>
                        <para>
                            Determines size of the internal buffer used by the VMUSB in units of 
                            words. The VMUSB fills the buffer before outputting data on a 
                            usb_bulk_read so a smaller buffer size is useful for low data rates. 
                            The optional values are: 13k, 8k, 4k, 2k, 1k, 512, 256, 128, 64, and evtcount.  
                            The evtcount option depends on the value of the -eventsperbuffer option.
                            The default value is 13k.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-eventsperbuffer</option></term>
                    <listitem>
                        <para>
                          If the -bufferlength option is set to evtcount, this determines how many
                          events must occur before transferring data to the FIFO for readout. The values
                          can be any in the range [1,4095]. The default value is 1.
                        </para>
                    </listitem>
                </varlistentry>
                
   
              </variablelist>
           </refsect1>
   
         </refentry>
   
   <!-- SIS 3300 simplified driver. -->
      <refentry id="vmusb3-sis3300">
	<refentryinfo>
	  <author>
		  <personname>
			  <firstname>Ron</firstname>
			  <surname>Fox</surname>
		  </personname>
	  </author>
	  <productname>NSCLDAQ</productname>
	  <productnumber></productnumber>
	</refentryinfo>
	<refmeta>
	   <refentrytitle id='vmusb3-sis3300-title'>sis3300</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
	   <refmiscinfo class='empty'></refmiscinfo>
	</refmeta>
	<refnamediv>
	   <refname>sis3300</refname>
	   <refpurpose>Simplified sis3300 support.</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	    <command>
package require sis330x
	   </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
sis330x <replaceable>name ?options...?</replaceable>
	       </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
<replaceable>name</replaceable> configure <replaceable>option value ?...?</replaceable>
	       </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
addtcldriver <replaceable>name</replaceable>
	       </command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
	       This driver provides a simplified driver for the SIS 3300/3301
	       FADC family.  The driver provides three modes of operation for
	       the device:
	   </para>
	   <variablelist>
	       <varlistentry>
		   <term>start</term>
		   <listitem>
		       <para>
			 In start mode an external start input is required to start
			 digitization.  Digitization stops either when the desired
			 number of samples have been acquired or when an external
			 stop input is provided. 
		       </para>
		       <para>
			 The start input is the second from the top (input 3).
			 The stop input is the third from the top (input 2).
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>stop</term>
		   <listitem>
		       <para>
			 In stop mode, the digitizer is continuously digitizing.
			 Digitization then stops  when an NIM pulse is presented
			 to input 2 (third from the top).
		       </para>
		       <para>
			 Note that in stop mode, the actual acquired data my
			 not be at the beginning of the digitizer data.
			 See <literal>OUPUT DATA FORMAT</literal> below for
			 more information.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>gate</term>
		   <listitem>
		       <para>
			 In gate mode, a gate signal is presented to
			 the start input (input 3 second from the top).
			 digitization begins on the falling edge of the gate
			 and ends on the rising edge of the gate, or when the
			 maximum number of samples has been acquired (if
			 the gate is wider than the time required to digitize
			 the maximum number of samples).
		       </para>
		   </listitem>
	       </varlistentry>
	   </variablelist>
	</refsect1>
	<refsect1>
	   <title>
	      OPTIONS
	   </title>
	   <variablelist>
	       <varlistentry>
		   <term><option>-base</option> <replaceable>base-address</replaceable></term>
		   <listitem>
		       <para>
			 Sets the VME base address of the module.  For the 3300,
			 this is set via jumpers that control the top four bits
			 of VME address.  For the 3301, this is set via a pair
			 of rotary switches that allow the top eight bits
			 of the VME address to be set.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-clock</option> <replaceable>source-spec</replaceable></term>
		   <listitem>
		       <para>
			 Sets the digitizer clock source.  This can be one of
			 several internal clock frequencies available or
			 one the external clock modes.
			 The default clock source is <literal>100Mhz</literal>
			 The valid clock
			 sources are:
		       </para>
		       <variablelist>
			 <varlistentry>
			     <term>100Mhz, 50Mhz, 25Mhz, 12.5Mhz, 6.25Mhz or 3.125Mhz</term>
			     <listitem>
				 <para>
				   Selects an internal clock source at the
				   specified frequency.  The default value is
				 </para>
			     </listitem>
			 </varlistentry>
			 <varlistentry>
			     <term><literal>external</literal></term>
			     <listitem>
				 <para>
				   The clock is provided as an external symmetric
				   pulse train on input 4 (top input).  See
				   section 2.5.2 of the SIS330x manual
				   for information about the signal
				   requriements for this clock.
				 </para>
			     </listitem>
			 </varlistentry>
			 <varlistentry>
			     <term><literal>random</literal></term>
			     <listitem>
				 <para>
				   Allows arbitray clock trains or slow clocks.
				   The internal logic runs at 100Mhz.  On each
				   falling edge of the external clock, data
				   are digitized by the next falling edge of the
				   internal clock and transferred to the buffer
				   memory 10 interal clocks later.
				 </para>
			     </listitem>
			 </varlistentry>
			 <varlistentry>
			     <term>hira</term>
			     <listitem>
				 <para>
				   Runs in HiRa random clock mode.  This is suitable
				   for use with the Wash-U multiplexing front end boards.
				   Note that new applications should make use
				   of XLM boards with integrated digitizers
				   rather than the XLM + SIS3301
				   pair.
				 </para>
			     </listitem>
			 </varlistentry>
		       </variablelist>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-mode</option> <literal>start | stop | gate</literal></term>
		   <listitem>
		       <para>
			 Selects the mode of the digitizer.  Defaults to <literal>start</literal> mode.
			 See <literal>DESCRIPTION</literal> above for a summary of the modes.
			 Note that <literal>start</literal> and <literal>stop</literal>
			 modes represent special use cases of the digitizers's
			 start/stop trigger mode while <literal>gate</literal>
			 is the digitizer's gate trigger mode.
		       </para>
		       <para>
			 The <option>-mode</option> selected can affect the
			 way you need to decode the data from each event.
			 See <literal>OUTPUT DATA FORMAT</literal> below
			 for more information.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-startdelay</option> <literal>disabled | value</literal></term>
		   <listitem>
		       <para>
			 If the value of this option is <literal>disabled</literal>,
			 the start delay is not enabled.  Otherwise, the value
			 must be a positive integer in the range <literal>[0,65535]</literal>
			 and is the number of clock ticks the digitizer start is
			 delayed before actually being applied.
		       </para>
		       <para>
			 This option defaults to <literal>disabled.</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-stopdelay</option> <literal>disabled | value</literal></term>
		   <listitem>
		       <para>
			 Same as <option>-startdelay</option> above, however
			 the delay, if enabled, applies to the stop time.
		       </para>
		       <para>
			 Defaults to <literal>disabled</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-samples</option> <replaceable>value</replaceable></term>
		   <listitem>
		       <para>
			 Selects the maximum number of sample that will be
			 acquired.  This defaults to <literal>128K</literal>.
			 The following values are allowed:
			 <literal>128K, 16K, 4K, 2K, 1K, 512, 256, 128</literal>.
			 Note that the <literal>K</literal> multiplier in the
			 list above means <literal>1024</literal>.
		       </para>
		       <para>
			 It is possible that fewer than <option>-samples</option>
			 will be acquired.  This can happen in:
		       </para>
		       <itemizedlist>
			 <listitem><para>
			      In <literal>start</literal> mode if there is a
			      stop input that fires to the time required
			      to digitize all samples.
			 </para></listitem>
			 <listitem><para>
			      In <literal>stop</literal> mode if the stop
			      comes soon enough after the digitizer is started
			      by the VMUSB that not all the samples have
			      been digitized.
			 </para></listitem>
			 <listitem><para>
			      In <literal>gate</literal> mode if the gate is
			      narrower than the time required to digitize
			      all samples.
			 </para></listitem>
		       </itemizedlist>
		       <para>
			 The data structure allows you to determine if this is
			 the case.  See <literal>OUTPUT DATA FORMAT</literal>
			 for information about this.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-thresholdslt</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			 A list of 8 booleans, one per digitizer channel.  If
			 a list element is
			 <literal>true</literal>, the channel threshold
			 is applied for a crossing from above to below the
			 threshold.  If <literal>false</literal>, the
			 channel threshold is applied to a crossing from
			 below the threshold to above it.
		       </para>
		       <para>
			 See <option>-thresholds</option> below for more information.
			 Defaults to an 8 element list of <literal>false</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-thresholds</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			 A list of 8 integer in the range <literal>[0,4096)</literal>
			 for the SIS 3300 and <literal>[0,16384)</literal> for
			 the SIS3301.  If the input signal crosses this value
			 in the direction specified by the corresponding
			 <option>-thresholdslt</option> value,
			 a pulse is sent on the trigger output (bottom lemo).
		       </para>
		       <para>
			 This pulse can be cabled to the <literal>start</literal>
			 or <literal>stop</literal> input to directly trigger
			 the digitizer or sent to external trigger logic
			 as a term in a more complex trigger scheme.
		       </para>
		       <para>
			 The default value is a list of 8 <literal>16383</literal>
			 values.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-minletime</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			 This parameter is a list of four integers, one per channel
			 group that
			 specifies the minimum number of clock ticks the trace
			 in a group must
			 be below the threshold to result in a trigger when a channel's
			 <option>thresholdslt</option> value is <literal>true</literal>.
			 This defaults to a list of 4<literal>0</literal> which disables the
			 use of this parameter.  The value must be in the range
			 <literal>[0, 16)</literal>.  A value of <literal>0</literal>
			 disables the enforcement of this parameter.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-mingttime</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			  Same as <option>-minletime</option> except that
			  this specifies the number of consecutive clock ticks a
			  channel must be above the threshold value when
			  <option>-thresholdslt</option> for the channels
			  is <literal>false.</literal>.
		       </para>
		       <para>
			 As with <option>-minletime</option>, this defaults to
			 <literal>0</literal> for all channelgroups.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-trigwidth</option> <replaceable>list</replaceable></term>
		   <listitem>
		       <para>
			 List of four integers in the range <literal>[0,16)</literal>,
			 one for each group of two channels.  If the value for
			 a group is <literal>0</literal> (the default), the
			 settable output gate width feature is disabled.  Otherwise,
			 this value represents the desired output width of the
			 trigger in clock ticks.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-groupenables <replaceable>list</replaceable></option></term>
		   <listitem>
		       <para>
			 List of four booleans (defaults to all <literal>true</literal>),
			 one for each ADC channel group.  If a group's flag is
			 <literal>true</literal> it is read out, if not it
			 is not read out.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-header</option> <replaceable>value</replaceable></term>
		   <listitem>
		       <para>
			 This 16 bit value is inserted into the data from the
			 module prior to the data from each group.
			 See <literal>OUTPUT DATA FORMAT</literal> below
			 for more information about where this appears.
		       </para>
		       <para>
			 This defaults to <literal>0xfadc</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term><option>-trailer</option> <replaceable>value</replaceable></term>
		   <listitem>
		       <para>
			 This 16 bit value is inserted into the data from the
			 module after the data from each group.  See
			 <literal>OUTPUT DATA FORMAT</literal> below for
			 more information.  Defaults to <literal>0xffff</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	   </variablelist>
	</refsect1>
        <refsect1>
	  <title>OUTPUT DATA FORMAT</title>
	
	<para>
	  The output format for this module does not depend on mode.  The
	  interpretation of some of the data is, however mode dependent.
	  The overal format of the data is shown below:
	</para>
	<informalexample>
	  <programlisting>
+----------------------------------------+
|  Mask of group enables (16 bit)        |
+----------------------------------------+
| DAQ Control register value (32 bits)   |
+----------------------------------------+
|  Data from the lowest set bit in       |
|  group enables                         |
              ...
+----------------------------------------+
              ...
	  </programlisting>
	</informalexample>
	<para>
	  The DAQ control register value provides two bits of useful
	  information:
	</para>
	<orderedlist>
	  <listitem><para>
	       If its bottom bit (bit 0) is set you need to delay more
	       prior to reading the module as this bit means the module
	       is still digitizing at the time of readout.
	  </para></listitem>
	  <listitem><para>
	       If bit number 10 is set, the module is being used in gate mode.
	       If not it is being used in either start or stop mode (there
	       is no hardware way to determine the difference).  
	  </para></listitem>
	  <listitem><para>
	       Bits 12-14 define the clock source according to the table in section
	       4.5.  Note that there is no way from this register alone to
	       distinguish between the various external clock modes.
	  </para></listitem>
	</orderedlist>
	<para>
	  Other bits may be set but they are not relevant to this discussion.
	</para>
	<para>
	  Data from each enabled group is provided from lowest to highest
	  group number.  No data is provided for disabled groups.
	</para>
	<para>
	  The data from each group is:
	</para>
	<informalexample>
	  <programlisting>
+-----------------------------------------------+
| header (16 bits)                              |
+-----------------------------------------------+
| Group trigger event directory (32 bits)       |
+-----------------------------------------------+
| Size of data from group                       |
+-----------------------------------------------+
|  Data from group                              |
             ...
+-----------------------------------------------+
| trailer  (16 bits)                            |
+-----------------------------------------------+

	  </programlisting>
	</informalexample>
	<para>
	  In the data format shown above;
	</para>
	<variablelist>
	  <varlistentry>
	      <term>header</term>
	      <listitem>
		  <para>
		    Is the value of the <option>-header</option> option.  If not
		    configured by you this defaults to <literal>0xfadc</literal>
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>trailer</term>
	      <listitem>
		  <para>
		    Is the value of the <option>-trailer</option> option
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>Group trigger event directory</term>
	      <listitem>
	          <para>
		    See section 4.25 of the SIS3300/3301 manual for the
		    detailed format of these 32 bits.
		  </para>
		  <para>
		    The bottom 17 bits of this value modula the number of samples
		    you have selected are sample in the data from the group after
		    which the data have ended.   In the  start and gate
		    mode the trace always begins at the first data item and this
		    value indicates the sample after which data end.  In start mode,
		    and gate mode, this may indicate fewer samples have been
		    digitized than were acquired if, for example there is an
		    external stop in start mode or, in gate mode, if
		    the gate is short relative to the selected sample size.
		  </para>
		  <para>
		    In
		    stop mode, the digitizer treats the data buffer as a circular
		    buffer into which it is continously digitizing the input.
		    The stop signal then indicates when digitization ends (
		    the actual stop may
		    be delayed by the <option>-stopdelay</option>).
		    Therefore in stop mode the bottom 17 bits modula the
		    <option>-samples</option> together with bit 19 (the wrap bit)
		    indicate at which sample the trace starts.
		  </para>
		  <para>
		    If the wrap bit is not set, then trace begins at the first
		    sample in the buffer and ends at the sample just prior to
		    the value in the bottom 17 bits.  If the wrap bit is set,
		    data begins at the sample number in the data indicated
		    by the bottom 17 bits and wraps circulalry to the beginnning
		    of the data before ending in the sample just prior to the
		    first sample.
		  </para>
		  <para>
		    If you are using the internal thresholds, bits 24-31 indicate
		    which, if any, channels satisfied their threshold conditions.
		    Bit 31 represents the state of the channel 1 trigger and
		    bit 24 the state of the channel 8 trigger.
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>Size of data from group</term>
	      <listitem>
		  <para>
		    This is the actual number of samples that will appear
		    in the data buffer.  At present, (this may change), in start
		    and in stop mode, this is the number of samples selected
		    by <option>-samples</option>.  In gate mode, this value
		    repeats the trigger event directory and the bottom 17 bits
		    indicate the number of samples acquired.
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>Data from the group.</term>
	      <listitem>
		  <para>
		    This is the raw sample data, 32 bits per sample containing
		    a sample from each ADC in the group of two samples as shown
		    in section 4.33 of the SIS3300/3301 manual.  Note that to
		    decode the data you will need to know if the digitizer
		    is an SIS3300 (12 bits of data over range flag in bit 12)
		    or an SIS3301 (14 bits of data over range flag in bit 14).
		  </para>
	      </listitem>
	  </varlistentry>
	  <varlistentry>
	      <term>trailer</term>
	      <listitem>
		  <para>
		    These 16 bits are the value of the <option>-trailer</option>
		    option.  If not configured by you, this defaults to
		    <literal>0xffff</literal>.  Note that since bit 15 is set,
		    this is not a legal conversion value from the AD and therefore
		    is distinguishable from real data.   I recommend that if you
		    choose a different <option>-trailer</option> from the
		    default value, that you select one that has the top bit
		    set.
		  </para>
	      </listitem>
	  </varlistentry>
	</variablelist>
	</refsect1>	
      </refentry>

   <!-- SIS 330x FADC driver -->
   
         <refentry id="vmusb3-sis330x">
           <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo> 
           <refmeta>
              <refentrytitle>sis330x</refentrytitle>
              <manvolnum>3vmusb</manvolnum>
              <refmiscinfo class='empty'></refmiscinfo>
           </refmeta>
           <refnamediv>
              <refname>sis330x</refname>
              <refpurpose>Driver for SIS3300/1 FADC</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require SIS330XDriver
                </command>
            </cmdsynopsis>
             <cmdsynopsis>
                 <command>
sis3300 <replaceable>name ?options?</replaceable>   
                </command>
             </cmdsynopsis>
             <cmdsynopsis>
                <command>
<replaceable>name</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
             <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>option</replaceable>
                </command>
             </cmdsynopsis>
             <cmdsynopsis>
                <command>
addtcldriver <replaceable>name</replaceable>
                </command>
             </cmdsynopsis>
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
                Provides support for the SIS 3300/3301 flash adc module.
                This is a Tcl driver, hence the need for a
                <command>package require</command> command to load the driver
                and a <command>addtcldriver</command> command to connect
                a driver instance with the framework.
              </para>
              <para>
                The driver support restricting the readout to a subset of the
                channels. See  the <option>-groupsread</option> option for
                more information in OPTIONS below.
              </para>
              <para>
                The structure of data read from the SIS3300/3301 is shown
                below (all elements are 32 bit integers unless otherwise
                indicated):
              </para>
	      <para>
	       This driver is known to work properly for HiRA for a simpler
	       driver, known to work in all use cases, see
	       <link linkend='vmusb3-sis3300' endterm='vmusb3-sis3300-title' />
	      </para>
              <informalexample>
                <programlisting>
+-------------------------------+
|  Group Mask                   | (16 bits)  <co id="sis3300_data_gmask" />
+-------------------------------+
|  Group size                   |            <co id="sis3300_data_gsize" />
+-------------------------------+
| Group data                    |
|          ...                  |            <co id="sis3300_data_group" />
+-------------------------------+
                </programlisting>
              </informalexample>
            <calloutlist>
                <callout arearefs="sis3300_data_gmask">
                    <para>
                        The low order four bits of this 16 bit data word
                        describe which ADC groups are present.  If bit 0
                        is set, group 1 is present, if bit 1 is set group 2
                        and so on.
                    </para>
                    <para>
                        Group data that follow are in order of low numbered
                        group to high numbered group for each group whose bit
                        is set in this group mask.
                    </para>
                </callout>
                <callout arearefs="sis3300_data_gsize" >
                    <para>
                        The group mask is followed by group data for each bit
                        set in the mask.  This field contains the number of
                        longwords of group data that follows.  The size
                        is not self-inclusive.
                    </para>
                </callout>
                <callout arearefs="sis3300_data_group">
                    <para>
                        Group data is the raw ADC trace data from the data
                        buffer.  The format of these longwords
                        is shown in section 4.34 of the SIS manual.
                    </para>
                </callout>
            </calloutlist>
           </refsect1>
           <refsect1>
              <title>
                 OPTIONS
              </title>
              <variablelist>
                <varlistentry>
                    <term><option>-base</option> <replaceable>base-address</replaceable></term>
                    <listitem>
                        <para>Module base address in VME.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-clocksource</option> <replaceable>clocksource</replaceable></term>
                    <listitem>
                        <para>
                            Module clock source.  This must be a value chosen
                            from one of the following strings:
                            <literal>100Mhz, 50Mhz, 25Mhz, 12.5Mhz, 6.25Mhz,
                            3.125Mhz FrontPanel P2Connector</literal>.
                            The clock source determines the sampling rate of the
                            ADC (or when data are clocked in in the case of
                            HiRA Mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-startdelay</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            If true the start delay is enabled and.  See
                            <option>-startdelayticks</option> to see how this delay
                            is controlled.  Note that the start delay determines when
                            the first sample is saved relative to the start.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-startdelayticks</option> <replaceable>integer</replaceable></term>
                    <listitem>
                        <para>Number of samples in the start delay.   If
                            <option>-startdelay</option> is <literal>
                            false</literal>, this parameter is not used.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-stopdelay</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                             If true, the stop delay is enabled. See
                             <option>-stopdelayticks</option> to set the actual
                             stop delay.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-stopdelayticks</option></term>
                    <listitem>
                        <para>
                            This is the number of samples in the stop delay.
                            If <option>-stopdelay</option> is <literal>true</literal>,
                            when a stop occurs, data will be taken for this
                            number of samples more.  Note that this value is
                            completely ignored if <option>-stopdelay</option>
                            is <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-stoptrigger</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            If <literal>true</literal> the module stop is the trigger.
                            This pretty much has to be used with
                            <option>-stopdelay</option> and
                            <option>-stopdelayticks</option>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-gatemode</option>  <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            Module is or is not in gate mode.  In gate mode
                            the module is started from the falling edge of the
                            gate input and stopped by the rising edge of that signal.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-lemostartstop</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            Start/Stop come from lemo inputs.  This is enabled by
                            default.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-p2startstop</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                                Backplane signals on the p2 connector
                                provide start/stop.  Note that this and
                                <option>lemostartstop</option> are not
                                mutually exlusive.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-hirarandomclock</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>If true, HiRA random clock mode is enabled.
                            HiRA Random clock is normally used with the
                            Washington University Chip board readouts when
                            the readout is done with an XLM other than the
                            XLM-VV when the analog information is collected
                            by an SIS 3301 board.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-randomclock</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>If true front panel provides a random clock with
                             a symmetric pulse shape
                             See section2.5.3 of the module documentation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-samplesize</option> <replaceable>enum value</replaceable></term>
                    <listitem>
                        <para>Size of sample buffers.  This is one of the
                            following text strings:
                            <literal>128K, 16K, 4K, 2K, 1K, 512, 256 128</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-wrap</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>Buffers are  in wrap mode (normally used if
                            start/stop is longer than the samplesize.  Once
                            sampling runs off the end of the buffer sampling
                            continues writing at the low memory location
                            (wraps).  Please note that at present, the
                            readout method used does not support this.
                            If you have a need to use this mode, please
                            contact the NSCL software development group to
                            arrange further development.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-thresholdslt</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>If true, channel thresholds represent a  level
                            _below_ which the conversion must fall. This is normally
                            used with negative going pulses since the data are
                            represented as half-scale offset unsigned integers.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-thresholds</option> <replaceable>8 element int list</replaceable></term>
                    <listitem>
                        <para>Threshold values for all 8 channels.  This parameter,
                              if provided is an 8 element integer list of
                              threshold values.  See as well
                              <option>thresholdslt</option> which can modify
                              how this value is interpreted.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-groupsread</option> <replaceable>4 element bool list</replaceable></term>
                    <listitem>
                        <para>List of flags indicating which groups of ADCs will
                            be read. The module is organized into 4 groups of 2 ADCs each).
                            The manual refers to them as groups 1,2,3,4.  The first
                            list element allows or disables the readout of group 1
                            and so on.
                        </para>
                    </listitem>
                </varlistentry>

              </variablelist>
           </refsect1>
   
         </refentry>
   
   <!-- SIS 3820 scaler command  -->
            
      <refentry id="vmusb3-sis3820">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
         <refmeta>
           <refentrytitle>sis3820</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
         </refmeta>
         <refnamediv>
           <refname>sis3820</refname>
           <refpurpose>Create and configure SIS 3820 scaler modules</refpurpose>
         </refnamediv>
        
         <refsynopsisdiv>
           <cmdsynopsis>
      	 <command>
sis3820 create <replaceable>name base ?option value...?</replaceable>
      	 </command>
          </cmdsynopsis>
             <cmdsynopsis>
                 <command>
sis3820 config <replaceable>name option value ...</replaceable>
                 </command>
             </cmdsynopsis>
                <cmdsynopsis>
                    <command>
sis3820 cget <replaceable>name</replaceable>
                    </command>
                </cmdsynopsis>
            
         </refsynopsisdiv>
         <refsect1>
           <title>DESCRIPTION</title>
           <para>
               Creates and configures the SIS3820 32 channel scaler for use in
               a stack.   The <command>create</command> subcommand creates a new
               module with a base address of <parameter>base</parameter>, and
               a name <parameter>name</parameter> which will be used to refer
               to this module in later configuration commands.
           </para>
            <para>
               The scaler readout will result in an array of 32 channels
               of scaler data placed in the buffer.  The first longword of this
               data is channel 0, the last, channel 1, unless the scaler in in
               <option>-timestamp</option> mode in which case the data are three
               longwords that consist of channel 0, channel 16 and the high bits
               register that has the top 16 bits of each of those channels as
               a 48 bit scaler. In the timestamp mode, the scaler values are 
               latched when a logic signal arrives on control input 1, because
               the module is configured for control input mode 1.
            </para>
            <para>
               The <command>config</command> sub-command configures the options
               for the scaler <parameter>name</parameter>.  The configuration
               is expressed as a series of one or more
               <parameter>option value</parameter> pairs.  Options may have
               default values and are validity checked to ensure that
               valid values are supplied.  See OPTIONS below for more information
               about the option keywords that are supported and their legal values.
            </para>
            <para>
               The <command>cget</command> sub-command returns the current module
               configuration.  The configuration is returned as a Tcl list of
               <parameter>option value</parameter> pairs.  See
               OPTIONS below for a description of the options ans values
               that are returned.  You should not rely on the list being in any
               specific order.  While the list will have a deterministic order,
               if additional option keywords are added later on, this order may
               change.
            </para>
         </refsect1>
         <refsect1>
           <title>
      	OPTIONS
           </title>
           <variablelist>
      	 <varlistentry>
      	    <term><option>-base</option> <parameter>value</parameter></term>
      	    <listitem>
      		<para>
                  Allows you to override the initial base address of the module,
                  specified when the module was created.
      		</para>
      	    </listitem>
      	 </varlistentry>
         <varlistentry>
            <term><option>--timestamp</option> <parameter>on | off</parameter></term>
            <listitem>
                <para>
                    If this option is true, the scaler is read in timestamp mode as
                    2 48 bit scalers.  If false (the default), 32 bits are read for
                    each channel.
                </para>
            </listitem>
	 </varlistentry>
           </variablelist>
         </refsect1>
         <refsect1>
           <title>EXAMPLES</title>
           <para>
               The example below configures an SIS 3820 scaler to have a base
               address of 0x38000000
           </para>
            <example>
               <title>Configuring an SIS3820 scaler module</title>
               <programlisting>
sis3820 create scaler1 0x38000000
               </programlisting>
            </example>
         </refsect1>

      </refentry>
           
      <!-- v830 command - configure CAEN V830 32 channel latching scalers -->
            
      <refentry id="vmusb3-v830">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>v830</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>v830</refname>
           <refpurpose>Create and configure CAEN V830 32 channel scalers.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
      	<command>
v830 create <replaceable>name base</replaceable>
      	</command>
          </cmdsynopsis>
             <cmdsynopsis>
                 <command>
v830 config <replaceable>name option value...</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
v830 cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
               This command creates, configures and queries the configuration of
               CAEN V830 scaler modules.  This is a latching scaler module.
               At present, not all functionality has been enabled. Specifically,
               the module code is now tailored to the typical use case of a
               run-time scaler module in the scaler stack.
           </para>

           <para>
               The <command>create</command> subcommand creates a new module.
               The <parameter>base</parameter> address should be the VME base
               address of the module, as configured in the module's
               rotary switches.  The <parameter>name</parameter> parameter is
               a name that you assign to the module, and will be used to
               refer to the module in future <command>config</command> or
               <command>cget</command> commands.
            </para>
            <para>
               The <command>config</command> subcommand configures the module
               <parameter>name</parameter>.  The configuration is supplied as a
               set of <parameter>option value</parameter> pairs.  More than one
               pair can appear on the same line, any number of <command>config</command>
               commands can be used and those that execute later can override
               those that execute earlier.
            </para>
            <para>
               The <command>cget</command> subcommand returns the configuration
               of the module <parameter>name</parameter> as a list of
               <parameter>option value</parameter> pairs.  You should not
               rely on the list being in any specific order.  While the list
               order is determinstic within a version of the program it is possible
               that later versions will return the list in a different order.
            </para>
        </refsect1>
        <refsect1>
           <title>
      	OPTIONS
           </title>
           <variablelist>
      	<varlistentry>
      	    <term><option>-base</option> <replaceable>address</replaceable></term>
      	    <listitem>
      		<para>
                  Allows you to override the base address of the module set at
                  creation time with a new base <parameter>address</parameter>.
      		</para>
      	    </listitem>
      	</varlistentry>
         <varlistentry>
            <term><option>-channels</option> <replaceable>mask</replaceable></term>
            <listitem>
               <para>
                  Provides a mask of enabled channels.  The low order bit represents
                  channel zero the high order bit, channel 31.  Each channel for which
                  a bit is present is enabled to count.  The default value for this
                  mask is <literal>0xffffffff</literal> which enables all channels.
               </para>
            </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-dwelltime</option> <replaceable>value</replaceable></term>
               <listitem>
                  <para>
                     This is used only if the <option>-trigger</option> is set
                     to <literal>periodic</literal> and is the time between
                     triggers in 400ns units.  Each trigger will latch the
                     current counter values into the MEB and, if
                     <option>-autoreset</option> is true, clear them.
                     If the <option>-ipl</option> and <option>-vector</option>
                     are set, this can produce a backplane interrupt which, in turn,
                     can trigger execution of a stack. The default value is zero
                     which disables the periodic trigger.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-header</option> <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     Enables or disables the inclusion of a header on data read from
                     the MEB.  For the format of the header, see figure 3.1 of the
                     CAEN V820/V830 manual.  Note that this header will only be present
                     if the MEB is read out.  A value of <literal>true</literal>
                     enables the header while a value of <literal>false</literal> disables it.
                     The default value is <literal>false</literal> which is appropriate
                     for the case where this module will be used in a scaler stack.
                  </para>
               </listitem>
            </varlistentry>
	    <varlistentry>
	      <term><option>-incremental</option> <replaceable>bool</replaceable></term>
	      <listitem>
		<para>
		  If <literal>true</literal> (the default) scaler ring items are labeled
		  as incremental.  If <literal>false</literal> scaler ring items are labeled
		  as not being incremental.
		</para>
	      </listitem>
	    </varlistentry>
            <varlistentry>
               <term><option>-trigger</option> <replaceable>random | periodic | vme</replaceable></term>
               <listitem>
                  <para>
                     Determines the source the latch trigger.  The values are
                     as follows:
                     <variablelist>
                        <varlistentry>
                           <term><literal>random</literal></term>
                           <listitem>
                              <para>The external trigger input is used to
                                 trigger the latch.
                              </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>periodic</literal></term>
                           <listitem>
                              <para>The module will have a periodic trigger that
                                 is governed by the value of the <option>-dwelltime</option>
                                 option.
                              </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>vme</literal> (default)</term>
                           <listitem>
                              <para>Triggers will be supplied by the stack that'
                                 reads the module out.
                              </para>
                           </listitem>
                        </varlistentry>
                     </variablelist>
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-wide</option>  <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     Determines if, when the MEB is read, the scalers will be
                     wide (32 bit counters) or narrow (24 bit counters tagged
                     with the channel number).  See figures 3.2 and 3.3 in
                     the CAEN V820/830 manual for the data forma in both
                     cases.
                  </para>
                  <para>
                     A value of <literal>true</literal> enables wide
                     (32 bit) mode. A value of <literal>false</literal> requests
                     narrow (24 bit) mode.  This only affects data read from the
                     MEB.  The counter data are always wide.
                     The default value is <literal>true</literal>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-autoreset</option>  <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     Configures the scaler to reset its counters after storing the data in the
                     MEB or not.  If <literal>true</literal> the counters are
                     cleared after latching the data.  If <literal>false</literal> not.
                     The defeault value is <literal>true</literal>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-geo</option>  <replaceable>slot</replaceable></term>
               <listitem>
                  <para>
                     Programs the module geographical address.  This value is only
                     relevant if <option>-header</option> is <literal>true</literal>
                     or <option>-wide</option> is <literal>false</literal>.
                     The value can only be programmed for modules that do not have
                     the PAUX connector.  Modules with the PAUX connector read their
                     geographical address from the backplane, and this value,
                     if used in other places, must be set to the physical slot number
                     the scaler is using (not a bad idea in any event).
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-setgeo</option> <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     If <literal>true</literal> the configuration code attempts
                     to set the module's GEO value from the <option>-geo</option>
                     parameter.  If not, the <option>-geo</option> value is
                     simply assumed to document the position of the module to other
                     software, and is ignored.  The default value is <literal>false</literal>
                     which is suitable for modules without a PAUX connector and
                     for the normal use case of a module in the scaler stack where
                     the GEO address is not relevant.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-ipl</option>  <replaceable>priority</replaceable></term>
               <listitem>
                  <para>
                     Provides the interrupt priority level for the module's
                     VME interrupt.  The V830 can interrupt when it has at least
                     <option>-highwatermark</option> events in its MEB.
                     This interrupt can be used to trigger a VM-USB stack.
                  </para>
                  <para>
                     VME bus interrupts are prioritized with the priority value
                     ranging from <literal>1</literal> through <literal>7</literal>.
                     This priority determines the service order of simultaneous interrupts.
                     Larger numbers are higher priorities.   A value of
                     <literal>0</literal> disables module interrupts.  The
                     default value is <literal>0</literal>
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-vector</option>  <replaceable>statusid</replaceable></term>
               <listitem>
                  <para>
                     VME interrupts are identified via a <firstterm>status-id</firstterm>
                     value presented by the interrupting device when the interrupt is
                     acknowledged by the <firstterm>interrupt responder</firstterm>
                     (VM-USB).  In the case of the CAEN V830, this is a value
                     from <literal>0</literal> through <literal>255</literal>.
                  </para>
                  <para>
                     For historical reasons, this status-id value is also called the
                     <firstterm>interrupt vector</firstterm>.  The <option>-vector</option>
                     option sets the value of the interrupt vector presented by the
                     CAEN V830 when it interrupts.  To interrupt, the module must also
                     be configured with a nonzero <option>-ipl</option> and
                     nonzero <option>-highwatermark</option> value.
                  </para>
                  <para>
                     Module interrupts can be used to triggers VM-USB stack
                     execution. 
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-highwatermakr</option> <replaceable>value</replaceable></term>
               <listitem>
                  <para>
                     Configures the value of the V830 <firstterm>Almost Full Level</firstterm>
                     register.  When non zero, if <option>-ipl</option> is also non-zero,
                     and <option>-vector</option> is also non zero, when there is at least
                     <parameter>value</parameter> events in the MEB, the module
                     will initiate a VME bus interrupt.  VME interrupts can be
                     used to trigger VM-USB stacks.  The default value is 1.
                  </para>
               </listitem>
            </varlistentry>
            </variablelist>
        </refsect1>

        <refsect1>
           <title>EXAMPLES</title>
           <para>
               The following example shows how to set up a CAEN V830 scaler
               for inclusion in the scaler stack.  The base address of the
               scaler is <literal>0x80000000</literal>.  The default configuration
               values are suitable for the scaler stack.
           </para>
           <example>
            <title>Configuring a CAEN V830 scaler</title>
               <programlisting>
v830 create scaler 0x80000000
               </programlisting>
           </example>
        </refsect1>

      </refentry>
      <refentry id="vmusb3-v977">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
	<refmeta>
	   <refentrytitle>v977</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
	</refmeta>
	<refnamediv>
	   <refname>v977</refname>
	   <refpurpose>Create and configure CAEN V977 Input registers</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	  <command>
v977 create <replaceable>name ?option value...?</replaceable>
	  </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	  <command>
v977 config <replaceable>name option value ?...?</replaceable>	  
	  </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	  <command>
v977 cget <replaceable>name</replaceable>	  
	  </command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
This command supports the CAEN V977 I/O register.  At this time support is only
provided to read the module's input register.  Other than setup modes that
echo the inputs to the outputs in some way, output is not supported.
	   </para>
	   <para>
The <command>create</command> subcommand creates a new module.  The <parameter>name</parameter>
parameter supplies a unique name by which that module will be known throughout the
rest of the configuration file.  The optional <parameter>option value</parameter>
pairs provide additional configuration options and can be selected from the
set of configuration options described in OPTIONS below.
	   </para>
	   <para>
The <command>config</command> subcommand allows you to further configure an
existing module.  The <parameter>name</parameter> parameter is the name
you assigned to the module in the <parameter>create</parameter> operation.
The <parameter>option value</parameter> pairs configure the module and can
be selecte from the configuration options described in OPTIONS below.
	   </para>
	   <para>
The <command>cget</command> allows you to retrieve the current configuration of
the module.  The <parameter>name</parameter> parameter provides the name of the module
as defined by the <command>create</command> subcommand.  The result is a
well formed Tcl list that consists of option name value pairs.
	   </para>
	</refsect1>
	<refsect1>
	   <title>OPTIONS</title>
	   <para>
          Configuration options provide a mechanism to define where a module
			 is located in the VME space as well as how the moduile should be
			 prepared for data taking.  A module is configured via the
			 <command>config</command> subcommand.  That command identifies
			 the module via the name assigned to it in the <command>create</command>
			 operation and provides configuration information in the form of
			 a set of name value pairs.  
	   </para>
		<para>
          Each name selects what is to be configured and each value provides
          the new value for that item.
          The configuration keywords supported and the meanings of their values
          are described below.
      </para>
      <variablelist>
          <varlistentry>
               <term><option>-base</option> <replaceable>base-address</replaceable></term>
               <listitem>
                  <para>
                     Defines the base address of the module.
                     <parameter>base-address</parameter> must match the base address
                     set in the module's rotary switches.  This address is used
                     to determine how to access the module in VME address space.
                  </para>
               </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-inputmask</option>  <replaceable>mask</replaceable></term>
             <listitem>
                <para>
                   Provides the value of the module's input mask register.
                   The value of <parameter>mask</parameter> is programmed into
                   the module's input mask register at initialization time.
                   Each bit set in the register prevents the corresponding
                   front panel input from being seen by the module.
               </para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-readmode</option>  <replaceable>mode</replaceable></term>
             <listitem>
                <para>
                   Together with the <option>-readandclear</option>, determines
                   which register is actually read by the stack.  Legal values
                   are <literal>singlehit</literal> and <literal>multihit</literal>.
                   If <literal>singlehit</literal> is selected (the default) is
                   provided the module will read either the Single hit read
                   register or the Singlehit read-clear register depending on the
                   value of the <option>-readandclear</option>.  <literal>multihit</literal>
                   is selected, the module's multihit read or multihit read-clear
                   register will be read.
                   </para>
               <para>
                   See the table at the end of this section for a complete
                   listing of the combinations of read modes and read and clear
                   settings and their implications for how the module is read.
                   </para>
              </listitem>
          </varlistentry>
          <varlistentry>
              <term><option>-outputmask</option>  <replaceable>mask</replaceable></term>
              <listitem>
                 <para>
                    Provides a value for the output mask register.
                    This defaults to zero.
                    </para>
                 </listitem>
          </varlistentry>
          <varlistentry>
              <term><option>-interruptmask</option> <replaceable>mask</replaceable></term>
              <listitem>
                 <para>
                    Provides a value that will be programmed into the
                    output mask regiseter.  The module can produce an interrupt
                    if bits that are not masked off in this register are set
                    in the pattern gated into the module.  See also the
                    <option>-ipl</option> and <option>-vetor</option> if
                    you intend to use the module with interrupts.
                    </para>
                 </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-readandclear</option> <replaceable>true|false</replaceable></term>
             <listitem>
                <para>
                   Determines whether the module will be atomically cleared
                   as it is read.  This option together with the
                   <option>-readmode</option> determines which module register
                   read is added to the readout stack.  For more information,
                   see the table at the end of this section.
                </para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-ipl</option> <replaceable>interrupt-level</replaceable></term>
             <listitem>
                <para>
                   Determines the interrupt priority level used by the module
                   when creating interrupt requests on the VME dataway.  If
                   <parameter>interrupt-level</parameter> is <literal>0</literal>
                   (the default), interrupts will not be used.
                </para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-vector</option> <replaceable>status-id</replaceable></term>
             <listitem>
                <para>
                   When the module creates a VME dataway interrupt it provides the
                   <parameter>status-id</parameter> as the interrupt vector
                   when requested to by the interrupt handler module (VM-USB normally).
                   If the <parameter>status-id</parameter> is <literal>0</literal>
                   (default), interrupts are not generated on the dataway.
                </para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-pattern</option> <replaceable>true|false</replaceable></term>
             <listitem>
                <para>
                   If this is <literal>true</literal>, the pattern bit is set
                   int he control register, and the module operates in pattern
                   mode.  If not, the module operates in I/O register mode.
                </para>
             </listitem>
          </varlistentry>
          
      </variablelist>
      <table frame='all'>
	  <title>Readmode and Read and clear implications</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	       <thead>
		    <row>
			 <entry>Read mode</entry>
			 <entry>Read and clear</entry>
			 <entry>Readout meaning</entry>
		    </row>
	       </thead>
	       <tbody>
		    <row>
			 <entry>singlehit</entry>
			 <entry>false</entry>
			 <entry>The SingleHitRead register (0x0006) will be read.
			 </entry>
		    </row>
		    <row>
			 <entry>singlehit</entry>			 
			 <entry>false</entry>
			 <entry>The SingleHitRdClear register (0x0016)
			      will be read.
			 </entry>
		    </row>
		    <row>
			 <entry>multihit</entry>
			 <entry>true</entry>
			 <entry>
			      The MultiHitRdClear register (0x0018) will be read.
			 </entry>
		    </row>
		    <row>
			 <entry>multhit</entry>
			 <entry>false</entry>
			 <entry>
			      The MultiHitRead register (0x0008) will be read.
			 </entry>
		    </row>
	       </tbody>
	  </tgroup>
	  
      </table>
	</refsect1>
      
      </refentry>
      <refentry id="vmusb3-sis3804">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>sis3804</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>sis3804</refname>
           <refpurpose>Create and configure SIS 3804 scalers</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
sis3804 create <replaceable>name ?options...?</replaceable>
              </command>
          </cmdsynopsis>
    <cmdsynopsis>
        <command>
sis3804 config <replaceable>name options...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
      <command>
sis3804 cget <replaceable>name option</replaceable>
      </command>
    </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
              This command creats and manipulates SIS3804 objects.  The SIS3804
              is an 8 channel latching scaler manufactured by Struck.  The
              SIS3804 objects can configure and add readout instructions for this
              hardware to VM-USB stacks.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-base</option> <replaceable>base-address</replaceable></term>
                  <listitem>
                      <para>
                        Sets the base address of the module. This must match the
                        value selected by  the rotary switches on the module.
                        The default for this option is 0, which is typically not
                        what you want.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
               <term><option>-refpulser</option> <replaceable>boolean</replaceable></term>
               <listitem>
                  <para>
                     Enables or disables the reference pulser.  When enabled,
                     the reference pulser disables the input to channel 1 and
                     supplies a 25Mhz pulse frequency to that channel.
                  </para>
                  <para>
                     A value of <literal>true</literal> enables the pulser while
                     <literal>false</literal> (the default) disables the reference
                     pulser.
                  </para>
               </listitem>
              </varlistentry>
              <varlistentry>
                  <term><option>-disables</option> <replaceable>mask</replaceable></term>
                  <listitem>
                     <para>
                        Allows you to disable specific channels from counting.
                        The bottom 8 bits if set disable the corresponding channel
                        of the pulse.  For example if mask &amp; 1 is nonzero,
                        channel 1 (numbered from 1) is disabled, while if
                        mask &amp; 0x10 is nonzero, channel 8 is disasbled.
                     </para>
                     <para>
                        The default value is zero which enables all channels.
                     </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
               <term><option>-autoclear</option> <replaceable>boolean</replaceable></term>
               <listitem>
                  <para>
                     If this option is <literal>true</literal> (the default),
                     scalers are cleared atomically after being latched for readout.
                     The NSCL data acquisition system scaler display program
                     expects the scaler counters to be incremental values  with
                     the sums computed in software (so that overflows can be
                     explicitly managed).  If you have a special application for this
                     scaler, e.g. to provide timestamps in an event, for which you
                     do not want this behavior, you can set this option to <literal>false</literal>
                  </para>
               </listitem>
              </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>EXAMPLES</title>
           <para>
            The example below creatse a scaler at the manufacturer's setting
            for the base address and configures it to have the 25Mhz
            reference pulser in channel 1:
           </para>
           <example>
            <title>Configuring the SIS 3804 scaler</title>
            <programlisting>
sis3804 create scaler1 -base 0x38383800
sis3804 config scaler1 -refpulser true
            </programlisting>
           </example>
        </refsect1>
      
      </refentry>
      <refentry id="vmusb3-hira">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>hira</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>hira</refname>
           <refpurpose>Pair up to 2 XLMs and FADC for HiRA</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
hira create <replaceable>name ?options?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
hira config <replaceable>name options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
hira cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            In situations where an XLM-XXV is not available, Wash-U chip boards
            can be read out using an XLM and an SIS3300/SIS3301 FADC module.
            This command allows you to combine these into a single module.
            from the point of view of a stack.
           </para>
           <note>
               <title>Note:</title>
               <para>
                  Normally the XLM modules used are either a hinp or psd
                  module.  As the code for these is maintained by Washington
                  Univ,  Those drivers are not documented here.
               </para>
           </note>
           <para>
            The command produces the following data format:
           </para>
           <informalexample>
            <programlisting>
+------------------------------------+
|   id (16) bits                     |
+------------------------------------+
| tag data from the xlm  1 srama     |
...
| tag data from xlm1 sram b          |
../
+------------------------------------+
| 0xfadc                             |
+------------------------------------+
| Mask of read groups                |
+------------------------------------+
| Data from the FADC module group1   |
+------------------------------------+
| 0xaaa                              |
+------------------------------------+
...
| Data from the FADC module group2   |
...
+y------------------------------------+
            </programlisting>
           </informalexample>
           <para>
            Note that the configuration parameters of the XLM's determine whether
            or not both SRAM banks are read, the configuration of the FADC determines
            which FADC groups are read, and the <option>-xlm</option> option value
            determines whether one or two XLM modules are associated witht this
            HiRA module.
          </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-id</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Provides the id tag that precedes the data from the
                        two actual modules.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-xlm</option> <replaceable>module-name</replaceable></term>
                <listitem>
                    <para>
                        This parameter is a list of one or two XLM modules assoiated
                        with this HiRA.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-fadc</option> <replaceable>module-name</replaceable></term>
                <listitem>
                    <para>
                        This parameter is the name of the sis330x module that
                        gets the analog data
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
           <note>
            <title>Note:</title>
            <para>
                The software does not check that the XLM is an XLM or that the
                fadc is an SIS 330x module.
            </para>
           </note>
        </refsect1>

      </refentry>

      <refentry id="vmusb3-hytec">
        <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
        <refmeta>
           <refentrytitle>hytec</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>hytec</refname>
           <refpurpose>Support the Hytec NADC 2530 adc module.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
hytec create <replaceable>name ?options?</replaceable>
              </command>
          </cmdsynopsis>
<cmdsynopsis>
    <command>
hytec <replaceable>config name ?options?</replaceable>
    </command>
</cmdsynopsis>
<cmdsynopsis>
    <command>
hytec cget <replaceable>name</replaceable>
    </command>
</cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
              This command provides support for the Hytec NADC2530.  The NADC2530
              is an 8 channel multi-event peak sensing adc.  While the module
              is capable of autonomously creating histograms, this software does
              not support that capability as it's much easier to treat that
              module differently if used in that way.
           </para>
	   <para>
	    Beginning with the VM-USB readout program verssion 3.2-001, the
	    software tags the ADC data with a user defined virtual slot number,
	    and the module provides a 48 bit timetamp with each event if
	    its firmware revision is 2530V305 or later.
	   </para>	
           <para>
               As for all VM-USB module support commands, <command>hytec</command>
               is a command ensemble with the subcommands
               <variablelist>
                  <varlistentry>
                     <term><command>create</command></term>
                     <listitem>
                        <para>Which creates an object for an NADC2530 adc
                           which can be referred to by the name <parameter>name</parameter>.
                           Additional options can provide device configuration.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><command>config</command></term>
                     <listitem>
                        <para>
                           Which configures the existing device object
                           <parameter>name</parameter>
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><command>cget</command></term>
                     <listitem>
                        <para>
                           Which returns the module <parameter>name</parameter>'s
                           configuration as an item list of name value pairs.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
                                                                
           </para>
            <para>
               Configuration options are described in the OPTIONS section below.
            </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-csr</option> <replaceable>address</replaceable></term>
                  <listitem>
                      <para>
                           This option must appear somewhere in the module configuration.
                           It establishes the base address of the module's
                           register space.  The NADC 2530 has two address spaces,
                           register space, used to configure and control the module,
                           and memory space where events get stored.
                      </para>
                      <para>
                        The <parameter>address</parameter> is an A24 address.
                        this means it must be in the range
                        <literal>0x000000</literal> through <literal>0xffffff</literal>.
                        Each module must have a unique base address, and the address
                        configured in the software must match the address configured
                        in the module's address jumpers.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
               <term><option>-memory</option> <replaceable>address</replaceable></term>
               <listitem>
                  <para>
                     This option must appear somewhere in the module configuration.
                     It establishes the base address of the module's event buffer
                     memory. Each module's event memory must carve out a unique
                     slice of A32 address space (values between
                     <literal>0x00000000</literal> and <literal>0xffffffff</literal>).
                  </para>
                  <para>
                     The buffer memory address space is software programmable.
                     See the NADC2530 manual for the size of this address space
                     as any overlap can cause corrupted data to be read from the
                     modules.
                  </para>
               </listitem>
              </varlistentry>
               <varlistentry>
                  <term><option>-ipl</option> <replaceable>irqlevel</replaceable></term>
                  <listitem>
                     <para>
                        If you are using the module's interrupt to trigger
                        a stack execution, <parameter>irqlevel</parameter> must
                        be a nonzero value between <literal>1</literal> and
                        <literal>7</literal>, and will be the interrupt priority
                        level on which the module will generate an iterrupt request.
                     </para>
                     <para>
                        The value of this parameter defaults to <literal>0</literal>
                        which disables module interrupts.  See also the
                        <option>-vector</option> option below.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-vector</option> <replaceable>statusid</replaceable></term>
                  <listitem>
                     <para>
                        If the module is being used to trigger a stack,
                        <parameter>statusid</parameter> should be the value the
                        module will use to reply to the interrupt acknowledge cycle's
                        request for a status/id from the module.
                     </para>
                     <para>
                        The NADC2530 has a status/id 16 bits wide
                        (between <literal>1</literal> and <literal>65535</literal>
                        where zero disables the interrupt).  The VM-USB, however
                        only triggers on the bottom 8 bits of the status id field.
                        therefore you should use values between
                        <literal>1</literal> and <literal>255</literal> unless
                        you are directing the interrupt at other modules in the VME
                        crate.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-lld</option> <replaceable>millivolts</replaceable></term>
                  <listitem>
                     <para>
                        Provides the low level threshold value in <parameter>millivolts</parameter>.
                        Due to the resolution of the threshold DAQ, the actual threshold
                        value programmed may be slightly different than the one requested.
                        See the manual for the relationship between
                        <parameter>millivolts</parameter> and threshold DAC values.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-hld</option> <replaceable>volts</replaceable></term>
                  <listitem>
                     <para>
                        Provides the high level discriminator value in floating
                        point <parameter>volts</parameter>.  Due to the
                        Due to the resolution of the threshold DAQ, the actual threshold
                        value programmed may be slightly different than the one requested.
                        See the manual for the relationship between
                        <parameter>volts</parameter> and threshold DAC values.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-events</option> <parameter>count</parameter></term>
                  <listitem>
                     <para>
                        Indicates that <parameter>count</parameter> events must
                        be in the event buffer before an interrupt will be
                        signalled on the VME backplane.  This item also configures
                        how many events are required for the module to indicate
                        that it has data.  Therefore, if not being used with interrupts,
                        this value should be programmed to its default value of
                        <literal>1</literal>
                     </para>
                  </listitem>
               </varlistentry>
	       <varlistentry>
		  <term><option>-id</option> <parameter>value</parameter></term>
		  <listitem>
		     <para>
			Provides a 16 bit id (virtual slot number) that will be
			used to tag the data.  The NADC2530 is not capable
			of providing a hardware virtual slot number as of firmware
			2530V305, therefore the <parameter>value</parameter> is
			inserted as a marker word prior to the data from the ADC.
		     </para>
		     </listitem>
		  </varlistentry>
	       <varlistentry>
		  <term><option>-zerosuppress</option> <parameter>on|off</parameter></term>
		  <listitem>
		     <para>
			If the value of this parameter is a true boolean, the
			channels that are outside the high and low level
			discriminators are not present in the data from the
			device.  If the value is a boolean true, all 8 channels
			are present in the data.
		     </para>
		  </listitem>
	       </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>EXAMPLES</title>
           <para>
               The example below configures an NADC 2530 with a register base
               address of <literal>0x400000</literal>, and a buffer address
               of <literal>0x10000000</literal>.  It leaves the thresholds
               wide open and does not enable module interrupts.  A marker
	       word 0xadc1 is inserted prior to the data, and, if the
	       discriminator levels are later set, data outside of them
	       will be supressed from the data stream.:
           </para>
           <example>
            <title>Sample Hytec 2530 configuration</title>
            <programlisting>
hytec create adc
hytec config adc  -csr 0x400000 -memory 0x10000000 
hytec config adc -lld 0.0 -hld 8.191 -events 1 -id 0xadc1 -zerosuppress on
            </programlisting>
           </example>
        </refsect1>
	<refsect1>
	    <title>DATA FORMAT</title>
	    <para>
	       Readout prepends the data from the ADC with three additional
	       data words.  This section describes what to expect in the
	       event file for this module.
	    </para>
	    <para>
	       The first word of data from this module will be the value of
	       the <option>-id</option> optin.  This defaults to zero if
	       not supplied.  This is followed by a mask word, and then a
	       count word.  These two words allow you to determine the number
	       of longwords of ADC data that follow.
	       </para>
	    <para>
	       Suppose the mask word is <literal>mask</literal> and the
	       count word is <literal>count</literal>.
	       <literal>mask &amp; count</literal> computes the number of longwords
	       of ADC data that follow in the data packet from this module.
	       </para>
	    <para>
	       Following these three words, the data from the ADC as shown in
	       section 4.3.1 of the manual is inserted in the event. Note that:
	    </para>
	    <orderedlist>
	       <listitem>
		  <para>
		     The ADC may convert serveral times for a single channel
		     if multiple signal peaks are detected within the gate
		     time.  SpecTcl will only pay attention to the largest of these
		     conversions for a specific channel.
		     </para>
	       </listitem>
	       <listitem>
		  <para>
		     When the system starts up, or if the busy lock out logic
		     is not perfect, and allows gates to go to the ADC when
		     the system is busy, you may see additional events or event
		     fragments.  SpecTcl will only pay attention to the data from
		     the first event (it will stop processing channels after the first)
		     trailer word or after the longword count described above is
		     exhausted.
		  </para>
		  </listitem>
	       <listitem>
		  <para>
		     When the system initially starts, there may be a large number
		     of gates prior to the VM-USB completing intialization...
		     depending on when it actually asserts busy.  Once more SpecTcl
		     will only histogram the first of these events from the ADC.
		     As subsequent data from the ADC should be synchronized to the
		     IN1 trigger, this should at most affect the first event.
		  </para>
	       </listitem>
	       <listitem>
		  <para>
		     When setting up the SpecTcl parameters for this module,
		     remember that the module provides 9 parameters. The first
		     of these is a 48 bit timestamp.  The remaining 8 are the
		     adc parameters.  SpecTcl is not able to guess how you want to
		     set up the timestamp spectrum.  In general this is not a problem
		     as usuall you will be using the timestamp to generate rate
		     stripchart spectra rather than looking at the timestamp
		     itself.
		     </para>
	       </listitem>
	       <listitem>
		  <para>
		     When looking at SpecTcl timestamp based spectra you may see
		     significant gaps in the time online. This happens because of
		     the way data are sampled to SpecTcl from the online system.
		     SpecTcl may miss complete buffers of data online if it is not
		     able to keep up with the data rate.  If you process the
		     event file for that run offline, these gaps disappear.
		     </para>
	       </listitem>
	    </orderedlist>
	</refsect1>
      </refentry>
      <refentry id="vmusb3-tcldriversupport">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>tcl driver support</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>tcl driver support</refname>
           <refpurpose>tcl driver support functions.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require VMUSBDriverSupport
            </command>
          </cmdsynopsis>
        <cmdsynopsis>
            <command>
::VMUSBDriverSupport::convertVmUSB <replaceable>name</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::VMUSBDriverSupport::convertVmUSBReadoutList <replaceable>name</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validInt <replaceable>value ?low ?high??</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validReal <replaceable>value ?low ?high??</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::valideEnum <replaceable>value set</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validBool <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validList <replaceable>value ?fewest ?most ?checker ?args????</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validIntList <replaceable>value ?fewest ?most ?low ?high????</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validBoolList <replaceable>value ?fewest ?most???</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides utiltities that are of use/interest to
            Tcl device driver modules for the VM-USB readout framework.
            The attempt is to centralize/factor common code out of driver
            modules that is commonly used.  
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::convertVmUSB <replaceable>name</replaceable>
                </command></term>
                <listitem>
                    <para>
                        Converts a swig CVMUSB object identifier into a usable
                        CVMUSB object.  Once converted the driver can invoke
                        methods on that object.  <parameter>name</parameter>
                        is the object passed in to the driver.  The return
                        value will be the  name of the new object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::convertVmUSBReadoutList <replaceable>name</replaceable></command></term>
                <listitem>
                    <para>
                        Converts a CVMUSBReadoutList swig object identifier into
                        an object.  Once converted, the object methods can
                        be directl invoked.
                        <parameter>name</parameter> is the name passed in to the
                        method by the framework.  the return value is the
                        name of the object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validInt <replaceable>value ?low ?high??</replaceable></command></term>
                <listitem>
                    <para>
                        Provides type checking and optional range checking for
                        integer data. This is most often called to validate
                        an integer driver option.
                    </para>
                    <para>
                        Throws an error if <parameter>value</parameter> is not
                        a valid integer.  Additionally, if <parameter>low</parameter>
                        is not empty, an error is thrown if
                        <literal>$value &lt; $low</literal>.  Similarly if
                        <parameter>high</parameter> is not empty an error
                        is thrown if <literal>$value &gt; $high</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validReal <replaceable>value ?low ?high??</replaceable></command></term>
                <listitem>
                    <para>
                        Provides type and optional range checking for
                        real parameters.
                    </para>
                    <para>
                        If <parameter>value</parameter> is not valid real number
                        this proc throws an error.  Furthermore if <parameter>low</parameter>
                        is not blank, an error is thrown if <literal>$value &lt; $low</literal>.
                        Similarly if <parameter>high</parameter> is not blank,
                        an error is thrown if <literal>$value &gt; $high</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::valideEnum <replaceable>value set</replaceable></command></term>
                <listitem>
                    <para>
                        Throw an error if <parameter>value</parameter> is not
                        one of the strings  in the Tcl list <parameter>set</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validBool <replaceable>value</replaceable></command></term>
                <listitem>
                    <para>
                        Throws an error if <parameter>value</parameter> is not
                        recognizable as a boolean by Tcl.
                        <ulink url='http://www.tcl.tk/man/tcl8.5/TclLib/GetInt.htm'>
                            http://www.tcl.tk/man/tcl8.5/TclLib/GetInt.htm</ulink>
                        describes the set of <parameter>value</parameter>s that are
                        recognized as valid booleans.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validList <replaceable>value ?fewest ?most ?checker ?args????</replaceable>
                </command></term>
                <listitem>
                    <para>
                        Throws an error if <parameter>value</parameter> is not
                        a valid Tcl list.  Futhermore if <parameter>fewest</parameter>
                        is not blank, an error is thrown if
                        <literal>[llength $value] &lt; $fewest</literal>.
                        Similarly, if <parameter>most</parameter> is not blank,
                        an error is thrown if
                        <literal>[llength $value] &gt; $most</literal>.
                    </para>
                    <para>
                        <parameter>checker</parameter> is a script which if
                        not blank is called for each element of
                        <parameter>value</parameter>. <parameter>checker</parameter> is
                        called as follows: <literal>$checker $element {*}$args</literal>
                        where <parameter>element</parameter> is an element of the
                        list.  The intent of this is to provide support for
                        type/range checking each element of the list.
                    </para>
                    <para>
                        One sample use of this proc is:
                        <literal>::::VMUSBDriverSupport::validList $value 32 32 ::::VMUSBDriverSupport::validInt 0 4095</literal>
                        which ensures that <parameter>value</parameter> is a valid
                        list that contains exactly 32 integer elements in the range
                        <literal>[0..4095]</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validIntList <replaceable>value ?fewest ?most ?low ?high????</replaceable>
                </command></term>
                <listitem>
                    <para>
                        This is a convenience procedure that uses <function>validList</function>
                        and <function>validInt</function> to determine if
                        <parameter>value</parameter> is a valid list of
                        integer values with optional range constraints.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validBoolList <replaceable>value ?fewest ?most???</replaceable>
                </command></term>
                <listitem>
                    <para>
                        This is a convenience procedure that uses <function>validList</function>
                        and <function>validBool</function> to determine if
                        <parameter>value</parameter> is a valid list of
                        boolean values.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>

      <refentry id="vmusb3-madc">
        <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
        <refmeta>
           <refentrytitle>madc</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>madc</refname>
           <refpurpose>Acquire events from Mesytec MADC32 ADC.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
madc create <replaceable>name ?options?</replaceable>              
              </command>
          </cmdsynopsis>
         <cmdsynopsis>
             <command>
madc config <replaceable>name ?options?</replaceable>
             </command>
         </cmdsynopsis>
         <cmdsynopsis>
             <command>
madc cget <replaceable>name</replaceable>         
             </command>
         </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
         
           <title>DESCRIPTION</title>
           <para>
              The <command>madc</command> command provides scripted support
               for the Mesytec 32 channel peak sensing adc module.  For scaler
               support for this module's dead time counters, see the
               <link linkend="vmusb3-madcscaler">madcscaler</link> command.
           </para>
           <para>
               As with all VM-USB module support commands, <command>madc</command>
               is a command ensemble with subcommands that
               <command>create</command> and
               <command>config</command>ure modules as well as
               <command>cget</command> which introspects a module configuration.
           </para>
           <para>
               <command>create</command> creates an object with the specified
               <parameter>name</parameter>. Additional options are treated like
               configuration options.  <command>config</command> configures
               an existing module, and <command>cget</command> returns a list of
               configuration name/value pairs that describe the configuration of
               the module.
           </para>
            <para>
               It is important to note that the module configuration does not
               actually get loaded until the run is initialized.  The order in
               which configuration parameter are supplied is therefore unimportant.
               Think of the configuration options as being accumulated and then
               applied as the run starts.  Only modules that are in
               <command>stack</command> are configured.
            </para>
          </refsect1>
          <refsect1>
            <title>
              OPTIONS
            </title>
            <variablelist>
              <varlistentry>
                <term><option>-base</option> <replaceable>address</replaceable></term>
                <listitem>
                  <para>
                    <parameter>address</parameter> must be the module base
                    address as configured in its rotary switches.
                    This base address is used to access the module's register
                    and event memory.
                  </para>
                  <para>
                    Each module must be programmed and hardware configured
                    with a different base address. The address used will be
                    an A32 VME address.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-id</option> <replaceable>vsn</replaceable></term>
                <listitem>
                  <para>
                    <parameter>vsn</parameter> will be used as the module's
                    identifier or <firstterm>virtual slot number</firstterm>.
                    The <parameter>vsn</parameter> will be encoded into the
                    event data that is returned by the module.  This, in turn
                    is normally used by event decoders to determine which parameters
                    the channels of the module should be unpacked into.
                  </para>
                  <para>
                    Each module should be given a unique <parameter>vsn</parameter>.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-ipl</option> <replaceable>irqlevel</replaceable></term>
                <listitem>
                  <para>
                    If the module will be used to trigger an interrupt driven
                    stack, the <parameter>irqlevel</parameter> parameter must
                    be programmed to a valid non zero interrupt priority level
                    (<literal>1</literal> through <literal>7</literal>).
                    This must match the interrupt priority level used to trigger
                    the stack.
                  </para>
                  <para>
                    The default value of <literal>0</literal> disables module
                    interrupts.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-vector</option> <replaceable>statusId</replaceable></term>
                <listitem>
                  <para>
                    If the module will be used to trigger an interrupt driven
                    stack, the <parameter>statusId</parameter> must be programmed
                    to a non zero 8 bit status id, or <firstterm>vector</firstterm>
                    (between <literal>1</literal> and <literal>255</literal>
                  </para>
                  <para>
                    The value used must match the value of the
                    <option>-vector</option> configuration parameter used to
                    trigger the stack.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-timestamp</option>  <replaceable>onoff</replaceable></term>
                <listitem>
                  <para>
                    This option controls whether or not the
                    module tags each event with a trigger number or with a
                    timestamp (see also the
                    <option>-timingsource</option> and
                    <option>-timingdivisor</option> options).
                  </para>
                  <para>
                    The <replaceable>onoff</replaceable> is a boolean value.
                    If true, the module tags events with a timestamp.  If
                    false, with a trigger number.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-gatemode</option>  <replaceable>mode</replaceable></term>
                <listitem>
                  <para>
                    The MADC32 has a pair of gate inputs.  The inputs may
                    be used either as <literal>separate</literal> gates,
                    where each gate controlls 16 of the 32 channels, or
                    as <literal>common</literal> where either input will
                    gate all 32 channels.
                  </para>
                  <para>
                    The value <parameter>mode</parameter> should be either
                    <literal>separate</literal> or <literal>common</literal>.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-gategenerator</option> <replaceable>onoff</replaceable></term>
                <listitem>
                  <para>
                    The module can either use the gates as provided or can
                    insert a gate and delay generator between the gate inputs
                    and the actual gates seen by the ADCs.  Since in most cases,
                    gate must be stretched and timed to match the ADC inputs,
                    this feature can reduce the external electronics needed to
                    properly gate the adc.
                  </para>
                  <para>
                    The <parameter>onoff</parameter> is a boolean that if
                    true enables this gate generator, if false, disables it.
                    See also the <option>-holddelays</option> and
                    <option>-holdwidths</option> configuration parameters
                    that control the gate and delay parameters for each of these
                    resources.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-holddelays</option> <replaceable>delayList</replaceable></term>
                <listitem>
                  <para>
                    If the gate generators are enabled (see
                    <option>-gategenerator</option> above), the
                    <parameter>delayList</parameter> is a Tcl list consisting of
                    the two delay parameters, one for each of the gate and
                    delay generators. See the MADC32 manual for a description of
                    the meaning of these values, which are just the values
                    programmed into the module registers.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-holdwidths</option> <replaceable>widthList</replaceable></term>
                <listitem>
                  <para>
                    If the gate generators are enabled (see
                    <option>-gategenerator</option> above), the
                    <parameter>widthList</parameter> is a Tcl l ilst
                    consisting of the two gate and delay generator width
                    parameters.  See the MADC32 manual for a description
                    of the meaning of these values, which are just the
                    values programmed into the module registers.
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><option>-inputrange</option> <replaceable>rangeSelector</replaceable></term>
                <listitem>
                  <para>
                    Programs the input range for the module.
                    The <parameter>rangeSelector</parameter> must
                    <literal>4v</literal>, <literal>8v</literal>,
                    or <literal>10v</literal>.  Where the selector
                        represents the input range in volts.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-ecltermination</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        This parameter when true enables the ECL input termination.
                        If disabled, the termination is off.  If you are bussing
                        the ECL inputs, only the final module in the bus should
                        have terminatinon enabled, all other modules, should
                        have termination turned off.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-ecltiming</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        This parameter, when true enables tge gate1 ECL input to
                        to be a clock source for the timestamp if true.  If false,
                        The ECL G1 input is an ECL gate1.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-nimtiming</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        If true, enables the NIM Gate1 input to be a clock source
                        for the timestamp.  If not, the NIM Gate1 input is an adc gate.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-timingsource</option> <replaceable>sourceName</replaceable></term>
                  <listitem>
                     <para>
                        Specifies the source of the clock for timestamps.
                        If <literal>external</literal>, whichever of the NIM or
                        ECL GATE1 inputs are enabled is the clock source.
                        If <literal>vme</literal> the VME 16Mhz backplane
                        clock is the clockk.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-timingdivisor</option> <replaceable>log2</replaceable></term>
                  <listitem>
                     <para>
                        Specifies a scale-down value for the timestamp clock.
                        At the time I'm typing this, this value is log base
                        2 of the scale down, that is
                        the final scale down is 1 &lt;&lt; <parameter>log2</parameter>.
                        By the time we get installed, I am supposed to have
                        some firwmare that will allow this to be a 16 bit
                        direct scaledown (e.g. the scaledown would be between 1 and
                        65535).
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-thresholds</option> <replaceable>valueList</replaceable></term>
                  <listitem>
                     <para>
                        Supplies the per channel thresholds for the adc.
                        Channels which convert below their threshold are suppressed
                        from the data stream reducing both data volume and
                        dead-time.  The <parameter>valueList</parameter> is a
                        32 element Tcl  list of the integer thresholds.
                     </para>
                     <para>
                        Note that at the time I'm typing this, channel thresholds
                        have not yet been implemented in the firmware.
                        The firmware I bring with me at installation time
                        will hopefully implement this feature.
                     </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term><option>-nimbusy</option> <replaceable>busyselect</replaceable></term>
                  <listitem>
                    <para>
                      This option selects which signal is presented at the
                      NIM busy output lemo connector.  By default, this will
                      be the module busy.  The <parameter>busyselect</parameter> can
                      be any of the following strings:
                    </para>
                    <variablelist>
                      <varlistentry>
                        <term><literal>busy</literal></term>
                        <listitem>
                          <para>The module busy is output.  This is the
                            default.
                          </para>
                        </listitem>
                      </varlistentry>
                      <varlistentry>
                        <term><literal>gate0</literal></term>
                        <listitem>
                          <para>
                            The Gate0 signal is output. If the internal gate
                            and delay generator is enabled for Gate0,
                            the output will be the output of the gate and
                            delay generator.  This provides a mechanism
                            to check the gate timing on a scope if you are
                            using the internal gate and delay generators.
                          </para>
                        </listitem>
                      </varlistentry>
                      <varlistentry>
                        <term><literal>gate1</literal></term>
                        <listitem>
                          <para>
                            The Gate1 signal is output.  If the internal gate
                            and delay generator is enabled for Gate1,
                            the output will be the output of the gate and
                            delay generator.  This provides a mechanism
                            to check the gate timing on a scope if you are
                            using the internal gate and delay generators.
                          </para>
                          <para>
                            It is not clear to me what happens if you are using
                            module common gates.
                          </para>
                        </listitem>
                      </varlistentry>
                      <varlistentry>
                        <term><literal>cbus</literal></term>
                        <listitem>
                          <para>
                            The CBUS output is reflected here.
                          </para>
                        </listitem>
                      </varlistentry>
                    </variablelist>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term><option>-multievent</option> <replaceable>boolean</replaceable></term>
                  <listitem>
                    <para>
                      Allows the module to be used in multi-event mode.
                      This is normally done in conjunction with the
                      <command>madcchain</command> configuration command.
                      It also usually requires a custom SpecTcl version
                      to handle the data from this device.
                    </para>
                    <para>
                      the default value for this parameter is
                      <literal>false</literal> which runs the module in
                      single event mode.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term><option>-irqthreshold</option> <replaceable>integer</replaceable></term>
                  <listitem>
                    <para>
                      Sets the interrupt threshold.  When a number of
                      complete events have put at least this number of
                      longwords in the fifo, if interupts are enabled,
                      the module will interrupt.
                    </para>
                  </listitem>
                </varlistentry>
                <varlistentry>
                  <term><option>-resolution</option> <replaceable>2k|4k|4khires|8k|8khires</replaceable></term>
                  <listitem>
                    <para>
                      Sets the resolution of the module.  This has an impact on
                      the conversion time. 
                    </para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </refsect1>

            <refsect1>
              <title>EXAMPLES</title>
              <example>
                <title>Sample use of madc command</title>
                <programlisting>
set madcTimeDivisor 14

madc create adc -base 0x40000000 -id 5 -ipl 0             <co id="madccreate" />
madc config adc -gatemode common -gategenerator disabled
madc config adc -inputrange 8v
madc config adc -timestamp on -timingsource vme -timingdivisor $madcTimeDivisor  <co id="madcsubst" />

for {set i 0} {$i &lt; 32} {incr i} {
    lappend thresholds 0                                 <co id="madcmakethresh" />
}
madc config adc -thresholds $thresholds                  <co id="madcthresholds" />

                </programlisting>
              </example>
              <calloutlist>
                <callout arearefs="madccreate">
                  <para>
                    This command creates an object to manage an MADC 32
                    whose base address is <literal>0x40000000</literal>.
                    The module will be referred to by the symbolic name:
                    <literal>adc</literal>
                  </para>
                </callout>
                <callout arearefs="madcsubst">
                  <para>
                    This line illustrates substitution of a Tcl variable for
                    a parameter value.  Tcl variable substition is textual,
                    so you can also use varibles to hold option names, though
                    that may be  a bit odd.
                  </para>
                </callout>
                <callout arearefs="madcmakethresh">
                  <para>
                    This highlights the fact that the configuration file is
                    really a configuration program.  The loop creates a
                    varaiable named <varname>thresholds</varname> that
                    contains a list of 32 zeroes.  This list will be used
                    to program the <literal>adc</literal> thresholds.
                    Normally these values will neither be zero nor uniform
                    from channel to channel.  It may be best to read them from
                    some external file.
                  </para>
                </callout>
                <callout arearefs="madcthresholds" >
                  <para>
                    This command uses the <varname>thresholds</varname> variable
                    and programs the channel thresholds of the ADC.
                  </para>
                </callout>
              </calloutlist>
            </refsect1>

          </refentry>

          <refentry id="vmusb3_mtdc">
            <refentryinfo>
              <author>
                <personname>
                  <firstname>Ron</firstname>
                  <surname>Fox</surname>
                </personname>
              </author>
              <productname>NSCLDAQ</productname>
              <productnumber></productnumber>
            </refentryinfo>
            <refmeta>
              <refentrytitle>mtdc</refentrytitle>
              <manvolnum>3vmusb</manvolnum>
              <refmiscinfo class='empty'></refmiscinfo>
            </refmeta>
            <refnamediv>
              <refname>mtdc</refname>
              <refpurpose>Mesytec 32/34 channel TDC</refpurpose>
            </refnamediv>

            <refsynopsisdiv>
              <cmdsynopsis>
                <command>
                  mtdc create <replaceable>name ?options...?</replaceable>
                </command>
              </cmdsynopsis>
              <cmdsynopsis>
                <command>
              mtdc config <replaceable>name option value ?...?</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
              mtdc cget <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The MTDC32 is a multi hit time digitizer from Mesytec.
            It has two fundamentally different modes of operation;
            <firstterm>trigger matching</firstterm> and
            <firstterm>timestamping</firstterm>
          </para>
          <para>
            In trigger matching mode you establish a time window
            relative to gate inputs.  Hits which occur during that
            time window are accepted and the hit time relative to
            the gate is returned for each hit.  By placing the
            time window correcty it is possible to use this
            mode to simulate a common start or common stop
            TDC. The module can run as two separate 16 channel
            logical modules or as a single 32 channel module.
          </para>
          <para>
            In timestamping mode, all hits are digitized and their
            times relative to the most recent time clear are
            returned.  In timestamping mode, the gate inputs are
            simply another pair of inputs making the module a
            34 channel module when used for timestamping.
          </para>
          <para>
            The module is very flexible and setup can be complex so it is
            important that you understand the MTDC32 manual when reading
            this documentation.
          </para>
          <para>
            The <command>mtdc</command> command is a typical VM-USB
            device support command.  It provides a
            <command>create</command> sub-command for generating module
            instances, a <command>config</command> sub-command for
            configuring module instances and a <command>cget</command>
            subcommand for introspecting the configuration of a module
            instance.
          </para>
        </refsect1>
        <refsect1>
          <title>
            OPTIONS
          </title>
          <variablelist>
            <varlistentry>
              <term><option>-base</option> <parameter>base-address</parameter></term>
              <listitem>
                <para>
                  Supplies the modules VME base address.
                  The <parameter>base-address</parameter>
                  value must match the base address as set in the
                  module rotary switches.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-id</option> <parameter>module-id</parameter></term>
              <listitem>
                <para>
                  Defines the module's id.  This value appears
                  in the id field of the data returned by the device.
                  The <option>-id</option> value is 8 bits wide
                  and therefore can be an unsigned value between
                  <literal>0</literal> and <literal>255</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-ipl</option> <parameter>priority-level</parameter></term>
              <listitem>
                <para>
                  Sets the interrupt priority level for interrupt
                  requests from this module.  The <option>-ipl</option>
                  value can be between <literal>0</literal>
                  and <literal>7</literal>.  A value of
                  <literal>0</literal> disables interrupts.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-vector</option> <parameter>status-id</parameter></term>
              <listitem>
                <para>
                  Provides the VME status id put on the bus
                  when the module generates an interrupt.
                  The MTDC issues an 8 bit status id.
                  Therefore this value can be between
                  <literal>0</literal> and
                  <literal>255</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-irqthreshold</option> <parameter>word-count</parameter></term>
              <listitem>
                <para>
                  Determines the minimum number of 32 bit words the
                  module  must have buffered before it interrupts.
                  When an event has been buffered, if the number of
                  words in the module FIFO is larger than the
                  <option>-irqthreshold</option> value,
                  an interrupt will be requested if enabled.
                </para>
                <para>
                  The FIFO is 32K 32 bit words long so this
                  value can be between
                  <literal>0</literal> and <literal>0x7fff</literal>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-maxtransfers</option> <literal>word-count</literal></term>
              <listitem>
                <para>
                  When the module is in multi-event mode 3, this sets
                  a soft limit on the number of 32 bit words
                  that can be transferred from the module before
                  it issues a <literal>BERR</literal>.
                  The limit is soft in that complete events are
                  always transferred.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-datalen</option> <parameter>length-spec</parameter></term>
              <listitem>
                <para>
                  Determins how the event is padded for alignment.
                  while the values <literal>8</literal>,
                  <literal>16</literal>, <literal>32</literal>
                  and <literal>64</literal> are all legal,
                  in pratice since the events are multiples
                  of 32 bit words, only the latter
                  two values are meaningful.  If the value
                  <literal>64</literal> is chosen then if
                  necessary 32 bit words containing
                  <literal>0xffff</literal> are added
                  to the event data to pad it out to the
                  next 64 bit boundary.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multievent</option> <parameter>on |off |limited</parameter></term>
              <listitem>
                <para>
                  Enables or disables multi-event mode.
                  If <literal>limited</literal> is used, the
                  <option>-datalen</option> specification is used
                  as well.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-skipberr</option> <parameter>on | off|</parameter></term>
              <listitem>
                <para>
                  If true then at the end of the read rather
                  than asserting <literal>BUSERR</literal>
                  return data with the top two bits set to
                  <literal>10</literal> indicating an end of
                  buffer.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-countevents</option> <parameter>yes | no</parameter></term>
              <listitem>
                <para>
                  If true, then the <option>-maxtransfers</option>
                  value is taken to be the number of events rather
                  than the number of words.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-marktype</option> <parameter>timestamp | eventcount | extended-timestamp</parameter></term>
              <listitem>
                <para>
                  Determines what the value in the event correlation
                  field of the data means.  
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-joinedbanks</option> <parameter>yes |no</parameter></term>
              <listitem>
                <para>
                  Only relevant in trigger matching mode when this determines if
                  the gates are ored in to both banks (<literal>yes</literal>
                  or if they affect individual banks
                  of 16 channels (<literal>no</literal>).
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-resolution</option> <parameter>resolution-value</parameter></term>
              <listitem>
                <para>
                  Sets the TDC resolution.  This is only relevant in
                  trigger matching modes as the timestamping mode
                  resolution is always 3.9ps.
                  Allowed values are
                  <literal>500ps 250ps 125ps 62.5ps 31.3ps 15.6ps 7.8ps</literal>
                  and <literal>3.9ps</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-format</option> <parameter>standard |fulltime</parameter></term>
              <listitem>
                <para>
                  Determines if the data are time differences from the
                  gate (trigger matching mode) or full timestamps
                  (timestamping mode).
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0winstart</option> <parameter>ns</parameter></term>
              <term><option>-bank1winstart</option> <parameter>ns</parameter></term>
              <listitem>
                <para>
                  Determines when the matching window for trigger matching
                  mode starts relative to the gate.  <option>-bank1winstart</option>
                  is only relevant with the <option>-joinedbanks</option> is
                  false.  This value is a number between <literal>0</literal>
                  and <literal>32767</literal> where the vaslue
                  <literal>16384</literal> means the window starts with the
                  gate, larger values delay the start and smaller
                  values start the
                  matching window prior to the gate.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0winwidth</option> <parameter>width</parameter></term>
              <term><option>-bank1winwidth</option> <parameter>width</parameter></term>
              <listitem>
                <para>
                  Determines the width of the trigger matching
                  window.  The <parameter>width</parameter>
                  value is in nanoseconds and can be
                  <literal>0</literal> through
                  <literal>16383</literal>, giving a range of
                  16 microseconds.
                </para>
                <para>
                  <option>-bank1winwidth</option> is only meaningful
                  if the
                  <option>-joinedbanks</option> is disabled.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0triggersource</option> <parameter>trigger-spec</parameter></term>
              <term><option>-bank1triggersource</option> <parameter>trigger-spec</parameter></term>
              <listitem>
                <para>
                  The actual triggering of the module is quite flexible.
                  These options allow you to specify how the module is triggered.
                  <option>-bank1triggersource</option> is only
                  meaningful if <option>-joinedbanks</option> is
                  off.
                </para>
                <para>
                  The valid values for the <parameter>trigger-spec</parameter>
                  are:
                </para>
                <variablelist>
                  <varlistentry>
                    <term><literal>Tr0</literal></term>
                    <listitem>
                      <para>
                        The bank is triggered on the Gate 0 input.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>Tr1</literal></term>
                    <listitem>
                      <para>
                        The bank is triggered on the Gate 1 input.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>Ch0</literal> ... <literal>Ch31</literal></term>
                    <listitem>
                      <para>
                        The specified channel is the trigger for the bank.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>Bank0</literal></term>
                    <listitem>
                      <para>
                        A hit in any channel of Bank 0 is the trigger for
                        the bank.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>Bank1</literal></term>
                    <listitem>
                      <para>
                        A hit in any channel of Bank 1 is a trigger
                        for the bank.
                      </para>
                    </listitem>
                  </varlistentry>

                </variablelist>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0firsthit</option> <parameter>boolean</parameter></term>
              <term><option>-bank1firsthit</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If true, only the first hit from the bank
                  is
                  transmitted.  Otherwise all hits in the
                  bank's trigger matching window are
                  transmitted.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-edge</option> <parameter>rising | falling</parameter></term>
              <listitem>
                <para>
                  Determines which signal edge is timed.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-tr0terminated</option> <parameter>boolean</parameter></term>
              <term><option>-tr1terminated</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If this parameter is true, the ECL Trn input is
                  terminated by the module.  If not that
                  input is unterminated.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-resetterminated</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If true, the ECL reset input is terminated
                  otherwise it is unterminated.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-ecltrig1isoscillator</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If true then the ECL trig1 input is treated
                  as an oscillator that is suitable for
                  incrementing the timestamp.  Note that you must also set the
                  <option>-timingsource</option> option properly as
                  well to actually ulse this input as the
                  timestamp clock.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-trigfromecl</option> <option>boolean</option></term>
              <listitem>
                <para>
                  If true, the trigger comes from the ECL inputs,
                  otherwise it comes from the NIM inputs.  This
                  is an exclusive setting (see register
                  <literal>0x6068</literal> documentation e.g.)
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-nimtrig1isoscillator</option> <option>boolean</option></term>
              <listitem>
                <para>
                  The nim TRIG1 input can be used to supply
                  a clock pulse train for the timestamp.
                  See <option>-timingsource</option> which must
                  be set properly as well.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-busy</option> <parameter>bothbanks | cbusoutput | abovethreshold</parameter></term>
              <listitem>
                <para>
                  Describes the function of the busy output:
                </para>
                <variablelist>
                  <varlistentry>
                    <term><literal>bothbanks</literal></term>
                    <listitem>
                      <para>
                        The busy is set when FIFO is full or
                        acquisition is halted (the module
                        cannot accept a busy).
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>cbusoutput</literal></term>
                    <listitem>
                      <para>
                        The busy output is used to run
                        a CBUS control bus.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>abovethreshold</literal></term>
                    <listitem>
                      <para>
                        The busy output indicates the
                        FIFO is occupied above the
                        <option>-irqthreshold</option>
                        value.
                      </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-pulseron</option> <parameter>boolean</parameter></term>
              <listitem>
                <para>
                  If true, the test pulser is active
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-pulserpattern</option> <parameter>bitmask</parameter></term>
              <listitem>
                <para>
                  Sets the pulser pattern, which determines
                  which channels are
                  pulsed.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-bank0threshold</option> <parameter>level</parameter></term>
              <term><option>-bank1threshold</option> <parameter>level</parameter></term>
              <listitem>
                <para>
                  When the modue is jumpered for
                  unipolar inputs, this value determines
                  the threshold used to determine when a
                  signal has happened on the inputs to bankn.
                  If you are doing this
                  <emphasis>read the manual carefully</emphasis>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-timingsource</option> <parameter>vme | external</parameter></term>
              <listitem>
                <para>
                  Determines the timing source for the
                  timestamp clock.  If <literal>vme</literal>
                  the 16Mhz backplane clock specified
                  by the VME standard is used.  If
                  <parameter>external</parameter>,
                  You must have configured one of
                  <option>-ecltrig1isoscillator</option>
                  or <option>-nimtrig1isoscillator</option>
                  to be true in which case the associated
                  input is used as the source for the
                  timestamp clock.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-tsdivisor</option> <parameter>divisor</parameter></term>
              <listitem>
                <para>
                  Sets the scaledown of the timestamp
                  clock input. This is a 16 bit value and
                  the value 0 means division by
                  <literal>65536</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multlow0</option> <parameter>0-255</parameter></term>
              <listitem>
                <para>
                  The bank0 number of channels that must be
                  present to define an event (note that
                  if <option>-joinedbanks</option> is true
                  this multiplicity is over both banks).
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multhi0</option> <parameter>0-255</parameter></term>
              <listitem>
                <para>
                  The largest number of channels that must
                  be
                  present to define an event for bank0
                  or both banks if <option>-joinedbanks</option>
                  is true.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multlow1</option> <parameter>0-255</parameter></term>
              <listitem>
                <para>
                  If banks are not joined the low multiplicity
                  required for an event from bank 1.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multhi1</option> <parameter>0-255</parameter></term>
              <listitem>
                <para>
                  If banks are not joined, the high multiplicity
                  allowed for an event from bank1.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </refsect1>
      </refentry>

      <refentry id="vmusb3-mqdc">
        <refmeta>
          <refentrytitle>mqdc</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
          <refmiscinfo class="empty"></refmiscinfo>
        </refmeta>

        <refnamediv>
          <refname>mqdc</refname>
          <refpurpose>Support Mesytec MQDC-32 modules</refpurpose>
        </refnamediv>

        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
mqdc create <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
mqdc config <replaceable>name ?options</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
mqdc cget <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>
        </refsynopsisdiv>

        <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The <command>mqdc</command> command provides scripted support
            for the Mesytec 32 channel charge-to-digital converter.
          </para>
          <para>
            As with all VM-USB module support commands, <command>mqdc</command>
            is a command ensemble with subcommands that
            <command>create</command> and
            <command>config</command>ure modules as well as
            <command>cget</command>, which introspects a module configuration.
          </para>
          <para>
            <command>create</command> creates an object with the specified
            <parameter>name</parameter>. Additional options are treated like
            configuration options.  <command>config</command> configures
            an existing module, and <command>cget</command> returns a list of
            configuration name/value pairs that describe the configuration of
            the module.
          </para>
          <para>
            It is important to note that the module configuration does not
            actually get loaded until the run is initialized.  The order in
            which configuration parameters are supplied is therefore unimportant.
            Think of the configuration options as being accumulated and then
            applied as the run starts.  Only modules that are registered to a 
            <command>stack</command> are configured. 
          </para>
          <para>
            The configurable options are given names and reasonable defaults
            for the purpose of reducing the learning curve for using the device.
            However, in order to address the considerable number of use cases 
            that this driver will be used in, the decision was made to support
            flexibility at the cost of some complexity. To create a specific 
            behavior, it is sometimes necessary to configure multiple options.
            For this reason, correlated options to the option be described are 
            listed for cross reference. Furthermore, two examples are provided
            in the EXAMPLES section to demonstrate common configurations.
          </para>
        </refsect1>

        <refsect1>
          <title>
            OPTIONS
          </title>
          <para>
            In contrast to some of the other Mesytec digitizer drivers provided
            by NSCLDAQ,
            this driver does not initiate a soft reset at the beginning of every
            run. This is so that timestamps have the option of not clearing between
            runs, which is a behavior that some experiments have required.
            If you would like to soft reset the device, see the slow controls module
            <command>mxdcsoftreset</command>. When used, this module will cause
            a soft reset at the startup of the VMUSBReadout program and then on-demand
            via the <command>init</command> command any time thereafter.
          </para>
          <variablelist>
            <varlistentry>
              <term><option>-base</option> <replaceable>address</replaceable></term>
              <listitem>
                <para>
                  <parameter>address</parameter> must be the module base
                  address as configured in its rotary switches.
                  This base address is used to access the module's register
                  and event memory.
                </para>
                <para>
                  Each module must be programmed and hardware configured
                  with a different base address. The address used will be
                  an A32 VME address.
                </para>
                <para>
                  By default, the value is <literal>0</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-id</option> <replaceable>vsn</replaceable></term>
              <listitem>
                <para>
                  <parameter>vsn</parameter> will be used as the module's
                  identifier or <firstterm>virtual slot number</firstterm>.
                  The <parameter>vsn</parameter> will be encoded into the
                  event data that is returned by the module.  This, in turn
                  is normally used by event decoders to determine which parameters
                  the channels of the module should be unpacked into.
                </para>
                <para>
                  Each module should be given a unique <parameter>vsn</parameter>.
                </para>
                <para>
                  By default, the value is <literal>0</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-timestamp</option>  <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  This option controls whether or not the
                  module tags each event with a trigger number (event count) or with a
                  timestamp (see also the
                  <option>-timingsource</option>,
                  <option>-timingdivisor</option>,
                  <option>-nimtiming</option>,
                  <option>-ecltiming</option>, and 
                  <option>-syncmode</option> options).
                </para>
                <para>
                  The <replaceable>onoff</replaceable> is a boolean value.
                  If true, the module tags events with a 46-bit timestamp. Otherwise,
                  a 32-bit trigger number number is used. The upper 16 bits of the 46-bit 
                  timestamp are encoded into the extended timestamp packet that is outputted before
                  the end of event word.
                </para>
                <para>By default, this is <literal>false</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-usethresholds</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>onoff</replaceable> sets whether the thresholds will be
                  used or not. The effect is the same as providing a list of 32 zeroes to the
                  <option>-thresholds</option> option.
                </para>
                <para>By default, the value is <literal>true</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-thresholds</option> <replaceable>valueList</replaceable></term>
              <listitem>
                <para>
                  Supplies the per channel thresholds for the adc.
                  Channels which convert below their threshold are suppressed
                  from the data stream reducing both data volume and
                  dead-time.  The <parameter>valueList</parameter> is a
                  32 element Tcl  list of the integer thresholds.
                </para>
                <para>
                  The user can supply an 8-bit threshold for each channel. Note that
                  there zero threshold value disables the threshold for the associated channel.
                  To disable all usage of thresholds, the user can either provide a 
                  TCL list containing all zero values or make use of the <option>-usethresholds</option>
                  option.
                </para>
                <para>By default, all values in the list are <literal>0</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-ipl</option> <replaceable>irqlevel</replaceable></term>
              <listitem>
                <para>
                  If the module will be used to trigger an interrupt driven
                  stack, the <parameter>irqlevel</parameter> parameter must
                  be programmed to a valid non zero interrupt priority level
                  (<literal>1</literal> through <literal>7</literal>).
                  This must match the interrupt priority level used to trigger
                  the stack.
                </para>
                <para>
                  The default value of <literal>0</literal> disables module
                  interrupts.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-vector</option> <replaceable>statusId</replaceable></term>
              <listitem>
                <para>
                  If the module will be used to trigger an interrupt driven
                  stack, the <parameter>statusId</parameter> must be programmed
                  to a non zero 8-bit status id, or <firstterm>vector</firstterm>
                  (between <literal>1</literal> and <literal>255</literal>).
                </para>
                <para>
                  The value used must match the value of the
                  <option>-vector</option> configuration parameter used to
                  trigger the stack.
                </para>
                <para>
                  The default value is <literal>1</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-irqthreshold</option> <replaceable>integer</replaceable></term>
              <listitem>
                <para>
                  Sets the interrupt threshold.  If interrupts are enabled, the module
                  will interrupt when the buffer contains at least this number of longwords.
                </para>
                <para>
                  The "max transfer data" (register at 0x601a) described in the MQDC-32 
                  manual is always the same as the value provided to this option.
                </para>
                <para>
                  The default value is <literal>1</literal>.
                </para>
                <para>
                  Be aware that the value provided will be overridden if <option>-multievent</option> is
                  set to <literal>off</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multievent</option> <replaceable>off | on | limited</replaceable></term>
              <listitem>
                <para>
		  Configures the device for multievent mode. The valid values are <literal>off</literal>,
		  <literal>on</literal>, and <literal>limited</literal>. When the value is <literal>off</literal>,
                  then the device is a purely single event mode. There is no buffering that occurs within the
                  device and no new gates are accepted until the device is read out (we reset the device when we read).
                  When the value is <literal>on</literal>, the device will transfer an unlimited amount of data with
                  each read. This driver is written so that each read will attempt to transfer 1024 words. 
                  Finally, if the value is <literal>limited</literal>, then the device will buffer events and then
                  read out an amount determined by the <option>-maxtransfers</option> option.
                  The default value for this parameter is <literal>off</literal>.                
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-countevents</option> <parameter>on | off</parameter></term>
              <listitem>
                <para>
                  If the value passed to this parameter is <literal>on</literal>, then the <option>-maxtransfers</option>
                  value is taken to be the number of events rather
                  than the number of words. If you inspect the manual, this controls the 
                  "count events" bit in the multievent mode register. Note that this
                  only affects the output when the <option>-multievent</option> parameter
                  is set to <literal>limited</literal>. The default value is <literal>no</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-skipberr</option> <parameter>yes | no</parameter></term>
              <listitem>
                <para>
                  If true, then an "end of buffer" is sent instead of a BERR (0xffffffff) when the 
                  reached and <option>-multievent</option>
                  is set to <literal>limited</literal>. This controls the "Emit EOE" bit in the
                  multievent register (see MQDC-32 manual). The default value is <literal>no</literal>.
                </para>
              </listitem>
            </varlistentry> 
            <varlistentry>
              <term><option>-maxtransfers</option> <parameter>integer</parameter></term>
	      <listitem>
                <para>
                  This is a soft threshold for the number of words that can be transferred in a single
                  read when the <option>-multievent</option> parameter is set to <literal>limited</literal>. The number of words 
	          transferred is the least number of words beyond the value set to complete an event. This is
                  only a meaningful parameter if the <option>-multievent</option> parameter is set to <literal>limited</literal>.
                  The default value is <literal>1</literal>.
                </para>
              </listitem>
	    </varlistentry>
	    
            <varlistentry>
              <term><option>-bankoffsets</option> <replaceable>intlist</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>intlist</replaceable> must be a two element TCL list whose
                  entries are interpreted as the bank 0 and bank 1 offsets, in that order. The 
                  values can be in the range [0,255] independently and effectively shift the 
                  spectrum by about 2000 channels.
                </para>
                <para>
                  The default value is <literal>128</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-gatemode</option>  <replaceable>mode</replaceable></term>
              <listitem>
                <para>
                  The MQDC32 has a pair of gate inputs.  The <replaceable>mode</replaceable>
                  can be either <literal>separate</literal> or <literal>common</literal>.
                </para>
                <para>
                  If set to <literal>separate</literal>, two separate gates are to be 
                  provided for each bank of inputs. One must go into gate 0 input and the 
                  other into the gate 1 input. If on the other hand, the option is set
                  to <literal>common</literal>, the gate 0 input will be used gate all 
                  32 channels.
                </para>
                <para>
                  The default setting is <literal>common</literal>.
                </para>
                <para>
                  Note that this value will modify the effect of some other
                  options such as <option>-multlowerlimits</option> and 
                  <option>-multupperlimits</option>,
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-gatelimits</option> <replaceable>intlist</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>intlist</replaceable> must be a two element TCL list
                  that contains integer elements in the range [0,255]. The manual provides
                  a coarse table describing the nonlinear mapping. 
                  It maps the values 0 to 254 to an integration 
                  width range between 4 and 300 ns. If the value is 255, the gate limit is
                  considered infinite such that the physical gate provided as input is 
                  used without any width limit. 
                </para>
                <para>
                  The default value is <literal>255</literal>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-exptrigdelays</option> <replaceable>intlist</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>intlist</replaceable> must be a two element TCL list
                  that contains integer elements each in the range [0,16383]. The range maps to
                  a range of delay from 0 ns to 16384 ns.
                </para>
                <para>
                  The default value is <literal>0</literal>.
                </para>
              </listitem>
            </varlistentry>
    
            <varlistentry>
              <term><option>-inputcoupling0</option> <replaceable>type</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>type</replaceable> determines whether or not the signal inputs
                  for bank 0 are AC or DC couplied. The accepted values for the option are
                  <literal>AC</literal> and <literal>DC</literal>.
                </para>
                <para>
                  The default value is <literal>AC</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-inputcoupling1</option> <replaceable>type</replaceable></term>
              <listitem>
                <para>
                  This has the exact same semantics as the <option>-inputcoupling0</option> option 
                  except that it applies to the bank 1 signal inputs.
                </para>
                <para>
                  The default value is <literal>AC</literal>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-pulser</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>onoff</replaceable> specifies whether the internal test
                  pulser will be turned on or off. It must be a valid boolean value. 
                </para>
                <para>
                  If the test pulser is enabled, the amplitude of the pulser is determined
                  by the value of the <option>-pulseramp</option> option. The pulser is not described
                  in detail in the manual. What happens at the time of writing is that when the 
                  pulser is enabled, an internally generated gate is used to integrate any input
                  signal. This will be uncorrelated to any pulses so the integrator will 
                  in general integrate the baseline noise. The pulser amplitude is added to this integrated
                  value. The result is that if no physical signal inputs are provided, the pulser peak will
                  be quite sharp. On the other hand, if any input signals are connected, the pulser 
                  peak will be smeared out by the variations in the baseline integration. HOWEVER!
                  What was just described only applies when no cable is attached to the individual
                  gate inputs. If the individual gates are potentially being provided 
                  (determined by the presence of a cable), the pulser is rendered ineffective!
                </para>
                <para>
                  The default value is <literal>false</literal>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-pulseramp</option> <replaceable>value</replaceable></term> 
              <listitem>
                <para>
                  The integer value provided for <replaceable>value</replaceable> is to be
                  used for the pulser amplitude. The value must be in the range [0,255].
                </para>
                <para>
                  The default value <literal>32</literal>.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-ecltermination</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  This parameter when true enables the ECL input termination.
                  If disabled, the termination is off.  If you are bussing
                  the ECL inputs, only the final module in the bus should
                  have terminatinon enabled, all other modules, should
                  have termination turned off.
                </para>
                <para>
                  The default value is <literal>true</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-ecltiming</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  When true, this parameter enables the gate1 ECL input to
                  to be used as a clock source for the timestamp. It also enables the
                  fast clear ECL input to be used as an external timestamp reset input. 
                  When false,
                  the ECL G1 input is an ECL gate1 and the ECL fast clear is a fast clear. 
                </para>
                <para>
                  In the case that it is used as a timestamp reset, the behavior is 
                  tightly coupled to the value of the <option>-resetlogic</option> option. 
                </para>
                <para>
                  The default value is false.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-nimtiming</option> <replaceable>onoff</replaceable></term>
              <listitem>
                <para>
                  If true, enables the NIM Gate1 input to be a clock source
                  for the timestamp and NIM faxt clear input to be used as a timestamp
                  reset.  If false, the NIM Gate1 input is a gate for bank 1 and the NIM 
                  fast clear input is a fast clear.
                </para>
                <para>
                  The actual behavior of
                  the reset depends on the value of the <option>-resetlogic</option>.
                </para>
                <para>
                  The default value is false.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-nimbusy</option> <replaceable>busyselect</replaceable></term>
              <listitem>
                <para>
                  This option selects which signal is presented at the
                  NIM busy output lemo connector.  By default, this will
                  be the module busy.  The <parameter>busyselect</parameter> can
                  be any of the following strings:
                </para>
                <variablelist>
                  <varlistentry>
                    <term><literal>busy</literal></term>
                    <listitem>
                      <para>The module busy is outputted.  This is the default.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>rcbus</literal></term>
                    <listitem>
                      <para>
                        This allows the device to be used as a proxy for the Mesytec RC-bus
                        protocol. The NIM busy output serves as the communication port. 
                        A slow-controls module,
                        <literal>mxdcrcbus</literal>, should be used to perform the
                        actual communication with devices.
                      </para>  
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>overthreshold</literal></term>
                    <listitem>
                      <para>
                        A gate will be outputted when the buffer contains more data words than 
                        are specified in the <option>-irqthreshold</option> value. This could 
                        in principle be used
                        as a signal indicating data is ready to be read out if not using an 
                        interrupt as a trigger.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>full</literal></term>
                    <listitem>
                      <para>
                        A gate will be outputted when the buffer is full of data.
                      </para>
                    </listitem>
                  </varlistentry>
                </variablelist>

              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-timingsource</option> <replaceable>sourceName</replaceable></term>
              <listitem>
                <para>
                  The value of <replaceable>sourceName</replaceable> specifies the 
                  source of the clock for timestamps.
                  If <literal>external</literal>, whichever of the NIM or
                  ECL GATE1 inputs are enabled is the clock source.
                  If <literal>vme</literal>, the VME 16Mhz backplane
                  clock is the clock.
                </para>
                <para>
                  If you use an <literal>external</literal> time
                  source,  it is very important that <option>-ecltiming</option>
                  and <option>-nimtiming</option> values are set in a manner that
                  matches your setup.
                </para>
                <para>
                  The default value is <literal>vme</literal>.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-timingdivisor</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The <literal>val</literal> is a 16-bit integer that scales down the 
                  counter in use (event count or timestamp).
                </para>
                <para>
                  The default value is 1.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-resetlogic</option> <replaceable>mode</replaceable></term>
              <listitem>
                <para>
                  The effect of this option should not be confused with enabling or disabling
                  the ability to reset the internal counters (i.e. timestamp or trigger count). 
                  Rather it should be used to set some reset logic in the device. There are 
                  three accepted values that are described below. The default value is
                  <literal>begin_run</literal>.
                </para>
                <variablelist>
                  <varlistentry>
                    <term><literal>never</literal></term>
                    <listitem>
                      <para>
                        In this mode, the counters will never reset automatically between
                        runs. The only 
                        way they will reset is by an external reset input, if the devices inputs are 
                        configured to accept one (See <option>-nimtiming</option> and 
                        <option>-ecltiming</option>). In which case, there is no limit to 
                        the number of times a reset by an external signal can occur.
                      </para>
                      <para>
                        You could use this mode to establish hardware level timestamp 
                        synchronization if you have enabled the device for timestamping 
                        and also for using an external timing source. If doing so, it is
                        left to the user to make sure only one reset signal arrives during
                        the run.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>begin_run</literal></term> 
                    <listitem>
                      <para>
                        In this mode, the counters will reset during the intialization phase
                        of every run. If using a trigger count (aka. an event count), this is 
                        the preferred reset logic.
                      </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term><literal>extern_oneshot</literal></term>
                    <listitem>
                      <para>
                        In this mode, the counter will never reset automatically between runs
                        unless an external signal arrives to a reset input 
                        (See <option>-nimtiming</option> and <option>-ecltiming</option>).
                        In this respect the behavior is similar to the <literal>never</literal>
                        mode. The difference is that this only allows a single reset to occur
                        after the start of a run. What this does is arm the device to reset
                        on the rising edge of the first external reset input. After this first
                        input, the device will not reset until it is armed again during the 
                        initialization phase of the next run.
                      </para>
                      <para>
                        If the user has enabled the device for timestamping
                        and the timing source is external, this is the simplest way to
                        establish hardware level synchronization with other components in the 
                        system. In fact, it is recommended over use of the <literal>never</literal>
                        mode.
                      </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-multlowerlimit0</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>val</replaceable> must be an integer in the range [0,32]. 
                  The effect of this option changes 
                  according to the value of the <option>-gatemode</option> option. In general,
                  this provides a lower multiplicity limit for accepting data. If the number
                  of channels with data for a single gate is greater than or equal to the lower
                  multiplicity limit, the data is added to the buffer. If that is not the case,
                  all data produced for that single gate is discarded.

                </para> 
                <para>
                  If <option>-gatemode</option> is set to <literal>common</literal>, then 
                  the value serves as the lower multiplicity limit for all 32 channels. 
                </para>
                <para>
                  If instead <option>-gatemode</option> is set to <literal>separate</literal>, 
                  it serves as the lower multiplicity limit for bank 0 channels
                  (channels 0 to 15).
                </para>
                <para>
                  The default value for this is 0.
                </para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-multlowerlimit1</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The <replaceable>val</replaceable> must be an integer in the range [0,16]. 
                  The effect of this option changes 
                  according to the value of the <option>-gatemode</option> option. 
                  If <option>-gatemode</option> is set to <literal>common</literal>, then 
                  the value is written to the device, but the device makes no use of it.
                  If instead <option>-gatemode</option> is set to <literal>separate</literal>, 
                  it serves as the lower multiplicity limit for bank 1 channels
                  (channels 16 to 31).
                </para>
                <para>
                  The default value for this is 0.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multupperlimit0</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The requirements and meaning for this are the same as for the 
                  <option>-multlowerlimit0</option> option. The difference is that the 
                  <replaceable>val</replaceable> provided is an upper limit
                  instead of a lower limit. If the number of channels with data for a gate must
                  be less than or equal to the upper limit value provided to be accepted. The
                  valid range of values for <replaceable>val</replaceable> are [0,32].
                </para>
                <para>
                  The default value for this 32.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-multupperlimit1</option> <replaceable>val</replaceable></term>
              <listitem>
                <para>
                  The requirements and meaning for this are the same as for the 
                  <option>-multlowerlimit1</option> option. The difference is that the 
                  <replaceable>val</replaceable> provided is an upper limit
                  instead of a lower limit. If the number of channels with data for a gate must
                  be less than or equal to the upper limit value provided to be accepted. The
                  valid range of values for <replaceable>val</replaceable> are [0,16].
                </para>
                <para>
                  The default value for this 16.
                </para>
              </listitem>
            </varlistentry>

          </variablelist>

        </refsect1>
        <refsect1>
          <title>EXAMPLES</title>
          <example>
            <title>Sample use of mqdc command for timestamping with external oscillator</title>
            <para>
              The following example configures the device for use in a system that 
              has single event readout logic. The user will initiate the data readout 
              by means of some logic external to the device. Furthermore the data must be timestamped for the 
              purpose of event building. The clock is provided on NIM G1 input and an external
              synchronization pulse is provided into the NIM Reset input. Furthermore, the
              device must scale down the clock count by 14.
            </para>
            <programlisting>
set madcTimeDivisor 10

mqdc create qdc -base 0x40000000 -id 5 -ipl 0             <co id="mqdccreate" />
mqdc config qdc -gatemode common
mqdc config qdc -nimtiming true
mqdc config qdc -timestamp on -timingsource external -timingdivisor $madcTimeDivisor 
mqdc config qdc -resetlogic extern_oneshot                <co id="mqdctiming"/>

set thresholds [list]
for {set i 0} {$i &lt; 32} {incr i} {
  lappend thresholds 0                                    <co id="mqdcmakethresh" />
}
mqdc config qdc -thresholds $thresholds                   <co id="mqdcthresholds" />
            </programlisting>
          </example>
          <calloutlist>
            <callout arearefs="mqdccreate">
              <para>
                This command creates an object to manage an MQDC-32
                whose base address is <literal>0x40000000</literal>.
                The module will be referred to by the symbolic name:
                <literal>qdc</literal>.
              </para>
            </callout>
            <callout arearefs="mqdctiming">
              <para>
                This line and the two above it set up the device to receive
                an external clock signal through the NIM inputs and then
                synchronize it via a signal at NIM FC. It also establishes
                that the sync reset will occur once after the run begins
                and that the number of clock cycles that arrive will be scaled
                down by a factor of 10 to produce the timestamp.
              </para>
            </callout>
            <callout arearefs="mqdcmakethresh">
              <para>
                This highlights the fact that the configuration file is
                really a configuration program.  The loop creates a
                variable named <varname>thresholds</varname> that
                contains a list of 32 zeroes.  This list will be used
                to program the <literal>qdc</literal> thresholds.
                Normally these values will neither be zero nor uniform
                from channel to channel.  It may be best to read them from
                some external file.
              </para>
            </callout>
            <callout arearefs="mqdcthresholds" >
              <para>
                This command uses the <varname>thresholds</varname> variable
                and programs the channel thresholds of the QDC.
              </para>
            </callout>
          </calloutlist>

          <example>
            <title>Sample configuration of mqdc for event counting and interrupt readout</title>
            <para>
              The following example will show how to use the device for readout triggered
              by an interrupt. It will also use an event count rather than a timestamp that
              resets between runs.  The readout will be single event mode.
            </para>
            <programlisting>
set thresholds [list]
for {set i 0} {$i &lt; 32} {incr i} {
  lappend thresholds 0                                   
}

mqdc create qdc -base 0x40000000 -ipl 1 -vector 0                   <co id="mqdcirqconfig"/>
mqdc config qdc -thresholds $thresholds

stack create evt
stack config evt -modules {qdc} -trigger interrupt -ipl 1 -vector 0 <co id="mqdcirqrdo"/>
            </programlisting>
          </example>
          <calloutlist>
            <callout arearefs="mqdcirqconfig">
              <para>
                This creates a new object to manage a QDC whose base address is 
                <literal>0x40000000</literal> that will generate an interrupt
                whenever an event occurs. The device's interrupt priority level will be
                1 and the vector it will respond to is 0.
              </para>
            </callout>
            <callout arearefs="mqdcirqrdo">
              <para>
                Here we set up a stack that is triggered by an interrupt with priority level 1. 
                It will then trigger readout of the qdc that we have enabled to respond via
                a vector 0.
              </para>
            </callout>
          </calloutlist>

        </refsect1>

      </refentry>


      <refentry id="vmusb3-madcchain">
        <refentryinfo>
          <author>
            <personname>
              <firstname>Ron</firstname>
              <surname>Fox</surname>
            </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
          <refentrytitle>madcchain</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
          <refname>madcchain</refname>
          <refpurpose>Support CBLT chains of Mesytec MxDC32 family of modules.</refpurpose>
        </refnamediv>
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
madcchain create <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
madcchain config <replaceable>name ?options</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
madcchain cget <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This module creates and configures chains of MxDC32 modules.
            At the moment the MADC-32, MTDC-32, and MQDC-32 all are 
            supported.
            If these modules are, in turn, run in multi-event mode,
            a specialized SpecTcl will be needed to unpack the data.
            It is possible, however to use single event mode with
            CBLT readout and use 'normal' SpecTcl unpacking.
          </para>
          <para>
            The <command>create</command> creates a new MxDC32 chain.
            <replaceable>name</replaceable> will be used to refer to this chain
            during configuration.  At any time the
            <command>cget</command> returns the configuration of the chain
            as a list of parameter-name parameter-value pairs.
          </para>
          <para>
            The <command>config</command> configures an MxDC32 chain.
            A set of option name option value argument pairs should follow
            the chain name on the commandline.  OPTIONS below describes the
            options and their legal values.
          </para>
        </refsect1>
        <refsect1>
          <title>OPTIONS</title>
          <para>
            This section describes the configuration options supported by
            the <command>cmadcchain</command> command.
          </para>
          <variablelist>
            <varlistentry>
              <term><option>-cbltaddress</option>  <replaceable>base-address</replaceable></term>
              <listitem>
                <para>
                  Defines the base address to which the CBLT reads will be
                  directed.  When the modules in the chain are initialized,
                  this address will be programmed as the CBLT base address.
                  Note that only the top 8 bits of this value are used.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-mcastaddress</option> <replaceable>base-address</replaceable></term>
              <listitem>
                <para>
                  Defines the base address for the chain's multicast address.
                  The multicast address is used to perform synchronous initialization
                  and time-stamp clears.  This address will be programmed as the
                  MCAST base address for all modules in the chain.
                  Only the top 8 bits of the <replaceable>base-address</replaceable>
                  have any meaning.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-maxwordspermodule</option> <replaceable>longword-coun</replaceable></term>
              <listitem>
                <para>
                  Defines the maximum words that can be read from each module.
                  This should be a number between
                  <literal>1</literal> and <literal>1024</literal>.
                  This value should usually be larger than the
                  <option>-irqthreshold</option> option programmed into the
                  MxDC32 modules in the chain.  For each block read, the
                  module will return no more data than the complete event that
                  causes the number of longwords read from the module to exceed
                  this value.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><option>-modules</option>  <replaceable>module-name-list</replaceable></term>
              <listitem>
                <para>
                  Defines the list of MxDC32 modules that make up the chain.
                  The value for this option should be a well formulated
                  Tcl list containing names of <command>madc</command> modules.
                  There is a restriction on the order of these names.  The
                  first name in the list must be the leftmost module in the
                  crate and the last name must be the right most module in the
                  chain. 
                </para>
                <para>
                  For practical purposes, to limit confusion, I generally
                  enumerate the modules from left (low slot number) to
                  right (higher slot number). 
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </refsect1>

        <refsect1>
          <title>EXAMPLE</title>
          <para>
            The following daqconfig.tcl script will operate on an MADC-32 and an
            MQDC-32 placed in adjacent slots of a VME crate. The MADC-32 has
            base address set to 0x0d000000 and the MQDC-32 has its base address
            set to 0x40000000 both via jumper switches. The two devices are
            configured to read out using an interrupt trigger. The MADC-32 is
            leftmost in the crate and thus is the first module to be read out.
            Both will respond to the chain block transfer address 0xaa000000 and
            multicast address 0xbb000000. 
          </para>
          <example>
            <title>Sample usage</title>
            <programlisting>
# create and configure the MADC-32 object
madc create adc -base 0x0d000000 -id 1
madc config adc -ipl 1 -vector 0

# create and configure the MQDC-32 object
mqdc create qdc -base 0x40000000 -id 2 
mqdc config qdc -ipl 1 -vector 0

# Create the chain
madcchain create chain 
madcchain config chain -cbltaddress 0xaa000000 
madcchain config chain -mcastaddress 0xbb000000
madcchain config chain -maxwordspermodule 1 

# order matters here. The adc is read first and the qdc last.
madcchain config chain -modules [list adc qdc]

# create a stack that executes via an interrupt
stack create event
stack config event -modules [list chain] -trigger interrupt -ipl 1 -vector 0 
            </programlisting>
          </example>
        </refsect1>
      </refentry>


      <refentry id="vmusb3-madcscaler">
        <refentryinfo>
            <author>
                <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
                </personname>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
          </refentryinfo>
        <refmeta>
           <refentrytitle>madcscaler</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>madcscaler</refname>
           <refpurpose>Support dead-time counters in MADC32 as scalers.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
madcscaler create <replaceable>name ?options?</replaceable>              
              </command>
          </cmdsynopsis>
         <cmdsynopsis>
             <command>
madcscaler config <replaceable>name ?options?</replaceable>
             </command>
         </cmdsynopsis>
         <cmdsynopsis>
             <command>
madcscaler cget <replaceable>name</replaceable>         
             </command>
         </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
              The Mesytec MADC 32 module provides two counters. These counters
              count time and ADC busy time (time between the adc gate and
              readout completion).  Reading these two values as periodic scalers
              in a scaler stack, allows for the computation of dead-time ratios
              without the use of an additional external scaler module..
           </para>
           <para>
               The <command>madcscaler</command> command supports configuring
               MADC32 modules for use as dead-time scalers.
           </para>
           <para>
            The <command>madcscaler</command> command provides the usual
            ensemble of subcommands;
            <command>create</command> to create a named module object,
            <command>config</command> to configure a previously existing object
            by name, and
            <command>cget</command> to obtain the configuration of an existing
            named object.
           </para>
           <para>
             OPTIONS below describes the configuration options.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-base</option> <replaceable>baseAddress</replaceable></term>
                  <listitem>
                      <para>
                        Provides the base address of the module as configured
                        in its rotary switches.
                      </para>
                  </listitem>
              </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>

      <refentry id="vmusb3-mase">
        <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>
	<refmeta>
	   <refentrytitle>mase</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
            <refmiscinfo class='empty'></refmiscinfo>
	</refmeta>
	<refnamediv>
	   <refname>mase</refname>
	   <refpurpose>Support for XLM with MASE firmware.</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	      <command>
mase create <replaceable>name ?options?</replaceable>
              </command>
	  </cmdsynopsis>
          <cmdsynopsis>
	     <command>
mase config <replaceable>name ?options?</replaceable>
	     </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	     <command>
mase cget <replaceable>name</replaceable>
	     </command>
          </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
	      The <command>mase</command> command allows you to create and configure
	      modules that are XLM-VV FGPA modules with firmware for the
	      Indiana MASE data acqusitiopn subsystem.  Please note that this
	      modules is a block mode device, in the sense that each
	      VM-USB trigger may result in multiple events being present in the
	      XLM memory by the time the VM-USB reads the data.  When used with
	      other modules, you must arrange for event building at some point
	      in the system to ensure that data from the MASE module are coherently
	      assembled with data from other devices.
	   </para>
	   <para>
              The module object is created via the <command>create</command>
	      subcommand.  The <parameter>name</parameter> on this defines
	      a unique name which will be used to refer to this module in
	      future commands directed at it.  The optional options are
	      name value pairs used to configure the module.  See
	      OPTIONS below for a list of the supported options.
	   </para>
	   <para>
	      The <command>config</command> subcommand can be used to set or modify
	      configuration parameters after the module is created.  The
	      <parameter>name</parameter> is the name of the module as defined
	      by the <command>create</command> subcommand.   The options are
	      once more name value pairs that are described in the OPTIONS section
	      below.
	   </para>
	   <para>
	      The <command>cget</command> subcommand is can be used to ask
	      a module about its current configuration.  The module configuration is
	      returned as a Tcl list of name value pairs where the name is the
	      name of a configuration option described in the OPTIONS section
	      and the value is the value of that configuration parameter.
	   </para>
	</refsect1>
	<refsect1>
	   <title>
	      OPTIONS
	   </title>
	   <variablelist>
              <varlistentry>
	         <term><option>-base</option>  <replaceable>base-address</replaceable></term>
		 <listitem>
		    <para>
		       Supplies the base address of the XLM module.  The XLM base
		       address is determined by the slot it occupies in a VME
		       backplane with V430 extensions (V430 supplies additional
		       voltages and the slot location on a middle 'JAUX' connector).
		       The base address must be an unsigned integer.  There is no
		       default value for this configuration option.  The value
		       supplied must match the actual board's base address.
                   </para>
		   <para>
		       The XLM-VV must be used in a V430 backplane as it has no other
		       mechanism for the board to set the base address.
		       For information about the JAUX connector see e.g.
		       <ulink url='http://cdsweb.cern.ch/record/1201456/files/Blanchetti_001.pdf'>
		       http://cdsweb.cern.ch/record/1201456/files/Blanchetti_001.pdf</ulink>
		       Specifically page 10 and page 25 and beyond.
		   </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
	         <term><option>-firmware</option>  <replaceable>firmware-path</replaceable></term>
		 <listitem>
		    <para>
		       <replaceable>firmware-path</replaceable> provides the path
		       to the XLM firmware file.  In the MASE module, the firmware
		       is loaded prior to the start of a run.  The file path
		       can be relative or absolute, however environment variables
		       and tilde expansions are not performed by the module driver.
		       The Tcl script however may use the <command>file normalilze</command>
		       and the <varname>envname</varname> to perform these substitutions
		       prior to providing the final filename to this option.
		    </para>
		 </listitem>
	      </varlistentry>
	   </variablelist>
	</refsect1>

      </refentry>


<refentry id="vmusb3-tdcv1x90">
  <refmeta>
     <refentrytitle>tdc1x90</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>tdc1x90</refname>
     <refpurpose>Provide support for the CAEN V1x90 TDC family.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
tdc1x90 create name ?options...?
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
tdc1x90 config name ?options?
    </command>
</cmdsynopsis>
<cmdsynopsis>
    <command>
tdc1x90 cget name
    </command>
</cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	Creates, configures and introspects CAEN V1x90 TDCs.  These modules
        are only supported in trigger matching mode.  Note that the trigger
        time is only good to the FPGA clock, to get precise trigger relative
        timing you will need to also digitize the trigger itself.  SpecTcl
        supports doing a digital subtraction of the trigger channel from
        all other channels to get precise trigger relative timing.
     </para>
     <para>
         The <command>create</command> subcommand creates a new TDC named
         <parameter>name</parameter> the <parameter>options...</parameter> optional
         parameter are configuration option value pairs as described in
         OPTIONS below.
         The <command>config</command> subcommand locates the TDC named
         <parameter>name</parameter> and further configures it via the
         options described in OPTIONS below.
     </para>
      <para>
         The <command>cget</command> subcommand returns as a value the module
         configuration.  The configurationis returned as a list.  Each element
         of the list is a two element sublist consisting of the configuration
         option name and its current value.
      </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><option>-base</option> <replaceable>base-address</replaceable></term>
	    <listitem>
		<para>
                  provides the module base address as set by the rotary switches
                  on the board.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
         <term><option>-vsn</option> <replaceable>geo</replaceable></term>
         <listitem>
            <para>
               Provides the virtual slot number. This value will appear in the
               data from the module in the GEO field.  The <parameter>geo</parameter>
               value must be between 0 and 31 inclusive.
            </para>
         </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>-ipl <replaceable>n</replaceable></option></term>
        <listitem>
            <para>
                Sets the interrupt priority level when using the device interrupts.
                If this is 0 interrupts are disabled.  Legal value are between
                0 and 7 inclusive.  See the <option>-vector</option> switch
                as well.  This defaults to 0.
            </para>
        </listitem>
       </varlistentry>
        <varlistentry>
            <term><option>-vector</option> <replaceable>nnn</replaceable></term>
            <listitem>
                <para>
                    Sets the interrrupt status id value for the module if
                    used in interrupt mode.  If this is 0, interrupts are disabled.
                    See <option>-ipl</option> as well.  This defaults to 0.
                    The values must be integers in the range 0 - 255 inclusive.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-termination</option> <replaceable>none|switch|on</replaceable></term>
            <listitem>
                <para>
                    Sets the module termination.  The value can be any of the
                    following:
                    <variablelist>
                    <varlistentry>
                       <term><literal>none</literal></term>
                       <listitem>
                       <para>
                          No termination will be supplied by the module.
                       </para>
                       </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>switch</literal></term>
                       <listitem>
                       <para>
                          Termination will be controlled by switches in the module
                       </para>
                       </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>on</literal></term>
                       <listitem>
                          <para>
                          Termination is enabled.
                          </para>
                       </listitem>
                    </varlistentry>
                    </variablelist>
                    The default is <literal>on</literal>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-tagtime</option> <replaceable>on|off</replaceable></term>
            <listitem>
                <para>
                    Controls wehther or not the trigger time will be inlcuded
                    in the data.  Note that the trigger time is only accurate
                    to within one tick of the 80Mhz FPGA clock.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-highwatermark</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Determines the numbger of events that must be buffered by the TDC
                to generate an interrupt.  The vale must be an integer in the range
                0..65535 inclusive.  The default value 1, means an interrupt is
                generated whenever there is at least one event in the TDC and
                the TDC interrupts are enabled.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-ecloutput</option> <replaceable>ready|full|almostfull|error</replaceable></term>
            <listitem>
            <para>
                Determines which signal is presented at the programmable ECL
                output pins.  See the CAEN V1190/1290 manuals for information about
                the possible values.  The default is <literal>ready</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-window</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
              The width of the trigger matching window in 25ns units.
              This is sets the effective range of the TDC when simulating
              a common stop or common start TDC. See also <option>-offset</option>,
              <option>-extramargin</option> and <option>-rejectmargin</option>
              and see the section of the TDC manual that describes trigger matching
              mode.  The default value is 40 which corresponds to a 1usec
              matching window.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-offset</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Determines when the trigger matching window starts relative
                to the gate.  A positive offset starts the match window after the
                gate while a negative offset starts the match window prior to the
                gate.  The values are integers and are in 25ns units.  See
                section 2.4.1 for additional constraints.  Note that the actual
                window start time will jitter by +/-25ns, and therefore you should
                use a reference channel to get good gate relative timing.
                Values must be in the range -2048 to 40 inclusive...
                Defaults to -40 or 1usec prior to the gate.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-extramargin</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                The extra search margin for hits.  This is the addtional
                time during after the matching window during which the module
                will search for hits that
                are within the window before declaring the event.  
                This is needed because hits are searched for in the
                module's L1 buffer. Contention may prevent matching hits
                from being written to the L1 buffer for some time after
                they have actually occured.  See 2.4.1 in the manual.
                The units of this value are also 25ns.
                Defaults to  8 which is 200ns.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-rejectmargin</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                 The reject margin.  This is also in 25ns units.  While
                 the module is in continuous storage, it maintains a reject
                counter that flushes hits from the buffer when the
                trigger window is not active.  The module will only
                retain hits for the width of the trigger 
                window + offset + reject marjin before throwing them away
                if there is no trigger.  This ensures the TDC buffer does
                not overflow and that the search for matching hits on the
                trigger is rapid.  
                Defaults to 4 which is 100ns.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-triggerrelative</option> <replaceable>enabled|disabled</replaceable></term>
            <listitem>
            <para>
                 If enabled, the trigger time is subtracted from all the
                hits.  Note again that the trigger time is 
                only precise to 25ns. Precise timing relative to the trigger
                can only be done by subtracting a digitized trigger time
                from the hits.
                Defaults to  <literal>enabled</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-edgedetect</option> <replaceable>pair | leading | trailing | both</replaceable></term>
            <listitem>
            <para>
                Sets the module edge detect mode.   Figure 2.2 provides
                trailing, both}  documentation about what this means;
                'pair' provides the width of a pulse in a 
                channel, 'leading' provides a hit time at the leading
                edge of a pulse, 'trailing' provides a hit time at the
                trailing edge of an input pulse, and 'both' provides
                the time of both the leading and trailing edges of a pulse
                Defaults to  <literal>leading</literal>.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-edgeresolution</option> <replaceable>800ps | 200ps | 100sp | 25ps </replaceable></term>
            <listitem>
            <para>
                 Selects the resolution for the leading/trailing resolution.
                 It is an error to use 25ps if the module is not a V1290
                Defaults to  <literal>100ps</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-leresolution</option> <replaceable>100ps | 200ps | 400ps
            | 800ps | 1.6ns | 3.12ns | 6.25ns | 12.5ns </replaceable></term>
            <listitem>
            <para>
                 In leading, trailing and both mode, sets the resolution
                 with which the leading edge is detected.  
                 Defaults to: <literal>100ps</literal>.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-widthresolution</option> <replaceable>
            100ps | 200ps | 400ops | 800ps | 1.6ns | 3.2ns | 6.25ns | 12.5ns | 400ns | 800ns </replaceable> </term>
            <listitem>
            <para>
                 Sets the resolution with which a pulse width is
                 measured in pair mode. 
                 defaults to <literal>100ps</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-deadtime</option> <replaceable>
            5ns | 10ns | 30ns | Sets 
                  100ns</replaceable></term>
            <listitem>
            <para>
                the double hit resolution. Defaults to <literal>5ns</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-encapsulatechip</option> <replaceable>true | false </replaceable></term>
            <listitem>
            <para>
                If true, the data from a chip is encapsulated as shown
                in figures 6.2/6.4 by a TDC Chip header/trailer.
                default <literal>enabled</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-maxhits</option> <replaceable>
            0 | 1 |  2 |  4 |  8 |
                 16 | 32 | 64 | 128 | infinite</replaceable></term>  
            <listitem>
            <para>
                     Specifies the maximum number of hits for each TDC chip
                     in an event.  Note that a TDC chip has 32 channels.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-errormark</option> <replaceable>true | false </replaceable></term>
            <listitem>
            <para>
                 If true, when an error is detected, an error mark item
                is placed in the output buffer. Figure 6.5 describes the
                format of this item.
                Defaults to  <literal>true</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-errorbypass</option> <replaceable>on | off</replaceable></term>
            <listitem>
            <para>
                If enabled, a TDC that reports an error will not be
                read out for that event.
                Default: <literal>on</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-globaloffset</option> <replaceable>{n m}</replaceable></term>
            <listitem>
            <para>
                Provides the global offset/vernier offset.
                Default: <literal>{0 0}</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-channeladjusts</option></term>
            <listitem>
            <para>
                 Arbitary number of elements that can adjust
                the value of individual channels by adding a positive
                offset to them.  The value of this is a list of two element
                lists where each element consist of a channel number and
                its offset. e.g. {{10 6} {32 5}}  sets the channel
                offsets for channel 10 to 6 and for channel 32 to 5.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-refchannel</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Sets the reference channel.  The value of this channel
                is subtracted from all other channels to produce
                high precision times.  Defaults to <literal>0</literal>.
                This option is only used by SpecTcl and does not influence
                the way the TDC is initialized or read.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-depth</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Sets the number of hits to retain for each channel
                for the purposes of histogramming.
                Defaults to <literal>16</literal>. This option is only
                processed by SpecTcl.  It setting does not influence the setup
                or readout of the TDC.  Note however that setting this value
                larger than the value of <option>-maxhits</option> is probably
                not very useful.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-channelcount</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Sets the number of channels the model of the TDC being used has.
                This is only used to setup SpecTcl's histogramming.
                The value should be one  of 16, 32, 64, or 128, however
                this is not checked by the processing code for this option.
            </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
     <title>METHODS</title>
     <variablelist>
	<varlistentry>
	    <term><command>create <replaceable>name base</replaceable></command></term>
	    <listitem>
		<para>
                    Creates a new instance of a CAEN multihit TDC from the
                    V1x90 family of digitizers.
                    <parameter>name</parameter> is used to refer to this module
                    from now on.
                    The 
                    <parameter>base</parameter> sets the base address of the
                    module.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
            <term><command>config <replaceable>name options</replaceable></command></term>
            <listitem>
            <para>
                Configures an existing TDC <parameter>name</parameter>
                <parameter>options</parameter> are option name value pairs described
                above.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>cget <replaceable>name</replaceable></command></term>
            <listitem>
            <para>
                Returns the module <parameter>name</parameter>'s configuration
                as a list of name value pairs.
            </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
     <title>EXAMPLES</title>
     <para>
     </para>
  </refsect1>

</refentry>
        <refentry id="vmusb3-v1729a">
          <refmeta>
             <refentrytitle>v1729a</refentrytitle>
             <manvolnum>3vmusb</manvolnum>
          </refmeta>
          <refnamediv>
             <refname>v1729a</refname>
             <refpurpose>CAENV1729a waveform digitizer.</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
            <cmdsynopsis>
                <command>
v1729a create <replaceable>name base</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
v1729a config <replaceable>name options</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
v1729a cget <replaceable>name</replaceable>
            </command>
            </cmdsynopsis>
      
          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                This command ensemble provides access to the CAEN V1729A
                waveform digitizer.  The three subcommands allow creation
                configuration and introspection.  See METHODS below for more
                information about these subcommands and their formats.
             </para>
             <para>
                The options described in OPTIONS below allow data taking
                and analysis to be configured according the needs of the
                application.
             </para>
          </refsect1>
          <refsect1>
             <title>
                OPTIONS
             </title>
             <variablelist>
                <varlistentry>
                <term><option>-base</option> <replaceable>base</replaceable></term>
                <listitem>
                <para>
                    Provides the module base address.  The <parameter>base</parameter>
                    must match the base address set in the rotary switches
                    of the module.
                </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term><option>-threshold</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                     Threshold for internal trigger.  The default value is
                     <literal>4095</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-pretrigger</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Pretrigger time in samples.  Defaults to
                    <literal>10240</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-posttrigger</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Post trigger time in samples.
                    Defaults to <literal>64</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggersource</option>
                <replaceable>external | internal | both</replaceable></term>
                <listitem>
                <para>
                    Specifies trigger source: his can also be 'internal', or 'both'.
                    Defaults to <literal>external</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggeredge</option> <replaceable>rising | falling</replaceable></term>
                <listitem>
                <para>
                    Specifies which edge of the trigger is used.
                    Default is <literal>rising</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggermask</option> <replaceable>on | off</replaceable></term>
                <listitem>
                <para>
                     Specifies whether the trigger is masked via the EXT_EN_TRIGGER
                    if this is 'on' EXT_EN_TRIGGER is required to enable triggers
                    to fire.  Defaults to <literal>off</literal>.
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggerchannels</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Only used if internal triggers are allowed.  Set one bit for each
                    channel from which triggers are allowed.
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-poststoplatency</option> <replaceable> n</replaceable></term>
                <listitem>
                <para>
                    Sets the post trigger latency register in samples.
                    Defaults to <literal>4</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-postlatencypretrig</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Sets the value of the post latency pretrigger register.
                    Defaults to <literal>1</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-samplingfreq</option>
                <replaceable>2ghz | 1gzh | 500mhz</replaceable></term>
                <listitem>
                <para>
                     Sampling frequency.  Default value is
                     <literal>2ghz</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-delay</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                     uSec to delay prior to executing the readout.
                    this can be set to zero if the modle interrupt is 
                    used to trigger the data acquisition else it should be set
                    to on the order of 700usec depending on triggering parameters.
                    650usec from end of the signal are required to transfer data.
                    the remaining time depends on the time of the computer trigger
                    relative to the time of the signal end.
                    When setting this recall that the module requires 650usec
                    to digitize and transfer data from the analog memory to
                    the readout memory.
                </para>
                </listitem>
            </varlistentry>

            </variablelist>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    Subcommands recognized by this module are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>create <replaceable>name base</replaceable></term>
                        <listitem>
                        <para>
                            Creates a new module that can be referred to by
                            <parameter>name</parameter>.  <parameter>base</parameter>
                            is the module base address. This can be overidden
                            by the <option>-base</option> configuration
                            parameter.
                        </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>config <replaceable>name options</replaceable></term>
                        <listitem>
                        <para>
                            Configures the module <parameter>name</parameter>.
                            The <parameter>optinos</parameter> are configuration
                            option value pairs described inthe OPTIONS
                            section above.
                        </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>cget <replaceable>name</replaceable></term>
                        <listitem>
                        <para>
                            Retrieves the module configuration as a list
                            of name value pairs.
                        </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
          </refsect1>
  
        </refentry>

      <refentry id="vmusb3-stack">
        <refmeta>
           <refentrytitle>stack</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>stack</refname>
           <refpurpose>Compose and configure VM-USB readout stacks.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
      	<command>
stack create <replaceable>name</replaceable>
      	</command>
          </cmdsynopsis>
             <cmdsynopsis>
                 <command>
stack config <replaceable>name option value...</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
stack cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         
        </refsynopsisdiv>        

        <refsect1>
    
           <title>DESCRIPTION</title>
           <para>
               The VM-USB supports eight readout <firstterm>stacks</firstterm>.
               A stack can be thought of as a set of VME operations the
               VM-USB should perform in response to some trigger condition.
               Reads performed by a stack are placed in an event buffer. Writes
               occure but result in no data.  At appropriate times, the VM-USB
               transmits buffers of read events to the host computer over its USB
               interface. Stacks provide avoid the high latency of the USB bus
               by pushing the readout intelligence for events into the VM-USB, and
               out of the host.
           </para>
           <para>
               The VM-USB supports 8 stacks, and  three kinds of triggers for stacks.
               While all stacks can be
               interrupt triggered, we simplify the VM-USB usage by only allowing
               stacks 2-7 to accept interrupt triggers, defining stack 0 to be
               only triggerable on the <literal>NIM1</literal> input, and stack
               1 to only be triggered with some time periodicity.
           </para>
            <para>
               The <command>stack</command> command allows you to compose stacks
               and specify their trigger conditions.  When data taking is
               enabled, all defined stacks are loaded into the VM-USB and
               their triggers set up.  Stacks are composed by specifying the
               set of modules they should read via the <option>-modules</option>
               configuration option.  All modules in a stack are initialized
               at stack load time and read when the stack is triggered, in the
               order in which they were specified.
            </para>
            <para>
               The <command>create</command> subcommand creates a stack named
               <parameter>name </parameter>.  <parameter>name</parameter>
               will be used by you in future <command>config</command> and
               <command>cget</command> subcommands to refer to this stack.
            </para>
            <para>
               The <command>config</command> subcommand allows you to configure
               the stack contents and trigger conditions of the stack.
               <parameter>name</parameter> determines which stack will be configured.
               The configuration is specified via a set of <replaceable>option value</replaceable>
               pairs.  These are described in OPTIONS below.
            </para>
            <para>
               The <command>cget</command> command returns the configuration of
               the stack as a well formed Tcl list of <replaceable>option value</replaceable>
               pairs.
            </para>
        </refsect1>
        <refsect1>
           <title>
      	OPTIONS
           </title>
           <variablelist>
      	<varlistentry>
      	    <term><option>-trigger</option> <replaceable>nim1 | scaler | interrupt</replaceable></term>
      	    <listitem>
      		<para>
                  Defines the strigger source for the stack.  When the designated
                  trigger is present, the stack will execute.
                  <literal>nim1</literal> triggers the stack on a nim logic true pulse
                  to the IN1 input of the VM-USB.  This forces the stack to be 
                  VM-USB stack number zero as that is the only stack that can be
                  triggered by the IN1.
      		</para>
                <para>
                  <literal>scaler</literal>
                  triggers the stack on the periodic scaler.  This forces the stack
                  to be stack number 1 as that is the only peridically triggerable stack.
                  We restrict periodic triggers to time based periodicity rather than
                  event division periodicity.  The <option>-period</option> option
                  defined below must be configured as well to define the periodicity
                  of the scaler stack.
                </para>
                <para>
                  <literal>interrupt</literal>
                  indicates the stack will be interrupt triggered. This can be
                  used for stacks 2 through 7 as defined by the <option>-stack</option>
                  configuration parameter.   The actual VME interrupt that will trigger
                  the stack is defined by both its interrupt priority level
                  <option>-ipl</option> and the status id the interrupt source
                  places on the backplane in response to the interrupt acknowledge
                  cycle, and specified with the <option>-vector</option> configuration
                  parameter.
                </para>
      	    </listitem>
      	</varlistentry>
         <varlistentry>
            <term><option>-period</option> <replaceable>seconds</replaceable></term>
            <listitem>
               <para>
                  Defines the number of seconds (integer) between scaler stack triggers.
                  This is ignored for all stacks that are not <literal>scaler</literal>
                  <option>-trigger</option>-ed.  The VM-USB manual defines the range of legal
                  values for this option.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-stack</option> <replaceable>stacknum</replaceable></term>
            <listitem>
               <para>
                  Defines the stack number for <literal>interrupt</literal>
                  <option>-trigger</option>-ed stacks.  This is an integer value
                  in the range 2-7 inclusive. This will also select the
                  interrupt register used to define the trigger for the stack.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-vector</option> <replaceable>status-id</replaceable></term>
            <listitem>
               <para>
                  For <literal>interrupt</literal> <option>-trigger</option>-ed
                  stacks, this defines the status Id that must be presented by
                  the interrupt source in response to an interrupt acknowledge
                  to trigger the list.  This taken together with the value of the
                  <option>-ipl</option> configuration option defines the trigger
                  condition for these stacks. The <parameter>status-id</parameter>
                  must be a value between 0 and 255.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-ipl</option> <replaceable>priority</replaceable></term>
            <listitem>
               <para>
                  Defines the interrupt priority level that of the interrupt
                  that will trigger the stack.  An iterrupter places a 3 bit
                  interrupt priority level (IPL) on the VME bus when it requests
                  an interrupt.  The IPL must be nonzero and is intended to reflect
                  the priority of the interrupt (7 highest, 1 lowest), although, in fact,
                  the VME standard allows interrupt responders to treat this value
                  in any way they want.
               </para>
               <para>
                  The VM-USB uses the specified <parameter>priority</parameter> as
                  part of the trigger condition for an <literal>interrupt</literal>
                  <option>-trigger</option>-ed stack.  When an acknowledged interrupt
                  matches both the <option>-ipl</option>, and the <option>-vector</option>
                  configuration parameters of a stack the stack is triggered.
                                                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-delay</option> <replaceable>microseconds</replaceable></term>
            <listitem>
               <para>
                  The VM-USB allows you to define a delay between the stack trigger condition
                  and the actual start of stack execution.  This is normally intended to be used
                  with stacks that are triggered on <literal>nim1</literal>, as there may be
                  a significant time between the generation of an external trigger and the
                  conversion of the digitizers associated with the trigger.  As I read the
                  VM-USB manual, however this delay applies to <emphasis>all</emphasis> stacks.
               </para>
               <para>
                  The <parameter>microseconds</parameter> is the number of microseconds to delay
                  (0-255) between triggers and stack executions.  Because of my understanding of the
                  <emphasis>intent</emphasis> of this delay, the <option>-delay</option> option
                  is ignored for all stacks that are not <literal>nim1</literal>
                  <option>-trigger</option>-ed.
               </para>
               <para>
                  In the very unlikely event that you need to apply a trigger delay
                  to interrupt triggered stacks (most hardware interrupts when data
                  are ready not on a trigger), and you are not using <literal>nim1</literal>
                  triggered stacks, simply build a non-empty <literal>nim1</literal> triggered
                  stack, set it's
                  <option>-delay</option> option to the required delay and never trigger
                  that stack (don't cable anything to the IN1 input).
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-modules</option>  <replaceable>module-list</replaceable></term>
            <listitem>
               <para>
                  Defines the set of modules that will be read out. This can be
                  a valid Tcl list of any set of modules that have been defined
                  so far.  The modules are specified in the order in which readout
                  commands for them will be added to the stack.  If you have
                  built a <command>caenchain</command> add that to the stack rather
                  than adding the individual modules.
               </para>
               <para>
                  Lists of modules must be valid Tcl lists thus:
                  <programlisting>
stack config astack -modules adc1 adc2 adc3  ;      # Incorrect
stack config astack -modules [list adc1 adc2 adc3]; # Correct.
                  </programlisting>
               </para>
            </listitem>
         </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>EXAMPLES</title>
           <para>
               The example below is a rather complete demonstration of how to
               define a set of modules, adc's and scalers, aggregate the
               three adc's into a caenchain, and read that chain as a stack
               triggered on NIM1, and read a pair of scalers triggered every two seconds.
           </para>
           <example>
            <title>Building Stacks</title>
            <programlisting>
adc create adc1    0x04000000
adc config adc1    -geo 12 -supressrange off  -ipl 0 -vector 0

adc create adc2    0x05000000
adc config adc2    -geo 13 -supressrange off  -ipl 0 -vector 0

adc create adc3    0x06000000
adc config adc3    -geo 14 -supressrange off -ipl 0 -vector 0


caenchain create chain

caenchain config chain -base 0x10000000 -modules [list adc1 adc2 adc3]


sis3820 create scaler1 0x35000000
v830    create scaler2 0x80000000
sis3804 create scaler3 -base 0x38383800



stack create events
stack config events -trigger nim1   -modules chain -delay 12

set scalers [list scaler1 scaler2 scaler3]


stack create scalers


stack config scalers -trigger scaler -modules $scalers -period 2

            </programlisting>
           </example>
        </refsect1>

      </refentry>
      
	 <refentry id="vmusb3-CVMUSB">
       <refmeta>
          <refentrytitle id='vmusb3-CVMUSB-title'>CVMUSB</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CVMUSB</refname>
          <refpurpose>Interface with VM-USB controller.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
        #include &lt;CVMUSB.h&gt;

        class <ooclass><classname>CVMUSB</classname></ooclass> {
        
        <methodsynopsis>
          <modifier>static </modifier>
          <type>std::vector&lt;struct usb_device*&gt;</type>
          <methodname>enumerate</methodname>
          <void />
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier> <type>std::string</type>
            <methodname>serialNo</methodname>
            <methodparam>
                <type>usb_device*</type> <parameter>dev</parameter>
            </methodparam>
        </methodsynopsis>
        <constructorsynopsis>
           <methodname>CVMUSB</methodname>
           <methodparam>
                <type>struct usb_device*</type> <parameter>vmUsbDevice</parameter>
           </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeActionRegister</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readFirmwareID</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeGlobalMode</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint16_t</type> <methodname>readGlobalMode</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDAQSettings</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type>
            <methodname>readDAQSettings</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeLEDSource</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readLEDSource</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDeviceSource</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDeviceSource</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDGG_A</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDGG_A</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDGG_B</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDGG_B</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDGG_Extended</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDGG_Extended</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readScalerA</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readScalerB</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeVector</methodname>
            <methodparam>
                <type>int</type> <parameter>which</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readVector</methodname>
            <methodparam>
                <type>int</type> <parameter>which</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeIrqMask</methodname>
            <methodparam>
                <type>uint8_t</type> <parameter>mask</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint8_t</type> <methodname>readIrqMask</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeBulkXferSetup</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readBulkXferSetup</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeWrite32</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeRead32</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_tM</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t*</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeWrite16</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint16_t</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeRead16</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint16_t*M</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeWrite8</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeRead8</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t*</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeBlockRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>baseAddress</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>transferCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeFifoRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>int8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>transferCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeReadBlockCount8</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>mask</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeReadBlockCount16</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>mask</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeReadBlockCount32</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>addressM</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>mask</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeVariableBlockRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>maxCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeVariableFifoRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>maxCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>executeList</methodname>
            <methodparam>
                <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pReadBuffer</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>readBufferSize</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>bytesRead</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>loadList</methodname>
            <methodparam>
                <type>uint8_t</type> <parameter>listNumber</parameter>
            </methodparam>
            <methodparam>
                <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
            </methodparam>
            <methodparam>
                <type>off_t</type> <parameter>listOffset</parameter>
                <initializer> 0</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>usbRead</methodname>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>bufferSize</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>transferCount</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>timeout</parameter>
                <initializer>2000</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>setDefaultTimeout</methodname>
            <methodparam>
                <type>int</type> <parameter>ms</parameter>
            </methodparam>
        </methodsynopsis>
        
        class <ooclass><classname>CVMUSB::RegisterOffsets</classname></ooclass>  {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>FIDRegister</varname> <initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>GMODERegister</varname> <initializer>4</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DAQSetRegister</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>LEDSrcRegister</varname><initializer>0xc</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DEVSrcRegister</varname><initializer>0x10</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DGGARegister</varname><initializer>0x14</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DGGBRegister</varname><initializer>0x18</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ScalerA</varname><initializer>0x1c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ScalerB</varname><initializer>0x20</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ExtractMask</varname><initializer>0x24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV12</varname><initializer>0x28</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV34</varname><initializer>0x2c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV56</varname><initializer>0x30</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV78</varname><initializer>0x34</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DGGExtended</varname><initializer>0x38</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>USBSetup</varname><initializer>0x3c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>USBVHIGH1</varname><initializer>0x40</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>USBVHIGH2</varname><initializer>0x44</initializer>
        </fieldsynopsis>

        };
        class <ooclass><classname>CVMUSB::ActionRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>startDAQ</varname><initializer>1</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>usbTrigger</varname><initializer>2</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>clear</varname><initializer>4</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>sysReset</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>scalerDump</varname><initializer>0x10</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL0</varname><initializer>0x100</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL1</varname><initializer>0x200</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL2</varname><initializer>0x400</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL3</varname><initializer>0x800</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL4</varname><initializer>0x1000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL5</varname><initializer>0x2000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL6</varname><initializer>0x4000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL7</varname><initializer>0x8000</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::FirmwareRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>minorRevMask</varname><initializer>0x000000ff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>minorRevShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>majorRevMask</varname><initializer>0x0000ff00M</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>majorRevShift</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>betaVersionMask</varname><initializer>0x00ff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>betaVersionShift</varname><initializer>16</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>yearMask</varname><initializer>0x0f000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>yearShift</varname><initializer>24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>monthMask</varname><initializer>0xf0000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>monthshift</varname><initializer>27</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::GlobalModeRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLenMask</varname><initializer>0xf</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLenShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen13K</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen8K</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen4K</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen2K</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen1K</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen512</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen256</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen128</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen64</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLenSingle</varname><initializer>9</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>spanBuffers</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>mixedBuffers</varname><initializer>0x20</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>doubleSeparator</varname><initializer>0x40</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>align32</varname><initializer>0x80</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>doubleHeader</varname><initializer>0x100</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>flushScalers</varname><initializer>0x200</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>busReqLevelMask</varname><initializer>0x7000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>busReqLevelShift</varname><initializer>12</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DAQSettingsRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>readoutTriggerDelayMask</varname><initializer>0xff</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>readoutTriggerDelayShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerReadoutPeriodMask</varname><initializer>0xff00</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>>uint32_t</type>
        <varname>scalerReadoutPeriodShift</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerReadoutFrequenyMask</varname><initializer>0xffff0000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerReadoutFrequencyShift</varname><initializer>16</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::LedSourceRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowOutFifoNotEmpty</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowInFifoNotEmpty</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowScalerEvent</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowInFifoFull</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowDTACK</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowBERR</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowBusRequest</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowBusGranted</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowInvert</varname><initializer>0x8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowLatch</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redEventTrigger</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redNimInput1</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redNimInput2</varname><initializer>(2 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBusyM</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redDTACK</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBERR</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBusRequest</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBusGranted</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redInvert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redLatch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenAcquire</varname><initializer>(0 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenStackNotEmpty</varname><initializer>(1 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenEventReady</varname><initializer>(2 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenEventTrigger</varname><initializer>(3 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenDTACK</varname><initializer>(4 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenBERR</varname><initializer>(5 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenBusRequest</varname><initializer>(6 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenBusGranted</varname><initializer>(7 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenInvert</varname><initializer>(8 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenLatch</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowNotArbiter</varname><initializer>(0 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowUsbTrigger</varname><initializer>(1 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowUSBReset</varname><initializer>(2 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBERR1</varname><initializer>(3 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowDTACK</varname> <initializer>(4 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBERR</varname><initializer>(5 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBusRequest</varname><initializer>(6 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBusGranted</varname><initializer>(7 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowInvert</varname><initializer>(8 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowLatch</varname><initializer>(0x10 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DeviceSourceRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Busym</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Trigger</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1BusRequest</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EventToBuffer</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGA</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGB</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EndOfEvent</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1UsbTrigger</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Invert</varname><initializer>8M</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Latch</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger1</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEExecuting</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEAS</varname><initializer>(2 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DataToUsbFIFO</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGA</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGB</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2EndOfEvent</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Invert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Latch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    
    <!-- Scaler A -->
    
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerADGGA</varname><initializer>(0   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI1</varname><initializer>(1   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI2</varname><initializer>(2   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEvent</varname><initializer>(3   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEnable</varname><initializer>(8   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAReset</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBCarryA</varname><initializer>(0   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI1</varname><initializer>(1   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI2</varname><initializer>(2   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEvent</varname><initializer>(3   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEnable</varname><initializer>(8   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBReset</varname><initializer>(0x10 &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggADisabled</varname><initializer>(0   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI1</varname><initializer>(1   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI2</varname><initializer>(2   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEventTrigger</varname><initializer>(3   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEndOfEvent</varname><initializer>(4   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAUsbTrigger</varname><initializer>(5   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAPulser</varname><initializer>(6   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBDisabled</varname><initializer>(0   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI1</varname><initializer>(1   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI2</varname><initializer>(2   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEventTrigger</varname><initializer>(3   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEndOfEvent</varname><initializer>(4   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBUsbTrigger</varname><initializer>(5   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBPulser</varname><initializer>(6   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>freezeScalers</varname><initializer>0x80000000</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DGGAndPulserRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    };
    class <ooclass><classname>CVMUSB::DGGCoarseRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    }; 
    class <ooclass><classname>CVMUSB::ISVRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorMask</varname><initializer>= 0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLMask</varname><initializer>0x700</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLShift</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDMask</varname><initializer>0x7000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDShift</varname><initializer>12</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorMask</varname><initializer>0xff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorShift</varname><initializer>16</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLMask</varname><initializer>0x7000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLShift</varname><initializer>24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDMask</varname><initializer>0x70000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDShift</varname><initializer>28</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::TransferSetupRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountMask</varname><initializer>0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutMask</varname><initializer>0xf00</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutShift</varname><initializer>8</initializer>
        </fieldsynopsis>
    };
    



};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CVMUSB</classname> encapsulates a VM-USB controller.
            Its methods are divided in to several categories:
          </para>
          <itemizedlist>
            <listitem>
                <para>Static methods for enumeration and selection</para>
            </listitem>
            <listitem>
                <para>Methods to access the VM-USB register set</para>
            </listitem>
            <listitem>
                <para>Methods to perform simple VME operations via the controller</para>
            </listitem>
            <listitem>
                <para>A method to execute immediate lists and get the data read
                by those stacks</para>
            </listitem>
            <listitem>
                <para>Methods to download lists and manage the module in
                data taking mode.
                </para>
            </listitem>
          </itemizedlist>
          <para>
            See METHODS below for descriptions of each of the methods.
          </para>
          <para>
            Register bits and field definitions are provided as nested classes
            see CONSTANTS below for a description of each of these classes.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            This section provides a description of each of the methods. Where
            appropriate reference is made to sections of the VM-USB manual.
          </para>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static </modifier>
                      <type>std::vector&lt;struct usb_device*&gt;</type>
                      <methodname>enumerate</methodname>
                      <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This function returns a vector of <type>usb_device*</type>
                        pointers, one for each VM-USB powered up and attached
                        to the system.  <type>usb_device</type> is an opaque
                        type used by libusb to refer to a specific device
                        attached to the host via USB.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static</modifier> <type>std::string</type>
                        <methodname>serialNo</methodname>
                        <methodparam>
                            <type>usb_device*</type> <parameter>dev</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a <type>usb_device</type> pointer, typically]
                        gotten from <methodname>CVMUSB::enumerate</methodname>,
                        returns the serial number string of the device that
                        corresponds to it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CVMUSB</methodname>
                       <methodparam>
                            <type>struct usb_device*</type> <parameter>vmUsbDevice</parameter>
                       </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CVMUSB</classname> object given
                        a <type>usb_device</type> pointer typically gotten from
                        <methodname>CVMUSB::enumerate</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeActionRegister</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the VM-USB
                        action register.  The action register is a write only
                        register that is used to control the overall behavior
                        of the VM-USB.  It allows you to enter or leave
                        data taking mode, reset the VME bus and trigger the
                        various downloaded VME lists.
                    </para>
                    <para>
                        The action register is described in section 3.1 of the
                        VM-UBS manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readFirmwareID</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Reads the firmware Id register.  The firmware Id is a
                        bit encoded readonly register that provides the date,
                        status (beta test or production), the major and minor
                        versions of the firmware.  The firmware Id register
                        is described by section 3.4.1 of the VM-USB manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeGlobalMode</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the VM-USB
                        global mode regiseter.  The global mode register determiens
                        the bus request level, header options and the size of the
                        output buffer, as well as a few other buffer options.
                        It is described in setion 3.4.2 of the VM-USB manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint16_t</type> <methodname>readGlobalMode</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the global mode register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDAQSettings</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                   <para>
                        Writes the data acquisition settings register with
                        <parameter>value</parameter>.  This register, described
                        in section 3.4.3 of the VM-USB manual, determines how
                        scaler buffers are read and the delay between a readout
                        trigger from <literal>IN1</literal> and the actual
                        start of VME list execution.  This is provided to
                        allow users to provide a common digitizer and VM-USB
                        trigger.  The delay, in that case allows digitizers to
                        complete their conversions prior to being read by the
                        readout list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type>
                        <methodname>readDAQSettings</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the data acquisition settings
                        register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeLEDSource</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Write <parameter>value</parameter> to the VM-USB
                        LED source register.  The VM-USB has a set of four LEDs.
                        This register determines the conditions under which each
                        of those LEDs is lit.  The LED source register is described
                        in section 3.4.4 of the VM-USB manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readLEDSource</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the current value of the LED source register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDeviceSource</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the VM-USB device
                        source register.  The VM-USB provides a pair of scalers
                        and gate and delay generators, as well as two front panel
                        NIM outputs.  This register defines the signal sources
                        for each of these devices (when scalers increment, what
                        starts a gate and delay generator and when the outputs
                        are asserted).
                    </para>
                    <para>
                        The Device Sources register is described in section
                        3.4.5 of the VM-USB manual.
                    </para>
                 </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDeviceSource</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the Device source register.        
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDGG_A</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the Delay and
                        Gate Generator A control register. This register
                        contains the length of the output gateas well as the
                        low order bits of the delay.  The Delay and Gate register
                        setup is described in section 3.4.6 of the VM-USB
                        manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDGG_A</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the DGG A control register.        
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDGG_B</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the Delay and
                            Gate Generator B control register. This register
                            contains the length of the output gateas well as the
                            low order bits of the delay.  The Delay and Gate register
                            setup is described in section 3.4.6 of the VM-USB
                            manual.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDGG_B</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of the DGG B control register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDGG_Extended</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the DGG extended delay offset.  This register
                            contains the top 16 bits of the delay for both
                            A and B DGG's. It is describedin section 3.4.6
                            of the VM-USB manual.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDGG_Extended</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the DGG extended delay register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readScalerA</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The VM-USB contains two scalers (counters) that
                            can be incremented as a result of several
                            conditions.  These scalers are named A and B and
                            are described in section 3.4.7 of the VM-USB manual.
                        </para>
                        <para>
                            This method returns the value of scaler A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readScalerB</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            See <methodname>readScalerA</methodname> this method
                            returns the value of scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeVector</methodname>
                        <methodparam>
                            <type>int</type> <parameter>which</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The VM-USB allows stacks to be triggered as a result
                            of VME interrupts.  4 interrupt registers are provided
                            as described in section 3.4.8.  Each register
                            describes the IPL and Status ID of two interrupts
                            and associates each of those with a stack.
                            This method allows you to program the value of one
                            of those registers.
                        </para>
                        <para>
                            The <parameter>which</parameter>   parameter selects
                            which of the interrupt registers to write, numbered
                            from 1 through 4.  The <parameter>value</parameter>
                            parameter is written to the selected register.
                        </para>
                        <para>
                            An error message is thrown as an <type>std::string</type>
                            if <parameter>which</parameter> is illegal.
                        </para>
                        <para>
                            As essentially all VME interrupters in existence
                            use an 8 bit status ID for which the top
                            bits must be set, according to the VME standard,
                            These methods also write both Status/ID expansion
                            registers to <literal>0xffffffff</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readVector</methodname>
                        <methodparam>
                            <type>int</type> <parameter>which</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of
                            one of the interrupt registers described
                            above.  <parameter>which</parameter> indicates
                            which one to read.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeIrqMask</methodname>
                        <methodparam>
                            <type>uint8_t</type> <parameter>mask</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the IRQ mask register described in section
                            3.5 of the VM-USB manual.  The register is
                            set to <parameter>mask</parameter>. Each bit in the
                            mask represents a VME IPL.  <literal>0x01</literal>
                            represents IPL1, <literal>0x40</literal> represents
                            IPL 7.  If a bit is set to 1, interrupts at that IPL
                            will be ignored by the VM-USB.
                        </para>
                        <para>
                            This register only needs to be programmed when
                            the VM-USB is used with other interrupt handling
                            modules (e.g. CPU modules).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint8_t</type> <methodname>readIrqMask</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value last written to the
                            IRQ mask register.  The actual register is write-only.
                            The <classname>CVMUSB</classname> class therefore
                            remembers the most recently written value. This
                            <firstterm>shadow register value</firstterm> is what
                            is returned by this method.  Note as well that
                            the IRQ mask register is set to <literal>0xff</literal>
                            by the constructor so that it has a known intial
                            value.  This initial value <emphasis>disables</emphasis>
                            all
                            interrupt handling by the VM-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeBulkXferSetup</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the Bulk
                            Transfer setup register.  This register is described
                            in section 3.4.10 of the VM-USB manual.  It controls
                            several parameters that can optimize the bandwidth of
                            the USB.  Specifically you can set the number of buffers
                            that will be sent from the VM-USB to the host without
                            generating a USB Packet end frame and the timeout
                            after which the packet end frame will be sent
                            regardless of how many bufers were sent.
                        </para>
                        <para>
                            If the paragraph above is not meaningful to you,
                            and you read 3.4.10 and its still not meaningful, you
                            should probably not touch this register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readBulkXferSetup</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of the Bulk Transfer Setup register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeWrite32</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes a 32 bit longword, <parameter>data</parameter>
                            to a vme <parameter>address</parameter> using
                            the VME Address modifier <parameter>aModifier</parameter>.
                        </para>
                        <para>
                            The function returns <literal>0</literal> on
                            success, <literal>-1</literal> if the USB write
                            failed, <literal>-2</literal> if the USB read of the
                            acknowledgement failed, and <literal>-3</literal>
                            if the acknowledgement packet indicated the
                            transfer failed due to a bus error.
                        </para>
                        <para>
                            For USB write and read failures, the resason for
                            the failure is available in <varname>errno</varname>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeRead32</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_tM</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t*</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a 32 bit longword read from
                            <parameter>address</parameter> using the VME bus
                            address modifier <parameter>aModifier</parameter>.
                            If successful, the data are stored in <parameter>data</parameter>.
                        </para>
                        <para>
                            The return value reflects a high level status of the
                            operation.
                            The function returns <literal>0</literal> on
                            success, <literal>-1</literal> if the USB write
                            failed, <literal>-2</literal> if the USB read of the
                            acknowledgement failed.
                        </para>
                        <para>
                            For USB write and read failures, the resason for
                            the failure is available in <varname>errno</varname>
                        </para>                            
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeWrite16</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Identical to <methodname>vmeWrite32</methodname>
                            however the data transfered is only a 16 bit
                            word wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeRead16</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t*M</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Identical to <methodname>vmeRead32</methodname>
                            however the data read are only a 16 bit word wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeWrite8</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeWrite32</methodname> however
                            the data written are an 8 bit byte in width.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeRead8</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t*</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeRead32</methodname> however
                            the data read are an 8 bit byte in width.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeBlockRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>baseAddress</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>transferCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a block read from the VME bus.  VME block
                            reads the requestor to only send an initial VME
                            base address followed by a new address every time
                            the address crosses a 256 byte boundary.  Subsequent
                            addresses are assumed  to represent a contiguous
                            block of storage.  Not all devices support block
                            transfers.  Block transfers also require specific
                            block transfer address modifiers.  When used properly,
                            block transfers allow higher throughput by
                            reducing the number of address cycles.
                        </para>
                        <para>
                            The base address of the block transfer is
                            <parameter>baseAddress</parameter>.  The address
                            modifier used is <parameter>aModifier</parameter>
                            the caller is responsible for ensuring that
                            <parameter>aModifier</parameter> is a valid
                            block transfer address modifier. <parameter>data</parameter>
                            is a buffer that will receive the data read.
                            <parameter>transferCount</parameter> is the number
                            of longwords (32 bit items) to transfer.  All transfers
                            will be 32 bit wide transfers.  <parameter>countTransferred</parameter>
                            will be the actual number of longwords transferred.
                        </para>
                        <para>
                            For some devices it is possible to transfer fewer
                            items thatn the number of items requested.  An example
                            of this is the use of CAEN V785's in chained block
                            mode.  In that case, the read will transfer data
                            until the ADC's have no more data left at which time
                            the modules will return a bus error on the next transfer
                            and the VM-USB will insert a <literal>0xffffffff</literal>
                            marker in the data stream when the bus error occured.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeFifoRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>transferCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This function is the same as <methodname>vmeBlockRead</methodname>
                            except that all address cycles use the same <parameter>address</parameter>
                            value.  This makes the function suitable to read FIFO
                            registers in modules that support block reads.
                        </para>
                   </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeReadBlockCount8</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>mask</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The VM-USB supports variable sized block reads.
                            These operate by first performing a
                            read of the block count from some register and providing
                            a mask that indicates what part of that data
                            contains the transfer count.
                            The block count read must at some point be
                            folowed by a call to
                            <methodname>vmeVariableBlockRead</methodname>
                            to actually perform the block read.
                        </para>
                        <para>
                            This method does an 8 bit transfer to read the
                            block count for the next
                            <methodname>vmeVariableBlockRead</methodname>
                            call. <parameter>address</parameter> is the
                            byte address of the location that contains the
                            count field.  The addressed module must support
                            byte addressing at this location.  <parameter>mask</parameter>
                            is the mask that defines the bit field containing
                            the count.
                            <parameter>amod</parameter> is the address modifier
                            for the transfer of the transfer count.
                        </para>
                        
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeReadBlockCount16</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>mask</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeReadBlockCount8</methodname>
                            but the block count transfer is 16 bits wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeReadBlockCount32</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>addressM</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>mask</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeReadouBlockCount8</methodname>
                            except the block count is read with a 32 bit transfer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeVariableBlockRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>maxCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Do a variable length block transfer.  This
                                transfer must have been
                                set up by doing a call to one of the
                                <methodname>vmeReadBlockCountxx</methodname> functions.
                                furthermore, no other block transfer can have
                                taken place since that
                                operation.  It is <emphasis>strongly</emphasis>
                                recommended that unless prohibited by the
                                hardware, a vmeReadBlockCountxx be
                                <emphasis>immediately</emphasis> followed by a
                                variable block read or variable fifo read.
                            </para>
                            <para>
                                <parameter>address</parameter> is the starting
                                address of the block read.  <parameter>amod</parameter>
                                is the VME address modifier.  <parameter>data</parameter>
                                is a buffer into which data will be stored and
                                <parameter>maxCount</parameter> the size of that buffer
                                in 32bit longwords.  <parameter>countTransferred</parameter>
                                will be filled in with the total number of longwords
                                actually transferred.
                            </para>
                            <para>
                                The total transfer count is the minimum of the
                                variable block read gotten by the
                                <methodname>vmeReadBlockCountxx</methodname>
                                method, the value of the <parameter>maxCount</parameter>
                                parameter to this call and the number of transfers
                                actually performed prior to and including the
                                transfer that caused a bus error if any.
                            </para>
                            <para>
                                As usual, in the event the transfer terminated
                                with a bus error, that operation inserts a
                                <literal>0xffffffff</literal> in the buffer.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeVariableFifoRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>maxCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeVariableBlockRead</methodname>
                            but all addresses cycles
                            provide <parameter>address</parameter> rather than
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>executeList</methodname>
                        <methodparam>
                            <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>pReadBuffer</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>readBufferSize</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>bytesRead</parameter>
                        </methodparam>
                    </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This function executes a list of operations.
                                The <parameter>list</parameter> parameter
                                is an instance of a
                                <classname>CVMUSBReadoutList</classname>
                                class.  See the documentation for that
                                class for a description of how to build up
                                lists of VM-USB operations.
                            </para>
                            <para>
                                <parameter>pReadBuffer</parameter> points to
                                a buffer into which the results of all
                                VME read operations will be put.
                                The buffer must be <parameter>readBufferSize</parameter>
                                8 bit bytes long.  <parameter>bytesRead</parameter>
                                will be written with the number of bytes actually
                                transferred to <parameter>pReadBuffer</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>loadList</methodname>
                        <methodparam>
                            <type>uint8_t</type> <parameter>listNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
                        </methodparam>
                        <methodparam>
                            <type>off_t</type> <parameter>listOffset</parameter>
                            <initializer> 0</initializer>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Loads a list for triggered execution in data taking
                            mode.  <parameter>listNumber</parameter> is the
                            number of the list to load (stack Number).  Tis
                            is a value in the range <literal>[0..7]</literal>.
                            <parameter>list</parameter> is a list of operations
                            built up by instantiating a <classname>CVMUSBReadoutList</classname>
                        </para>
                        <para>
                            <parameter>listOffset</parameter> is the starting
                            offset in  VM-USB memory at which the list
                            should be loaded.  When computing where to load
                            multiple stacks you need to know that each
                            stack requires:
                            <informalexample>
                                <programlisting>
list.size() * sizeof(uint32_t)/sizeof(uint16_t) + 4
                                </programlisting>
                            </informalexample>
                            locations.
                        </para>
                    </listitem>
                </varlistentry>
                    <varlistentry>
                        <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>usbRead</methodname>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>bufferSize</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>transferCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>timeout</parameter>
                            <initializer>2000</initializer>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a bulk read on the VM-USB.
                            <parameter>data</parameter> provides a buffer
                            into which the data will be read.
                            <parameter>bufferSize</parameter> is the number
                            of bytes of space pointed to by <parameter>data</parameter>
                            <parameter>transferCount</parameter>
                            will be written with the
                            number of transfers that actually were performed.
                        </para>
                        <para>
                            The return value is <literal>0</literal> on success
                            or <literal>-1</literal> on failure.  On failure,
                            zero will be stored in the <parameter>transferCount</parameter>
                            and <varname>errno</varname> will have the reason
                            for the failure.
                        </para>
                        <para>
                            If no data are available by <parameter>timeout</parameter>
                            milliseconds, the read will fail with an
                            <varname>errno</varname> value of
                            <literal>ETIMEDOUT</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>setDefaultTimeout</methodname>
                        <methodparam>
                            <type>int</type> <parameter>ms</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the timeout used for transactions that
                            don't provide a timeout value.  <parameter>ms</parameter>
                            is the number of milliseconds these methods will
                            wait for a response from the VM-USB.
                        </para>
                        <para>
                            Almost all actions with the VM-USB require the
                            host to send a USB packet to the VM-USB and receive
                            a packet in return.  This function sets the timeout
                            that will be used for the <methodname>usbRead</methodname>
                            call to get the return packets.
                        </para>
                    </listitem>
                </varlistentry>        
          </variablelist>
       </refsect1>
        <refsect1>
           <title>CONSTANTS</title>
           <para>
                This class defines a large number of nested classes.  Each nested
                class defines symbolic constants for a register.  The
                SYNOPSIS section shows these definitions.  
           </para>
           <para>
            For example, the <classname>CVMUSB::ActionRegister</classname>
            provides bit definitions fro the Action register.
           </para>
        </refsect1>
     </refentry>
         
	 <refentry id="vmusb3-CVMUSBReadoutList">
       <refmeta>
          <refentrytitle id='vmusb3-CVMUSBReadoutList-title'>CVMUSBReadoutList</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CVMUSBReadoutList</refname>
          <refpurpose>Construct VM-USB stacks</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <synopsis>
#include &lt;CVMUSBReadoutList.h&gt;

class <ooclass><classname>CVMUSBReadoutList</classname></ooclass>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <void />
       
    </constructorsynopsis>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <type>std::vector&lt;uint32_t&gt;&amp;</type> <parameter>list</parameter>
       </methodparam>
       
    </constructorsynopsis>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <modifier>const</modifier> <type>CVMUSBReadoutList&amp;</type>
            <parameter>rhs</parameter>
       </methodparam>
       
    </constructorsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>clear</methodname>
      <void />
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>size_t</type>
      <methodname>size</methodname>
      <void />
      <modifier>const</modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>std::vector&lt;uint32_t&gt;</type>
      <methodname>get</methodname>
      <void />
      <modifier>const</modifier>
    </methodsynopsis>                    
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRegisterRead</methodname>
      <methodparam>
        <type>unsigned int</type> <parameter>address</parameter>
      </methodparam>
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRegisterWrite</methodname>
      <methodparam>
        <type>unsigned int</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type> <parameter>data</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addWrite32</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type> <parameter>datum</parameter>    
      </methodparam>
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addWrite16</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>uint16_t</type> <parameter>datum</parameter>
      </methodparam>
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addWrite8</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>datum</parameter>   
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRead32</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRead16</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRead8</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockRead32</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addFifoRead32</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
      </methodparam>    
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addFifoRead16</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
      </methodparam>    
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockWrite32</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>void*</type><parameter>data</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockCountRead8</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type><parameter>mask</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockCountRead16</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type><parameter>mask</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockCountRead32</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type><parameter>mask</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addMaskedCountBlockRead32</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addMaskedCountFifoRead32</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>    
        <modifier></modifier>
        <type>void</type>
        <methodname>addDelay</methodname>
        <methodparam>
            <type>uint8_t</type><parameter>clocks</parameter>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addMarker</methodname>
        <methodparam>
            <type>uint16_t</type><parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier>
        <type>uint8_t</type> <varname>a32UserData</varname>
        <initializer>0x09</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a32UserProgram</varname><initializer>0xa</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier>
        <type>uint8_t</type><varname>a32UserBlock</varname>
        <initializer>0x0b</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint8_t</type>
        <varname>a32PrivData</varname><initializer>0x0d</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier>
        <type>uint8_t</type><varname>a32PrivProgram</varname><initializer>0x0e</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint8_t</type>
        <varname>a32PrivBlock</varname><initializer>0x0f</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a16User</varname><initializer>0x29</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a16Priv</varname><initializer>0x2d</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24UserData</varname><initializer>0x39</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24UserProgram</varname><initializer>0x3a</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24UserBlock</varname><initializer>0x3b</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24PrivData</varname><initializer>0x3d</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24PrivProgram</varname><initializer>0x3e</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24PrivBlock</varname><initializer>0x3f</initializer>
    </fieldsynopsis>

</synopsis>

       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This object is used to build up lists (stacks) of VME commands.
            The normal procedure is to create an instance of a
            <classname>CVMUSBReadoutList</classname> and invoke its member
            functions to build up the list of operations desired.  The resulting
            list is then passed either to
            <classname>CVMUSB</classname>::<methodname>executeList</methodname>,
            which executes the operations in the list immediately and returns
            any data read.  Alternatively, if the list is being created for
            use as a data acquisition mode stack, it is passed to
            <classname>CVMUSB</classname>::<methodname>loadList</methodname>
            to load it into the VM-USB stack memory.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            This section desribes the methods provide by the
            <classname>CVMUSBReadoutList</classname> class and objects.  Several
            parameters are common throughout and will only be explained here.
          </para>
          <para>
            <type>uint8_t</type> <parameter>amod</parameter> is always a VME Bus
            address modifier.  See CONSTANTS below for a list of the address
            modifiers.
          </para>
          <para>
            <type>uint32_t</type><parameter>address</parameter> is the VME
            address that is the source or target of an operation.  
          </para>
          <para>
            <type>uint32_t</type><parameter>baseAddress</parameter> is the
            starting address of a block transfer operation.
          </para>
          <variablelist>
        <varlistentry>
            <term>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <void />
    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    This is the constructor you will normally use.  It produces
                    an empty VM-USB stack which can be built up using
                    the remaining methods described in this section.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <type>std::vector&lt;uint32_t&gt;&amp;</type> <parameter>list</parameter>
       </methodparam>
    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    This constructor builds a VM-USB list that is intially
                    stocked with the stack contained in <parameter>list</parameter>.
                    This list can be built either by hand or could have been
                    gotten by a call to <methodname>get</methodname> on a
                    previously existinglist.
                    </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <modifier>const</modifier> <type>CVMUSBReadoutList&amp;</type>
            <parameter>rhs</parameter>
       </methodparam>
       
    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Copy constructor.   The existence of this constructor
                    also allows lists to be passed by value to other functions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                  <modifier></modifier>
                  <type>void</type>
                  <methodname>clear</methodname>
                  <void />
                  <modifier></modifier>
                </methodsynopsis>
                </term>
            <listitem>
                <para>
                    Clears the stack.  This allows a <classname>CVMUSBReadoutList</classname>
                    to be re-used once it has been either loaded or executed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>size_t</type>
              <methodname>size</methodname>
              <void />
              <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the number of stack lines. The VM-USB manual
                    defines a stack line as a 32 bit datum.  Most instructions
                    require at least two lines.  Some are even longer.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>std::vector&lt;uint32_t&gt;</type>
              <methodname>get</methodname>
              <void />
              <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the undelying std::list that is used to store
                    the stack as it is being built.  The return value from
                    this method is also usable in a constructor.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRegisterRead</methodname>
              <methodparam>
                <type>unsigned int</type> <parameter>address</parameter>
              </methodparam>
              <modifier></modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to read a VM-USB internal register.
                    In this case <parameter>address</parameter> is a VM-USB
                    register rather than a VME address. The register addresses
                    are listed in the table in section 3.4 of the VM-USB
                    manual.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRegisterWrite</methodname>
              <methodparam>
                <type>unsigned int</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type> <parameter>data</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to do a write to a VM-USB internal
                    register.  <parameter>data</parameter> is the data to be
                    written.  As with <methodname>addRegisterRead</methodname>,
                    <parameter>address</parameter> is a register file address
                    from the table in section 3.4 of the VM-USB manual.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addWrite32</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type> <parameter>datum</parameter>    
              </methodparam>
              <modifier></modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a command to write a 32 bit <parameter>datum</parameter>
                    to the VME bus.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addWrite16</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t</type> <parameter>datum</parameter>
              </methodparam>
              <modifier></modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a command to write a 16 bit <parameter>datum</parameter>
                    to the VME bus.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addWrite8</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>datum</parameter>   
              </methodparam>
            </methodsynopsis>
              </term>
              <listitem>
                <para>
                    Adds an instruction to perform an 8 bit write
                    of <parameter>datum</parameter> to the VME-Bus.
                </para>
              </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRead32</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to do a 32 bit read from the VME
                    bus to the stack.  The data read are either placed in the
                    buffer handed to
                    <classname>CVMUSB</classname>::<methodname>executeList</methodname>
                    or, if the stack is triggered in data taking mode, to the
                    event read for the trigger.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRead16</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to perform a 16 bit read from
                    the VME bus to the stack.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRead8</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to perform an 8 bit read from the VME
                    bus to the stack.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockRead32</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a block read of 32 bit wide quantities to the stack.
                    <parameter>transfers</parameter> is the maximum number of
                    transfers that will be performed.   The transfer will also
                    terminate if VME bus reports a bus error.  In that case,
                    a 32 bit <literal>0xffffffff</literal> will be put in the
                    buffer to mark termination.
                </para>
                <para>
                    If the <parameter>amod</parameter> is a VME block transfer
                    address modifier, the block transfer will only provde an
                    address cycle at the beginning of the transfer and whenever
                    the address crosses a 256 byte boundary as provided for
                    in the VME bus specification for block transfers.  This can
                    significantly improve performance.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addFifoRead32</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
              </methodparam>    
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockRead32</methodname>, however
                    all address cycles will assert
                    <parameter>baseAddress</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addFifoRead16</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
              </methodparam>    
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addFifoRead32</methodname>, however
                    the transfers will be 16 bits wide.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockWrite32</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>void*</type><parameter>data</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a block write to the list.  <parameter>data</parameter>
                    is a buffer containing <parameter>transfers</parameter>
                    worth of 32 bit data to transfer.  If a block transfer
                    <parameter>amod</parameter> is used, the controller will
                    only perform address cycles atthe start of the transfer
                    and as the address crosses 256-byte boundaries as provided
                    for in the VME bus block transfer specification. There must
                    be at least 2 transfers for this to succeed. 
                  </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockCountRead8</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type><parameter>mask</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    The VM-USB provides a set of instructions that
                    allow you to perform variable length block transfers.
                    This is done in two steps.   The first step readss the
                    length of the transfer from somewhere on the VME bus
                    (usually this is a module register).  The second step is
                    to actually perform the variable block transfer.
                </para>
                <para>
                    This method adds a stack instruction to perform
                    an 8 bit data transfer from the VME
                    bus and place the result in the output buffer or event.
                    The set of bits in that data defined by <parameter>mask</parameter>
                    are used to set the transfer count for the next variable length
                    block transfer.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockCountRead16</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type><parameter>mask</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockCountRead8</methodname> however
                    the datum transferred from the VME bus is 16 bits wide rather
                    than 8.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockCountRead32</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type><parameter>mask</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockCountRead16</methodname>, however
                    the datum transferred from the VME bus is 32 bits wide
                    rather than 16.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMaskedCountBlockRead32</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>baseAddress</parameter>
                </methodparam>
                <methodparam>
                    <type>uint8_t</type><parameter>amod</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This method adds an instruction to use the transfer count
                    register loaded by one of the <methodname>addBlockCountRead</methodname>xx
                    methods as the transfer count for a block read that is 32 bits wide.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMaskedCountFifoRead32</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>address</parameter>
                </methodparam>
                <methodparam>
                    <type>uint8_t</type><parameter>amod</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addMaskedCountBlockRead32</methodname>
                    however all address cycles provide <parameter>address</parameter>
                    on the bus.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>    
                <modifier></modifier>
                <type>void</type>
                <methodname>addDelay</methodname>
                <methodparam>
                    <type>uint8_t</type><parameter>clocks</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a delay of <parameter>clocks</parameter> FPGA cycles
                    to the stack.  Each cyle is 12.5ns long.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMarker</methodname>
                <methodparam>
                    <type>uint16_t</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to put the literal <parameter>value</parameter>
                    into the output buffer.
                </para>
            </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
        <refsect1>
           <title>CONSTANTS</title>
           <para>
            The class defines a set of constants that are symbolic definitions of
            the VME address modifiers.  Remember that since these constants
            are defined within <classname>CVUSBReadoutList</classname> the
            classname must be used to scope uses of those definitions.
            For example <programlisting>CVMUSBReadoutList::a32UserData</programlisting>.
           </para>
           <variablelist>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier>
                    <type>uint8_t</type> <varname>a32UserData</varname>
                    <initializer>0x09</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME bus standard this is referred to
                        as <firstterm>Extended Non-privileged Data Access</firstterm>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a32UserProgram</varname><initializer>0xa</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME bus standard thisis referred to as
                        <firstterm>Extended Non-privileged program access</firstterm>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier>
                    <type>uint8_t</type><varname>a32UserBlock</varname>
                    <initializer>0x0b</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME bus standard this is referred to as
                        <firstterm>Extended Non-privileged Block Transfer</firstterm>
                        Block transfer address modifiers only require address
                        cycles on the first cycle, to establish the base address
                        and whenver the address would cross a 256 byte boundary.
                        Using block transfers where possible provides a measurable
                        performance improvement.
                    </para>
                    <para>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier> <type>uint8_t</type>
                    <varname>a32PrivData</varname><initializer>0x0d</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME bus standard refers to this as
                        <firstterm>Extended Supervisory Data</firstterm>.
                        Supervisory data accesses are considered to be from
                        a privileged state.
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier>
                    <type>uint8_t</type><varname>a32PrivProgram</varname><initializer>0x0e</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME bus standard refers to this as
                        <firstterm>Extended Supervisory Program access</firstterm>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier> <type>uint8_t</type>
                    <varname>a32PrivBlock</varname><initializer>0x0f</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME bus standard refers to this as
                        <firstterm>Extended Supervisory Block Transfer</firstterm>.
                        Transfers using block transfer modifiers are assumed to
                        go over a contiguous address block.  The bus master only
                        needs to perform an address cycle at the beginning of the
                        transfer and again as the address crosses 256 byte
                        boundaries.
                    </para>
                    <para>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a16User</varname><initializer>0x29</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME standard this is referred to as
                        <firstterm>Short Non-privileged</firstterm>.
                        Short addresses are those that only use 16 bits of
                        address. The address space is assumed to be used for
                        devices.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a16Priv</varname><initializer>0x2d</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME standard this is referred to as
                        <firstterm>Short Supervisory</firstterm>.
                      Short addresses are those that only use 16 bits of
                        address. The address space is assumed to be used for
                        devices.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>  
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24UserData</varname><initializer>0x39</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME standard, this is referred to as
                        <firstterm>Standard Non-privileged Data</firstterm>.
                        Standard address modifiers pay attention to 24 bits of'
                        address.
                    </para>
                    <para>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>      
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24UserProgram</varname><initializer>0x3a</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to this a
                        <firstterm>Standard Non-Privileged Program</firstterm>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24UserBlock</varname><initializer>0x3b</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standad refers to this as
                        <firstterm>Standard Non-privileged Block</firstterm>.
                        Block transfer address modifiers allow the master to
                        improve performance by only requiring an address cycle
                        at the start of the first transfer and as the block
                        transfer crosses 256 byte address boundaries.
                    </para>
                    <para>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24PrivData</varname><initializer>0x3d</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to ths as
                        <firstterm>Standard Supervisory Data</firstterm>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24PrivProgram</varname><initializer>0x3e</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to this as
                        <firstterm>Standard Supervisory Program</firstterm>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24PrivBlock</varname><initializer>0x3f</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to this as
                        <firstterm>Standard Supervisory Block</firstterm>.
                        Block transfer address modifiers allow the master to
                        improve performance by only requiring an address cycle
                        at the start of the first transfer and as the block
                        transfer crosses 256 byte address boundaries.
                    </para>
                    <para>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
     </refentry>
	 <refentry id="vmusb3-CVMUSBRemote">
       <refmeta>
          <refentrytitle id='vmusb3-CVMUSBRemote-title'>CVMUSBRemote</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CVMUSBRemote</refname>
          <refpurpose>Execute lists remotely on VMUSBReadout</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
#include &lt;CVMUSBRemote.h&gt;

class <ooclass><classname>CVMUSBRemote</classname></ooclass> {
    <constructorsynopsis>
        <methodname>CVMUSBRemote</methodname>
        <methodparam>
            <type>std::string</type> <parameter>deviceName</parameter>
            <initializer>"vmusb"</initializer>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>host</parameter>
            <initializer>"localhost"</initializer>
        </methodparam>
        <methodparam>
            <type>unsigned int</type> <parameter>port</parameter>
            <initializer>27000</initializer>
        </methodparam>
    </constructorsynopsis>
    <destructorsynopsis>
        <modifier>virtual</modifier><methodname>~CVMUSBRemote</methodname><void />
    </destructorsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readFirmwareID</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeGlobalMode</methodname>
        <methodparam>
            <type>uint16_t</type><parameter>value)</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint16_t</type><methodname>readGlobalMode</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDAQSettings</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDAQSettings</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeLEDSource</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readLEDSource</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDeviceSource</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDeviceSource</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDGG_A</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readDGG_A</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDGG_B</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDGG_B</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDGG_Extended</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDGG_Extended</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readScalerA</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readScalerB</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeVector</methodname>
        <methodparam>
            <type>int</type> <parameter>which</parameter>
            </methodparam>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readVector</methodname>
        <methodparam>
            <type>int</type> <parameter>which</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeBulkXferSetup</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readBulkXferSetup</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeWrite32</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type><parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeRead32</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t*</type> <parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeWrite16</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint16_t</type><parameter>data</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeRead16</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type> <parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint16_t*</type><parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeWrite8</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>data</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeRead8</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
            </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t*</type> <parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeBlockRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>baseAddress</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
            </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>transferCount</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeFifoRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type> <parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>transferCount</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeReadBlockCount8</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type> <parameter>mask</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeReadBlockCount16</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type><parameter>mask</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeReadBlockCount32</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type><parameter>mask</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeVariableBlockRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>maxCount</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeVariableFifoRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>maxCount</parameter>
            </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>executeList</methodname>
        <methodparam>
            <type>CVMUSBReadoutList&amp;</type><parameter>list</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>pReadBuffer</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>readBufferSize</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>bytesRead</parameter>
        </methodparam>
    </methodsynopsis>


    // Register bit definintions.

public:
    class <ooclass><classname>RegisterOffsets</classname></ooclass> {
    public:
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>FIDRegister</varname><initializer>0</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>GMODERegister</varname><initializer>4</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DAQSetRegister</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>LEDSrcRegister</varname><initializer>0xc</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DEVSrcRegister</varname><initializer>0x10</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DGGARegister</varname><initializer>0x14</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DGGBRegister</varname><initializer>0x18</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ScalerA</varname><initializer>0x1c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ScalerB</varname><initializer>0x20</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ExtractMask</varname><initializer>0x24</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV12</varname><initializer>0x28</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV34</varname><initializer>0x2c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV56</varname><initializer>0x30</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV78</varname><initializer>0x34</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DGGExtended</varname><initializer>0x38</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>USBSetup</varname><initializer>0x3c</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>USBVHIGH1</varname><initializer>0x40</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>USBVHIGH2</varname><initializer>0x44</initializer>
        </fieldsynopsis>
    };

    class <ooclass><classname>ActionRegister</classname></ooclass>
    public:
        <fieldsynopsis>        
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>startDAQ</varname><initializer>1</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>usbTrigger</varname><initializer>2</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>clear</varname><initializer>4</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>sysReset</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>scalerDump</varname><initializer>0x10</initializer>
        </fieldsynopsis>
    };
   class <ooclass><classname>FirmwareRegister</classname></ooclass> {
    public:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>minorRevMask</varname><initializer>0x000000ff</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>minorRevShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>majorRevMask</varname><initializer>0x0000ff00</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>majorRevShift</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>betaVersionMask</varname><initializer>0x00ff0000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>betaVersionShift</varname><initializer>16</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>yearMask</varname><initializer>0x0f000000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>yearShift</varname><initializer>24</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>monthMask</varname><initializer>0xf0000000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>monthshift</varname><initializer>27</initializer>
    </fieldsynopsis>
    };

    class <ooclass><classname>GlobalModeRegister</classname></ooclass> {
    public:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLenMask</varname><initializer>0xf</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLenShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen13K</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen8K</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen4K</varname><initializer>2</initializer>
        </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen2K</varname><initializer>3</initializer>
        </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen1K</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen512</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen256</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen128</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen64</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLenSingle</varname><initializer>9</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>mixedBuffers</varname><initializer>0x20</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>doubleSeparater</varname><initializer>0x40</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>align32</varname><initializer>0x80</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>doubleHeader</varname><initializer>0x100</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>flushScalers</varname><initializer>0x200</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>busReqLevelMask</varname><initializer>0x7000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>busReqLevelShift</varname><initializer>12</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>DAQSettingsRegister</classname></ooclass> {
    public:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>readoutTriggerDelayMask</varname><initializer>0xff</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>readoutTriggerDelayShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutPeriodMask</varname><initializer>0xff00</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutPeriodShift</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutFrequenyMask</varname><initializer>0xffff0000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutFrequencyShift</varname><initializer>16</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>LedSourceRegister</classname></ooclass> {
    public:
        // Top yellow led:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowOutFifoNotEmpty</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowInFifoNotEmpty</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowScalerEvent</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowInFifoFull</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowDTACK</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowBERR</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowBusRequest</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowBusGranted</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowInvert</varname><initializer>0x8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowLatch</varname><initializer>0x10</initializer>
    </fieldsynopsis>

        // Red LED:
        
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redEventTrigger</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redNimInput1</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redNimInput2</varname><initializer>(2 &lt;&lt; 8)</initializer>
        </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBusy</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redDTACK</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBERR</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBusRequest</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBusGranted</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redInvert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redLatch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>

        // Green led:

    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenAcquire</varname><initializer>(0 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenStackNotEmpty</varname><initializer>(1 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenEventReady</varname><initializer>(2 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenEventTrigger</varname><initializer>(3 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenDTACK</varname><initializer>(4 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenBERR</varname><initializer>(5 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenBusRequest</varname><initializer>(6 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenBusGranted</varname><initializer>(7 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenInvert</varname><initializer>(8 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenLatch</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>

        // Bottom yellow LED

    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowNotArbiter</varname><initializer>(0 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowUsbTrigger</varname><initializer>(1 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowUSBReset</varname><initializer>(2 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBERR1</varname><initializer>(3 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowDTACK</varname><initializer>(4 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBERR</varname><initializer>(5 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBusRequest</varname><initializer>(6 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBusGranted</varname><initializer>(7 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowInvert</varname><initializer>(8 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowLatch</varname><initializer>(0x10 &lt;&lt; 24)</initializer>
    </fieldsynopsis>

    };
    class <ooclass><classname>CVMUSB::DeviceSourceRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Busym</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Trigger</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1BusRequest</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EventToBuffer</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGA</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGB</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EndOfEvent</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1UsbTrigger</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Invert</varname><initializer>8M</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Latch</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger1</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEExecuting</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEAS</varname><initializer>(2 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DataToUsbFIFO</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGA</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGB</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2EndOfEvent</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Invert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Latch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerADisabled</varname><initializer>(0   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI1</varname><initializer>(1   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI2</varname><initializer>(2   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEvent</varname><initializer>(2   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEnable</varname><initializer>(8   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAReset</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBDisabled</varname><initializer>(0   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI1</varname><initializer>(1   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI2</varname><initializer>(2   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEvent</varname><initializer>(2   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEnable</varname><initializer>(8   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBReset</varname><initializer>(0x10 &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggADisabled</varname><initializer>(0   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI1</varname><initializer>(1   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI2</varname><initializer>(2   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEventTrigger</varname><initializer>(3   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEndOfEvent</varname><initializer>(4   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAUsbTrigger</varname><initializer>(5   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAPulser</varname><initializer>(6   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBDisabled</varname><initializer>(0   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI1</varname><initializer>(1   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI2</varname><initializer>(2   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEventTrigger</varname><initializer>(3   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEndOfEvent</varname><initializer>(4   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBUsbTrigger</varname><initializer>(5   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBPulser</varname><initializer>(6   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DGGAndPulserRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    };
    class <ooclass><classname>CVMUSB::DGGCoarseRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    }; 
    class <ooclass><classname>CVMUSB::ISVRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorMask</varname><initializer>= 0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLMask</varname><initializer>0x700</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLShift</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDMask</varname><initializer>0x7000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDShift</varname><initializer>12</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorMask</varname><initializer>0xff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorShift</varname><initializer>16</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLMask</varname><initializer>0x7000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLShift</varname><initializer>24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDMask</varname><initializer>0x70000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDShift</varname><initializer>28</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::TransferSetupRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountMask</varname><initializer>0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutMask</varname><initializer>0xf00</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutShift</varname><initializer>8</initializer>
        </fieldsynopsis>
    };

}; 
 
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Provides remote access to the VM-USB via the VMUSBReadout's
            slow controls server.  This class is a proxy and transparently
            performs network operations with the slow control server to
            execute each method.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            With the exception of the constructor, please refer to
            <link linkend='vmusb3-CVMUSB' endterm='vmusb3-CVMUSB-title' />
            for per method documentation.
            The constructor forms a connection with the VMUSBReadout's
            control server or throws an exception if that is not possible.
          </para>
          <para>
            The parameter constrcutors are:
          </para>
          <variablelist>
            <varlistentry>
                <term>
                    <fieldsynopsis>
                        <type>std::string</type> <varname>deviceName</varname>
                        <initializer>"vmusb"</initializer>
                    </fieldsynopsis>
                    </term>
                <listitem>
                    <para>
                        The n ame of the device driver to direct requests to.
                        This is the name of the driver instance
                        created by the <command>Module</command> command
                        in the control configuration file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <fieldsynopsis>
                        <type>std::string</type> <varname>host</varname>
                        <initializer>"localhost"</initializer>
                    </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The host in which the readout software is running.
                    </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                    <fieldsynopsis>
                        <type>unsigned int</type> <varname>port</varname>
                        <initializer>27000</initializer>
                    </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The port on which the control server is running.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     
         
        <refentry id="vmusb3-CConfigurableObject">
          <refmeta>
             <refentrytitle>CConfigurableObject</refentrytitle>
             <manvolnum>3vmusb</manvolnum>
          </refmeta>
          <refnamediv>
             <refname>CConfigurableObject</refname>
             <refpurpose>Configuration database</refpurpose>
          </refnamediv>
          <refsynopsisdiv>
           <synopsis>
#include &lt;CConfigurableObject.h&gt;
class <ooclass><classname>CConfigurableObject</classname></ooclass>
{
    <constructorsynopsis>
      <methodname>CConfigurableObject</methodname>
      <methodparam>
          <type>std::string</type> <parameter>name</parameter>
      </methodparam>
    </constructorsynopsis>
    <constructorsynopsis>
        <methodname>CConfigurableObject</methodname>
        <methodparam>
            <modifier>const</modifier> <type>CConfigurableObject&amp;</type>
            <parameter>rhs</parameter>
        </methodparam>
    </constructorsynopsis>
    <methodsynopsis>
        <type>std::string</type><methodname>getName</methodname>
        <void /><modifier>const</modifier>
    </methodsynopsis>
    <methodsynopsis>
        <type>std::string</type> <methodname>cget</methodname>
        <methodparam>
            <type>std::string</type><parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>ConfigurationArray</type> <methodname>cget</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>getIntegerParameter</methodname>
        <methodparam>
            <type>std::string</type><parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>bool</type> <methodname>getBoolParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>double</type> <methodname>getFloatParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>typeChecker</type> <parameter>checker</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultValue</parameter>
            <initializer>std::string(""))</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>clearConfiguration</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>configure</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addIntegerParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type>
        <methodname>addIntegerParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>low</parameter>
        </methodparam>
        <methodparam>
            <type>int </type> <parameter>high</parameter>
        </methodparam>
        <methodparam>
            <type>int</type>    <parameter>defaultVal</parameter>
            <initializer>0</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname> addBooleanParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter>
            <initializer>true</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname> addEnumParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>const char**</type> <parameter>pValues</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultValue</parameter>
            <initializer>std::string(""))</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addBoolListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter>
            <initializer>true</initializer>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <type>void</type> <methodname>addBoolListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter>
            <initializer>true</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addIntListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addIntListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minlength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addIntListParam</methodname>
        <methodparam><type>std::string</type> <parameter>name</parameter></methodparam>
        <methodparam><type>int</type> <parameter>minvalue</parameter></methodparam>
        <methodparam><type>int</type> <parameter>maxvalue</parameter></methodparam>
        <methodparam><type>unsigned</type> <parameter>minlength</parameter></methodparam>
        <methodparam><type>unsigned</type> <parameter>maxlength</parameter></methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
        </methodparam>       
        
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type><parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultLength</parameter>
            <initializer>-1</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier><type>bool</type> <methodname>isInteger</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type><methodname> isBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type><methodname> isEnum</methodname>
        <methodparam>
            <type>std::string</type><parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type><parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type><methodname> isFloat</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier><type>bool</type>
        <methodname>isList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type><parameter> value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>isEnumParameter</type>
        <methodname>makeEnumSet</methodname>
        <methodparam>
            <modifier>const</modifier> <type>char**</type> <parameter>values</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>>strToBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    
    typedef <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; ConfigurationArray</type>;
    
    struct  limit {
    <fieldsynopsis>
        <type>bool</type> <varname>s_checkMe</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <type>long</type> <varname>s_value</varname>
    </fieldsynopsis>
    <constructorsynopsis>
        <methodname>limit</methodname><void />
    </constructorsynopsis>
    <constructorsynopsis><methodname>limit</methodname>
        <methodparam>
            <type>long</type> <parameter>value</parameter>
        </methodparam>
    </constructorsynopsis>

  typedef <type>std::pair&lt;limit, limit&gt;   LimitsM</type>
  typedef <type>std::set&lt;std::string&gt; isEnumParameter</type>
  
  typedef struct _ListSizeConstraint {
    <fieldsynopsis>
        <type>limit</type> <varname>s_atLeast</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <type>limit</type> <varname>s_atMost</varname>
    </fieldsynopsis>    
  } ListSizeConstraint;

  struct isListParameter {
  <fieldsynopsis>
    <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
  </fieldsynopsis>
  <fieldsynopsis>
    <type>TypeCheckInfo</type> <varname>s_checker</varname>
  </fieldsynopsis>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>limit</type> <parameter>atLeast</parameter>
    </methodparam>
    <methodparam>
        <type>limit</type> <parameter>atMost</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>ListSizeConstraint</type> <parameter>limits</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <void />
  </constructorsynopsis>
  
  };
    
  struct  flimit {
  <fieldsynopsis>
    <type>bool</type> <varname>s_checkMe</varname>
  </fieldsynopsis>
  <fieldsynopsis>
    <type>float</type> <varname>s_value</varname>
  </fieldsynopsis>
  <constructorsynopsis>
    <methodname>flimit</methodname><void />
  </constructorsynopsis>
  <constructorsynopsis>
    <methodname>flimit</methodname>
    <methodparam>
        <type>float</type> <parameter>value</parameter>
    </methodparam>
  </constructorsynopsis>
  };
  
  typedef <type>?std::pair&lt;flimit, flimit&gt;</type> <varname>FloatingLimits</varname>;
  typedef <type>std::vector&lt;isEnumParameter*&gt;</type> <varname>EnumCheckers</varname>;

}

           </synopsis>
          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                Each VM-USB device driver object contains an instance of
                a <classname>CConfigurableObject</classname>.  The driver
                defines its configuration parameters within that object and
                the object is transparently hooked into the driver command's
                config and cget methods so that the driver code does not have
                to worry about handling those commands.
             </para>
             <para>
                <classname>CConfigurableObject</classname> provides mechanisms
                for not only defining and retrieving configuration parameters, but
                for enforcing constraints on those parameters.  Constraint checking
                can include not only checking the type of a parameter but
                checking for completely arbitrary constraints on the values
                of the confgiguration parameter.
             </para>
             <para>
                Constraint checking is accomplished by associating a validity
                checking function with each parameter.  A set of pre-defined
                validity checking functions, implemented as static class methods
                mean that for most cases you don't need to define your own
                constraint checkers.
             </para>
             <para>
                Another side enforcing strong parameter typing and constraints is
                a set of parameter getters that transparently convert the
                string representation of a parameter to a form that is meaningful
                to the driver.
            </para>
            <para>
                As a simple example, consider a threshold value that must be
                an integer in the range of <literal>[0..4095]</literal>.
                This can be easily defined as a configuration parameter that
                uses the predefined <methodname>isInteger</methodname>
                constraint checker passed an appropriate limit checking
                structure.  When retrieving the paramter, since the <command>config</command>
                subcommand has already perfromed type and range checking, the
                driver can simply use <methodname>getIntegerParameter</methodname>
                to retrieve the parameter value without worrying about
                having any illegal values for the parameter.
            </para>
          </refsect1>
          <refsect1>
             <title>
            METHODS
             </title>
             <para>
                This section describes the bulk of the methods provided by
                <classname>CConfigurableObject</classname>.  The sections
                UTILITY METHODS and BUILT IN TYPE CHECKERS provide information
                about utility methods provided to objects and the built in
                constraint checking methods respetively.
             </para>
             <variablelist>
                <varlistentry>
                    <term><constructorsynopsis>
                    <methodname>CConfigurableObject</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                  </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Basic constructor for a configurable object.
                            Each configuratino has a <parameter>name</parameter>
                            under which it is registered with the device configuration
                            database.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>std::string</type><methodname>getName</methodname>
                            <void /><modifier>const</modifier>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the name of the configuable object.
                                
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>std::string</type> <methodname>cget</methodname>
                            <methodparam>
                                <type>std::string</type><parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                All configuration values are stored as strings.
                                This method returns the configuration value of
                                the configuration parameter named <parameter>name</parameter>.
                            </para>
                            <para>
                                Note  that other methods exist that convert the
                                string ot a more natural type given for
                                parameters with specific semantics.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>ConfigurationArray</type> <methodname>cget</methodname>
                            <void />
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a <classname>ConfigurationArray</classname>
                                that contains the entire device configuration.
                                For information about the shape of a
                                <classname>CConfigurationArray</classname>  see
                                the TYPES section below.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>getIntegerParameter</methodname>
                            <methodparam>
                                <type>std::string</type><parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of the configuration parameter
                                <parameter>name</parameter> converted to a
                                signed integer.  Care should be taken when
                                using this with a parameter that is not validated
                                vai <methodname>isIntegerParameter</methodname>.
                                If the underlying string is not a valid integer,
                                this method will throw a <type>std::string</type>
                                exception.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as <methodname>getIntegerParameter</methodname>
                                however the conversion is to an unsigned integer.
                                If your driver requires a
                                <option>-base</option> option, you should use
                                this method to retrieve that rather than
                                <methodname>getIntegerParameter</methodname>
                                to avoid overflow.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>bool</type> <methodname>getBoolParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of <parameter>name</parameter>
                                converted to a boolean.  Boolean parameters
                                should use <methodname>isBool</methodname>
                                as their constraint checkers.
                            </para>
                            <para>
                                In order to make boolean parameters more natural.
                                The following set of strings is acceepted as
                                <literal>true</literal>
                                <literal>{"true", "yes", "1", "on", "enabled"}</literal>
                                and <literal>false</literal> strings are in the
                                set:
                                <literal>{"false", "no", "0", "off", "disabled"}</literal>.
                            </para>
                            <para>
                                If the string value is not in one of those
                                two sets, a <type>std::string</type>
                                exception is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>double</type> <methodname>getFloatParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the parameter <parameter>name</parameter>
                                converted to a floating point value.  <parameter>name</parameter>
                                should be associated with the
                                <methodname>isFloat</methodname> constraint checker.
                                If, however it is not, an <type>std::string</type>
                                exception is thrown if the value does not have
                                a floating point representation.
                            </para>
                         </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This member function parses the value of
                                parameter <parameter>name</parameter> as a Tcl
                                list of integers and returns those integers
                                as a <type>std::vector&lt;int&gt;</type>.
                                This is most often used when a configuration
                                parameter is used to represent per channel
                                values for a digitizer.
                            </para>
                            <para>
                                Normally you will use this to process values
                                of parameters that use the <methodname>isList</methodname>
                                constraint checker with <methodname>isInteger</methodname>
                                specifies as a per element constraint chedker.
                            </para>
                            <para>
                                As with all parameter value getting methods, if
                                the value does not parse correctly (is not a
                                Tcl list or a list element is not an integer),
                                a <type>std::string</type> exception is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>typeChecker</type> <parameter>checker</parameter>
                            </methodparam>
                            <methodparam>
                                <type>void*</type> <parameter>arg</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>defaultValue</parameter>
                                <initializer>std::string(""))</initializer>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>void</type> <methodname>clearConfiguration</methodname>
                            <void />
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a new parameter to the configurable object.
                                This parameter will be reported in
                                <command>cget</command> subcommands and
                                can be modified in <command>config</command>
                                subcomands.
                            </para>
                            <para>
                                The <parameter>name</parameter> parameter is
                                the name fo the new parameter. By convention,
                                the first character of a configuration option
                                is a hyphen (<literal>-</literal>), although
                                the configurable object makes no such restriction.
                            </para>
                            <para>
                                <parameter>defaultValue</parameter> specifies
                                the initial value given to this variable.
                                Careful thought about initial/default values
                                allows users to minimize the number of
                                configuration options they actually need to set.
                            </para>
                            <para>
                                <parameter>checker</parameter> and
                                <parameter>arg</parameter> specify the constraint
                                checking that is performed on a parameter when
                                the configuration script attempts to modify it.
                                <parameter>checker</parameter> is a function that
                                is expected to check the proposed new value for
                                validity.  <parameter>arg</parameter> is a
                                parameter that is passed, without interpretation,
                                to the checker.  See TYPE CHECKERS below for
                                more information about constraint checking.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>configure</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides a new proposed <parameter>value</parameter>
                                to the configuration parameter <parameter>name</parameter>.
                                This method does not bypass constraint checks.
                                If the constraint check on the parameter fails,
                                a <type>std::string</type> error message exception
                                is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addIntegerParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultVal</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is a convenience method that adds a new
                                parameter,
                                <parameter>name</parameter>,
                                to the configuration database.
                                The <methodname>isInteger</methodname>
                                constraint checker is associated with
                                the parameter, however no range limits are
                                specified.
                            </para>
                            <para>
                                The <parameter>defaultVal</parameter> is
                                used as the initial value of the parameter>
                            </para>
                        </listitem>    
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type>
                            <methodname>addIntegerParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>low</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int </type> <parameter>high</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type>    <parameter>defaultVal</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous method, however
                                <parameter>low</parameter> and <parameter>high</parameter>
                                constrain the range of the integer value.
                                If you require an asymmetric range you have two choices.
                                Use <methodname>addParameter</methodname> and
                                fill in the parameter struct for <methodname>isInteger</methodname>
                                appropriately, or use one of
                                <literal>INT_MAX, INT_MIN, UINT_MAX</literal>
                                for the appropriate limit.  These values
                                are defined in <literal>&lt;limits.h&gt;</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type><methodname> addBooleanParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>bool</type> <parameter>defaultVal</parameter>
                                <initializer>true</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter>
                                whose value checked via
                                <methodname>isBool</methodname> to ensure
                                it is always a boolean value.
                                <parameter>defaultVal</parameter> is the
                                initial value given to the parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type><methodname> addEnumParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>const char**</type> <parameter>pValues</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>defaultValue</parameter>
                                <initializer>std::string(""))</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter>
                                whose type checker ensures that valid values
                                are constrained to be in the list of
                                strings in <parameter>pValues</parameter>.
                                The initial value of the parameter is
                                <parameter>defautltValue</parameter>
                            </para>
                            <para>
                                <parameter>pValues</parameter> is a null
                                terminated array of pointers to the legal strings.
                                These can be declared as shown below:
                            </para>
                            <informalexample>
                                <programlisting>
static const char* validEnums[] = {
"one", "two", "three", NULL
};
                                </programlisting>
                            </informalexample>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addBoolListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>bool</type> <parameter>defaultVal</parameter>
                                <initializer>true</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter> to
                                the configuration whose legal values are
                                lists of boolean parameters.  The list
                                is a fixed <parameter>size</parameter>.
                                The <parameter>defaultVal</parameter>
                                is the value that each element of the list is
                                initialized to.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addBoolListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>minLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>maxLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>bool</type> <parameter>defaultVal</parameter>
                                <initializer>true</initializer>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultSize</parameter>
                                <initializer>-1</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous method, however
                                the length of the list can vary between a
                                minimum length (<parameter>minLength</parameter>)
                                and a maximum length (<parameter>maxLength</parameter>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addIntListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultVal</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter>
                                that is checked to ensure it consists of a
                                list of integer values.  The size of the list
                                is fixed at <parameter>size</parameter>.
                                The initial value of all elements of the list
                                is set to <parameter>defaultValue</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addIntListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>minlength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>maxLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultVal</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultSize</parameter>
                                <initializer>-1</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous function however
                                the length of the list can vary between
                                <parameter>minlength</parameter> and
                                <parameter>maxLength</parameter> and the
                                list has an initial value of <parameter>defaultSize</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void</type>
                                    <methodname>addIntListParam</methodname>
                                    <methodparam><type>std::string</type> <parameter>name</parameter></methodparam>
                                    <methodparam><type>int</type> <parameter>minvalue</parameter></methodparam>
                                    <methodparam><type>int</type> <parameter>maxvalue</parameter></methodparam>
                                    <methodparam><type>unsigned</type> <parameter>minlength</parameter></methodparam>
                                    <methodparam><type>unsigned</type> <parameter>maxlength</parameter></methodparam>
                                     <methodparam>
                                        <type>int</type> <parameter>defaultVal</parameter>
                                    </methodparam>
                                    <methodparam>
                                        <type>int</type> <parameter>defaultSize</parameter>
                                    </methodparam>       
                                    
                                    <exceptionname></exceptionname>
                                    <modifier></modifier>
                                </methodsynopsis>  
                        </term>
                        <listitem>
                            <para>
                                Same as the other <methodname>addIntListParam</methodname>
                                methods however <parameter>minvalue</parameter>
                                and <parameter>maxvalue</parameter>
                                place constraints on the value that can be given to each
                                element of the list.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addStringListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type><parameter>defaultVal</parameter>
                                <initializer>""</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter> that
                                is a list of <parameter>size</parameter>   strings. Initially
                                each element of the list will have the value
                                <parameter>defautlVal</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addStringListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>minLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>maxLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>defaultVal</parameter>
                                <initializer>""</initializer>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultLength</parameter>
                                <initializer>-1</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous method however the
                                length of the list can provide to a
                                <command>config</command> subcommand can be
                                between <parameter>minLength</parameter>
                                and <parameter>maxLength</parameter>. The initial
                                length will be <parameter>defaultLength</parameter>  .
                            </para>
                        </listitem>
                    </varlistentry>
             </variablelist>
        </refsect1>
        <refsect1>
          <title>
              UTILITY METHODS
          </title>
          <para>
              This section provides some simple
              utility methods.
          </para>
          <variablelist>
              <varlistentry>
                  <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>isEnumParameter</type>
                      <methodname>makeEnumSet</methodname>
                      <methodparam>
                          <modifier>const</modifier>
                          <type>char**</type>
                          <parameter>values</parameter>
                      </methodparam>
                  </methodsynopsis>
                  </term>
                  <listitem>
                      <para>
                          Produces a data structure used
                          by the enumerated parameter checker
                          <methodname>isEnum</methodname>
                          decribing the legal options.
                          <parameter>values</parameter>
                          is an array of pointers to
                          acceptable strings.  The last pointer
                          must be a NULL value.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term>
                      <methodsynopsis>
                          <modifier>static</modifier>
                          <type>bool</type>
                          <methodname>>strToBool</methodname>
                          <methodparam>
                              <type>std::string</type>
                              <parameter>value</parameter>
                          </methodparam>
                      </methodsynopsis>
                      </term>
                      <listitem>
                          <para>
                              Converts a string to its
                              boolean representation or
                              throws a <type>std::string</type>
                              exception if the string does
                              not map to a bool.
                          </para>
                      </listitem>
                  </varlistentry>
          </variablelist>
  
          </refsect1>
          <refsect1>
            <title>
                TYPE CHECKERS
            </title>
            <para>
                A type checker is a function that can be passed to
                <methodname>addParameter</methodname> to check constraints on
                the value of a parameter. See below in BUILT IN TYPE CHECKERS
                for information about the constraint checkers that are
                available for drop in use.
            </para>
            <para>
                A type checker <function>myTypeChecker</function>
                function has the following signature:
            </para>
            <informalexample>
                <programlisting>
bool myTypeChecker(std::string name, std::string value, void* arg)
                </programlisting>
            </informalexample>
            <para>
                <parameter>name</parameter> is the name of the configuration
                parameter that is being checked.
            </para>
            <para>
                <parameter>value</parameter> is the proposed new string value
                for the parameter.
            </para>
            <para>
                <parameter>arg</parameter> is the
                <parameter>arg</parameter> parameter in the
                <methodname>addParameter</methodname> method.  While not always
                the case, this parameter usually is a pointer to some struct
                or object that further refines the constraint checking required.
                For example, for the <methodname>isInteger</methodname> pre-packaged
                checker, this parameter is a pointer to a struct that defines
                whichi limits should be checked and what those limit values
                are, where appropriate.
            </para>
            <para>
                Type checkers are supposed to return <literal>true</literal>
                if the constraints they are checking match,
                <literal>false</literal> otherwise.
            </para>
        </refsect1>
          <refsect1>
            <title>
                BUILT IN TYPE CHECKERS.
            </title>
            <para>
                A built in set of type checkers allows you to define the vast
                majority of parameters without any need to write your own
                type checking function.
            </para>
            <para>
                In the descriptions below, <parameter>arg</parameter>
                always refers to the <parameter>arg</parameter> parameter
                of the <methodname>addParameter</methodname> method. It will
                be referred to as the <firstterm>additional data</firstterm>
                parameter and described in the documentation for each
                checker.
            </para>
            <para>
                Note that all type checkers descdibed allow you to pass a
                <literal>NULL</literal> for the <parameter>args</parameter>
                parameter which means that the value of the
                parameter does not undergo any of the processing that is
                implied by the data normally pointed to by <parameter>arg</parameter>.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                <methodsynopsis>
                    <modifier>static</modifier><type>bool</type> <methodname>isInteger</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Checks that the proposed new value is a valid integer.
                        Optionally, depending on the <parameter>arg</parameter>
                        struct this function can also ensure that the
                        converted integer value of the new value meets
                        range constraints.
                    </para>
                    <para>
                        <parameter>arg</parameter> actually points to a
                        <type>Limits</type> which provides optional flags
                        and values to determine if a lower and/or an upper limit
                        should be checked and the limit values as well.
                        <type>Limits</type> is described fully in TYPES
                        below.
                    </para>
                </listitem>
            </varlistentry>
                <varlistentry>
                    <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type><methodname> isBool</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Type checker that determines if the proposed new value
                        has a valid conversion to a  <type>boolean</type>.
                        The <parameter>args</parameter> parameter is not used by
                        this checker.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type><methodname> isEnum</methodname>
                    <methodparam>
                        <type>std::string</type><parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type><parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Ensures that the proposed new <parameter>value</parameter>
                        is an element of a set of allowed strings.  <parameter>args</parameter>
                        is actually a pointer to a <type>std::set&lt;std::string&gt;</type>
                        where the elements of that set are the allowed values of the
                        parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type><methodname> isFloat</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Requires that the proposed new parameter
                        <parameter>value</parameter> is a valid floating point
                        and optionally that it satisfies lower and/or upper
                        limit constraints.  The <parameter>arg</parameter>
                        parameter actually points to a
                        <type>FloatingLimits</type> struct.
                        See TYPES below for a description of that struct.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier><type>bool</type>
                    <methodname>isList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type><parameter> value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This type checker requires that the proposed new
                        <parameter>value</parameter> is a valid Tcl list.
                        The <parameter>arg</parameter> parameter points to a
                        <type>isListParameter</type>.  This is described in
                        TYPES below.  The struct allows you to constrain the list
                        size as well as to provide an additional type checker
                        that is applied to each element of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a simplified version of the previous function
                        that ensures that each element of the list
                        <parameter>value</parameter>is a
                        valid boolean.  The <parameter>arg</parameter>
                        parameter points to a <type>ListSizeConstraint</type>
                        which, as described in TYPES below, allows you to
                        place constraints on the length of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        A specialized version of <methodname>isList</methodname>
                        that checks that all elements of a list parameter
                        are unbounded integers.  <parameter>arg</parameter>
                        is actually a pointer to a <type>ListSizeConstraint</type>
                        that allows you to place constraints of the size of the
                        list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Checks only that a parameter is a valid Tcl List
                        constrained by the sizes specified by the
                        <type>ListSizeConstraint</type> pointed to by
                        <parameter>arg</parameter>
                    </para>
                </listitem>
            </varlistentry>
            </variablelist>
          </refsect1>
           <refsect1>
              <title>TYPES</title>
             <para>
                This section describes the data types that are exported
                 by the <classname>CConfigurableObject</classname>.
                 To a large extent, these are parameters to
                 constraint/type checkers described in the previous
                 secition.
             </para>
             <variablelist>
                <varlistentry>
                    <term>typedef <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;
                          ConfigurationArray</type>;
                    </term>
                    <listitem>
                        <para>
                          This type is returned from <methodname>getConfiguration</methodname>
                          It consists of an <type>std::vector</type>.  Each element
                          of the vector is a <type>std::pair</type>.   The
                          first element of the pair is a configuration parameter
                          name.  The second element of that pair is the
                          parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> struct<type>limit</type></term>
                    <listitem>
                        <para>
                            Provides a struct that describes a single optional
                            limit. <varname>s_checkMe</varname> is a boolean
                            which is <literal>true</literal> if the
                            limit should be checked and
                            <varname>s_value</varname> is the limit value.
                        </para>
                        <para>
                            The Constructor <methodname>limit</methodname>
                            comes in two flavors.  Without a parameter it
                            initializes the struct so that <varname>s_checkme</varname>
                            is false.  With an integer parameter it initializes
                            <varname>s_checkme</varname> to <literal>true</literal>
                            and sets the limit value to the parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>typedef <type>std::pair&lt;limit, limit&gt;   Limits</type></term>
                    <listitem>
                        <para>
                            Defines a set of integer limits.  The first item in
                            the pair is the lower limit, the second item,
                            the upper limit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>typedef <type>std::set&lt;std::string&gt; isEnumParameter</type></term>
                    <listitem>
                        <para>
                            A set of strings that constrain the legal values
                            of an enumerated parameter.
                            The <methodname>makeEnumSet</methodname> is a
                            conveniencde method that builds one of these
                            from a null terminated array of const char*
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>struct ListSizeConstraint</term>
                    <listitem>
                        <para>
                            Defines a constraint on the size of a list
                            parameter.  <varname>s_atLeast</varname>
                            is the smallest length the list can have,
                            <varname>s_atMost</varname> the longest length.
                            These values are inclusive so if you specify
                            <varname>s_atLeast</varname> = <varname>s_atMost</varname>,
                            the list will have a fixed length.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>struct <type>isListParameter</type></term>
                    <listitem>
                        <para>
                            Defines a fully constrained list.  The list size
                            is constrained by the <varname>s_allowedSize</varname>
                            field which is a <type>ListSizeConstraint</type>.
                            The contents of the list are constrainded by the
                            <varname>s_checker</varname> field which is
                            a <type>TypeCheckinfo</type> data item.
                        </para>
                        <para>
                            The <varname>s_checker</varname> is an
                            <type>std::pair</type> whose first elemnent
                            is a pointer to a typeChecker function and
                            whose second element is the user parameter
                            that is normally passed in to allow the type checker
                            to further constrain values.
                        </para>
                        <para>
                            Several constructors are supplied to help build
                            this structure:
                            <informalexample>
                                <programlisting>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>limit</type> <parameter>atLeast</parameter>
    </methodparam>
    <methodparam>
        <type>limit</type> <parameter>atMost</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
                                </programlisting>
                            </informalexample>
                            Allows you to specify the size limits and
                            <type>TypeCheckInfo</type> pair used to
                            initialize all of the fields.
                        </para>
                        <para>
                            <informalexample>
                                <programlisting>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>ListSizeConstraint</type> <parameter>limits</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
                                </programlisting>
                            </informalexample>
                            Provides a constructor you an use if  you already
                            have built up a <type>ListSizeConstraint</type>
                            that descsribes the constraints on the list size.
                        </para>
                        <para>
                            A default constructor is also provided that doe
                            <emphasis>no</emphasis> initialization of the
                            struct.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>struct <type>flimit</type></term>
                    <listitem>
                        <para>
                            This is analagous to the
                            <type>limit</type> described above, however
                            the <varname>s_value</varname> field is
                            a <type>float</type> rather than an
                            <type>int</type>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>typedef <type>?std::pair&lt;flimit, flimit&gt;</type> <varname>FloatingLimits</varname>;
                    </term>
                    <listitem>
                        <para>
                            Defines a pair of floating point limits that constrain
                            the value of a float parameter.
                        </para>
                    </listitem>
                </varlistentry>
             </variablelist>

           </refsect1>
           
        </refentry>
      <refentry id='vmusb3_ccontrolhardware'>
         <refmeta>
	   <refentrytitle id='vmusb3_ccontrolhardware_title'>CControlHardware</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
	 </refmeta>
	 <refnamediv>
	   <refname>CControlHardware</refname>
	   <refpurpose>Base class for slow controls drivers</refpurpose>
	 </refnamediv>
	 <refsynopsisdiv>
	   <synopsis>
	     #include &lt;CControlHardware.h&gt;
	     class <ooclass><classname>CControlHardware</classname></ooclass> {
             protected:
                 CControlModule* m_pConfig;
             public:
	         <constructorsynopsis>
		   <methodname>CControlModule</methodname>
		   <methodparam>
		     <type>std::string</type><parameter>name</parameter>
		   </methodparam>
		 </constructorsynopsis>
		 <methodsynopsis>
		   <type>CControlModule*</type> <methodname>getConifguration</methodname>
		   <void />
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname>onAttach</methodname>
		   <methodparam>
		     <type>CControlModule&amp;</type> <parameter>configuration</parameter>
		   </methodparam>
		   <modifier> = 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname>Initialize</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type> <parameter>vme</parameter>
		   </methodparam>
		   <modifier> = 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>std::string</type><methodname>Update</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type> <parameter>vme</parameter>
		   </methodparam>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>std::string</type> <methodname>Set</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type><parameter> vme</parameter>
		   </methodparam>
		   <methodparam>
		     <type>std::string</type> <parameter>parameter</parameter>
		   </methodparam>
		   <methodparam>
		     <type>std::string</type><parameter> value</parameter>
		   </methodparam>
		   <modifier>= 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
                   <type>std::string</type><methodname>Get</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type><parameter> vme</parameter>
		   </methodparam>
		   <methodparam>
		     <type>std::string</type> <parameter>parameter</parameter>
		   </methodparam>
		   <modifier> = 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname> clone</methodname>
		   <methodparam>
		     <modifier>const</modifier>
		     <type> CControlHardware&amp;</type> <parameter> rhs</parameter>
		   </methodparam>
		   <modifier>= 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname> addMonitorList</methodname>
		   <methodparam>
		     <type>CVMUSBReadoutList&amp;</type> <parameter> vmeList</parameter>
		   </methodparam>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void*</type> <methodname>processMonitorList</methodname>
		   <methodparam>
		     <type>void*</type><parameter> pData</parameter>
		   </methodparam>
		   <methodparam>
		     <type>size_t</type><parameter> remaining</parameter>
		   </methodparam>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier> virtual</modifier>
		   <type>std::string</type>
		   <methodname>getMonitoredData</methodname>
		   <void />
		 </methodsynopsis>
		 
	     };
           </synopsis>
         </refsynopsisdiv>
	 <refsect1>
	   <title>DESCRIPTION</title> 
	   <para>
	     <classname>CControlHardware</classname> is an abstract base class for
	     slow control drivers.  To build a driver one must build a concrete
	     derived class, a <classname>CModuleCreator</classname> and register 
	     them with the <classname>CModuleFactory</classname> which associates
	     a module type string with a creator.
	   </para>
	   <para>
	     The base class and its <classname>CControLModule</classname> take care
	     of configuration management, command dispatching and parameter marshalling
	     for the methods of this class.  This framework therefore frees people
	     writing controls support software from most tasks not directly related to
	     controlling their devices.
	   </para>
	   <para>
	     The driver framework supports get and set operations and these transparently 
	     interrupt data taking if active.  Thus a series of sets or gets performed
	     while data taking is active can take a substantial time as each get or set
	     will pause data taking, flush in-flight buffers, perform the operatin and then
	     resume data taking.
	   </para>
	   <para>
	     In addition to get and set operations, the driver supports using a periodically
	     triggered list to monitor device state.  This monitoring does
	     <emphasis>not</emphasis> impact data taking other than the time required to
	     execute the list.   This mechanism is normally used to support the recognition
	     of exceptional states in the hardware (e.g. trips in detector bias supplies).
	   </para>
	   <para>
	     Implementation of the set/get interface is mandatory (those methods are pure
	     virtual)  Implementation of the monitor list operations is optional, as there
	     are do-nothing default behaviors defined in this base class.
	   </para>
	 </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                          <methodname>CControlModule</methodname>
                          <methodparam>
                            <type>std::string</type><parameter>name</parameter>
                          </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The base class constructor makes a correspondence between
                            the name of the module and the actual device.  Therefore
                            when you construct an object you should invoke this
                            base class constructor passing <parameter>name</parameter>
                            the name passed into your own constructor>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                          <type>CControlModule*</type> <methodname>getConifguration</methodname>
                          <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Obtains the configuration object from the module.
                            Your own methods can refer directly to the
                            <varname>m_pConfig</varname> member variable.
                            See MEMBER DATA below for more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void</type> <methodname>onAttach</methodname>
                          <methodparam>
                            <type>CControlModule&amp;</type> <parameter>configuration</parameter>
                          </methodparam>
                          <modifier> = 0</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This method must be implemented by concrete classes.
                            It is invoked as a new module instance is being
                            put together internally and hooked into the
                            slow controls server.  <parameter>configuration</parameter>
                            is the coniguration object.  Its address should be
                            stored in <varname>m_pConfig</varname> (see
                            MEMBER DATA) below.
                        </para>
                        <para>
                            This method should also be used to define any
                            configuration options you need.  Normally drivers will
                            define at least an option to allow the hardware to be
                            located.  For modules with base addressing this is
                            normally an option named <option>-base</option>
       H                 </para>
                    </listitem>
                </varlistentry>
		<varlistentry>
		  <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void</type> <methodname>Initialize</methodname>
                          <methodparam>
                            <type>CVMUSB&amp;</type> <parameter>vme</parameter>
                          </methodparam>
                          <modifier> = 0</modifier>
                        </methodsynopsis>
		  </term>
		<listitem>
		  <para>
		    Optional method that can be implemented by concrete sub-classes.
		    The method is intended to do one-time initialization of the hardware
		    being controlled by this driver.  <parameter>vme</parameter>
		    is a reference to a VMUSB controller object.  This object can
		    perform VME operations on behalf of the method or execute
		    <classname>CVMUSBReadoutLists</classname> this method builds.
		  </para>
		  <para>
		    If this method is not implemented the base class method does nothing.
		  </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>std::string</type><methodname>Update</methodname>
                          <methodparam>
                            <type>CVMUSB&amp;</type> <parameter>vme</parameter>
                          </methodparam>
			  <modifier>= 0</modifier>
                        </methodsynopsis>
		</term>
		<listitem>
		  <para>
		    This method must be implemented by concrete sub-classes.
		    It is intended for use by drivers that work with devices that have 
		    write only state.  The method is called by clients that want to
		    push shadow data out to the write only state of the device.  Typically,
		    a device of this sort would have an initialization file that
		    describes the desired initial state of the device.  The <methodname>Update</methodname>
		    often is a means to push that state out to the device when the GUI starts and
		    reads in the same initializationfile.
		  </para>
		</listitem>
	      </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>std::string</type> <methodname>Set</methodname>
                          <methodparam>
                            <type>CVMUSB&amp;</type><parameter> vme</parameter>
                          </methodparam>
                          <methodparam>
                            <type>std::string</type> <parameter>parameter</parameter>
                          </methodparam>
                          <methodparam>
                            <type>std::string</type><parameter> value</parameter>
                          </methodparam>
                          <modifier>= 0</modifier>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method must be implemented by concrete sub-classes.
                        The framework will call this in response to a request
                        by a client to make a setting for this instance of the driver.
                        The <parameter>vme</parameter> object is a
                        <classname>CVMUSB</classname> object that can be used to
                        perform individual VME operations or execute immediate
                        <classname>CVMUSBReadoutList</classname> objects
                        created and filled by this method.
                    </para>
                    <para>
                        <parameter>parameter</parameter> is a string that specifies
                        the name of the parameter the client wants to set.
                        The parameter names that are supported by a driver are
                        up to the driver and hardware specific.  If the
                        client requests a parameter that is not supoprted an
                        error should be returned.
                    </para>
                    <para>
                        The <parameter>value</parameter> parameter is the
                        new value requested by the client.  If this value is
                        not legal for the parameter (e.g. a string that is not
                        an integer for an integer parameter), an error should
                        be returned.
                    </para>
                    <para>
                        The return value of this method is a
                        <classname>std::string</classname>.  On successful
                        completion this should be the value <literal>OK</literal>.
                        On failure, this should be a string that begins with
                        the word <literal>ERROR</literal> and, after some whitespace
                        provides a human readable message describing the error.
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>std::string</type> <methodname>Get</methodname>		   
                          <methodparam>
                            <type>CVMUSB&amp;</type><parameter> vme</parameter>
                          </methodparam>
                          <methodparam>
                            <type>std::string</type> <parameter>parameter</parameter>
                          </methodparam>
                          <modifier> = 0</modifier>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method must be implemented by a concrete class.
                        It is invoked by the framework when a client requests the
                        value of a parameter from this instance of the driver.
                    </para>
                    <para>
                        <parameter>vme</parameter> is a <classname>CVMUSB</classname>
                        object that can be used to perform simple VME operations
                        or execute <classname>CVMUSBReadoutList</classname> objects
                        created by this method. 
                    </para>
                    <para>
                        <parameter>parameter</parameter> is the name of a parameter
                        supported by the driver.  The parameter names that are supported by a driver are
                        up to the driver and hardware specific.  If the
                        client requests a parameter that is not supoprted an
                        error should be returned.
                    </para>
                    <para>
                        The return value of this method is a
                        <classname>std::string</classname>.  On successful
                        completion this should be the value <literal>OK</literal>.
                        On failure, this should be a string that begins with
                        the word <literal>ERROR</literal> and, after some whitespace
                        provides a human readable message describing the error.
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                          <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>void</type> <methodname> clone</methodname>
                            <methodparam>
                              <modifier>const</modifier>
                              <type> CControlHardware&amp;</type> <parameter> rhs</parameter>
                            </methodparam>
                            <modifier>= 0</modifier>
                          </methodsynopsis>
                </term>
                <listitem>
                  <para>
                      This must be implemented by concrete subclasses.  It is a
                      virtual copy constructor in the sense that the state of the
                      <parameter>rhs</parameter> object must be copied to the state
                      of <varname>this</varname>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void</type> <methodname> addMonitorList</methodname>
                          <methodparam>
                            <type>CVMUSBReadoutList&amp;</type> <parameter> vmeList</parameter>
                          </methodparam>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method need only be implemented by drivers for
                        devies that require continuous monitoring.
                        <parameter>vmeList</parameter> is a reference for
                        a <classname>CVMUSBReadoutList</classname> to which this
                        call must add appropriate operations to obtain the
                        data fromt he device that needs to be monitored.
                        See also <methodname>processMonitorList</methodname> and
                        <methodname>getMonitoredData</methodname>
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void*</type> <methodname>processMonitorList</methodname>
                          <methodparam>
                            <type>void*</type><parameter> pData</parameter>
                          </methodparam>
                          <methodparam>
                            <type>size_t</type><parameter> remaining</parameter>
                          </methodparam>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called for each execution of the monitor list built up
                        via <methodname>addMonitorList</methodname>.
                        <parameter>pData</parameter> points to the data
                        for this device from that list and
                        <parameter>remaining</parameter> is the number of bytes
                        of data remaining in that buffer.
                    </para>
                    <para>
                        The method must return a pointer to the first byte in
                        the buffer pointed to by <parameter>pData</parameter>
                        beyond the data returned by this driver's monitor list.
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier> virtual</modifier>
                          <type>std::string</type>
                          <methodname>getMonitoredData</methodname>
                          <void />
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called to return the most recently received data from
                        the driver's monitor list.  The data are encoded
                        as a string that must begin with the word
                        <literal>OK</literal>.  normally the remainder of the
                        string is whitespace separated followed by a well formed
                        Tcl list containing the data from the monitor list.
                    </para>
                    <para>
                        If the device does not use monitor lists the return
                        value should be <literal>ERROR</literal>
                    </para>
                </listitem>
              </varlistentry>
            </variablelist>
        </refsect1>
	<refsect1>
            <title>MEMBER DATA</title>
            <para>
            </para>
        </refsect1>
       </refentry>

      <refentry id="vmusb3-cvmusb-swig">
        <refmeta>
           <refentrytitle>cvmusb</refentrytitle>
           <manvolnum>3tcl</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>cvmusb</refname>
           <refpurpose>SWIG Tcl wrapping of <classname>CVMUSB</classname></refpurpose>
        </refnamediv>
    
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require cvmusb
                </command>
            </cmdsynopsis>
            <formalpara>
                <title>Device enumeration and identification</title>
                <para></para>
            </formalpara>   
          <cmdsynopsis>
            <command>
::cvmusb::CVMUSB_enumerate
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
::cvmusb::usb_device_vector_get <replaceable>enumeration i</replaceable>
            </command>
          </cmdsynopsis>
        <cmdsynopsis>
        <command>
::cvmusb::usb_device_vector_size <replaceable>enumeration</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSB_serialNo  <replaceable>usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        
        <formalpara>
            <title>Construction</title>
            <para></para>
        </formalpara>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSBusb <replaceable>name usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSBusb <replaceable>name</replaceable> -this <replaceable>usb-object-ptr</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>VM-USB register operations</title>
            <para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readBulkXferSetup
            </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> readDAQSettings
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_A
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_B
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_Extended
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDeviceSource
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readFirmwareID
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readGlobalMode
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readIrqMask
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readLEDSource
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerA
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerB
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readVector
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeActionRegister <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeBulkXferSetup <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDAQSettings <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_A <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_B <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_Extended <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDeviceSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeGlobalMode <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeIrqMask <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeLEDSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeVector <replaceable>which value</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>VME operations</title>
            <para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeBlockRead <replaceable>base amod xfers</replaceable>
            </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> vmeFifoRead <replaceable>base amod xfers</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableBlockRead  <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableFifoRead  <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>List operations</title><para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> executeList <replaceable>list maxbytes</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> loadList    <replaceable>number list offset</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>Miscellaneous operations.</title><para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::getuint16 <replaceable>uint16</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::string_to_char <replaceable>std_string</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_get <replaceable>std_uint32_vector i</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_size <replaceable>std_uint32_vector</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_get <replaceable>std_uint8_vector i</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_size <replaceable>std_uint8_vector</replaceable>
            </command>
        </cmdsynopsis>
        
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                This package provides a tcl interface to the
                <classname>CVMUSB</classname> class described in
                <link linkend='vmusb3-CVMUSB' >CVMUSB(3)</link>.
                See COMMANDS below for more information.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
            <formalpara>
                <title>Device enumeration and identification</title>
                <para>
                    The commands in this section are used to determine the
                    set of VM-USB controllers attached to the host and
                    identify them by serial number.
                </para>
            </formalpara>

           <variablelist>
            <varlistentry>
                <term>
          <cmdsynopsis>
            <command>
::cvmusb::CVMUSB_enumerate
            </command>
          </cmdsynopsis>
          </term>
                <listitem>
                    <para>
                        Enumerates the set of VM-USB devices that are
                        attached to and powered up on the host.  The result
                        of this command is <type>usb_device_vector</type>.
                        You can think of this as a sort of an array with integer
                        indices whose elements represent a single VM-USB device.
                        See below for commands that can manipulate this vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
          <cmdsynopsis>
            <command>
::cvmusb::usb_device_vector_get <replaceable>enumeration i</replaceable>
        </command>
          </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given the result of the <command>::cvmusb::CVMUSB_enumerate</command>
                command <parameter>enumeration</parameter>   and an integer
                index <parameter>i</parameter>, returns a single element
                of the enumerated device set.  The return value is of type
                <type>usb_device</type> and can be passed to the constructor,
                to create a controller object that talks to this device or to
                <command>cvmusb::CVMUSB_serialNo</command> to get the device's
                serial number string.
                </para>
                </listitem>
                </varlistentry>
          <varlistentry>
            <term>
        <cmdsynopsis>
        <command>
::cvmusb::usb_device_vector_size <replaceable>enumeration</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <parameter>enumeration</parameter> gotten from
                <command>::cvmusb::CVMUSB_enumerate</command>,
                returns the number of elements in that array.  The array is
                indexed from 0.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSB_serialNo  <replaceable>usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <parameter>usbdevice</parameter> returned from
                <command>::cvmusb::usb_device_vector_get</command>
                Returns the serial number string.  Note that this is not
                immediately usable but must be converted to a Tcl string
                via a call to
                <command>::cvmusb::string_to_char</command>
                described below.
                </para>
                </listitem>
            </varlistentry>
           </variablelist>
        <formalpara>
            <title>Construction</title>
            <para>
                This set of commands is used to construct CVMUSB objects.
                The return value of these constructors is a command. The
                command can be either explicitly named by the
                <parameter>name</parameter> parameter in each of these
                constructors or you can use the name <literal>%AUTO</literal>
                to allow constructors to generate a unique object command
                name.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSBusb <replaceable>name usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Creates a new CVMUSBusb object given a <parameter>usbdevice</parameter>
                gotten from
                <command>::cvmusb::usb_device_vector_get</command>.
                This results in a new command <parameter>name</parameter> unless
                <parameter>name</parameter> is the special value
                <literal>%AUTO</literal>, in which case a unique name will be
                assigned the object. To construct a CVMUSB-type object to control
                a locally connected usb, this CVMUSBusb constructor must be used rather than 
                a CVMUSB because the C++ CVMUSB base class is abstract and cannot be instantiated.
                SWIG therefore does not produce a cvmusb::CVMUSB constructor. With that said, 
                the object produced by this command will inherit the functionality of the
                cvmusb::CVMUSB type.
                </para>
            <para>
                Naturally if you use <literal>%AUTO</literal> as the name
                 you must capture the actual name in a Tcl variable e.g.:
            </para>
            <informalexample>
                <programlisting>
set controller [::cvmusb::CVMUSBusb %AUTO $device]
$controller <replaceable>some method</replaceable>
                </programlisting>
            </informalexample>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
    <cmdsynopsis>
        <command>
::cvmusb::CVMUSB <replaceable>name</replaceable> -this <replaceable>usb-object-ptr</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs a VMUSB object given a <replaceable>usb-object-ptr</replaceable>
                    object pointer.  This is normally used to wrap a pointer to a C++
                    underlying object passsed into a method from compiled code
                    (e.g in the Tcl driver <methodname>Initialize</methodname> method).
                    </para>
                    </listitem>
                    </varlistentry>
        </variablelist>
        <formalpara>
            <title>VM-USB register operations</title>
            <para>
                These methods all require a constructed VM-USB object
                <parameter>object</parameter> and write internal registers
                of the VM-USB.  It is beyond the scope of this document to fully
                describe these registers.  For each method, therefore, a high level
                description will be given along with the VM-USB reference manual
                section that does fully describe the register.
            </para>
        </formalpara>
        <variablelist>
        
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readBulkXferSetup
            </command>
    </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the current value of the USB Bulk transfer register.
                This register is described in section 3.4.10.  It can be used
                to tune performance of the USB interface by setting the number
                of buffers that can be streamed without a packet end signal.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> readDAQSettings
            </command>
        </cmdsynopsis>
    </term>
    <listitem>
        <para>
            Returns the current value of the Data acquisition settings register.
            This register is described in section 3.4.3 of the VM-USB manual.
            It contains bit fields that control the way in which the scaler stack
            is trigggered and the delay between a trigger and stack start.
            Note that within the VM-USB readout framework, this register is
            programmed by the framework at the start of each run.  You will
            only need to program this register if you are building pure Tcl
            applications with the VM-USB.
            </para>
            </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_A
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the contents of the VM-USB A gate and delay generator.
                The VM-USB has two internal Gate and delay generators named
                A and B.  Section 3.4.6 describes the registers that control
                these resources. The
                bit fields in this register control the gate width and delay of
                the A gate and delay generator.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_B
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <command>readDGGG_A </command> but the register
                for the B gate and delay register is read.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_Extended
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the value of the extended gate and delay generator
                register.  This supplies high order bits for the delay values
                for both the A and B DGG's.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDeviceSource
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the device source register.  This register, described in
                section 3.4.5 defines the sources for the the NIM outputs, the
                internal scalers and the starts for the gate generators.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readFirmwareID
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the current firmware revision level of the controller.
                The bit fields of this register are defined in section 3.4.1 of
                the VM-USB manual.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readGlobalMode
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the module's global mode register
                (see VM-USB manual secgtion 3.4.2).  This register sets the
                VME bus request level, as well as several data acquisition
                options.
                </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readIrqMask
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
 
                            This reads a shadow regiseter that remembers
                            the last value written to the VM-USB's
                            interrupt request mask register (see
                            section 3.5 of the VM-USB manual).  This is
                            a write only register.  Therefore, when you
                            create a <classname>CVMUSB</classname> object,
                            the value of the register is set to all ones which
                            disables all interrupts.  Remember to set interrupt
                            enable bits if you use interrupt triggered stacks.
                
                </para>
                </listitem>
                </varlistentry>
             <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readLEDSource
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the LED source selectors register.  This is described in
                section 3.4.4 of the VM-USB manual.  The registser allows you to
                determine the cirumstances which light each of the four LED's on
                the VM-USB front panel.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerA
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                The VM-USB has a pair of 32 bit scalers, Scaler A and B.
                These are descsribed in section 3.4.7 of the VM-USB manual.
                This method returns the value of scaler A's counter.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerB
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                The VM-USB has a pair of 32 bit scalers, Scaler A and B.
                These are descsribed in section 3.4.7 of the VM-USB manual.
                This method returns the value of scaler B's counter.
                   </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readVector <replaceable>which</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the value of the interrupt vector register designated
                by <parameter>which</parameter>
                The vector registers are described in section 3.4.8 of the VM-USB
                Manual.  The VM-USB supports triggering stacks as a result of
                an interrupt on the VME bus.  To do this, an interrupt service vector
                register must be programmed with the IPL, the vector and stack id.
                The interrupt sevice vectors are in pairs numbered <literal>1-4</literal>.
                This function returns one of those pairs.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeActionRegister <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes the <parameter>value</parameter> to the action register.
                This register is responsible for starting data acquisition
                mode and can be used to trigger lists.  It is a write only register
                that is described in section 3.1 of the VM-USB manual.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeBulkXferSetup <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the bulk transfer setup
                register described in section 3.4.10 of the VM-USB manual.
                This register allows sophisiticated users to optimize the
                bandwidth of the USB during event data transfer.
                </para>
                </listitem>
                </varlistentry>
       
            <varlistentry>
                <term>
                <cmdsynopsis>
                   <command>
               <replaceable>object</replaceable> writeDAQSettings <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
 
            </term>
            <listitem>
                <para>
                    Writes <parameter>value</parameter> to the data
                    acquisition settings register described in sectino
                    3.4.3 of the VM-USB manual.  TYhat register allows
                    you to determine how the scaler stack is triggered as well
                    as the delay betrweena stack trigger and the start of
                    stack execution.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_A <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the A delay and gate
                generator.  The gate and delay generator registers are
                described in section 3.4.6 of the VM-USB manual.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_B <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as above but writes to the B delay and gate generator
                register.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_Extended <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes the gate and delay extended delay register. This is
                provides the ability to run very long delays.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDeviceSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the users device
                sources selection register described in section 3.4.5 of the
                VM-USB manual.  This determines what is gated to the
                NIM 0/1 outputs, the Scaler inputs and the gate and delay
                generator inputs.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeGlobalMode <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the global mode
                register described in section 3.4.2 of the VM-USB manual.  This
                sets a variety of data acquisition parameters as well as
                the VM-USB bus request level.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeIrqMask <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes the interrupt request mask register.  This register is
                desacribed in section 3.5 and describes the set of interrupt
                priority levels the VM-USB responds to.  See also
                <methodname>writeVector</methodname>.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeLEDSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes
                <parameter>value</parameter>
                the LED source register described in section 3.4.4 of the
                VM-USB manual.  This register determines the conditions under
                which the four programmable LEDS on the front panel of the
                VM-USB light.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeVector <replaceable>which value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes one of the four vector registers (numbered
                <literal>[1-4]</literal>) described in section 3.4.8.  These
                allow stacks to be triggered by specific VME interrupts.
                Note that at present there is no support to write the
                interrupt extension bits registers as virtually all VME
                interrupters use 8-bit vectors.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
        <formalpara>
            <title>VME operations</title>
            <para>
                This section describes the methods that perform VME
                actions.  Single shot read operations return the value
                read, howver block reads return an std::vector which
                requires further calls to obtain the actual number
                of items read and to fish out individual items.
            </para>
        </formalpara>
            <para>
                VME operations target an address within an address space.
                The address space is seleted by what in VME parlance is
                called an <firstterm>address modifier</firstterm>.
                A table of address modifiers is available on the Wikipedia
                article describing the VME bus:
                <ulink url='http://en.wikipedia.org/wiki/VMEbus'>
                    http://en.wikipedia.org/wiki/VMEbus</ulink>.
            </para>
            <para>
                The documentation that describes each module describes the
                set of address modifiers it supports.  Modules occupy an
                address space whose base is generally configured by switches,
                jumpers or rotary switches.  The module documentation will describe
                both the size and contents of its address space as well as
                how the base address is determined.
            </para>
        <variablelist>
        <varlistentry>
        <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeBlockRead <replaceable>base amod xfers</replaceable>
            </command>
    </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a block read from the the VME bus. The source is
                determined by the <parameter>base</parameter> address and
                the address  modifier (<parameter>amod</parameter>).
                At most <parameter>xfers</parameter> transfers will be performed.
                The block transfer may terminate prematurely if a bus error
                occurs during the transfer.
                </para>
            <para>
                The result of the block read is returned as an item that is
                encapsulates a <type>std::vector&lt;uint32_t&gt;</type>.
                See <methodname>::cvmusb::CVMUSB_uint32_vector_size</methodname>
                which will return the actual number of transfers performed.
                <methodname>::cvmusb::CVMUSB_uint32_vector_get</methodname>
                allows you to extract individual values from the data
                returned.
            </para>
            <para>
                Suitable address modifiers force the VME bus to run in
                <firstterm>block transfer mode</firstterm>. In that mode,
                Addresses cycles are only performed infrequently with the
                source device keeping track of the offset from the last address
                cycle.  If the module providing the data supports block transfer
                address modifiers, substantial peformance gains can be had
                by using it.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> vmeFifoRead <replaceable>base amod xfers</replaceable>
            </command>
        </cmdsynopsis>
    </term>
    <listitem>
        <para>
            This method is the same as <methodname>vmeBlockRead</methodname>
            however all address cycles assert the <parameter>base</parameter>
            address. This makes the operation suitable for address blocks
            that actually implement FIFO memories.
        </para>
        <para>
            Consider, for example the
            data buffer address block of a large group of CAEN 32 bit
            digitizers run in multi-event mode read out via a chained block
            transfer.  If a block read is used to read this module, it is possible
            for the address to increment off the end of the window that is
            recognized as the data buffer.  Using a FIFO read ensures this
            cannot happen.
            </para>
            </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a single 16 bit transfer from <parameter>address</parameter>
                in the address space selected by <parameter>amod</parameter>
                The result of the command is word that was read.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeRead16</methodname> however a 32
                bit read is performed.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeRead16</methodname> however a 16 bit
                read is performed.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                The VM-USB provides the ability to do a variable sized block read.
                When using this facility you first perform a VME read operation
                to obtain the number of transfers in the block read.
                You then perform the block read itself
                </para>
            <para>
                The block read count is a field in the data transferred from
                the VME <parameter>address</parameter>/<parameter>amod</parameter>
                specified by a <parameter>mask</parameter>.  This method performs
                an 16 bit read from the VME bus and uses the
                <parameter>mask</parameter> provided to determine which bits
                constitute the transfer size.  The resulting block transfer
                size is saved for the variable block transfer operation which
                should immediately follow.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeReadBlockCount16</methodname> however
                the read is 32 bits wide.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeReadBlockCount16</methodname> however
                the data transfer is 8 bits wide.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableBlockRead  <replaceable>address mask maxcount</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a variable block read whose transfer count was
                determined by one of the previous three methods.
                The transfer base address is specified by
                <parameter>address</parameter>/<parameter>amod</parameter>.
                <parameter>maxcount</parameter> is used to allocate aninternal
                buffer fro the transfer and can further limit the number of
                transfers.  The return value from this method is the same as
                a return value from <methodname>vmeBlockRead</methodname>
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableFifoRead  <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeVariableBlockRead</methodname> however
                all address cycles provide <parameter>address</parameter> as
                the address making this suitable as a block read froma  FIFO.
                The return value is the same as from
                <methodname>vmeBlockRead</methodname>.
                </para>
                </listitem>
                </varlistentry>
             <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a single shot 16 bit write of <parameter>data</parameter>
                to the VME target specified by
                <parameter>address</parameter>/<parameter>amod</parameter>.
                The least significant bits of <parameter>data</parameter>
                are written.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <parameter>vmeWrite16</parameter> however 32bits of
                <parameter>data</parameter> are written.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as vmeWrite16, however only the least significant 8 bits
                of <parameter>data</parameter> are written.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
        <formalpara>
            <title>List operations</title>
            <para>
                The VM-USB allows you to build and execute lists of VME
                operations.  These are built up using
                cvmusbreadoutlist.  Lists can also be downloaded for
                execution in data acquisition mode when triggered.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> executeList <replaceable>list maxbytes</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Executes a list of instructions.  <parameter>list</parameter>
                is a <classname>cvmusbreadoutlist</classname> object or pointer.
                <parameter>mabytes</parameter> is the maximum number of
                bytes of data that miight be returned from this list as a result
                of the reado operations it contains.   This is used to size
                an internal buffer into which that data are accepted.
                </para>
            <para>
                The return value from this command is a
                <type>std::vector&lt;uint8_t&gt;</type>.
                See <methodname>cvmusb::CVMUSB_uint8_vector_size</methodname>
                and <methodname>cvmusb::CVMUSB_uint8_vector_get</methodname>
                for information about how to get data ouf of this object.
            </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> loadList    <replaceable>number list offset</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Loads a list into the VM-USB for execution in response to a trigger
                in data taking mode.
                <parameter>list</parameter> is a <classname>cvmusbreadoutlist</classname>
                object.  <parameter>number</parameter> is the stack number and
                must be in the range <literal>[0..7]</literal>.
                <parameter>offset</parameter> is the memory offset at which
                the list should be loaded.  See
                <classname>CVMUSB</classname>::<methodname>loadList</methodname>
                for information about how to compute this.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
        <formalpara>
            <title>Miscellaneous operations.</title>
            <para>
                This section describes methods that don't fit into a convenient
                category.  Many of these are static methods that provide
                impedance matching between the data types in use in the
                <classname>CVMUSB</classname> underlying class ansd Tcl data types.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Sets the default timeout of VM-USB operations as
                <parameter>ms</parameter> milliseconds.  This timeout is
                used to define how long most of the methods in this
                section will wait for a response from the VM-USB before
                giving up. It is ONLY valid to call with a cvmusb::CVMUSBusb
                object.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::getuint16 <replaceable>uint16</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <type>uint16_t</type>
                Returns an integer that has the same value  This is needed
                because SWIG thinks that <type>uint16_t</type> is some
                fancy object type and will not allow it to be shimmered
                to an int.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::string_to_char <replaceable>std_string</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given an <type>std::string</type>, returns a string that
                Tcl can deal with.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_get <replaceable>std_uint32_vector i</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <type>std::vector&lt;uint32_t&gt;</type>
                (<parameter>std_uint32_vector</parameter>) returns
                element <parameter>i</parameter>.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_size <replaceable>std_uint32_vector</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given <parameter>std_uint32_vector</parameter> a
                <type>std::vector&lt;uint32_t&gt;</type> returns
                the number of elements it contains.  Elements
                are indexed from zero.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_get <replaceable>std_uint8_vector i</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as
                <methodname>::cvmusb::uint32_vector_get</methodname> but
                <parameter>std_uint8_vector</parameter> is a
                <type>std::vector&lt;uint8_t&gt;</type>.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_size <replaceable>std_uint8_vector</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>::cvmusb::uint32_vector_size</methodname>
                but <parameter>std_uint8_vector</parameter>
                is a <type>std::vector&lt;uint8_t&gt;</type>
                </para>
                </listitem>
                </varlistentry>
        

           </variablelist>
        </refsect1>

      </refentry>
            <refentry id="vmusb3-cvmusbreadoutlist-swig">
              <refmeta>
                 <refentrytitle>cvmusbreadoutlist</refentrytitle>
                 <manvolnum>3tcl</manvolnum>
              </refmeta>
              <refnamediv>
                 <refname>cvmusbreadoutlist</refname>
                 <refpurpose>SWIG wrappers for <classname>CVMUSBReadoutList</classname>
                 </refpurpose>
              </refnamediv>
              
              <refsynopsisdiv>

                <formalpara>
                    <title>Construction</title>
                    <para></para>
                </formalpara>
                     <synopsis>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable>
            </command>
            </cmdsynopsis>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable> -this <replaceable>ptr</replaceable>
            </command>
            </cmdsynopsis>
                     </synopsis>
            <formalpara>
                <title>Simple VME/register operations</title>
                <para></para>
            </formalpara>
            <synopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterRead <replaceable>address</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterWrite <replaceable>address data</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </synopsis>
            <formalpara>
                <title>Block transfer operations</title>
                <para></para>
            </formalpara>
            <synopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockRead32 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead16 <replaceable>address amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead32 <replaceable>address amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountBlockRead32 <replaceable>base amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountFifoRead32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </synopsis>
        <formalpara>
            <title>Miscellaneous methods</title>
            <para></para>
        </formalpara>
        <synopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> addMarker <replaceable>value</replaceable>
            </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> addDelay <replaceable>cycles</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> clear
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> get
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> size
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_get <replaceable>v i</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_size <replaceable>v</replaceable>
            </command>
        </cmdsynopsis>
        </synopsis>
        <formalpara>
            <title>Variables</title>
            <para></para>
            </formalpara>
    <synopsis>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16Priv</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16User</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivProgram</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserProgram</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivProgram</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserProgram</varname>

     </synopsis>
              </refsynopsisdiv>
              <refsect1>
                 <title>DESCRIPTION</title>
                 <para>
                    This package encapsulates a <classname>CVMUSBReadoutList</classname>
                    class/object.  The class allows you to create instances
                    of VME operation lists.  Once created, you can add
                    operations to that list that can either be executed
                    immediately or stored fro execution in data taking mode
                    in response to an appropriate trigger.
                 </para>
                 <para>
                    For more information about this class and its methods,
                    see METHODS below.  The class also defines a set of
                    variables that contain the VME address modifier values.
                    See VARIABLES for information about those.
                 </para>
              </refsect1>
              <refsect1>
                 <title>
                    METHODS
                 </title>
                <formalpara>
                    <title>Construction</title>
                    <para>
                        Two construction mechanisms are provided.  The first
                        creates an empty list.  The second creates an object
                        that wraps itself around a pointer to an existing list.
                    </para>
                </formalpara>
                <para>
                    Constructed objects appear like a command ensemble who's
                    base command name is the <parameter>name</parameter> parameter
                    to the constructor command.  If the special name
                    <literal>%AUTO</literal> is specified, the constructor will
                    assign a unique name.  In all cases the base name of the
                    command ensemble (or object name) is returned by the constructor.
                </para>
                <variablelist>
                <varlistentry>
                    <term>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable>
            </command>
            </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an empty list object named <parameter>name</parameter>
                        (see the discussion above however).  The name of the object
                        is returned by this command.
                        </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable> -this <replaceable>ptr</replaceable>
            </command>
            </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an object around an existing pointer to a
                        list object.  The name of the object is
                        <parameter>name</parameter> and <parameter>ptr</parameter>
                        is a SWIG type safe pointer.  Type-safe pointers are
                        just the address of a C++ object as a string that has
                        been decorated with information about the type of the
                        object.
                        </para>
                    <para>
                        A type-safe pointer to a readout list is passed to a Tcl
                        driver's <methodname>addReadoutList</methodname>
                        sub-command.
                    </para>
                        </listitem>
                        </varlistentry>
                </variablelist>
            <formalpara>
                <title>Simple VME/register operations</title>
                <para>
                    This group of methods add single shot VME operations
                    and register transfers to a list.  A VME operation is
                    specified by both an address and an address modifier.
                    The address modifier selects a specific address space.
                    See
                    <ulink url="http://en.wikipedia.org/wiki/VMEbus">
                        http://en.wikipedia.org/wiki/VMEbus</ulink>
                    for a table of address modifiers and their meaning.
                </para>
            </formalpara>
            <para>
                    <classname>cvmusbreadoutlist</classname> also defines
                    some variables that contain these address modifiers.
                    See VARIABLES below for a description of those
                    variables.
            </para>
            <variablelist>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a 16 bit read from the address and address modifier
                    specified by <parameter>address</parameter> and
                    <parameter>amod</parameter> respectively.  The data
                    are put in either the output buffer if the read is performed
                    by <methodname>cvmsub::executeList</methodname> or in the
                    event buffer if the list is triggered in data acquisition
                    mode.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addRead16</methodname> however the
                    data transfer width is 32 bits.  The list performs
                    the operation in little endian order.   That is the
                    low order part of the longword is placed in the
                    output/event buffer prior to the upper order bits.
                    </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addRead16</methodname> however only
                    the data emitted consists of 8 bits of data in the low order
                    8 bits of a 16 bit word.
                    </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterRead <replaceable>address</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a read of an internal register to the stack.
                    The <parameter>address</parameter> parameter specifies
                    which register to read.  This is a number that should be
                    taken from the table in section 3.4 of the VM-USB
                    manual.
                    </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterWrite <replaceable>address data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a register write to the list.  <parameter>address</parameter>
                    specifies the register address (taken from the table in
                    section 3.4 of the VM-USB manual), <parameter>data</parameter>
                    is the value to write.
                    </para>
                    </listitem>
                    </varlistentry>
             <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Writes the 16 bit <parameter>data</parameter> to the VME
                    location specified by <parameter>address</parameter>
                    and <parameter>amod</parameter>.  If there are bits set
                    above the least significant 16 bits of <parameter>data</parameter>,
                    they are ignored.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as for <methodname>addWrite16</methodname> however 32 bits of
                    <parameter>data</parameter> are written.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addWrite16</methodname> however only the
                    least significant 8 bits are written.
                    </para>
                    </listitem>
                    </varlistentry>
            </variablelist>
            <formalpara>
                <title>Block transfer operations</title>
                <para>
                    The VM-USB is capable of several types of block transfer
                    operations.  If the address modifier is a block transfer
                    address modifier, the VM-USB will take advantage of that
                    mode of transfer.
                </para>
            </formalpara>
                <para>
                    VME block transfer operations allow a significant
                    improvment in performance by reducing the number of address
                    cycles asserted on the bus by the master.  Specifically,
                    in steady state operation, an address is only cycled on the
                    bus as the transfer address crosses a 256 byte address
                    boundary.  In between these boundaries, slave boards that
                    support block transfers are assumed to maintain counters
                    that keep track of the transfer offset within the 256 byte
                    page.
                </para>
                <para>
                    In addition to block transfer operations as described above,
                    the VM-USB also supports FIFO block transfers.   A FIFO
                    block transfer is just a block transfer that always asserts
                    the base address when an address cycle is required.
                </para>
                <para>
                    Finaly the VM-USB also supports block transfers whose
                    size depends on a bit field in a value read from the VME
                    bus.
                </para>
            <variablelist>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockRead32 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a block read that is 32 bits wide tyo the stack.
                    The first transfer address is <parameter>base</parameter>,
                    transfers are all done with <parameter>amod</parameter> as
                    the address modifier.  <parameter>transfers</parameter>
                    operations are performed (transers*sizeof(uint32_t) bytes), unless
                    a transfer causes a bus error.
                    </para>
                <para>
                    If a transfer triggered a bus error, a <literal>0xffffffff</literal>
                    is placed in the output/event buffer and the transfer terminates.
                    Note that if the last transfer was a bus error and the data
                    in a successful transfer might have been a <literal>0xffffffff</literal>,
                    there is some ambiguity about how the transfer actually terminated.
                    If you expect that the tranfer might be terminated by a bus
                    error "normally", ber sure to specify a transfer count very
                    much in exceess of what you might reasonably expect to get.
                </para>
                    </listitem>
                    </varlistentry>
             <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead16 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a 16 bit FIFO read to the list.  All transfers are
                    performed from <parameter>base</parameter> with the
                    <parameter>amod</parameter> address modifier.
                    At most <parameter>transfers</parameter> transfers are performed.
                    In the even to of a bus error, a marker value;
                    <literal>0xffff</literal> will be inserted in the
                    read/event buffer, and the transfer will terminate.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead32 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addFifoRead16</methodname> however
                    each read transfers 32 bits of data.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a 16 bit read that extracts the transfer count for the
                    next variable block read.   A 16 bit read is performed from
                    the location specified by <parameter>address</parameter> and
                    address modifier <parameter>amod</parameter>.  The
                    bits that are set in <parameter>mask</parameter> determine the final
                    actual value of the transfer count (bits set in
                    <parameter>mask</parameter> matter unset bits don't).
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockCount16</methodname> however
                    the tranfer is 32 bits wide.
                    </para>
                    </listitem>
                    </varlistentry>
        <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addblockCountRead16</methodname> but the
                    transfer is 8 bits.
                    </para>
                    </listitem>
            </varlistentry>

             <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountBlockRead32 <replaceable>base amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a variable block read operation to the VME operation
                    list.  The last block count read by one of the
                    <methodname>addBlockCountReadxxx</methodname> methods'
                    above is used as the transfer count.    The base address
                    of the transfer is <parameter>base</parameter>
                    and all transfers are done with the <parameter>amod</parameter>
                    address modifier.
                    </para>
                <para>
                    The normal rules for bus error termination of block transfers
                    apply.
                </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountFifoRead32 <replaceable>base amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addMaskedCountBlockRead32</methodname>,
                    however any needed address cycles always place
                    <parameter>base</parameter> on the address bus.  This
                    makes this method usable to get data from a FIFO register.
                    </para>
                    </listitem>
                    </varlistentry>
        </variablelist>
        <formalpara>
            <title>Miscellaneous methods</title>
            <para>
                The methods in this section don't fit into any other category.
                Where the method is not a subcommand of a <parameter>object</parameter>
                it is a static method of the class.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> addMarker <replaceable>value</replaceable>
            </command>
    </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Adds a command to put a literal marker for
                <parameter>value</parameter> in to the buffer/event.
                </para>
                </listitem>
                </varlistentry>
    <varlistentry>
        <term>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> addDelay <replaceable>cycles</replaceable>
            </command>
        </cmdsynopsis>
    </term>
    <listitem>
        <para>
            Adds a delay to the list.  When this instruction is executed,
            stack execution stalls for <parameter>cycles</parameter> cycles where
            one cycle is 200ns.    The maximum wait time is 255 cycles, however
            you can insert more than one wait operation to get longer waits.
            </para>
            </listitem>
            </varlistentry>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> clear
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Clears the list
                </para>
                </listitem>
                </varlistentry>
         <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> get
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns a vector to a uint32 where each vector element is one
                32 bit stack line.  See below for static methods to get
                information about/from this vector.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> size
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the number of 32 bit stack lines in the object.
                </para>
                </listitem>
                </varlistentry>
         <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_get <replaceable>v i</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a vector <parameter>v</parameter> retrived from
                the <methodname>get</methodname> method tells you  how many
                elements it contains.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_size <replaceable>v</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a vector <parameter>v</parameter> gotten from
                <methodname>get</methodname> returns the nmber of 32 bit entities
                 in the vrctor.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
              </refsect1>
              <refsect1>
                <title>VARIABLES</title>
                <para>
                    The <classname>cvmusbreadoutlist</classname> class provides
                    several variables that define the various address modifiers
                    symbolcally:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16Priv</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 16 bit address
                                widths privilege access.  16 bit address space
                                is often refered to as shortio as  well.
                            </para>
                        </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16User</varname></term>
                        <listitem>
                            <para>
                                Same as above, however accesses are in user
                                mode rather than privileged transfer mode.
                                </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivBlock</varname></term>
                            <listitem>
                                <para>
                                    Defines the address modifier for A24
                                    privileged block transfers.  Block transfers
                                    are a mechanism the VME bus defines for
                                    reducing the number of address cycles required
                                    to transfer a contiguous block of data.
                                    </para>
                                <para>
                                    A24 bit addressing mode is also called
                                    standard addressing.
                                </para>
                            </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivData</varname></term>
                                <listitem>
                                    <para>
                                        Defines the address modifier for 24
                                        bit wide addressing of privileged data.
                                        A24 address modes are also called
                                        standard addressing.
                                        </para>
                                </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivProgram</varname></term>
                                    <listitem>
                                        <para>
                                            Same as above, however the
                                            addressing is to privileged progfam space.
                                            </para>
                                    </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserBlock</varname></term>
                                        <listitem>
                                            <para>
                                                Defines the address modifier for
                                                24 bit wide address block transfers.
                                                </para>
                                        </listitem>
                                        </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserData</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 24 bit wide
                                user data transfers.
                                </para>
                        </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserProgram</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 24 bit wide
                                user program space.
                                </para>
                        </listitem>
                        </varlistentry>
                <varlistentry>
                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivBlock</varname></term>
                    <listitem>
                        <para>
                            Defines the address modifier for 32 bit privileged
                            block transfers.
                            </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivData</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 32 bit wide
                                privileged data transfers.  32 bit addressing is
                                sometimes called <firstterm>extended addressing</firstterm>.
                                </para>
                        </listitem>
                        </varlistentry>
                   <varlistentry>
                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivProgram</varname></term>
                    <listitem>
                        <para>
                            Defines the address modifier for 32 bit privileged
                            program accesses.
                            </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserBlock</varname></term>
                    <listitem>
                        <para>
                            Defines the address modifier for 32 bit user
                            block transfers.
                            </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserData</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 32 bit user
                                data transfers.
                                </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserProgram</varname></term>
                            <listitem>
                                <para>
                                    Defines the address modifier for 32 bit user
                                    program access.
                                    </para>
                            </listitem>
                            </varlistentry>
                </variablelist>
              </refsect1>               
      
            </refentry>
      <refentry id="vmusb3-Module">
        <refmeta>
           <refentrytitle>Module</refentrytitle>
           <manvolnum>3tcl</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Module</refname>
           <refpurpose>control config command: create/configure modules.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <synopsis>
          <cmdsynopsis>
          <command>
Module create <replaceable>type name</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module config <replaceable>name ?option value? ...</replaceable> 
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
          </synopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This command is processed by the Tcl slow controls server when it
            processes the control configuration file.  It is used to create,
            configure and query the configuration of slow controls
            modules.
           </para>
           <para>
                The <command>create</command> subcommand creates a new module
                assigned the <parameter>name</parameter> by which it can be
                referred to by remote control panels, and the remainder of
                the cofiguration file.  The module will be of type
                <parameter>type</parameter>.  See MODULE TYPES below for
                information about the module types supported.
           </para>
           <para>
            The <command>config</command> subcommand configures the
            module <parameter>name</parameter>, setting the configuration
            options provided on the command line to the specified values.
            See MODULE TYPES below for information about the configuration
            options accepted by each module.
           </para>
           <para>
            The <command>cget</command> subcommand returns the configuration of
            the <parameter>name</parameter>ed module.  The configuration is
            returned as a list of pairs where each pair consists of the
            configuration parameter name and value.
           </para>  
        </refsect1>
        <refsect1>
           <title>
              MODULE TYPES
           </title>
            <para>
                This section describes the module types that are supported
                currently and the device specific configuration options and
                settable/readable parameters
                each supports.  Device support includes both the
                driver and a control panel for the device.
            </para>
            <refsect2>
                <title>jtecgdg</title>
                <para>
                    This module is actually a general purpose logic module.
                    The only support for it at this time is as a multi-channel
                    gate and delay generator.
                </para>
                <refsect3>
                    <title>Options</title>
                    <para>
                        The only option supported by the <literal>jtecgdg</literal>
                        is the <option>-base</option> option which sets the
                        VME base address for the module (must match the
                        rotary switch settings).
                    </para>
                </refsect3>
                <refsect3>
                    <title>Parameters</title>
                    <variablelist>
                        <varlistentry>
                            <term>delay<emphasis>n</emphasis></term>
                            <listitem>
                                <para>
                                    The delay register value for register n.
                                    There are 8 registers numbered
                                    <literal>[0..7]</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>width<emphasis>n</emphasis></term>
                            <listitem>
                                <para>
                                    The width of channel <parameter>n</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect3>
            </refsect2>
            <refsect2>
                <title>caenv812/caen895</title>
                <para>
                    The CAEN V812 is a VME 16 channel constant fraction
                    disriminator while the V895 is a software compatible
                    leading edge discriminator.
                </para>
                <refsect3>
                    <title>Options</title>
                    <variablelist>
                        <varlistentry>
                            <term><option>-base</option></term>
                            <listitem>
                                <para>
                                    The value of this parameter is the base
                                    address of the module as set by the
                                    on-board rotary switches.
                                    </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><option>-file</option></term>
                            <listitem>
                                <para>
                                    The value of this parameter is the path to a
                                    configuration file whose contents are used to
                                    initialize the state of the device. Note
                                    that these modules are write-only so writing
                                    their initial state is the only way to put them
                                    into a known state.
                                </para>
                                <para>
                                    The contents of this file are described in
                                    <link linkend='manpage.caenv812config'>
                                        CAENV812Config(5)</link>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect3>
                <refsect3>
                    <title>Parameters</title>
                    <variablelist>
                        <varlistentry>
                            <term><parameter>threshold</parameter>n</term>
                            <listitem>
                                <para>
                                    The threshold register value for
                                    channel <parameter>n</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>width</parameter>i</term>
                            <listitem>
                                <para>
                                    The width register value for bank
                                    <parameter>i</parameter>.  The module
                                    is divided into two banks of 8 modules.
                                    the banks are numbered 0 and 1.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </refsect3>
            </refsect2>
            <refsect2>
                <title>vmusb</title>
                <para>
                    This slow control module supports remote execution of
                    arbitrary VM-USB lists.  Full documentation of this facility
                    will be produced in a later version of this document.
                    The idea is, however that the module, which has no
                    configuration options, has exactly one parameter,
                    <literal>list</literal>
                </para>
                <para>
                    <literal>list</literal> is a set only parameter.  It's
                    value is a Tcl list.  The first element of thel ist specifies
                    the maximum input buffer size required by the list.
                    The second value of the list is a Tcl list containing
                    the VM-USB stack.  The Set operation executes the stack
                    and returns the text <literal>Ok - </literal> followed by a
                    Tcl list  whose elements are the bytes of data put in the
                    read buffer by the stack.
                </para>
            </refsect2>
            <refsect2>
              <title>mxdcrcbus</title>
              <para>
                This slow-controls module enables a Mesytec MxDC device to be used as a 
                proxy for the RC-bus protocol. The NIM busy output of the targeted 
                MxDC will be hijacked for this purpose. To use, clients of the slow-controls
                server can send Set and Get commands with appropriate
                arguments to the slow-controls server. The first argument should specify 
                the name of the mxdcrcbus slow-controls module to handle the request. 
                The second argument, i.e. the parameter name, will provide the device 
                number of the hardware on the rc-bus and address of the parameter 
                referred to in it. The device number, D, and parameter address, A, are to be encoded
                into a string of the form "dDaA". In other words, if an mxdcrcbus module
                was created with the name "mymod" and the user wanted to use it 
                to write the value 23 to a parameter 
                address 10 on the device whose number is 20, the client would write
                "Set mymod d20a10 23" to the slow-controls server. To read the value
                back, the client would write "Get mymod d20a10" to the slow-controls server.
              </para>
              <refsect3>
                <title>OPTIONS</title>
                <para>
                  The module supports only the <option>-base</option>
                  option which describes to the software the base address
                  of the Mesytec digitizer as encoded in the module's rotary
                  switches.
                </para>
              </refsect3>
            </refsect2>
            <refsect2>
              <title>mxdcreset</title>
              <para>
                This slow-controls module provides an on-demand soft reset. It also 
                clears the device's internal counters.
              </para>
              <refsect3>
                <title>OPTIONS</title>
                <para>
                  The module supports only the <option>-base</option>
                  option which describes to the software the base address
                  of the Mesytec digitizer as encoded in the module's rotary
                  switches.
                </para>
              </refsect3>
            </refsect2>

            <refsect2>
                <title>v6553</title>
                <para>
                    This is a CAEN bias supply controller.  It makes use of the
                    slow controls monitor facility to maintain an up-to-date
                    module state without interrupting data acquisition.
                </para>
                <refsect3>
                    <title>Options</title>
                    <para>
                        The module supports only the <option>-base</option>
                        option which describes to the software the base address
                        of the bias supply as encoded in the module rotary
                        switches.
                    </para>
                </refsect3>
                <refsect3>
                    <title>Parameters</title>
                    <para>
                        The following parameters can be Set:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>>v</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the requested voltage on channel
                                    <parameter>i</parameter> in floating point
                                    volts.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>i</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the current limit on channel <parameter>i</parameter>
                                    in floating point micro-amps.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>on</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Turns channel on or off.  The value of this
                                    parameter is a legal boolean value.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>ttrip</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the number of seconds (floating point)
                                    for which channel <parameter>i</parameter>
                                    is allowed to be out of specification before
                                    it trips  off.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>svmax</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the maximum voltage allowed for
                                    channel <parameter>i</parameter> in floating
                                    point volts.  If a voltage setting is made
                                    that is larger than this, the actual requested
                                    voltage will be limited to this value.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rdown</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the ramp down rate of channel
                                    <parameter>i</parameter> in
                                    floating point volts per second.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rup</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the ramp up rate of channel
                                    <parameter>i</parameter> in floating point
                                    volts per second.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>pdownmode</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the power down mode of channel
                                    <parameter>i</parameter>.  The value of this
                                    parameter can be either <literal>kill</literal>
                                    which abruptly drops the voltage to zero,
                                    or <literal>ramp</literal> which ramps the
                                    channels down at the ramp down rate.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                    <para>
                        Note that if you want to monitor key components
                        of this device periodically you should use the
                        <command>Mon</command> command as that will retrieve
                        data without temporarily halting data taking.
                    </para>
                    <para>
                        The following parameters can be retrieved via Get:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>globalmaxv</literal></term>
                            <listitem>
                                <para>
                                    Returns the global maximum voltage
                                    for the module.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>globalmaxI</literal></term>
                            <listitem>
                                <para>
                                    Returns the global maximum current for the
                                    module.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>v</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the requested voltages from all
                                    channels.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>i</literal></term>
                            <listitem>
                                <para>
                                    Returns  a list consisting of the requested
                                    maximum currents
                                    from all channels.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>on</literal></term>
                            <listitem>
                                <para>
                                    Returns a list that contains the requested
                                    channel states (on or off for each
                                    channel).
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>vact</literal></term>
                            <listitem>
                                <para>
                                    Returns a list contaning the actual voltage
                                    reading from each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>iact</literal></term>
                            <listitem>
                                <para>
                                    Returns a list containing the actual
                                    current readings from each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>status</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of status values for each
                                    channel.  See sections 3.2.2.6 for a bit
                                    b bit description of the valuesthat
                                    can be set in each list element.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>ttrip</literal></term>
                            <listitem>
                                <para>
                                    Returns the trip times for each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>svmax</literal></term>
                            <listitem>
                                <para>
                                    Returns the software maximum voltage for
                                    each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rdown</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of ramp down rates for each
                                    channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rup</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the ramp up rates for each
                                    channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>pdownmode</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the power down modes
                                    for each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>polarities</literal> </term>
                            <listitem>
                                <para>
                                    Returns a list of the channel polarity values.
                                    Each channel polarity is represented by a
                                    <literal>+</literal> or a
                                    <literal>-</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                        
                        <varlistentry>
                            <term><literal>temp</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the temperaturs  for each
                                    channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </refsect3>
                <refsect3>
                    <title>Monitored variables</title>
                    <para>
                        Bias supplies must normally be monitored periodically
                        so that operators can be informed of trip and alarm
                        conditions.  The VM-USB framework provides for each
                        slow control device to contribut to a list that is
                        triggered periodically via the action register.
                        This allows this monitoring to be done without
                        pausing data taking.
                    </para>
                    <para>
                        The V5633 driver uses this capability and the
                        <command>mon</command> command should be used to
                        retrieve the most recent values of the monitored
                        variables.
                    </para>
                    <para>
                        The <command>mon</command> protocol command
                        will return the the string
                        <literal>OK </literal> followed by a Tcl list of lists.
                        The first list will be the channel status values.
                        The second list will be the channel actual voltages.
                        The third list will be the actual channel currents.
                        The fourth and last list will be the channel temperatures.
                    </para>
                </refsect3>
            </refsect2>
            <refsect2>
                <title>mdgg16</title>
                <para>
                  This slow-controls module provides support for the Wiener 
                  MDGG-16 device as used as a fourfold 16-channel configurable
                  OR. It sets up the device to output NIM logic signals
                  according to four separately defined OR definitions.                 
                </para>
                <refsect3>
                  <title>Options</title>
                  <variablelist>
                    
                    <varlistentry>
                      <term><option>-base</option></term>
                      <listitem>
                        <para>
                          The value of the base address of the Wiener MDGG-16
                          must be provided via this option.  
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-mode</option></term>
                      <listitem>
                        <para>
                          This is an enumerated option that only accepts two
                          parameter values: explicit, file. The "explicit" value
                          will use the values of the -or_a, -or_b, -or_c, and
                          -or_d parameters to set up the ORs. The "file" value
                          will read an input file defined by the -configfile
                          parameter to load the definitions. Default =
                          explicit.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_a</option></term>
                      <listitem>
                        <para>
                          This is a 16-bit integer that represents the 16-bit
                          mask identifying which input channels will
                          contribute to the NIM 0 output (OR A). A bit that is
                          set indicates that its corresponding channel will
                          contribute to the OR A output. Bit 0 corresponds to
                          the first input channel and bit 15 corresponds to the
                          last input channel.  Default value is 65535 (i.e. all
                          16 channels contribute to output).
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_b</option></term>
                      <listitem>
                        <para>
                          This is the same as the -or_a parameter except that it
                          corresponds to the OR B definition controlling the NIM
                          1 output.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_c</option></term>
                      <listitem>
                        <para>
                          This is the same as the -or_a parameter except that it
                          corresponds to the OR C definition controlling the NIM
                          2 output.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_d</option></term>
                      <listitem>
                        <para>
                          This is the same as the -or_a parameter except that it
                          corresponds to the OR D definition controlling the NIM
                          3 output.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-configfile</option></term>
                      <listitem>
                        <para>
                          The value of this parameter should be a valid path to
                          a configuration file. The configuration file should be
                          in the same form as the one generated by the
                          MDGG16Control program. In general, it should have the
                          following form:
                        </para>

                        <programlisting>
                         or_a  value_a  
                         or_b  value_b  
                         or_c  value_c  
                         or_d  value_d  
                        </programlisting>

                        <para> 
                          where value_a, value_b, value_c, and value_d are the
                          16-bit integers defining the bit masks for OR A, OR B,
                          OR C, and OR D, respectively.
                        </para>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                </refsect3>

                <refsect3>
                  <title>Parameters</title>

                  <para>
                    The following parameters can be Set:
                  </para>

                  <variablelist>
                    <varlistentry>
                      <term><literal>or_ab</literal></term>
                      <listitem>
                        <para>
                          Provides the bit masks for the OR A and the OR B 
                          definitions. See the description of the -or_a option 
                          for how each of these are defined individually. The
                          value to provide for this parameter should be a
                          combination of the two individual masks. It is a 32-bit
                          integer where the least significant 16-bits are the OR A
                          definition and the upper 16-bits are the OR B
                          definition.
                        </para>
                        <para>
                          The return value of this should be the response of the
                          device when successful. Any failure will result in a
                          return value beginning with "ERROR - " and is followed
                          by a description of the error.
                        </para>

                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><literal>or_cd</literal></term>
                      <listitem>
                        <para>
                          This is the same as the <parameter>or_ab</parameter> 
                          parameter except that it is formed by OR C and OR D bit
                          masks. The least significant 16-bits are the OR C
                          definition and the upper 16-bits are the OR D
                          definition.
                        </para>
                        <para>
                          The return value of this should be the response of the
                          device when successful. Any failure will result in a
                          return value beginning with "ERROR - " and is followed
                          by a description of the error.
                        </para>

                      </listitem>
                    </varlistentry>
                  </variablelist>

                  <para>
                    The following parameters can be retrieved via Get:
                  </para>

                  <variablelist>
                    <varlistentry>
                      <term><literal>or_ab</literal></term>
                      <listitem>
                        <para>
                          Reads the values of the OR A and OR B bit masks from the
                          device. The returned value will have both 16-bit masks
                          encoded into a 32-bit integer. The least significant
                          16 bits define the OR A mask and the upper 16 bits
                          define the OR B mask.
                        </para>

                        <para>
                          If an error occurs while communicating with the device,
                          the response will begin with "ERROR - " and will be
                          followed by a description of the error.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><literal>or_cd</literal></term>
                      <listitem>
                        <para>
                          Reads the values of the OR C and OR D bit masks from the
                          device. The returned value will have both 16-bit masks
                          encoded into a 32-bit integer. The least significant
                          16 bits define the OR C mask and the upper 16 bits
                          define the OR D mask.
                        </para>

                        <para>
                          If an error occurs while communicating with the device,
                          the response will begin with "ERROR - " and will be
                          followed by a description of the error.
                        </para>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                </refsect3>
            </refsect2> 
            <refsect2>
                <title>marker</title>
                <para>
                    This module inserts a marker in the monitor list.  The main use
                    is to get data buffers periodically flushed for slow data
                    rate applications.
                </para>
                <para>
                    The module has no gettable or settable parameters.  It has a
                    single configuration option <option>-value</option> which
                    sets the of the marker word.  Normally  you don't need to
                    modify this as the marker word will never make it outside the
                    VMUSBReadout program.
                </para>
            </refsect2>
        </refsect1>

      </refentry>
      <refentry id="vmusb3-watch">
        <refmeta>
           <refentrytitle id='vmusb3-watch-title'>watch</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>watch</refname>
           <refpurpose>Watch variables (slow controls)</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
watch <replaceable>name</replaceable>   
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Informs the slow controls server that a variable or array
            named <parameter>name</parameter> should be monitored.  The
            watched variable are monitored for changes (which are initiated
            by clients performing <command>set</command> commands). Periodically
            the current values of changed variables are dumped to the event
            stream as string items of type <literal>MONITORED_VARIABLES</literal>.
           </para>
           <para>
            If <parameter>name</parameter> is an array, all elements
            of that array are monitored.
           </para>
        </refsect1>
      </refentry>

<refentry id="vmusb3-delay">
  <refmeta>
     <refentrytitle>delay</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>

  <refnamediv>
     <refname>delay</refname>
     <refpurpose>Insert a stack delay.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    	<command>
delay create <replaceable>name ?options...?</replaceable>
	    </command>
    </cmdsynopsis>
    
    <cmdsynopsis>
      <command>
delay config <replaceable>name option value ...</replaceable>
      </command>
    </cmdsynopsis>
  
    <cmdsynopsis>
        <command>
delay cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
 
  </refsynopsisdiv>

  <refsect1>
     <title>DESCRIPTION</title>
     <para>
      This command creates a wait point in a stack. 	
     </para>
  </refsect1>

  <refsect1>
     <title>OPTIONS</title>
  
     <variablelist>
	    <varlistentry>
	       <term><command>-value</command> <replaceable>value</replaceable></term>
	       <listitem>
		       <para>Defines the duration of delay in units of 200 ns.</para>
	       </listitem>
	     </varlistentry>
     </variablelist>
 
  </refsect1>

  <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>A simple delay example</title>
         <programlisting>
delay create delay0 -value 4 
         </programlisting>
      </example>
      <para>
        Defines an 800 ns delay.
      </para>
  </refsect1>

</refentry>

<refentry id="vmusb3-CBDCamacBranch">
  <refmeta>
     <refentrytitle>CBDCamacBranch</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>

  <refnamediv>
     <refname>CBDCamacBranch</refname>
     <refpurpose>run a CAMAC branch through a CES CBD8210 bridge</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    	<command>
CBDCamacBranch create <replaceable>name base</replaceable>
	    </command>
    </cmdsynopsis>
    
    <cmdsynopsis>
      <command>
CBDCamacBranch config <replaceable>name option value ...</replaceable>
      </command>
    </cmdsynopsis>
  
    <cmdsynopsis>
      <command>
CBDCamacBranch cget <replaceable>name</replaceable>
      </command>
    </cmdsynopsis>
 
   </refsynopsisdiv>
  
  <refsect1>
    <title>DESCRIPTION</title>
    
    <para>
When the user intends to read out CAMAC devices through the VM-USB this driver can be used if the branch driver is a CES CBD8210. This class maintains a camac branch driver object that must encapsulate the necessary functionality for controlling the CAMAC devices on its branch. The camac branch driver essentially provides the means for translating standard bcnaf commands to VME commands that are executable by the VM-USB in a command stack. It must also properly implements the CCamacBranchDriver interface. 
    </para>
    
    <para>
A CAMAC branch is just a bunch of CAMAC crates strung together with a common branch number. For this reason, the CBDCamacBranch must be told which branch number it is operating on and also the camac crates that exist on the branch. Be sure that the camac crates registered to the branch are consistent with the driver being used by the CBDCamacBranch. In other words, modules prefixed by CBD, like CBDCamacCrates, must be registered to the CBDCamacBranch if the driver has been defined as a CES CBD8210.
    </para>
    
    <para>
    At initialization the following operations occur:
    <orderedlist>
      <listitem>
        <para> Setup the appropriate camac branch driver </para>
      </listitem>
      
      <listitem>
        <para> The branch driver will initiate the branch </para>
      </listitem>
     
      <listitem>
        <para> Call initialize for each crate registered to the branch </para>
      </listitem>
  
    </orderedlist>
    </para>

    <para>
    At the end of the run, the specific end of run operations are called for each crate registered to the branch.
    </para>

    <para>
    During execution of an event stack, the operations defined in each crate are executed in the order that the crate list was passed.
    </para>
  
  </refsect1>

  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-branch</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the branch index. Default is 0.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-crates</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
        Specify a proper tcl list of crate modules to be operated on the branch. These crates must be compatible with the driver in use. Care should also be taken to ensure that the crate indices are all different. Default is an empty list. 
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>Sample setup of two camac crates on branch 0</title>
         <programlisting>
# define some camac crates
CBDCamacCrate create crate1 -crate 1
CBDCamacCrate create crate2 -crate 2

CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate1 crate2]
         </programlisting>
      </example>
      <para>
       Defines two camac crates compatible with the CBD8210 branch driver and adds those to the camac branch, whose branch index is 0.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDCamacCrate">
  <refmeta>
     <refentrytitle>CBDCamacCrate</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDCamacCrate</refname>
     <refpurpose>group CBD8210 compatible modules into a crate</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDCamacCrate create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDCamacCrate config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDCamacCrate cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
     <title>DESCRIPTION</title>
     <para>
The CBDCamacCrate command defines a container type driver that holds a registry of modules. It is designed to work on a CAMAC branch rooted in a VME crate by a CES CBD8210 device. If this is not the case, use of this driver will fail. In addition, the modules that are registered to this crate must also be capable of working with a CBD8210 device. This module cannot operate on its own and must be registered to a valid CBDCamacBranch. 
  </para>

  <para>
At the start of every run, the initialization procedures will be called for all of the registered modules in the order the modules were listed.
  </para>

  <para>
At the end of every run, the end of run procedures will be called for all of the registered module in the order the modules were listed.
  </para>

  <para>
During stack execution initiated by an event trigger, the event-wise procedures of each of the registered modules will be executed in the order that they were listed.
  </para>

  </refsect1>

  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-crate</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the crate index. Default is 0.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-modules</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
        Specify a proper tcl list of modules to be registered with this crate. these must all be compatible with the CBD8210 branch driver. The order in which modules are listed will be the order in which each module is serviced. A single module can be registered to multiple CBDCamacCrates. Default is an empty list. 
		    </para>
	       </listitem>
	    </varlistentry>
  </variablelist>

  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>Sample setup of a single LeCroy 2551</title>
         <programlisting>
CBDLeCroy2551 create sclr -slot 10

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list sclr]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
       Defines a camac crate with a single LeCroy2551 to operate on with a CBD8210 branch driver. This crate is labeled with index 1 on the branch and the branch is labeled with index 0.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDLeCroy4300B">
  <refmeta>
     <refentrytitle>CBDLeCroy4300B</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDLeCroy4300B</refname>
     <refpurpose>control a LeCroy 4300B FERA on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDLeCroy4300B create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4300B config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4300B cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
  <para>
The CBDLeCroy4300B cannot be registered as a stack module by itself. Instead it must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be registered to a CBDCamacBranch module. See the example below to understand how this works. 
  </para>
  <para>
There are a number of options that are provided to ultimately control the command register of the device. The command register is what establishes how the FERA will read out its data. Two options must be specified to operate the device, -pedestals and slot. If either of these are not specified, the initialization of the module will fail. 
  </para>

  <para>
  During initialization the following operations occur:
    <orderedlist>
     <listitem> 
        <para> Clear the module </para>
     </listitem>
     <listitem>
      <para> Write all pedestals passed to the -pedestal option </para>
     </listitem>
     <listitem>
      <para> Compute the command register from user define options and write it to the module </para>
     </listitem>
  </orderedlist>
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate based on the following logic:
  <programlisting>

  if "-camacclear" is true
      Clear the module

  </programlisting>
  
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. DEFAULT is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pedestals</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
          A proper tcl list of 16 integer parameters defining the pedestals for each of the 16 channels. The first element of the list will configure the first channel of the FERA, the second element will configure the second channel, and so on. REQUIRED
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-vsn</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
The virtual station number to associate with the target device. This will be included in the header if data compression is enabled. 
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to use pedestal subtraction in ECL port readout (aka. EPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclcompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before ECL port readout (aka. ECE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclenable</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to enable ECL port readout (aka. EEN). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to use pedestal subtraction in CAMAC readout (aka. CPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaccompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before CAMAC readout (aka. CCE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacseqrdo</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to configure the device for sequential readout in CAMAC (aka. CSR). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaclam</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether the allow the device to emit a LAM when data is available to be read (aka. CLE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-overflowsuppress</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to suppress output of overflows as well as zeros (aka. OAFS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Sample setup of a few FERAs</title>
         <programlisting>
CBDLeCroy4300B create fera -slot 10 
CBDLeCroy4300B config fera -pedestals \
          [list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
CBDLeCroy4300B config fera -eclenable on
CBDLeCroy4300B config fera -eclpedsub on
CBDLeCroy4300B config fera -eclcompression on
CBDLeCroy4300B config fera -camacclear off

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list fera]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy4300B module with all pedestals 1 to be read out by the ECL ports. The FERA resides in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDLeCroy4434">
  <refmeta>
     <refentrytitle>CBDLeCroy4434</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDLeCroy4434</refname>
     <refpurpose>control a LeCroy 4434 Scaler on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDLeCroy4434 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4434 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4434 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The CBDLeCroy4434 is intended to control a LeCroy 4434 scaler situated on a camac branch rooted in a VME crate by a CES CBD8210 branch driver. If you intend to utilize the driver in a camac crate controlled by a CCUSB, see the LeCroy4434 command. It provides the exact same functionality but understands the CCUSB to be its controller.
  </para>

  <para>
The CBDLeCroy4434 cannot be registered as a stack module by itself. Instead it must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be registered to a CBDCamacBranch module. See the example below to understand how this works.
  </para>

  <para>
  During initialization, all scalers are cleared and the auxiliary bus is disabled. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate based on the following logic:
  <programlisting>

  Read all channels
  if "-incremental" is true
      Clear the module
  </programlisting>

  Just as a note, the latch and the clear are not atomic.
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-incremental</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specifies whether to clear the scalers on each event after latching them. Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Sample setup of a single scaler</title>
         <programlisting>
CBDLeCroy4434 create sclr -slot 10

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list sclr]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 4434 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>
  
<refentry id="vmusb3-CBDLeCroy2551">
  <refmeta>
     <refentrytitle>CBDLeCroy2551</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDLeCroy2551</refname>
     <refpurpose>control a LeCroy 2551 Scaler on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDLeCroy2551 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy2551 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy2551 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The CBDLeCroy2551 is intended to control a LeCroy 2551 scaler situated on a camac branch rooted in a VME crate by a CES CBD8210 branch driver. If you intend to utilize the driver in a camac crate controlled by a CCUSB, see the LeCroy2551 command. It provides the exact same functionality but understands the CCUSB to be its controller.
  </para>

    <para>
The CBDLeCroy2551 cannot be registered as a stack module by itself. Instead it must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be registered to a CBDCamacBranch module. See the example below to understand how this works.
    </para>

  <para>
  During initialization, all scalers are cleared. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, all 12 scaler channels are read individually. There is no clear at the end of an event.
  </para>

  <para>
  It is important for the user to understand that format of the data is outputted by the VMUSB when this scaler is used. Each channel readout consists of two separate 16-bit reads that accomplish the reading of the upper bits followed by the lower 16-bits of the actual scaler value. This is done because the CBD8210 is a D16 device rather than a D32 device. There is no getting around it. What this means is that the actual scaler values need to be filtered or processed before they look like meaningful numbers.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of a single scaler</title>
         <programlisting>
CBDLeCroy2551 create sclr -slot 10

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list sclr]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 2551 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDULMTrigger">
  <refmeta>
     <refentrytitle>CBDULMTrigger</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDULMTrigger</refname>
     <refpurpose>control a LeCroy 2637 ULM running trigger firmware on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDULMTrigger create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDULMTrigger config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDULMTrigger cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The CBDULMTrigger is intended to control a LeCroy 2367 ULM situated on a camac branch rooted in a VME crate by a CES CBD8210 branch driver. If you intend to utilize the driver in a camac crate controlled by a CCUSB, see the ULMTrigger command. It provides the exact same functionality but understands the CCUSB to be its controller.
  </para>

    <para>
The CBDULMTrigger cannot be registered as a stack module by itself. Instead it must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be registered to a CBDCamacBranch module.
    </para>

  <para>
Two options need to be specified to function properly. The first is firmware which defines the location of the firmware file to load. The second is the slot number in the camac crate it lives in.
  </para>


  <para>
  On initialization the module will always be cleared and the GO bit set to 1.
  </para>

  <para>
  At the end of the run, the GO bit is set to 0.
  </para>

  <para>
  During stack execution initiated by an event trigger, the following logic is carried out:

  <programlisting>
if "-registerRead" is true
    Read the register

if "-eventwiseClear" is true
    Clear the register
  </programlisting>
  
  By default, both -registerRead and -eventwiseClear are set to false.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
        The path to the firmware file usbtrig.bit. Default is "".
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-readRegister</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to add a hit register read into the event stack. Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eventwiseClear</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to send a clear command via the CAMAC dataway at the end of the event. Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-forceFirmwareLoad</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        By default, the ULM will only load the firmware if it fails to validate the configuration. This occurs always after a bad firmware load or after a crate has been power cycled. Firmware loads take a bit of time so it is worthwhile to skip reloading the firmware on every run. However, sometimes it may be considered useful. This option causes the firmware to be loaded at the start of EVERY run. Defaults to false.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-configuration</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Specifies the number that will be used to validate a successful firmware configuration. This number is compared to the value returned by the function A=15 F=0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pcDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ccWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ssDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-bypasses</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-sdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-triggerBox</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect1</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect2</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect3</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect4</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-adcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-qdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-tdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-coincWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Setup of a single ULM trigger module</title>
         <programlisting>
# Define values for each parameter in TRIGGER array
CBDULMTrigger create sclr -slot 23
CBDULMTrigger config ulm firmware /user/s800/server/fpga/usbtrig.bit
CBDULMTrigger config ulm -pcDelay $TRIGGER(PCDelay) \
                  -pcWidth $TRIGGER(PCWidth) \
                  -scDelay $TRIGGER(SCDelay) \
                  -scWidth $TRIGGER(SCWidth) \
                  -psDelay $TRIGGER(PSDelay) \
                  -ccWidth $TRIGGER(CCWidth) \
                  -ssDelay $TRIGGER(SSDelay) \
                  -bypasses $TRIGGER(Bypasses) \
                  -pdFactor $TRIGGER(PDFactor) \
                  -sdFactor $TRIGGER(SDFactor) \
                  -triggerBox $TRIGGER(TriggerBox) \
                  -inspect1 $TRIGGER(Inspect1) \
                  -inspect2 $TRIGGER(Inspect2) \
                  -inspect3 $TRIGGER(Inspect3) \
                  -inspect4 $TRIGGER(Inspect4) \
                  -adcWidth $TRIGGER(ADCWidth) \
                  -qdcWidth $TRIGGER(QDCWidth) \
                  -tdcWidth $TRIGGER(TDCWidth) \
                  -coincWidth $TRIGGER(CoincidenceWidth) \
                  -configuration $TRIGGER(configuration) 
CBDULMTrigger config trig -forceFirmwareLoad off
CBDULMTrigger config trig -readRegister on
CBDULMTrigger config trig -eventwiseClear off


# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list trig]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a ULM module in slot 23 of crate 1 on branch 0.
      </para>
  </refsect1>
</refentry>

  
<refentry id="vmusb3-XLMTimestamp">
  <refmeta>
     <refentrytitle>XLMTimestamp</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>XLMTimestamp</refname>
     <refpurpose>control an XLM running 64-bit latching scaler firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
XLMTimestamp create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMTimestamp config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMTimestamp cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>

     <para>
      The XLMTimestamp module is a driver to control an JTech XLM running a 64-bit latching scaler firmware. It is intended to be used specifically with the stamp64.bit firmware written by Daniel Bazin at the NSCL.
    </para>

  <para>
  During initialization, the firmware is loaded and all scalers are cleared. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, the 64-bits of scaler are read out in two 32-bit chunks. The lower 32-bits are read first and the upper 32-bits are read second. 
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>

	    <varlistentry>
	      <term><command>-base</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          Specifies the base address of the module. See the manual on how to address the XLM. When the module is using geographic addressing, the slot number is pushed up 27 bits (i.e. slot 10 produces a base address of 0x50000000).
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
          The path to the stamp64.bit firmware file.
		    </para>
	       </listitem>
	    </varlistentry>

   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of a single timestamp module</title>
         <programlisting>
          xlmtstamp create tstamp -base 0x50000000
          xlmtstamp config tstamp -firmware /user/s800/server/fpga/stamp64.bit
         </programlisting>
      </example>
      <para>
        Sets up an XLM in slot 10 to run the stamp64.bit firmware.
      </para>
  </refsect1>
</refentry>
      <refentry id="vmusb3-marker">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='vmusb3-marker-title'>marker</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>marker</refname>
           <refpurpose>Insert a constant into the VMUSB data stream</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
marker create <replaceable>name</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
marker config <replaceable>name -value uint16</replaceable>                    
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
marker cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
            
            
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            When added to a stack, a marker inserts a constant 16 bit unsigned
            value in the outupt data produced by the VM-USB in response to that
            stack's trigger.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-value</option> <replaceable>uint16</replaceable></term>
                <listitem>
                    <para>
                        The <replaceable>uint16</replaceable> unsigned 16 it
                        bit integer will be inserted into the output stream.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>

<refentry id="vmusb3-XLMFERA">
  <refmeta>
     <refentrytitle>XLMFERA</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>XLMFERA</refname>
     <refpurpose>control an XLM72V running firmware to readout FERA via ECL ports</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
XLMFERA create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMFERA config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMFERA cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>

     <para>
      The XLMFERA module is a driver to control a JTech XLM72V running firmware to handle readout of FERA modules via ECL ports. The XLM actually interfaces with a LeCroy 4301 FERA driver to accomplish this. The firmware associated with this is the xferajan.bit firmware that was written primarily by an unknown author but was assisted by Jan Toke (JTech). 
    </para>

    <para>
     This is just a derived class of the CXLM base class. 
    </para>

  <para>
  During initialization, the firmware is loaded. The user must provide the path to the firmware file by means of the -firmware option. If no firmware file is specified or the path provided is invalid, an exception will be thrown. The firmware will always be validated on initialization by a validation test. This validation test reads the signature of the firmware from the device and compares it to the value passed by the -configuration option. If these numbers are not identical or the -forceFirmwareLoad flag is set to true, the firmware will be loaded. The user will be alerted to the success of the validation via messages printed to the console. Immediately following the firmware load, the validation test is repeated and the user will be alerted of the results. An exception will be thrown if the validation test fails at this point.
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution, a block transfer is executed. First, the lowest 16-bits of memory in the sramA is read via a 32-bit read. The value of these 16-bits will be used to specify the number of 32-bit transfers to execute in a subsequent block transfer. The block transfer will begin at 5th byte of sramA (i.e. the second 32-bits).
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>

	    <varlistentry>
	      <term><command>-base</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          Specifies the base address of the module. See the manual on how to address the XLM. When the module is using geographic addressing, the slot number is pushed up 27 bits (i.e. slot 10 produces a base address of 0x50000000).
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
          The path to the xferajan.bit firmware file.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-configurationID</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The value to use in the validation test. Default is 0x54000041. 
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-forceFirmwareLoad</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Force reload of the firmware every run regardless of whether the XLM passes the validation test.
		    </para>
	       </listitem>
	    </varlistentry>

   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of a single timestamp module</title>
         <programlisting>
          XLMFERA create myxlm -base 0x50000000
          XLMFERA config myxlm -firmware /user/s800/server/fpga/xferajan.bit
         </programlisting>
      </example>
      <para>
        Sets up an XLM in slot 10 to run the xferajan.bit firmware.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-AXLM72ScalerControl">
  <refmeta>
     <refentrytitle>AXLM72ScalerControl</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>AXLM72ScalerControl</refname>
     <refpurpose>slow-controls driver for controlling an XLM72 running 32-ch scaler firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
AXLM72ScalerControl <replaceable>name option value ...</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> Set <replaceable>usb parameter value</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> Get <replaceable>usb parameter</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> Update <replaceable>usb</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> addMonitorList <replaceable>list</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> processMonitorList <replaceable>data</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>

  <title>DESCRIPTION</title>

     <para>
    The AXLM72ScalerControl driver is a pure-TCL driver that is used to communicate with the XLM72 when running the ech32x24.bit firmware. It implements the CControlHardware interface as is equivalent in TCL. When loaded into the slow-controls server, any remote process can send it commands that it will translate into actual communication with a specific XLM72 device. It communicates through the low-level driver for the ech32x24.bit firmware called AXLM72Scaler. The XLM72ScalerGUI requires that an instance of this class is registered as a TCL module (see Module command), in the slow-controls server.
    </para>

  </refsect1>
  
  <refsect1>
  <title>OPTIONS</title>
    <variablelist>

	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          Specifies the slot in which the target XLM72 module resides.
		    </para>
	       </listitem>
	    </varlistentry>
    </variablelist>

  </refsect1>

  <refsect1>
  <title>METHODS</title>
  <variablelist>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>Set</command> <replaceable>vmusb parameter value</replaceable></term>
      <listitem>
        <para>
          The Set command causes a write to the XLM72. There are 34 supported parameters: enable, reset, trigger0, trigger1, trigger2, ..., and trigger31. The number appended to the trigger parameter identifies the channel number. The values provided for reset and the any trigger must be either 0 or 1, and the value of the reset command is ignored. The returned value is the status value of the return value for the write operation (0 => success, otherwise => failure).
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>Get</command> <replaceable>vmusb parameter</replaceable></term>
      <listitem>
        <para>
          The Get command causes a read from the XLM72. There are 5 parameters that can be provided to this method: enable, alltriggers, firmware, runstate, and allscalers. These all return the value read from the device. The enable parameter returns a 0 or 1 indicating whether the scalers are enabled. The alltriggers parameter returns a 32-bit integer with the status of each channel's trigger status encoded in its bits. Channel 0's status is encoded in bit 0 and channel 31's status is encoded in bit 31, with all others likewise. The firmware parameter returns the firmware signature. The runstate parameter causes a return of the run state as one of the following strings: idle, starting, stopping, active, paused. Finally the allscalers parameters causes the scaler values to be latched and read out of the device. These are returned as a list of 32 integers beginning with channel 0.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>Update</command> <replaceable>vmusb</replaceable></term>
      <listitem>
        <para>
          The Update method is defined but does nothing.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>addMonitorList</command> <replaceable>list</replaceable></term>
      <listitem>
        <para>
          The addMonitorList method is defined but does nothing.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>processMonitorList</command> <replaceable>data</replaceable></term>
      <listitem>
        <para>
          The processMonitorList method is defined but does nothing more than return 0.
        </para>
      </listitem>
    </varlistentry>
  </variablelist> 

  </refsect1>

  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of the AXLM72ScalerControl</title>
         <programlisting>
          package require scalerxlm72

          # Instantiation an object
          AXLM72ScalerControl mysclr -slot 5 

          # create the module for the slow-controls configure it to call the methods of the mysclr object
          Module create tcl sclrmod
          Module config sclrmod -ensemble mysclr
         </programlisting>
      </example>
      <para>
        Sets up an instance of the AXLM72ScalerControl to run on the slow-controls server. If the XLM72ScalerGUI is to be run with this module, it would have to be given the name of the module as "sclrmod".
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-XLM72ScalerGUI">
  <refmeta>
     <refentrytitle>XLM72ScalerGUI</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>XLM72ScalerGUI</refname>
     <refpurpose>Diagnostics GUI for controlling an XLM72 running 32 ch scaler firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
  <cmdsynopsis>
    <command>
      XLM72ScalerGUI <replaceable>name option value ...</replaceable>
    </command>
  </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>

  <title>DESCRIPTION</title>
  <para>
The XLM72ScalerGUI is a graphical user interface (GUI) that provides interactive control over an XLM72 running the ech32x24.bit firmware in a crate being readout by VMUSBReadout program. This firmware was written and is supported by Daniel Bazin and the software driver that supports the readout is provided by NSCLDAQ as the AXLM72Scaler tcl driver. The XLM72ScalerGUI is a UI that displays the scaler values of the XLM72 when not in DAQ mode and gives the user some basic control over the XLM72 while the VMUSB is not in acquisition mode. It is primarily a diagnostics tools that can be used to enable or disable the scaler channels from counting, to clear the scaler counters, and also to repeatedly update the values at a selectable frequency.
  </para>

  </refsect1>

  <refsect1>
    <title>PARAMETERS</title>

    <variablelist>

	    <varlistentry>
	      <term><command>--module</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The name of the module registered to the VMUSBReadout slow-controls server that will handle the requests of the GUI.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>--host</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The host running the VMUSBReadout slow-controls server.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>--port</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The port on which the VMUSBReadout slow-controls server is listening for connections.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>--ring</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The name of the ring being filled by the VMUSBReadout program
		    </para>
	       </listitem>
	    </varlistentry>
    </variablelist>

  </refsect1>


  <refsect1>
    <title>Configuration</title>

    <para>
      The XLM72ScalerGUI is designed as a client-server architecture and thus using it requires setting up two different pieces: the client and the server. The setup of the server will be explained first. To avoid confusion, the server that will be communicated with is the VMUSBReadout slow-controls server and thus setting it up requires loading a driver with the needed functionality into it. The specific driver to be used is contained in the AXLM72ScalerControl class. It is just a standard slow-controls driver written purely in TCL that implements the Set, Get, and Update methods. Once an instance has been created of the AXLM72ScalerControl class, it needs to be registered as a TCL module using the ?Module? command. The name of the ensemble is just the name of the instance created. As with all slow-controls set up, this must be done in the ctlconfig.tcl file. The name of the AXLM72ScalerControl instance is not important so long as it does not conflict with any other tcl commands (e.g. setting the name to ?set? would lead to unexpected failures). Here is a sample of how to set it up in the ctlconfig.tcl file.
    </para>

    <example>
    <title>Example ctlconfig.tcl entry</title>
    <programlisting>
package require scalerxlm72			          ;# load the plugin

AXLM72ScalerControl XLM72SclrCtl -slot 5  ;# Create an instance of for an XLM72 in slot 5

Module create tcl xlm72sclrctl		        ;# Create a new pure tcl module named xlm72sclrctl
Module config xlm72sclrctl -ensemble XLM72SclrCtl ;# set the name of the ensemble to be the same as the name of the instance
    </programlisting>
    </example>

    <para>
The second portion of the XLM72ScalerGUI is the setup of the client. The client is much simpler and amounts to running the XLM72ScalerGUI program with the appropriate arguments. This program requires a few pieces of information to successfully communicate with the server. Those are the name of the host running the VMUSBReadout slow-controls server, the port on which that server is listening for connections, the name of the ringbuffer being filled by the VMUSBReadout program, and the name of the slow-controls module that is receiving requests from the GUI. In the above example, the name of that module would be "xlm72sclrctl".  
    </para>

    <para>
    That is it. If you want know why the ringbuffer name is needed read on about run state awareness.
    </para>

  </refsect1>

  <refsect1>
    <title>Run State Awareness</title>
    <para>
  The XLM72ScalerGUI is only allowed to query the XLM72 while a run is not in progress. When a run is in progress (i.e. the VM-USB is in data acquisition mode rather than interactive mode), all of the GUI components become disabled except for the Exit button. When a run ends, the GUI components become active again. The idea is that the XLM72ScalerGUI is really a diagnostics tool rather than a tool for data acquisition. In order to respond to run state transitions, the GUI needs to have some run state awareness. Two mechanisms provide this to form some redundancy. The primary means by which it obtains run state information is through a sclclient program attached to the ringbuffer filled by the VMUSBReadout program. This is why the user must provide the name of the ringbuffer, when starting up the GUI. The sclclient communicates with a TclServer embedded into the GUI and manages a variable called RunState. Unfortunately, this approach is leaves a small chance that the GUI sends a request after the run has started but before the sclclient has alerted the TclServer of the change. In this scenario, the second redundancy kicks in because the first thing that happens before a request is a request from the slow-controls server to return the run state. If the run state is not idle, then it is assumed that a run is in progress. Otherwise, the requests proceed as usual. 
    </para>

    <para>
      This may seem overkill but there is a good reason for doing it this way that is tied to how the slow-controls server handles requests while in acquisition mode. Should a request come in that mode, the VMUSB will exit acquisition mode, process the request, and then resume acquisition. Unfortunately, ending a run usually lasts about a second or two, which causes long wait times. To avoid repeated interruptions like this, the above scheme ensures that at most, one interruption can occur. Understand that no data is ever lost in these scenarios, the data stream is simply interrupted for a period of time. 
    </para>
  </refsect1>
  
</refentry>

      <refentry id="vmusb3-AXLM72">
        <refmeta>
           <refentrytitle>AXLM72</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>AXLM72</refname>
           <refpurpose>TCL base class for JTech XLM72 family of devices</refpurpose>
        </refnamediv>
    
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require xlm72
                </command>
            </cmdsynopsis>
          
        <cmdsynopsis>
            <command>
AXLM72 <replaceable>name slot</replaceable>
            </command>
        </cmdsynopsis>
        
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> GetVariable <replaceable>v</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Read <replaceable>ctlr dev address</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Write <replaceable>ctlr dev address data</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadSBLT <replaceable>ctlr dev address words</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadNBLT <replaceable>ctlr ndev naddr mask dev addr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> AccessBus <replaceable>ctlr code</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReleaseBus <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> BootFPGA <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetFPGABoot <replaceable>ctlr source</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Configure <replaceable>ctlr filename</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ExecuteLongStack <replaceable>ctlr stack</replaceable>
            </command>
        </cmdsynopsis>
      
        <formalpara> 
          <title>Stack Building Methods</title>
          <para></para>
        </formalpara> 
  
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sRead <replaceable>stack dev addr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sWrite <replaceable>stack dev addr data</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReadSBLT <replaceable>stack dev addr words</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReadNBLT <replaceable>stack ndev naddr mask dev addr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sAccessBus <replaceable>stack code</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReleaseBus <replaceable>stack code</replaceable>
            </command>
        </cmdsynopsis>

        </refsynopsisdiv>

        <refsect1>
           <title>DESCRIPTION</title>
           <para>
 This is the IncrTcl base class for the family of XLM72 devices. It provides
 a large number of convenience functions that derived classes can use
 in their drivers. The JTech XLM72 family of devices are general purpose
 logic modules that have no real function independent of the firmware
 loaded onto them. For this reason, derived classed typically handle
 how to interact with devices that are running a specific firmware.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>

           <variablelist>

             <varlistentry>
               <term><cmdsynopsis><command>
AXLM72 <replaceable>name slot</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Constructs an AXLM72 object for a device seated in
                      slot <parameter>slot</parameter>
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> GetVariable <replaceable>v</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Returns the value of the variable named <parameter>v</parameter>
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Read <replaceable>ctlr dev address</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs an A32/D32 read from the address $<parameter>dev</parameter>+$<parameter>address</parameter>. The access is performed through the swig wrapped CVMUSB class provided as <parameter>ctlr</parameter>. The method returns the value of read from the device.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Write <replaceable>ctlr dev address data</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs an A32/D32 write of <parameter>data</parameter> to the address $<parameter>dev</parameter>+$<parameter>address</parameter>. The access is performed through the swig wrapped CVMUSB class provided as <parameter>ctlr</parameter>. The returns the status of the write operation (success = 0, failure otherwise).
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadSBLT <replaceable>ctlr dev address words</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs a block transfer (A32/D32) of <parameter>words</parameter> transfers beginning at address $<parameter>dev</parameter>+$<parameter>address</parameter>. The access is performed through the swig wrapped CVMUSB class provided as <parameter>ctlr</parameter>. The method returns a swig wrapped std::vector&lt;uint8_t&gt; so one must use the cvmusb::uint8_vector_get and cvmusb::uint8_vector_size procs to handle it. The VMUSBDriverSupport::convertBytesListToTclList will convert it to a tcl list of 32-bit integer values if that is desired and sensible.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadNBLT <replaceable>ctlr ndev naddr mask dev addr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs a block transfer (A32/D32) whose transfer count is determined by read data from the address $<parameter>ndev</parameter>+$<parameter>naddr</parameter> and applying the mask <parameter>mask</parameter> to the result. This read is an unprivileged A32/D32 read. A subsequent block transfer then begins at address $<parameter>dev</parameter>+$<parameter>address</parameter>. The access is performed through the swig wrapped CVMUSB class provided as <parameter>ctlr</parameter>. The method returns a swig wrapped std::vector&lt;uint8_t&gt; so one must use the cvmusb::uint8_vector_get and cvmusb::uint8_vector_size procs to handle it. The VMUSBDriverSupport::convertBytesListToTclList will convert it to a tcl list of 32-bit integer values if that is desired and sensible.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> AccessBus <replaceable>ctlr code</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Convenience function for gaining access of an internal bus. This is 
                      two single shot operations. The first requests the bus of interest
                      and the second inhibits the FPGA and DSP from gaining mastership.
                      The valid values for <parameter>code</parameter> are any bitwise OR of bus A (0x1), bus B (0x2), 
                      bus X (0x1000), and bus D (0x2000). The <parameter>ctlr</parameter> is a 
   swig cvmusb::CVMUSB object.

                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReleaseBus <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Convenience function for releasing ownership of the internal busses. 
   This is similar to the AccessBus method but writes 0 to both the bus
   request and bus inhibit addresses. The <parameter>ctlr</parameter> is a 
   swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> BootFPGA <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Convenience function for booting the device. The operation only boots
   the FPGA. This is accomplished by first writing 1's to the reset bits 
   of the FPGA and DSP and then writing a 1 to the DSP and a 0 to the FPGA. 
   This causes the FPGA to boot and the DSP remains in reset mode (i.e. its 
   reset bit is still set). The <parameter>ctlr</parameter> is a 
   swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetFPGABoot <replaceable>ctlr source</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   A convenience method for writing to the FPGA boot source register.
   Valid values for <parameter>source</parameter> are : 0x0, 0x1, 0x2, 0x3, and 0x10000. The meanings
   are as follows: 
                  </para>
  <informaltable frame="all">
    <tgroup cols='2'>
    <tbody>
      <row>
        <entry>Boot Source Value</entry>
        <entry>Description</entry> 
      </row>
      <row>
        <entry>0x0</entry>
        <entry>Sector 0 flash</entry>
      </row>
      <row>
        <entry>0x1</entry>
        <entry>Sector 1 flash</entry>
      </row>
      <row>
        <entry>0x2</entry>
        <entry>Sector 2 flash</entry>
      </row>
      <row>
        <entry>0x3</entry>
        <entry>Sector 3 flash</entry>
      </row>
      <row>
        <entry>0x10000</entry>
        <entry>SRAM A</entry>
      </row>
    </tbody>
    </tgroup>
  </informaltable>
                    <para>
    The <parameter>ctlr</parameter> is a swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Configure <replaceable>ctlr filename</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Loads firmware into SRAMA and then boots the device from SRAMA. The firmware is
    loaded from <parameter>filename</parameter>. The <parameter>ctlr</parameter> is a swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ExecuteLongStack <replaceable>ctlr stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Converts the <parameter>stack</parameter> tcl list of raw stack commands into a 
   cvmusbreadoutlist::CVMUSBReadoutList object that gets 
   subsequently executed. Before returning the value data it is 
   parsed using the VMUSBDriverSupport::convertBytesListToTclList
   because the executeList command returns a vector of bytes.
   The <parameter>ctlr</parameter> is a swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sRead <replaceable>stack dev addr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Adds an A32/D32 read from $<parameter>dev</parameter>+$<parameter>addr</parameter> to <parameter>stack</parameter>. <parameter>stack</parameter> is a swig cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sWrite <replaceable>stack dev addr data</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Adds a A32/D32 write of <parameter>data</parameter> to $<parameter>dev</parameter>+$<parameter>addr</parameter> to <parameter>stack</parameter>. <parameter>stack</parameter> is a swig cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReadSBLT <replaceable>stack dev addr words</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a standard block read of <parameter>words</parameter> transfers beginning at <parameter>dev</parameter>+<parameter>addr</parameter> to <parameter>stack</parameter>. <parameter>stack</parameter> is a swig cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReadNBLT <replaceable>stack ndev naddr mask dev addr words</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      This adds the same functionality of ReadNBLT to <parameter>stack</parameter>. See documentation for ReadNBLT for explanation of its functionality.
                    </para>
                </listitem>
            </varlistentry>
           
             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sAccessBus <replaceable>stack code</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Adds a bus access command to the <parameter>stack</parameter> readoutlist. See documentation for AccessBus for the allowed values.
                    </para>
                </listitem>
            </varlistentry>
           
             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReleaseBus <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Adds a command to the <parameter>stack</parameter> readoutlist to release acquisition of any previously acquired busses.
                    </para>
                </listitem>
            </varlistentry>

          </variablelist>
        </refsect1>

    </refentry>

      <refentry id="vmusb3-AXLM72Scaler">
        <refmeta>
           <refentrytitle>AXLM72Scaler</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>AXLM72Scaler</refname>
           <refpurpose>Driver for an XLM72 running 32-channel scaler firmware</refpurpose>
        </refnamediv>
    
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require scalerxlm72
                </command>
            </cmdsynopsis>
          
        <cmdsynopsis>
            <command>
AXLM72Scaler <replaceable>name slot</replaceable>
            </command>
        </cmdsynopsis>
        
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> GetFirmware <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Reset <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Latch <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetTrigger <replaceable>ctlr bit</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetTriggetBit <replaceable>ctlr bit value</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetTriggerBits <replaceable>ctlr bitset</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadTrigger <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetEnable <replaceable>ctlr onoff</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadEnable <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadAll <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <formalpara> 
          <title>Stack Building Methods</title>
          <para></para>
        </formalpara> 

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sEnable <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>
  
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sDisable <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sLatch <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReadAll <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReset <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        </refsynopsisdiv>

        <refsect1>
           <title>DESCRIPTION</title>
           <para>
 This device is mostly just a 32-bit latching scaler but has the feature
 that channel inputs can be redirected as a trigger output. The trigger 
 output is the result of OR'ing all of the input signals of channels
 whose trigger bits are set. 
          </para>

          <para>
 The scaler can be enabled/disabled and atomically cleared (aka reset).
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>

           <variablelist>

             <varlistentry>
               <term><cmdsynopsis><command>
AXLM72Scaler <replaceable>name slot</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Constructs an AXLM72Scaler object for a device seated in
                      slot <parameter>slot</parameter>
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> GetFirmware <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Reads and returns the firmware signature. The <parameter>ctlr</parameter> is
                      a cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Reset <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                    Atomically resets all scaler values by writing a 1 and then a 0 to the lowest
                    address of the FPGA address space. Returns 0 on success or a negative value for failure.
                    The <parameter>ctlr</parameter> is a cvmusb::CVMUSB object. 
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Latch <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Latch the current values of the scaler counters into SRAMA for readout. 
                      The <parameter>ctlr</parameter> is a cvmusb::CVMUSB object.

                    </para>
                    <para>
                      The return value of this is either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetTrigger <replaceable>ctlr bit</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   As a result of history, this relies on the state of the
   trigger array to determine what to write. This ultimately
   calls SetTriggerBits after properly setting the requested
   bit. The <parameter>ctlr</parameter> is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this is either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetTriggerBits <replaceable>ctlr bitset</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   As opposed to the previous two methods, this replaces the
   entire trigger register value rather than manipulating 
   specific bits. It is therefore a lower level method but
   it enables one to write all bits at once. The value of <parameter>bitset</parameter>
   is written to the entire register. The <parameter>ctlr</parameter> is a 
   cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this is either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadTrigger <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Read the trigger register.
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this the value of the trigger register. 
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetEnable <replaceable>ctlr onoff</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Write the value of <parameter>onoff</parameter> to the enable register. Valid
    values for <parameter>onoff</parameter> are 0 (i.e. enable on) and 1 (i.e. enable off).
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    Returns either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadEnable <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Read and return the value of the enable register. 
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadAll <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Read and return the value of all 32 scaler counters.
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this is a tcl list of all 32 channels of scaler values.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sEnable <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Appends a write of 1 to the enable register onto <parameter>stack</parameter>.
    The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sDisable <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Appends a write of 0 to the enable register onto <parameter>stack</parameter>.
    The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sLatch <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a command to <parameter>stack</parameter> to latch the current value of the scaler
    counter into the SRAMA memory for later readout. The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReadAll <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a readout cycle to <parameter>stack</parameter>. The values of the counters are
    latched and then are readout using a BLT. After the BLT, the SRAMA data is reset. This handles the acquisition of the appropriate busses. The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object. 
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReset <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a write of 0 to SRAMA[0] to reset the data. The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
        </refsect1>

    </refentry>

   <!-- caenchain command - aggregate 785's into CBLT chains -->

      <refentry id="vmusb3_v1495sc">
	<refentryinfo>
	  <author>
		  <personname>
			  <firstname>Ron</firstname>
			  <surname>Fox</surname>
		  </personname>
	  </author>
	  <productname>NSCLDAQ</productname>
	  <productnumber></productnumber>
	</refentryinfo>
	<refmeta>
	   <refentrytitle id='vmusb3_v1495sc_title'>v1495sc</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
	   <refmiscinfo class='empty'></refmiscinfo>
	</refmeta>
	<refnamediv>
	   <refname>v1495sc</refname>
	   <refpurpose>CAEN V1495 with Scaler firmware</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	  <command>
v1495sc create <replaceable>name base-address</replaceable>
	   </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
v1495sc create <replaceable>name ?options...?</replaceable>
	       </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
v1495sc cget <replaceable>name</replaceable>
	       </command>
	  </cmdsynopsis>
	  

	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
	       When equipped with the appropriate firmware a V1495 logic
	       module is a 128 channel scaler.  This module is then sold
	       under the name V1495sc.  This command supplies support for the
	       V1495sc module in the VMUSBReadout program.
	   </para>
	   <para>
	       As with all device support commands <command>v1495sc</command>
	       is a command ensemble with the three subcommands;
	       <command>create</command>, <command>config</command> and
	       <command>cget</command>.  The <command>create</command>
	       command is responsible for adding new scalers to the system
	       configuration and naming them.  The <command>config</command>
	       command is responsible for setting the detailed configuration
	       of the module.  The configuration is used to define how the
	       module is going to be programmed when the run starts.  The
	       <command>cget</command> command allows you to retrieve a module's
	       current configuration.  See <literal>OPTIONS</literal> below
	       for information about the options supported.
	   </para>
	</refsect1>
	<refsect1>
	   <title>
	      OPTIONS
	   </title>
	   <variablelist>
	       <varlistentry>
		   <term>
		    <option>-base</option>
		    <replaceable>base-addresss</replaceable>
		   </term>
		   <listitem>
		       <para>
			 Allows you to override the base address set at creation
			 time.  The base address must be the address of a
			 V1495sc module.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-exttrig </option> <literal>enabled | disabled</literal>
		   </term>
		   <listitem>
		       <para>
			 Enables the external trigger to latch scaler
			 values into the multi-event memory of the module.
			 The external trigger is the module's G0 input.
			 By default this is <literal>disabled</literal>.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		     <option>-inttrig</option>  <replaceable>enabled | disabled</replaceable>
		   </term>
		   <listitem>
		       <para>
			  Enables the internal trigger to latch values in to the
			  scaler's mult-event memory.  THe internal trigger
			  fires when the scaler dwell tiem has been reached.
			  See <option>-dwelltime</option> for more information
			  about this.  The default value is
			  <literal>disabled</literal>.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		     <option>-vmetrigger</option> <replaceable>enabled |disabled</replaceable>
		   </term>
		   <listitem>
		       <para>
			  Enables or disables the software trigger.  This is used
			  to programmatically latch scaler values as desired.
			  The default value of this option is  <literal>enabled</literal>
			  which is suitable for using this scaler as
			  a provider of scaler channels to the scaler display program.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-inputlevel</option> <replaceable>nim | ttl</replaceable>
		   </term>
		   <listitem>
		       <para>
			 Sets the input signalling levels expected by the
			 G0, and G1 inputs.  The default value is <literal>nim</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-autoreset</option> <replaceable>on | off</replaceable>
		   </term>
		   <listitem>
		       <para>
			  If <literal>on</literal> (the default), the scalers are
			  atomically reset after a read.  This is suitable for use
			  in creating incremental scaler items.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-g1_mode</option> <replaceable>inhibit | reset | test</replaceable>
		   </term>
		   <listitem>
		       <para>
			 Sets the use of the G1 input.  If <literal>inhibit</literal>
			 (the default), while G1 is logic true, the scalers are
			 inhibited from counting.  If <literal>reset</literal>,
			 scaler values will be cleared on the leading edge of a
			 false to true transition.  See the documentation for the
			 V1495sc module for information about the effect of using
			 <literal>test</literal> for this configuration value.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-includetime</option> <replaceable>yes | no</replaceable>
		   </term>
		   <listitem>
		       <para>
			 If
			 <literal>yes</literal>, includes the trigger time since
			 the latest board reset
			 in the event data in the MEB.  This is <literal>no</literal>
			 by default
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-bank*enables</option> <replaceable>mask</replaceable>
		   </term>
		   <listitem>
		       <para>
			 Where <literal>*</literal> should be replaced by any of
			 <literal>1, 2, 3, 4</literal> (e.g. -bank1enables).
			 The value is a bitmask that determines which scaler
			 channels are enabled to count.  These options
			 all default to <literal>0xffffffff</literal> enabling
			 all 32 channels in an input bank.  Input banks represent
			 the scalers associated with one of the input connectors
			 on the module.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-dwelltime</option> <replaceable>micro-seconds</replaceable>
		   </term>
		   <listitem>
		       <para>
			 When the internal trigger is enabled, this sets the
			 number of microseconds between internal triggers.
			 The default value is <literal>0x20000</literal>, an
			 arbitrary value that works out to .131 seconds or so.
		       </para>
		   </listitem>
	       </varlistentry>
	   </variablelist>
	</refsect1>

      </refentry>
        


<!-- /manpage -->
<!-- manpage 5vmusb -->

    <refentry id="vmusb5-slowcontrols-protocol">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>  
      <refmeta>
         <refentrytitle>VMUSB slow controls protocol</refentrytitle>
         <manvolnum>5vmusb</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>VMUSB Slow controls protocol</refname>
         <refpurpose>VMUSB Slow controls protocol</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <cmdsynopsis>
        <command>
Set <replaceable>module-name parameter-name value</replaceable>
        </command>
        </cmdsynopsis>
          <cmdsynopsis>
              <command>
Get <replaceable>module-name parameter-name</replaceable>
              </command>
          </cmdsynopsis>
          <cmdsynopsis>
              <command>
mon <replaceable>module-name</replaceable>
              </command>
          </cmdsynopsis>

      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
          The slow controls protocol allows control panel software
          to be built that communicates with slow controls drivers
          in the VM-USB raadout framework.   This is intended to allow
          the contruction of control panels for devices that have slow
          controls drivers.  Note that the <classname>vmusb</classname>
          controller allows drivers to be written for devices
          that don't have slow controls drivers yet.
         </para>
         <para>
          The slow controls server listens for connections on the port
          specified by the Readout program's <option>--port</option>
          option or <literal>27000</literal> if that option is not
          specified.
         </para>
         <para>
          Connected clients send commands to the server as lines
          of text and get back singe line replies.  Replies are
          expected to begin with <literal>OK</literal> if the request
          was successful and <literal>ERROR</literal> otherwise.
          The text that follows the header text depends on the
          driver.
         </para>
      </refsect1>
      <refsect1>
          <title>
             COMMANDS
          </title>
          <variablelist>
              <varlistentry>
                  <term><command>Set <replaceable>module-name module-parameter value</replaceable></command></term>
                  <listitem>
                      <para>
                          Attempts to set a parameter
                          <parameter>module-parameter</parameter>
                          in a module <parameter>module-name</parameter>
                          to a new <parameter>value</parameter>.
                      </para>
                      <para>
                          <parameter>module-name</parameter> is the name
                          of a module that has been defined by the
                          control configuration file.
                          <parameter>module-parameter</parameter>
                          is a parameter that must be recognized by
                          the driver that manage that module.
                          <parameter>value</parameter> must be a valid
                          new value for that parameter.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><command>Get <replaceable>module-name module-parameter</replaceable></command></term>
                  <listitem>
                      <para>
                          Retrives a parameter (<parameter>module-parameter</parameter>)
                          from a module (<parameter>module-name</parameter>).   
                      </para>
                      <para>
                          <parameter>module-name</parameter> is the name
                          of a module that has been defined by the
                          control configuration file.
                          <parameter>module-parameter</parameter>
                          is a parameter that must be recognized by
                          the driver that manage that module.
                          It is entirely up to the module driver to
                          decide what is returned, however by
                          convention, as described above, the string
                          returned will begin either with
                          <literal>OK</literal> or
                          <literal>ERROR</literal>.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><command>mon <replaceable>module-name</replaceable></command></term>
                  <listitem>
                      <para>
                          Returns data that is monitored by the
                          device.  Again it is up to the driver
                          to decide exactly what should be returned.
                      </para>
                  </listitem>
              </varlistentry>
              
          </variablelist>
       </refsect1>

    </refentry>


        
<!-- /manpage -->
