<!-- manpage 3daq -->

<refentry id="daq3_CStatusDb">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
        <personblurb><para></para></personblurb>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_CStatusDb_title'>CStatusDb</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CStatusDb</refname>
     <refpurpose>class description</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CStatusDb.h&gt;
       class <ooclass><classname>CStatusDb</classname></ooclass>
{
public:
   <constructorsynopsis>
      <methodname>CStatusDb</methodname>
      <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>dbSpec</parameter>
      </methodparam>
      <methodparam>
        <modifier></modifier><type>int</type>
            <parameter> flags</parameter>
      </methodparam>
      <exceptionname></exceptionname>
   </constructorsynopsis>
   <methodsynopsis>
       <modifier></modifier>
       <type>void </type>
       <methodname>insert</methodname>
       <methodparam>
        <modifier></modifier><type>std::vector&lt;zmq::message_t*&gt;&amp; </type>
            <parameter>message</parameter>
       </methodparam>
       <exceptionname></exceptionname>
       <modifier></modifier>
   </methodsynopsis>  
   <methodsynopsis>
       <modifier></modifier>
       <type>void </type>
       <methodname>addRingStatistics(
       </methodname>
       <methodparam>
        <modifier></modifier><type>uint32_t </type>
            <parameter>severity </parameter>
       </methodparam>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>app</parameter>
       </methodparam>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>src</parameter>
       </methodparam>
       <methodparam>
        <modifier>const </modifier><type>CStatusDefinitions::RingStatIdentification&amp; </type>
            <parameter>ringId</parameter>
       </methodparam>
       <methodparam>
        <modifier>const </modifier><type>std::vector&lt;const CStatusDefinitions::RingStatClient*&gt;&amp; </type>
            <parameter>clients</parameter>
       </methodparam>
       <exceptionname></exceptionname>
       <modifier></modifier>
   </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>addStateChange</methodname>
        <methodparam>
            <modifier></modifier><type>uint32_t </type>
                <parameter>severity</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>app</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>src</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>int64_t  </type>
                <parameter>tod</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>from</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>to</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>addReadoutStatistics</methodname>
        <methodparam>
            <modifier></modifier><type>uint32_t </type>
                <parameter>severity</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>app</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>src</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>int64_t </type>
                <parameter>startTime</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>uint32_t </type>
                <parameter>runNumber</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter> title</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>CStatusDefinitions::ReadoutStatCounters* </type>
                <parameter>pCounters</parameter><initializer>NULL</initializer>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>addLogMessage</methodname>
        <methodparam>
            <modifier></modifier><type>uint32_t </type>
                <parameter>severity</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>app</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>src</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>int64_t  </type>
                <parameter>time</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>message</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    
    // Queries:
    
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>queryLogMessages</methodname>
        <methodparam>
            <modifier></modifier><type>std::vector&lt;LogRecord&gt;&amp; </type>
                <parameter>result</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>CQueryFilter&amp; </type>
                <parameter>filter</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>listRings</methodname>
        <methodparam>
            <modifier></modifier><type>std::vector&lt;RingBuffer&gt;&amp; </type>
                <parameter>result</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>CQueryFilter&amp; </type>
                <parameter>filter</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void listRingsAndClients</type>
        <methodname></methodname>
        <methodparam>
            <modifier></modifier><type>RingDirectory&amp; </type>
                <parameter>result</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>CQueryFilter&amp; </type>
                <parameter>filter</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>queryRingStatistics</methodname>
        <methodparam>
            <modifier></modifier><type>CompleteRingStatistics&amp; </type>
                <parameter>result</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>CQueryFilter&amp; </type>
                <parameter>filter</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>listStateApplications</methodname>
        <methodparam>
            <modifier></modifier><type>std::vector&lt;StateApp&gt;&amp; </type>
                <parameter>result</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>CQueryFilter&amp; </type>
                <parameter>filter</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>queryStateTransitions</methodname>
        <methodparam>
            <modifier></modifier><type>std::vector&lt;StateTransition&gt;&amp; </type>
                <parameter>result</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>CQueryFilter&amp; </type>
                <parameter>filter</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>listReadoutApps</methodname>
        <methodparam>
            <modifier></modifier><type>std::vector&lt;ReadoutApp&gt;&amp; </type>
                <parameter>result</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>CQueryFilter&amp; </type>
                <parameter>filter</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>listRuns</methodname>
        <methodparam>
            <modifier></modifier><type>RunDictionary&amp;</type>
                <parameter> result</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>CQueryFilter&amp; </type>
                <parameter>filter</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>queryReadoutStatistics</methodname>
        <methodparam>
            <modifier></modifier><type>ReadoutStatDict&amp; </type>
                <parameter>result</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>CQueryFilter&amp; </type>
                <parameter>filter</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    
    // public data structures:
public:
    typedef struct _LogRecord {
       unsigned    s_id;
       std::string s_severity;
       std::string s_application;
       std::string s_source;
       std::time_t s_timestamp;
       std::string s_message;
    } LogRecord, *pLogRecord;
    
    typedef struct _RingBuffer {
        unsigned    s_id;
        std::string s_fqname;
        std::string s_name;
        std::string s_host;
    } RingBuffer, *pRingBuffer;
    
    // Needs copy construction/assignment and comparison.
    
    typedef struct _RingClient {
        unsigned     s_id;
        pid_t        s_pid;
        bool         s_isProducer;
        std::string  s_command;
    } RingClient, *pRingClient;
    
    typedef struct _RingStatistics {
        unsigned     s_id;
        time_t       s_timestamp;
        uint64_t     s_operations;
        uint64_t     s_bytes;
        uint64_t     s_backlog;
    } RingStatistics, *pRingSatistics;
    
    // Rings and client:
    
    typedef std::pair&lt;RingBuffer, std::vector&lt;RingClient&gt; &gt; RingAndClients;
    typedef std::map&lt;std::string, RingAndClients&gt; RingDirectory;
    
    // Rings, clients and statistics:
    
    typedef std::pair&lt;RingClient, std::vector&lt;RingStatistics&gt; &gt; RingClientAndStats;
    typedef std::pair&lt;RingBuffer, std::vector&lt;RingClientAndStats&gt; &gt; RingsAndStatistics;
    typedef std::map&lt;std::string, RingsAndStatistics&gt; CompleteRingStatistics;
    
    // Result struct for state transitions:
    
    typedef struct _StateApp {
        unsigned      s_id;
        std::string   s_appName;
        std::string   s_appHost;

    } StateApp, *pStateApp;

    typedef struct _StateTransition {
        StateApp    s_app;
        unsigned    s_appId;
        unsigned    s_transitionId;                 
        time_t      s_timestamp;
        std::string s_leaving;
        std::string s_entering;
    } StateTransition, *pStateTransition;
    
    // Readout statistics structs:
    
    typedef StateApp ReadoutApp, *pReadoutApp;    // For now identical.
    typedef struct _RunInfo {
        unsigned   s_id;
        uint64_t   s_startTime;
        uint32_t  s_runNumber;
        std::string s_runTitle;

    } RunInfo, *pRunInfo;
    
    typedef std::pair&lt;ReadoutApp, std::vector&lt;RunInfo&gt; &gt; ApplicationRun, *pApplicationRun;
    typedef std::map&lt;unsigned, ApplicationRun&gt; RunDictionary, *pRunDictionary;

        typedef struct _ReadoutStatistics {
        unsigned      s_id;
        time_t        s_timestamp;
        unsigned      s_elapsedTime;
        uint64_t      s_triggers;
        uint64_t      s_events;
        uint64_t      s_bytes;
        
    } ReadoutStatistics, *pReadoutStatistics;
    typedef std::pair&lt;RunInfo, std::vector&lt;ReadoutStatistics&gt; &gt; RunStatistics;
    typedef std::pair&lt;ReadoutApp, std::vector&lt;RunStatistics&gt; &gt;  ReadoutAppStats;
    typedef std::map&lt;unsigned, ReadoutAppStats&gt; ReadoutStatDict, *pReadoutStatDict;

};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The NSCLDAQ status distribution system can log all status messages in
        an Sqlite3 database.   This class provides an API to a database that
        contains the status message schema. The API supports the Creation
        and Retrieval part of CRUD (Create, Retrieve, Update, Delete) only.  The
        assumption is that status data are immutable.  Once entered they can
        neither be changed nor destroyed.
     </para>
     <para>
        In <literal>METHODS</literal> below the methods of the API are decscribed.
        In <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal> The API data
        types are decribed.  Note that internally the API makes use of
        transactions to ensure database consistency.  In the future, the
        API will export <literal>SAVEPOINT</literal>s which are a form of
        nested transaction.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <para>
        Note that the query methods in the list below can filter the result set
        using the filtering objects that are defined in <filename>CSqliteWhere.h</filename>.
        The query method definitions describe the fields that can be used
        to construct filters for the query.  Note as well that the
        <filename>CSqliteWhere.h</filename> header defines an object
        <varname>DAQ::acceptAll</varname> that matches all records.
     </para>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CStatusDb</methodname>
                   <methodparam>
                     <modifier>const </modifier><type>char* </type>
                         <parameter>dbSpec</parameter>
                   </methodparam>
                   <methodparam>
                     <modifier></modifier><type>int</type>
                         <parameter> flags</parameter>
                   </methodparam>
                   <exceptionname></exceptionname>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    The constructor connects to a database. <parameter>dbSpec</parameter>
                    specifies the database file to be used.  <parameter>flags</parameter>
                    is a bitwise or of a set of flag values defined in the
                    <classname>CSqlite</classname> class that govern exactly how
                    the database is opened or created.
                </para>
                <para>
                    If the database is opened writable, or created, the
                    tables and indices needed by the API are transparently
                    created by this method.  Any existing tables are not
                    modified either in form or content.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>insert</methodname>
                    <methodparam>
                     <modifier></modifier><type>std::vector&lt;zmq::message_t*&gt;&amp; </type>
                         <parameter>message</parameter>
                    </methodparam>
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Given a status message that consists of the message part
                    in <parameter>message</parameter>, determines the
                    message type and inserts that message into the database.
                    If the message type is illegal or determined to be malformed,
                    <classname>std::length_error</classname> (not enough message
                    segments) or <classname>std::invalid_argument</classname>
                    is thrown.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>addRingStatistics(
                    </methodname>
                    <methodparam>
                     <modifier></modifier><type>uint32_t </type>
                         <parameter>severity </parameter>
                    </methodparam>
                    <methodparam>
                     <modifier>const </modifier><type>char* </type>
                         <parameter>app</parameter>
                    </methodparam>
                    <methodparam>
                     <modifier>const </modifier><type>char* </type>
                         <parameter>src</parameter>
                    </methodparam>
                    <methodparam>
                     <modifier>const </modifier><type>CStatusDefinitions::RingStatIdentification&amp; </type>
                         <parameter>ringId</parameter>
                    </methodparam>
                    <methodparam>
                     <modifier>const </modifier><type>std::vector&lt;const CStatusDefinitions::RingStatClient*&gt;&amp; </type>
                         <parameter>clients</parameter>
                    </methodparam>
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Inserts a set of ring statistics into the database.  Ring
                    statistics messages may have information about more than
                    one consumer.  Thus this method may create more than one
                    statistics entry.
                </para>
                <para>
                    Severity is one of <classname>CStatusDefinitions::SeverityLevels</classname>
                    and describes the severity level of the message.  As ring statistics
                    are informative in nature, this should normally be
                    <literal>CStatusDb::SeveritLevels::INFO</literal>.
                    Note that at present, the severity level for this sort of
                    message is not retained in the database.
                </para>
                <para>
                    <parameter>app</parameter>, and <parameter>src</parameter>
                    identify the application and host that emitted this message.
                    <parameter>src</parameter> will be a fully qualified
                    domain name (e.g. not <literal>charlie</literal> but
                    <literal>charlie.nscl.msu.edu</literal>).
                </para>
                <para>
                    ringId describes the ringbuffer for which statistics are
                    being provided.  See the documentation for
                    <classname>CStatusDefinitions</classname>
                    for
                    information about the fields in this struct.
                </para>
                <para>
                    <parameter>clients</parameter> is a vector that describes
                    the clients and counters of operations, bytes and backlog
                    at the time the message was emitted.  See the
                    <classname>CStatusDefinitions</classname> documentation for
                    more about the field in this struct.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>addStateChange</methodname>
                     <methodparam>
                         <modifier></modifier><type>uint32_t </type>
                             <parameter>severity</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char* </type>
                             <parameter>app</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char* </type>
                             <parameter>src</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>int64_t  </type>
                             <parameter>tod</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char* </type>
                             <parameter>from</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char* </type>
                             <parameter>to</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Adds a state change message to the database.  State change
                    message describe changes in run state performed by components
                    of the experiment that participate in global state changes.
                    For example, at the start of a run, each Readout program
                    will first transition to <literal>Beginning</literal> and
                    then to <literal>Active</literal> in order to first prepare
                    to and then actually start taking data.
                </para>
                <para>
                    <parameter>severity</parameter> should be one of the values
                    in <classname>CStatusDefinitions::SeverityLevels</classname>.
                    Normally the proper value for this parameter is
                    <literal>CStatusDefinitions::SeverityLevels::INFO</literal>
                    as these are merely informative messages.  
                </para>
                <para>
                    <parameter>app</parameter> and <parameter>src</parameter>
                    identify the application and host from which this message
                    was issued.
                </para>
                <para>
                    <parameter>tod</parameter> is the <function>time(2)</function>
                    at which the message was emitted.
                </para>
                <para>
                    <parameter>from</parameter> is the state that is being left.
                </para>
                <para>
                    <parameter>t</parameter> is the state being entered.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>addReadoutStatistics</methodname>
                     <methodparam>
                         <modifier></modifier><type>uint32_t </type>
                             <parameter>severity</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char* </type>
                             <parameter>app</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char* </type>
                             <parameter>src</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>int64_t </type>
                             <parameter>startTime</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>uint32_t </type>
                             <parameter>runNumber</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char*</type>
                             <parameter> title</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>CStatusDefinitions::ReadoutStatCounters* </type>
                             <parameter>pCounters</parameter><initializer>NULL</initializer>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Adds information from a readout statistics  message to the
                    database. 
                </para>
                <para>
                    <parameter>severity</parameter> is the message severity.
                    This should be a value from
                    <classname>CStatusDefinitions::SeverityLevels</classname> and
                    is normally
                    <literal>CStatusDefinitions::SeverityLevels::INFO</literal>.
                </para>
                <para>
                    <parameter>app</parameter> and <parameter>src</parameter>
                    identify the application and host from which the message came.
                </para>
                <para>
                    <parameter>startTime</parameter> is the <function>time(2)</function>
                    at which the run being described began.
                </para>
                <para>
                    <parameter>runNumber</parameter> is the number of the run
                    these statistics describe.
                </para>
                <para>
                    <parameter>title</parameter> is the title of the run.
                </para>
                <para>
                    If supplied, <parameter>pCounters</parameter> points to
                    the counter information to be entered.  See the
                    docs for <classname>CStatusDefinitions</classname> for
                    information on the contents of a <classname>CStatusDefinitions::ReadoutStatCounters></classname>
                    struct.
                </para>
                <para>
                    If <parameter>pCounters</parameter> is omitted or a null pointer,
                    The readout application and run information are entered in the
                    database if they are not already known.   Please note thtat
                    runs are a per application thing.  Thus the statistics
                    for a global run are made up of the statistics from
                    all the component applications.
                </para>
            </listitem>
        </varlistentry>         
        <varlistentry>
            <term>
                <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>addLogMessage</methodname>
                     <methodparam>
                         <modifier></modifier><type>uint32_t </type>
                             <parameter>severity</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char* </type>
                             <parameter>app</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char* </type>
                             <parameter>src</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>int64_t  </type>
                             <parameter>time</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const </modifier><type>char* </type>
                             <parameter>message</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
                 
            </term>
            <listitem>
                <para>
                    Adds a log message to the database.  Log messagse are simple
                    text messages with a source and a severity level that
                    indicates how bad the condition was that required the
                    log message.
                </para>
                <para>
                    <parameter>severity</parameter> indicates the severity of
                    the condition being logged.  This should be one of the
                    <classname>CStatusDefinitions::SeverityLevels</classname>
                    values.  
                </para>
                <para>
                    <parameter>app</parameter> and <parameter>src</parameter>
                    identify the application and the host from which the
                    message was emitted.
                </para>
                <para>
                    <parameter>time</parameter> is the unix time
                    (<function>time(2)</function>) at which the message was
                    emitted. This value can be turned into a human readable
                    time via e.g. <function>ctime(3)</function> and its
                    related functions.
                </para>
                <para>
                    <parameter>message</parameter> is the message string to log.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>queryLogMessages</methodname>
                     <methodparam>
                         <modifier></modifier><type>std::vector&lt;LogRecord&gt;&amp; </type>
                             <parameter>result</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>CQueryFilter&amp; </type>
                             <parameter>filter</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector of log messages that match the <parameter>filter</parameter>
                    condition.  The matching messages are appended to the
                    <parameter>result</parameter> (passed by reference).
                </para>
                <para>
                    The following fields can be used in the filter:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>id</literal></term>
                        <listitem>
                            <para>
                                An integer primary key of the log message.
                                Log messages are currently stored in a single
                                table.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>severity</literal></term>
                        <listitem>
                            <para>
                                The textual equivalent of the severity level
                                of the message.  The text equivalent is just the
                                last section of the name of the severity level,
                                for example
                                <literal>CStatusDefinitions::SeverityLevels::WARNING</literal>
                                has a string equivalent of <literal>WARNING</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>application</literal></term>
                        <listitem>
                            <para>
                                The name of the application that emitted the message
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>source</literal></term>
                        <listitem>
                            <para>
                                The fully qualified domain name of the host
                                that emitted the log message.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>timestamp</literal></term>
                        <listitem>
                            <para>
                                The integer timestamp value.
                                <function>ctime(3)</function> e.g. can be used
                                to create a human readable version of this.
                                <function>strptime(3)</function> and
                                <function>mktime(3)</function> can be used to
                                convert a human readable time into a compatible
                                value.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>message</literal></term>
                        <listitem>
                            <para>
                                The text if the log message.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>         
        <varlistentry>
            <term>
                <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>listRings</methodname>
                     <methodparam>
                         <modifier></modifier><type>std::vector&lt;RingBuffer&gt;&amp; </type>
                             <parameter>result</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>CQueryFilter&amp; </type>
                             <parameter>filter</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Creates a vector that describes the set of ring buffers that
                    satisfy the <parameter>filter</parameter> condition.
                    The result set is appended to the <parameter>result</parameter>
                    vector (passed in by reference).
                    See <literal>PUBLIC VARIABLES, TYPES AND CONSTANTS</literal>
                    below for a description of the <type>CStatusDb::RingBuffer</type>
                    data type.
                </para>
                <para>
                    The filter can be constructed from the following database
                    fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>r.id</literal></term>
                        <listitem>
                            <para>
                                The integer primary key of the ring buffer definition
                                record in its table.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>r.name</literal></term>
                        <listitem>
                            <para>
                                Name of the ring buffer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>r.host</literal></term>
                        <listitem>
                            <para>
                                Host in which the ring buffer 'lives'.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>r_fqname</literal></term>
                        <listitem>
                            <para>
                                This is a 'synthetic' field that is generated
                                by stringing together the ring name and the hostname
                                separated by an <literal>@</literal> symbol.
                                For example, a ring named <literal>fox</literal>
                                in the host <literal>charlie.nscl.msu.edu</literal>
                                will have a <literal>r_fqname</literal> of
                                <literal>fox@charlie.nscl.msu.edu</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                     <modifier></modifier>
                     <type>void listRingsAndClients</type>
                     <methodname></methodname>
                     <methodparam>
                         <modifier></modifier><type>RingDirectory&amp; </type>
                             <parameter>result</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>CQueryFilter&amp; </type>
                             <parameter>filter</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Lists the ringbuffers and the clients that have attached
                    to them that match the <parameter>filter</parameter>
                    criteria.  The result is merged into the
                    <type>RingDirectory</type> which is described in
                    <literal>PUBLIC VARIABLES, TYPES AND CONSTANTS</literal> below.
                </para>
                <para>
                    The <parameter>filter</parameter> object can be
                    constructed from all of the fields described in
                    <methodname>listRings</methodname> above and the following
                    additional fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>c.id</literal></term>
                        <listitem>
                            <para>
                                The primary key of a client in its table in the
                                database.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>c.pid</literal></term>
                        <listitem>
                            <para>
                                The process id of the client in the ring buffer's
                                host
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>c.producer</literal></term>
                        <listitem>
                            <para>
                                A boolean that nonzero if this client is/was a
                                producer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>c.command</literal></term>
                        <listitem>
                            <para>
                                The command string used to start the client.
                                Note that these are the command words in the
                                command with a single space between each word.
                                Thus, for example, the command:
                                <command>dumper     --source=tcp://localhost/fox</command>,
                                will be stored in the database as
                                <literal>dumper --source=tcp://localhost/fox</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>queryRingStatistics</methodname>
                     <methodparam>
                         <modifier></modifier><type>CompleteRingStatistics&amp; </type>
                             <parameter>result</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>CQueryFilter&amp; </type>
                             <parameter>filter</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the ringbuffers, clients and transfer statistics
                    records that match the <parameter>filter</parameter>.  These
                    are merged into the <parameter>result</parameter> value
                    See
                    <literal>PUBLIC VARIABLES, TYPES AND CONSTANTS</literal> below
                    for a description of the <type>CStatusDb::CompleteRingStatistics</type>
                    data type.
                </para>
                <para>
                    The <parameter>filter</parameter> can be constructed using any
                    of the fields from <methodname>listRingsAndClients</methodname>
                    in addition to any of the fields below:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>s.id</literal></term>
                        <listitem>
                            <para>
                                The integer primary key of a statistics entry in
                                the ring statistics table.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s.timestamp</literal></term>
                        <listitem>
                            <para>
                                A timestamp that defines when the record was
                                emitted.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s.operations</literal></term>
                        <listitem>
                            <para>
                                A number of operations performed.  For producers,
                                this is the number of ring items put into the ring.
                                For consumers, this is the number of ring items
                                that have been removed from the ring.
                            </para>
                            <para>
                                Please note that this and all counters are counts
                                from the time the client attached to the ring
                                buffer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s.bytes</literal></term>
                        <listitem>
                            <para>
                                Then number of bytes that were transferred
                                in (producer) or out (consumer) of the
                                client.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s.backlog</literal></term>
                        <listitem>
                            <para>
                                This can only be non-zero for consumers.
                                This represents the number of bytes that are
                                available for the consumer (backlogged in
                                the ring buffer).   Once the backlog gets to be
                                the same as the ring buffer size, back pressure
                                flow control will halt the transfer of data into the
                                ring until space is available.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                 <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>listStateApplications</methodname>
                     <methodparam>
                         <modifier></modifier><type>std::vector&lt;StateApp&gt;&amp; </type>
                             <parameter>result</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>CQueryFilter&amp; </type>
                             <parameter>filter</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Produces a vector of state application descriptions
                    that satisfy the <parameter>filter</parameter>.  State applications
                    are applications that emit state transition status messages.
                    These are defined by an application name and the host they
                    run in.
                </para>
                <para>
                    The resulting descriptions are appended to <parameter>result</parameter>
                    which was passed in by reference. See
                    <literal>PUBLIC VARIABLES, TYPES AND CONSTANTS</literal> for
                    a description of the <type>CStatusDb::StateApp</type>
                    data type.
                </para>
                <para>
                    <parameter>filter</parameter> can make use of any of the
                    following fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>a.id</literal></term>
                        <listitem>
                            <para>
                                Integer primary key of the record that contains
                                a state application.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>a.name</literal></term>
                        <listitem>
                            <para>
                                Name of the application.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>a.host</literal></term>
                        <listitem>
                            <para>
                                The host on which the application runs.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                 <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>queryStateTransitions</methodname>
                     <methodparam>
                         <modifier></modifier><type>std::vector&lt;StateTransition&gt;&amp; </type>
                             <parameter>result</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>CQueryFilter&amp; </type>
                             <parameter>filter</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Gets information about the state transitions and the
                    applications that performed them.  Only those transitions
                    that satisfy the <parameter>filter</parameter> parameter are
                    returned.
                </para>
                <para>
                    Matching data are appended to the <parameter>result</parameter>.
                    See
                    <literal>PUBLIC VARIABLES, TYPES AND CONSTANTS</literal>
                    below for a description of the <type>CStatusDb::StateTransition</type>
                    type.
                </para>
                <para>
                    The <parameter>filter</parameter> may use any of the fields
                    described for <methodname>listStateApplications</methodname>
                    as well as the additional fields below:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>t.id</literal></term>
                        <listitem>
                            <para>
                                Primary key of the state transition part of the
                                data.  This is an integer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>t.app_id</literal></term>
                        <listitem>
                            <para>
                                The primary key of an application that is stored
                                in the state transition part of the data to relate
                                it back to the application that emitted the
                                transition (foreign key in RDBMS parlance).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>t.timestamp</literal></term>
                        <listitem>
                            <para>
                                The <function>time(2)</function> at which this
                                state transition status message was emitted.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>t.leaving</literal></term>
                        <listitem>
                            <para>
                                Name of the state being left as a result of the
                                transition.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>t.entering</literal></term>
                        <listitem>
                            <para>
                                Name of the state being entered as a result of the
                                transition.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>listReadoutApps</methodname>
                     <methodparam>
                         <modifier></modifier><type>std::vector&lt;ReadoutApp&gt;&amp; </type>
                             <parameter>result</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>CQueryFilter&amp; </type>
                             <parameter>filter</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Produces a list of the applications that have emitted
                    acquisition run or readout statistics information that match
                    the <parameter>filter</parameter>.  The resulting information
                    is appended to the <parameter>result</parameter> vector.
                    See <literal>PUBLIC VARIABLES, TYPES AND CONSTANTS</literal>
                    for a description of the
                    <type>CStatusDb::ReadoutApp</type> data type.
                </para>
                <para>
                    The filter can be constructed using the following fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>a.id</literal></term>
                        <listitem>
                            <para>
                                Integer primary key of the record that contains
                                a readout application.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>a.name</literal></term>
                        <listitem>
                            <para>
                                Name of the application.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>a.host</literal></term>
                        <listitem>
                            <para>
                                The host on which the application runs.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                 <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>listRuns</methodname>
                     <methodparam>
                         <modifier></modifier><type>RunDictionary&amp;</type>
                             <parameter> result</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>CQueryFilter&amp; </type>
                             <parameter>filter</parameter>
                     </methodparam>
                     <exceptionname></exceptionname>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Lists the set of data taking runs initiated by each
                    readout program.  Note that for the purposes of readout statistics,
                    each readout program initiates runs independently of all others.
                    Other than while setting up, this is not the normal way to run,
                    but it provides a simple model to trace back counters to
                    both the run and the readout program that created it.
                </para>
                <para>
                    Only the runs/programs that satisfy the <parameter>filter</parameter>
                    are added to the <parameter>result</parameter>.  
                </para>
                <para>
                    The <parameter>filter</parameter> can be constructed from
                    the fields that are described by
                    <methodname>listReadoutApps</methodname> as well as the
                    additional fields below:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>r.id</literal></term>
                        <listitem>
                            <para>
                                The primary key of a run description in its table.
                                This is a sequentially assigned integer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>r.start</literal></term>
                        <listitem>
                            <para>
                                The <function>time(2)</function> at which the
                                run began.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>r.run</literal></term>
                        <listitem>
                            <para>
                                The number of the run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>r.title</literal></term>
                        <listitem>
                            <para>
                                The run title.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                 <methodsynopsis>
                     <modifier></modifier>
                     <type>void </type>
                     <methodname>queryReadoutStatistics</methodname>
                     <methodparam>
                         <modifier></modifier><type>ReadoutStatDict&amp; </type>
                             <parameter>result</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier></modifier><type>CQueryFilter&amp; </type>
                             <parameter>filter</parameter>
                     </methodparam>
                     <modifier></modifier>
                 </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the readout application, associated runs and
                    readout statistics that satisfy the <parameter>filter</parameter>
                    object's conditions. Data are merged into the
                     <parameter>result</parameter> which is passed by
                     reference.
                     See <literal>PUBLIC VARIABLES, TYPES AND CONSTANTS</literal>
                     for a description of the <type>CStatusDb::ReadoutStatDict</type>.
                </para>
                <para>
                    The <parameter>filter</parameter> can be constructed using
                    the fields available to <methodname>listRuns</methodname>
                    as well as the following additional fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>s.id</literal></term>
                        <listitem>
                            <para>
                                The primary key (integer) of a statistics entry.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s.timestamp</literal></term>
                        <listitem>
                            <para>
                                The <function>time(2)</function> at which
                                a statistics entry was emitted.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s.elapsedtime</literal></term>
                        <listitem>
                            <para>
                                The number of seconds into the associated run at
                                which a statistics entry was emitted.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>,<literal>s.triggers</literal></term>
                        <listitem>
                            <para>
                                The total number of triggers the program responded
                                to at the point of the run at which the
                                status message was emitted.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s.events</literal></term>
                        <listitem>
                            <para>
                                The total number of events emitted by the readout
                                program.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>s.bytes</literal></term>
                        <listitem>
                            <para>
                                The total number of bytes of data emitted by
                                the application.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
                

     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        The <classname>CStatusDb</classname> class defines quite a few nested
        data types.  These data types are used to return result sets from the
        query methods.  Some of these data types can be quite complex but it is
        necessary to understand them in order to be able to extract data from
        them.
      </para>
      <para>
        The subsections of this section will describe data structures used
        returned by each of the query families.
      </para>
      <refsect2>
        <title>Log messages</title>
        <para>
            Log messages are very simple.  An application running in some host
            emits some message.  The message has a severity, text and a timestamp
            that tells consumers when it was emitted.
        </para>
        <para>
            <methodname>queryLogMessages</methodname> is the only query method
            for log messages an it produces an
            <type>std::vector&lt;CStatusDb::LogRecord&gt;</type>.  Each element
            of the vector is as a <structname>CStatusDb::LogRecord</structname>
            struct that has the following fields:
        </para>
        <variablelist>
            <varlistentry>
                <term><type>unsigned</type> <structfield>s_id</structfield></term>
                <listitem>
                    <para>
                        The primary key of the record represented by this
                        item.  In the schema for the status database, every table
                        has an integer field named <literal>id</literal>.  The
                        value of that field is assigned by the database to be
                        a unique, sequential integer as new records are inserted.
                    </para>
                    <para>
                        Some tables, may have values that are the <literal>id</literal>
                        value from some other related table.  These are called
                        foreign keys and allow  one to describe relationships
                        between records in separate tables without needing to
                        duplicate data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type> <structfield>s_severity</structfield></term>
                <listitem>
                    <para>
                        The stringified severity code.
                        In <filename>CStatusMessage.h</filename>, see the functions
                        <function>CStatusDefinitions::stringToSeverity</function>
                        which turns a severity string into a severity code, and
                        the inverse function
                        <function>CStatusDefinitions::severityToString</function>
                        which, given a severity code returns the corresponding
                        severity string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>std::string</type> <structfield>s_application</structfield>
                </term>
                <listitem>
                    <para>
                        Contains the name of the application that emitted the
                        log message. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_source</structfield></term>
                <listitem>
                    <para>
                        Contains the fully qualified domain name of the host from
                        which the log message was emitted.  The application name
                        combined with the hostname are assumed to be unique
                        system wide for an experiment.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::time_t </type><structfield>s_timestamp</structfield></term>
                <listitem>
                    <para>
                        This is the value the <function>time(2)</function>
                        function returned at the time the message was being
                        generated.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_message</structfield></term>
                <listitem>
                    <para>
                        Contains the log message itself.
                    </para>
                </listitem>
            </varlistentry>
                   
        </variablelist>
      </refsect2>
      <refsect2>
        <title>Ring Buffer Statistic queries</title>
        <para>
            Ring buffers statistics have three classes of data associated
            with them.  The first identifies the ring buffer itself.  The
            second a client, which can be a consumer or a producer.  Finally,
            these queries must provide the actual transfer counters.
        </para>
        <para>
            Queries whose result sets provide several types of these objects must
            provide them in structures that preserve the proper relationship
            between those objects.  In thinking about these data and the
            structures that tie them together it's useful to remember that:
        </para>
        <orderedlist>
            <listitem><para>
                The system can have several ring buffers that are distributed
                across several systems.  Note that proxy ringbuffers are treated
                as any other ring buffers by the statistics system.
            </para></listitem>
            <listitem><para>
                Each ringbuffer can have zero or more clients.  At most one of
                those clients can be the producer, all other clients consume
                data from the ring buffer.
            </para></listitem>
            <listitem><para>
                Each client will have zero or more statistics entries as statistics
                are periodically compiled and transmitted.
            </para></listitem>
        </orderedlist>
        <para>
            Let's start by looking at the simple, non-aggregate data structures.
        </para>
        <para>
            <structname>RingBuffer</structname> identifies a ring buffer.
            It has the following fields:
        </para>
        <variablelist>
            <varlistentry>
                <term><type>unsigned </type><structfield>s_id</structfield></term>
                <listitem>
                    <para>
                        RingBuffer identification is held in a separate table
                        in the database.  This field of the struct is the
                        primary key value of the record in the database that
                        produced the instance of this struct.  This field is
                        assigned a value by the database and is a sequentially
                        incrementing unsigned integer that numbers from
                        .<literal>1</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string</type><structfield>  s_name</structfield></term>
                <listitem>
                    <para>
                        Contains the name of a ring buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_host</structfield></term>
                <listitem>
                    <para>
                        Contains the host in which the ring buffer lives.  Note
                        that proxy rings for this ringbuffer have names of
                        the form
                        <replaceable>remotering</replaceable>@<replaceable>remotehost</replaceable>.
                        This form of the ring name is different than that of
                        nscldaq versions prior to 12.0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_fqname</structfield></term>
                <listitem>
                    <para>
                        This is the <firstterm>fully qualified ring name</firstterm>.
                        The fully qualified name of a ring is
                        <replaceable>ringname</replaceable>@<replaceable>host</replaceable>.
                        For example a ring named <literal>fox</literal> in the
                        host <literal>charlie.nscl.msu.edu</literal> will have
                        a fully qualified ring name of
                        <literal>fox@charlie.nscl.msu.edu</literal>
                    </para>
                    <para>
                        This field is a synthetic field.  Synthetic fields don't
                        actually get stored in the database but are generated
                        by the query itself from other fields.
                    </para>
                    <para>
                        Note that proxy ring fully qualified names will have two
                        <literal>@</literal> symbols in their names.  For
                        example, the proxy ring in spdaq20 for
                        <literal>fox@charlie.nscl.msu.edu</literal> will have
                        a fully qualified name
                        <literal>fox@charlie.nscl.msu.edu@spdaq20.nscl.msu.edu</literal>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The <structname>RingClient</structname> struct describes the client
            of a ring. It normally does not appear in isolation but in compound
            data structures that include both a <structname>RingBuffer</structname>
             and one or more <structname>RingClient</structname> structs.
             This is the case because clients have no meaning without a ringbuffer
             for which they either produce or consume data.
        </para>
        <para>
            <structname>RingClient</structname> has the fields described below:
        </para>
        <variablelist>
            <varlistentry>
                <term><type>unsigned </type><structfield>s_id</structfield></term>
                <listitem>
                    <para>
                        The primary key of the record in the ring clients table
                        that created this instance of a
                        <structname>RingClient</structname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>pid_t </type><structfield>s_pid</structfield></term>
                <listitem>
                    <para>
                        The process if of the consumer.  Note that over time
                        systems re-use process ids, however this software
                        assumes that the pid is unique over the life of an
                        experiment.
                    </para>
                    <para>
                        Note as well, that this struct only describes producers
                        and consumers in the same host as the ring for which
                        they are clients.  Remote clients are listed as clients
                        of the proxy ring. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>bool </type><structfield>s_isProducer</structfield></term>
                <listitem>
                    <para>
                        This is <literal>true</literal> if the client is a producer.
                        A ring can have at most one producer client.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_command</structfield></term>
                <listitem>
                    <para>
                        The command string used to start the consumer.  Note
                        that if the command was run from within a script the
                        command in the script is given, not the scripname.
                    </para>
                    <para>
                        The command is a string containing the words that make
                        up the command, each separated by a single space.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The <structname>RingStatistics</structname> struct contains the
            actual counters associated at a specific point in time, associated
            with a client and its ring buffer.  It has the following fields:
        </para>
        <variablelist>
            <varlistentry>
                <term><type>unsigned </type><structfield>s_id</structfield></term>
                <listitem>
                    <para>
                        The primary key of the record in the statistics table
                        that was used to populate this instance of the
                        <structname>RingStatistics</structname> struct.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>time_t </type><structfield>s_timestamp</structfield></term>
                <listitem>
                    <para>
                        The value returned from <function>time(2)</function>
                        at the time the message containing these statistics
                        was being created.  Note that since the statistics are
                        all totals, computation of rates requires these timestamps.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>uint64_t </type><structfield>s_operations</structfield></term>
                <listitem>
                    <para>
                        The total number of operations performed by the
                        associated clients.  If the client is a producer of
                        ring items, this will be the total number of ring items
                        put to the ring by that producer.  If the client is
                        a consumer of ring items,
                        this will be the total number of ring items gotten from the
                        ring by the client.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>uint64_t </type><structfield>s_bytes</structfield></term>
                <listitem>
                    <para>
                        The total number of bytes transferred into or out of the
                        ringbuffer by the client.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>uint64_t </type><structfield>s_backlog</structfield></term>
                <listitem>
                    <para>
                        The number of bytes of backlog for consumers.  For
                        producers this will always be zero.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            In addition to these simple types there are composite types that
            tie together simple data types into a coherent whole.  The remainder of
            this section describes those data types and what they contain.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <type>typedef std::pair&lt;RingBuffer, std::vector&lt;RingClient&gt; &gt; RingAndClients;</type>
                </term>
                <listitem>
                    <para>
                        The second element of the pair is a vector of the descriptions
                        of all of the clients for the first element of the pair.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>typedef std::map&lt;std::string, RingAndClients&gt; RingDirectory;</type>
                </term>
                <listitem>
                    <para>
                        The keys to this map are the fully qualified name
                        of rings.  The contents are a pair that contains a
                        description of the ring and  a vector of known
                        ring clients.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>typedef std::pair&lt;RingClient, std::vector&lt;RingStatistics&gt; &gt; RingClientAndStats;</type>
                </term>
                <listitem>
                    <para>
                        The first element of this pair describes a ring buffer client.
                        The second element is a vector of statistics for that
                        client.  Each element of that vector represents the
                        transfer counters at some point in time.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>typedef std::pair&lt;RingBuffer, std::vector&lt;RingClientAndStats&gt; &gt; RingsAndStatistics;</type>
                </term>
                <listitem>
                    <para>
                        The first element of this pair describes a ring.  The
                        second is a vector of client descriptions along with
                        a vector of statistics records for that client on
                        that ringbuffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>typedef std::map&lt;std::string, RingsAndStatistics&gt; CompleteRingStatistics;</type>
                </term>
                <listitem>
                    <para>
                        The map is keyed by the fully qualified ring name.
                        The contents of each key is the ring, the clients and
                        associated statitics
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
      </refsect2>
      <refsect2>
        <title>State Transition queries</title>
        <para>
            State transitions represent an application performing part of a
            DAQ global state change in the run control system.  This implies
            that a state transition is performed by an application.  That
            application may undergo many state transitions.
        </para>
        <para>
            Only simple data types are defined.  Application definition is
            light enough weight that when we need to associate emitting
            applications with transitions the emitting program is bundled in
            with the transition record.
        </para>
        <para>
            State transitions are emitted by applications.  The
            <structname>StateApp</structname> struct describes an application
            that can emit state transitions:
        </para>
        <variablelist>
            <varlistentry>
                <term><type>unsigned </type><structfield>s_id</structfield></term>
                <listitem>
                    <para>
                        This is the primary key of the state application record
                        that was used to populate the struct.  Primary keys
                        are unique integer values that are assigned to
                        records in a table.  By declaring the status database
                        primary keys to be integer auto incrementing, this
                        system allows the database to assign sequential
                        incrementing keys (numbered from 1) as record
                        primary keys.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_appName</structfield></term>
                <listitem>
                    <para>
                        Contains the name of an applicationt that can emit
                        state transitions.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_appHost</structfield></term>
                <listitem>
                    <para>
                        Contains the host in which the application is running.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            State transitions themselves are loaded into
            <structname>StateTransition</structname> structs.  These structs
            have the following fields:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <type>StateApp </type><structfield>s_app</structfield>
                </term>
                <listitem>
                    <para>
                        This defines the application that emitted the transition
                        described by the remainder of the struct.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>unsigned </type><structfield>s_appId</structfield></term>
                <listitem>
                    <para>
                        This is the primary key of the state program that
                        created this transition.  It should be the same as
                        <structfield>s_app.s_id</structfield>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>unsigned </type><structfield>s_transitionId</structfield></term>
                <listitem>
                    <para>
                        The primary key of the transition record used to stock
                        the struct.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>time_t </type><structfield>s_timestamp</structfield></term>
                <listitem>
                    <para>
                        Contains the value of <function>time(2)</function>
                        at the time the transition was logged.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_leaving</structfield></term>
                <listitem>
                    <para>
                        Contains the name of the state being exited due to
                        the state transition.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_entering</structfield></term>
                <listitem>
                    <para>
                        Contains the name of the state being entered as a result
                        of the state transition.
                    </para>
                </listitem>
            </varlistentry> 
        </variablelist>
      </refsect2>
      <refsect2>
        <title>Readout Statistics</title>
        <para>
            Readout statistics are counters that are maintained by applications
            that generate data.   Readout programs are applications.  Each
            application produces several data taking runs.  Each of those
            runs has several periodically emitted statistics records.
        </para>
        <para>
            We start by looking at the simple types that
            represent data in the readout statistics system.
        </para>
        <para>
            <structname>ReadoutApp</structname> is a readout application.
            At this point in time, this is an alias for a
            <structname>StateApp</structname> as the data both types of
            applications have is identical.  Refer to the state transition
            section for information about the fields this struct has.
        </para>
        <para>
            Each readout program can create data taking runs.  Data taking
            runs are described by the <structname>RunInfo</structname>
            data structure.  This struct has the following fields.
        </para>
        <variablelist>
            <varlistentry>
                <term><type>unsigned </type><structfield>s_id</structfield></term>
                <listitem>
                    <para>
                        The primary key of the record used to load this
                        struct.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>uint64_t </type><structfield>s_startTime</structfield></term>
                <listitem>
                    <para>
                        The <function>time(2)</function> when the run started.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>uint32_t </type><structfield>s_runNumber</structfield></term>
                <listitem>
                    <para>
                        The run number of the run.  This should be unique
                        across all runs created by a readout program.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::string </type><structfield>s_runTitle</structfield></term>
                <listitem>
                    <para>
                        The title of the run.  This is an arbitrary user assigned
                        string usually used to document the purpose of the run.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The <structname>ReadoutStatistics</structname> struct stores counter
            information for a readout program at some point in time within a run.
            The counters are cumulative however they reset at the start of a new
            run.
        </para>
        <variablelist>
            <varlistentry>
                <term><type>unsigned </type><structfield>s_id</structfield></term>
                <listitem>
                    <para>
                        The primary key of the statistics entry.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>time_t </type><structfield>s_timestamp</structfield></term>
                <listitem>
                    <para>
                        The value returned from <function>time(2)</function>
                        when this statistics record was produced.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>unsigned </type><structfield>s_elapsedTime</structfield></term>
                <listitem>
                    <para>
                        The number of seconds into the run this statistics
                        record was emitted.  Normally, this is the difference
                        between <structfield>s_timestamp</structfield> of this
                        struct and
                        the <structfield>s_startTime</structfield> field of the
                        associated <structname>RunInfo</structname> struct.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>uint64_t </type><structfield>s_triggers</structfield></term>
                <listitem>
                    <para>
                        The number of triggers the application has responded to
                        in this run at this time.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>uint64_t </type><structfield>s_events</structfield></term>
                <listitem>
                    <para>
                        The number of events emitted by this program over the
                        course of the run to this point in time.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>uint64_t </type><structfield>s_bytes</structfield></term>
                <listitem>
                    <para>
                        The number of bytes of data emitted by this application
                        over the course of the run to this point.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            In addition to the simple types described above, several
            compound types capture the relationships between readout applications,
            the runs they initiated and the statistics accumulated during those
            runs.  Note that in the case of the <type>std::map</type> data types
            with <type>unsigned</type> key types, the key is the primary key
            of the application.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <type>typedef std::pair&lt;ReadoutApp, std::vector&lt;RunInfo&gt; &gt; ApplicationRun, *pApplicationRun;</type>
                </term>
                <listitem>
                    <para>
                        <type>ApplicationRun</type> is a pair that associates the
                        first element, a <type>ReadoutApp</type> with the
                        runs that readout application initiated stored as
                        a vector of <type>RunInfo</type> structs in the
                        second element of the pair.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>typedef std::map&lt;unsigned, ApplicationRun&gt; RunDictionary, *pRunDictionary;</type>
                </term>
                <listitem>
                    <para>
                        <type>RunDictionary</type> maintains the association between
                        applications and their runs over several applications.
                        The primary key of the application is used as the
                        key for the <type>std::map</type>.
                    </para>
                </listitem>
            </varlistentry> 
            <varlistentry>
                <term>
                    <type>typedef std::pair&lt;RunInfo, std::vector&lt;ReadoutStatistics&gt; &gt; RunStatistics;</type>
                </term>
                <listitem>
                    <para>
                        This pair associates information about a single run
                        (the first element of the pair)
                        with the readout statistics counters that were
                        accumulated during that run.  The readout
                        statistics are stored as a vector of
                        <type>ReadoutStatistics</type> and is the second
                        element of the pair.
                    </para>
                    <para>
                        Note that runs are a property of a readout application
                        and not shared between those applications.  This
                        allows for the possibility that during the setup of
                        a larger experiment, readout applications might run
                        independently for testing only to be run in lock synch
                        as the experiment approaches production running.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>typedef std::pair&lt;ReadoutApp, std::vector&lt;RunStatistics&gt; &gt;  ReadoutAppStats;</type>
                </term>
                <listitem>
                    <para>
                        This pair associates the readout applications (first element)
                        with the runs it initiates and their associated statistics
                        (second element).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>typedef std::map&lt;unsigned, ReadoutAppStats&gt; ReadoutStatDict, *pReadoutStatDict;</type>
                </term>
                <listitem>
                    <para>
                        Captures several readout programs, their runs and the
                        statistics acquired during those runs.  The map
                        keys are the primary keys of the readout programs.
                    </para>
                </listitem>
            </varlistentry>
    
    
        </variablelist>
      </refsect2>
   </refsect1>
</refentry>     

<!-- /manpage -->

<!-- manpage 3tcl -->

<refentry id="tcl3_statusdb">
  <refentryinfo>
    <author>
            <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
            </personname>
            <personblurb><para></para></personblurb>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='tcl3_statusdb_title'>statusdb</refentrytitle>
     <manvolnum>3tcl</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>statusdb</refname>
     <refpurpose>Tcl bindings to <classname>CStatusDb</classname></refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <literallayout>
        <command>package require statusMessage ?1.0?</command>
        ...
        <command>set object [statusdb create <replaceable>filename</replaceable> ?flag1 ...?]</command>
        <command>statusdb destroy <replaceable>$object</replaceable></command>
        
        <command>$object <replaceable>subcommand ?...?</replaceable></command>
    </literallayout>


  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The <command>statusdb</command> command provides an object oriented
        encapsulation of the <classname>CStatusDb</classname> class.
        For more information about <classname>CStatusDb</classname>,
        see:
        <link linkend="daq3_CStatusDb" endterm="daq3_CStatusDb_title" />.
     </para>
     <para>
        The <command>create</command> subcommand creates a new status database
        API object.  The only required parameter is the filename that contains
        the status database.  The remaining parameters are Sqlite3 flag
        names that modify how the database is opened.  Note that if the database
        is opened with write access  and the schema is not entirely present,
        it is created.
        See <literal>SQLITE3 FLAGS</literal> below for the valid Sqlite3
        flags.  A newly created command ensemble base name is returned.
     </para>
     <para>
        Once the database interface object has been created, subcommands can
        be invoked on it.  See <literal>API SUBCOMMANDS</literal> below
        for a description of the subcommands, their parameters and what they do.
     </para>
     <para>
        Onc the API object is no longer needed it can be passed to the
        <command>statusdb destroy</command> subcommand which will destroy the
        command and release any resources the command required.
     </para>
  </refsect1>
  <refsect1>
    <title>SQLITE3 FLAGS</title>
    <para>
        The sqlite3 flags keyword supported by the <command>create</command>
        subcommand closely parallel the constant name values described in
        <ulink url='https://www.sqlite.org/c3ref/open.html'>
            https://www.sqlite.org/c3ref/open.html
        </ulink>.  See that page for information about what the flags actually
        do.
    </para>
    <para>
        The flags available, and their corresponding SQLITE_OPEN flag values
        are as follows:
    </para>
    <segmentedlist>
        <segtitle>flag</segtitle><segtitle>value</segtitle>
        <seglistitem>
            <seg>nomutex</seg><seg>SQLITE_OPEN_NOMUTEX</seg>
        </seglistitem>
        <seglistitem>
            <seg>fullmutex</seg><seg>SQLITE_OPEN_FULLMUTEX</seg>
        </seglistitem>
        <seglistitem>
            <seg>sharedcache</seg><seg>SQLITE_OPEN_SHAREDCACHE</seg>
        </seglistitem>
        <seglistitem>
            <seg>privatecache</seg><seg>SQLITE_OPEN_PRIVATECACHE</seg>
        </seglistitem>
        <seglistitem>
            <seg>uri</seg><seg>SQLITE_OPEN_URI</seg>
        </seglistitem>
        <seglistitem>
            <seg>readonly</seg><seg>SQLITE_OPEN_READONLY</seg>
        </seglistitem>
        <seglistitem>
            <seg>readwrite</seg><seg>SQLITE_OPEN_READWRITE</seg>
        </seglistitem>
        <seglistitem>
            <seg>create</seg><seg>SQLITE_OPEN_CREATE</seg>
        </seglistitem>
    </segmentedlist>
  </refsect1>
  <refsect1>
     <title>
        API SUBCOMMANDS
     </title>
     <para>
        API objects created by <command>statusdb create</command> have the
        following subcommands:
     </para>
     <para>
        The subcommands below add data to the database either from an undecoded
        message (<command>insert</command>) or from a message that has
        been decoded:
     </para>
     <variablelist>
        <varlistentry>
            <term><command>insert part1...</command></term>
            <listitem>
                <para>
                    Inserts the the database equivalent of an arbitrary status
                    message in the database.  <parameter>part1...</parameter>
                    are the raw message parts gotten from e.g.
                    a <command>receive</command> subcommand on a subscripion
                    object.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>addRingStatistics severity app source ringidDict ?stat1...</command></term>
            <listitem>
                <para>
                    Adds ring statistics information to the database open on the
                    object.  The <parameter>severity</parameter>, <parameter>app</parameter>,
                    <parameter>source</parameter> parameters are the severity
                    application and source strings decoded from the message
                    header.
                </para>
                <para>
                    <parameter>ringidDict</parameter> is the dictionary gotten by decoding
                    a ring id message part.  This contains 
                    <literal>timestamp</literal> and <literal>name</literal>
                    keys which are thetime of the message and the name of
                    the ring this is all about.
                </para>
                <para>
                    The <parameter>stat1...</parameter> optional parameters
                    are ringstatistics dictionaries decoded from ring
                    statistics message parts.  Thes are dicts with the following
                    keys:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>ops</literal></term>
                        <listitem>
                            <para>
                                Number of operations performed by the client.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>bytes</literal></term>
                        <listitem>
                            <para>
                                Number of bytes transferred by the client.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>producer</literal></term>
                        <listitem>
                            <para>
                                True if the client is a producer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>backlog</literal></term>
                        <listitem>
                            <para>
                                Number of bytes backlogged for consumers. For
                                producers, this is always 0.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>pid</literal></term>
                        <listitem>
                            <para>
                                Process id of the client.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>command</literal></term>
                        <listitem>
                            <para>
                                Tcl list of command words that were used to
                                start the client.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <command>addStateChange sev app src timestamp from to</command>
            </term>
            <listitem>
                <para>
                    Logs a state change event in the database.  The
                    <parameter>sev</parameter> parameter is the severity of
                    the message and normally can be <literal>INFO</literal>.
                    The <parameter>app</parameter> and <parameter>src</parameter>
                    parameters describe the application and host emitting the
                    state transition.
                </para>
                <para>
                    <parameter>timestamp</parameter> is the
                    <command>clock seconds</command> value at the time the
                    message was emitted. 
                </para>
                <para>
                    The <parameter>from</parameter> parameter is the state
                    that is being left by the transition.  <parameter>to</parameter>
                    is the state that is being entered by the transition.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <command>addReadoutStatistics sev app src runStartTime runNumber title ?counters?</command>
            </term>
            <listitem>
                <para>
                    Adds the statistics from a Readout program to the database.
                    <parameter>sev</parameter> is the severity and normally is
                    <literal>INFO</literal>. <parameter>app</parameter> and
                    <parameter>src</parameter> identify the application emitting
                    the message and the host it's running on.
                </para>
                <para>
                    <parameter>runStartTime</parameter>, <parameter>runNumber</parameter>
                    and <parameter>title</parameter> identify the run being logged
                    by the start time, the run number and the title of the run.
                </para>
                <para>
                    If the optional <parameter>counters</parameter> parameter is
                    not provided, the command will produce a run number record
                    for the application.  If <parameter>counters</parameter> is
                    present it must be a dict that contains the following keys:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>timstamp</literal></term>
                        <listitem>
                            <para>
                                The <command>clock seconds</command>
                                at which the statistics were emitted.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>elapsed</literal></term>
                        <listitem>
                            <para>
                                The number of seconds into the run the statistics
                                in this dict were emitted.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>triggers</literal></term>
                        <listitem>
                            <para>
                                Number of triggers the readout application
                                responded to.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>events</literal></term>
                        <listitem>
                            <para>
                                Number of events the application emitted.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>bytes</literal></term>
                        <listitem>
                            <para>
                                Number of bytes emitted by the application.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Note all statistics in the counters dict are cumulative
                    from the beginning of the run.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <command>addLogMessage sev app src timestamp message</command>
            </term>
            <listitem>
                <para>
                    Adds  new log message to the database.  <parameter>sev</parameter>
                    is the severity of the message.  This can be one of
                    <literal>DEBUG, INFO, WARNING, SEVERE</literal> or
                    <literal>DEFECT</literal> as appropriate.
                </para>
                <para>
                    <parameter>app</parameter> and <parameter>src</parameter>
                    provide the name of the application emitting the message
                    and the host in which it is running respectively.
                </para>
                <para>
                    <parameter>timestamp</parameter> is the
                    <command>clock seconds</command> when the message was emitted
                    and <parameter>message</parameter> is the text of the log
                    message.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
        <para>
            The subcommands below query the database.  Note that each of these
            subcommands accepts an optional <parameter>filter</parameter> parameter.
            The filter parameter can be used to restrict the results of the
            query to records that satisfy specific conditions.
        </para>
        <para>
            The SqlWhere package provides building blocks for
            filter objects.  Any of the snit::type class instances there can be
            used as a filter parameter as can any command ensemble that has a
            <command>toString</command> subcommand that produces the body
            of an SQLITE WHERE clause.
        </para>
        <para>
            Now lets look at each of the subcommands that perform queries over the
            families of data the status database holds.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <command>queryLogMessages ?filter?</command>
                </term>
                <listitem>
                    <para>
                        Returns the set of log messages that meet the optional
                        <parameter>filter</parameter> parameter's condition
                        string.  If <parameter>filter</parameter> is not supplied,
                        all log messages are returned.
                    </para>
                    <para>
                        The result is a (possibly empty) list of dicts.
                        Each dict in the list has the following keys:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>id</literal></term>
                            <listitem>
                                <para>
                                    The primary key of the record used to fill
                                    this dict.  In SQL data bases records
                                    can have a
                                    field called the primary key which must be
                                    unique.  There are advantages to defining a
                                    primary key.  In this subsystem, all tables
                                    have primary keys that are sequentially assigned
                                    integers.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>severity</literal></term>
                            <listitem>
                                <para>
                                    The severity string for the message.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>application</literal></term>
                            <listitem>
                                <para>
                                    The name of the application that produced
                                    the log message.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>source</literal></term>
                            <listitem>
                                <para>
                                    The fully qualified domain name of the
                                    host in which the application was running.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>timestamp</literal></term>
                            <listitem>
                                <para>
                                    The value of <command>clock seconds</command>
                                    at the time the log message was emitted?
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>message</literal></term>
                            <listitem>
                                <para>
                                    The actual log message.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        The filter can be  constructed using the following fields:
                        <literal>id, severity, application, source, timestamp</literal> and
                        <literal>message</literal>.
                    </para>
                    
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>listRings ?filter?</literal></term>
                <listitem>
                    <para>
                        Lists the set of ringbuffers known to the ring statistics
                        subsystem.  If a filter is provided, the ringbuffers
                        listed only the records that satisfy the filter are
                        included in the result.
                    </para>
                    <para>
                        The result is a possibly empty list of dicts.
                        Each dict identifies a single ringbuffer and has
                        the following keys:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>id</literal></term>
                            <listitem>
                                <para>
                                    The primary key of the ringbuffer
                                    description record.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>name</literal></term>
                            <listitem>
                                <para>
                                    The name of the ringbuffer.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>host</literal></term>
                            <listitem>
                                <para>
                                    The name of the host the ring buffer
                                    lives in.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>fqname</literal></term>
                            <listitem>
                                <para>
                                    A fully qualified ringbuffer name that is
                                    constructed by gluing the name and host
                                    together with an <literal>@</literal>
                                    between them.  
                                </para>
                                <para>
                                    Note that the form of a proxy ring is
                                    <literal>ring@originatinghost</literal>.
                                    Therefore it is possible to have fully
                                    qualified ring names that have more than
                                    one <literal>@</literal>.  For example,
                                    the proxy ring for a ring named fox
                                    that lives in spdaq20.nscl.msu.edu would
                                    be <literal>fox@spdaq20.nscl.msu.edu</literal>.
                                    If that proxy ring lived in charlie.nscl.msu.edu,
                                    the fqname for that proxy would be
                                    <literal>fox@spdaq20.nscl.msu.edu@charlie.nscl.msu.edu</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        The filter can be constructed using any of the
                        following fields.
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>r.id</literal></term>
                            <listitem>
                                <para>
                                    The ringbuffer table primary key.  The
                                    leading <literal>r.</literal> allows us,
                                    in later queries to add primary keys from other,
                                    related tables.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>r.name</literal></term>
                            <listitem>
                                <para>
                                    Name of the ringbuffer.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>r.host</literal></term>
                            <listitem>
                                <para>
                                    Host in which the ring buffer lives.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>r_fqname</literal></term>
                            <listitem>
                                <para>
                                    The fully qualified ring name.  Note that the
                                    <literal>_</literal> is not a typo.  The
                                    fully qualified name is a <firstterm>synthetic</firstterm>
                                    field that is generated by the query from the
                                    ring and host.  Synthetic field names cannot
                                    be qualified by table names or table aliases.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>listRingsAndClients ?filter?</command></term>
                <listitem>
                    <para>
                        Lists ring buffers and their associated clients.
                        A ringbuffer client either produces data into the ring
                        or consumes data from the ring.  A ring buffer can have
                        at most one producer.  It can have many consumers.
                    </para>
                    <para>
                        The result of this command is possibly empty dict whose
                        keys are indices are fully qualified ring names
                        (see <command>listRings</command>
                        above for more
                        information about what that means).
                        The contents of each dict is a two element list.
                        The first element of the list is the ring description.
                        See <command>listRings</command> for documentation of
                        this dict.  The second element of each list is a list
                        of dicts.  Each element of that list describes a single
                        client using the following keys:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>id</literal></term>
                          <listitem>
                              <para>
                                The primary key of the client record that populated
                                this dict.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>pid</literal></term>
                          <listitem>
                              <para>
                                The process id (PID) of the client.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>isProducer</literal></term>
                          <listitem>
                              <para>
                                Boolean that is true if the client is a producer.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>command</literal></term>
                          <listitem>
                              <para>
                                Space separated command words. Note that in the
                                presence of some Tcl special characters this may
                                not be a valid Tcl list. It can be made one by
                                using the Tcl <command>split</command> command
                                with a space as the splitChars parameter.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                    <para>
                      The optional <parameter>filter</parameter> command
                      can use any of the field described by
                      <command>listRings</command> as well as the
                      fields described below:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>c.id</literal></term>
                          <listitem>
                              <para>
                                The primary key of the client.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>c.pid</literal></term>
                          <listitem>
                              <para>
                                The client's process id.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>c.producer</literal></term>
                          <listitem>
                              <para>
                                The producer flag for clients.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>c.command</literal></term>
                          <listitem>
                              <para>
                                The client's command string.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>queryRingStatistics ?filter?</command></term>
                <listitem>
                    <para>
                      Produces ring statistics for each client of each ring that
                      satisfies the specified conditions in the optional
                      <replaceable>filter</replaceable> parameter.
                    </para>
                    <para>
                      The result of this query is a dict that is indexed by
                      ringbuffer fully qualified names.  Each dict contains
                      a pair of elements.  The first element of each pair is
                      the ring description dict.
                    </para>
                    <para>
                      The second element of each pair is a list of pairs one pair
                      for each client of the ring buffer.  The first element of
                      each of <emphasis>those</emphasis> pairs is the dict
                      that describes a client of the ringbuffer.  The
                      second element is a list of dicts that contain
                      counters for that client over time.  These dicts have
                      the following keys:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>id</literal></term>
                          <listitem>
                              <para>
                                Primary key of the statistics table used to
                                populate the dict.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>timestamp</literal></term>
                          <listitem>
                              <para>
                                The value of <command>clock seconds</command>
                                at the time the counter/statistics entry was
                                created.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>operations</literal></term>
                          <listitem>
                              <para>
                                The number of operations performed by the client.
                                This is the total number  of puts (for
                                producers) or gets (for consumers) done since
                                the client started.  To compute rates it is
                                necessary to have at least two of these dicts.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>bytes</literal></term>
                          <listitem>
                              <para>
                                The number of bytes transferred by the client.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>backlog</literal></term>
                          <listitem>
                              <para>
                                This value is only relevant for consumers and
                                contains the number of bytes that are
                                backlogged in the ringbuffer for that
                                consumer client.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                    <para>
                      In addition to the fields described for <command>listRings</command>
                      and <command>listRingsAndClients</command>, The following
                      fields can be used when constructing filter objects:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>s.id</literal></term>
                          <listitem>
                              <para>
                                The primary key of the statistics entry used
                                to populate a dict.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>s.timestamp</literal></term>
                          <listitem>
                              <para>
                                The statistics entry timestamp.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>s.operations</literal></term>
                          <listitem>
                              <para>
                                The number of operations performed by the client
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>s.bytes</literal></term>
                          <listitem>
                              <para>
                                The number of bytes transferred by the client.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>s.backlog</literal></term>
                          <listitem>
                              <para>
                                The number of bytes backloged for consumer
                                clients (this is always 0 for producers).
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>listStateApplications ?filter?</command></term>
                <listitem>
                    <para>
                      Lists the set of state transition applications that satisfy
                      the optional filter parameter.  State transition applications
                      are simply programs that issue state transition status
                      messages.
                    </para>
                    <para>
                      The command results in a list of dicts, one dict per
                      application.   The keys in the dict include:P
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>id</literal></term>
                          <listitem>
                              <para>
                                The primary key of the record in the
                                state application table that populated the
                                dict.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>name</literal></term>
                          <listitem>
                              <para>
                                The name of the application.  Each application
                                should  have a name that is unique within the
                                host in which it runs.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>host</literal></term>
                          <listitem>
                              <para>
                                Fully qualified domain name of the host in which
                                the application is running.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                    <para>
                      Filters can be constructed using the following
                      fields:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>a.id</literal></term>
                          <listitem>
                              <para>
                                Record primary key.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>a.name</literal></term>
                          <listitem>
                              <para>
                                Name of the program.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>a.host</literal></term>
                          <listitem>
                              <para>
                                Host in which the program is running.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>queryStateTransitions ?filter?</literal></term>
                <listitem>
                    <para>
                      Queries about state transitions.  Returns a list of dicts
                      that describe the state transitions, and the applications
                      that issued them which match the optional
                      <replaceable>filter</replaceable> parameter.
                    </para>
                    <para>
                      The result is a list of dicts, one for each state transtion
                      that  matches the filter.  The dicts have the following
                      keys:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>application</literal></term>
                          <listitem>
                              <para>
                                The application description dict for the
                                application that issued this transition.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>timestamp</literal></term>
                          <listitem>
                              <para>
                                The <command>clock seconds</command> at which
                                the transition was logged.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>leaving</literal></term>
                          <listitem>
                              <para>
                                The name of the state that was left as a result
                                of the transition.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>entering</literal></term>
                          <listitem>
                              <para>
                                The name of the new state.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                    <para>
                      In addition to the fields described by
                      <command>listStateTransitions</command>, the filter
                      may use any of the following fields:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>t.id</literal></term>
                          <listitem>
                              <para>
                                The primary key of the transition record
                                in the trasitions table.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>t.timestamp</literal></term>
                          <listitem>
                              <para>
                                The timestamp for the transition.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>t.leaving</literal></term>
                          <listitem>
                              <para>
                                The state being left.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>t.entering</literal></term>
                          <listitem>
                              <para>
                                The state being entered.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>listReadoutApps</literal></term>
                <listitem>
                    <para>
                      Lists the applications that have emitted readout
                      statistics messages.  Each readout program may emit
                      run definition records and emit statistics counters
                      associated with a run definition record.
                    </para>
                    <para>
                      The result is a list of dicts.  Each dict describes a
                      readout program.  The dicts have the same fields
                      as application definitions for
                      <command>listStateApplications</command>  above.
                    </para>
                    <para>
                      The filter fields available to
                      <command>listReadoutApps</command> are also identical
                      to those of <command>listStateApplications</command>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>listRuns ?filter?</literal></term>
                <listitem>
                    <para>
                      For each readout application, lists the runs it created.
                      The results must satisfy the conditions described by the
                      optional <replaceable>filter</replaceable> parameter.
                    </para>
                    <para>
                      The result is a dict that has the primary key of readout
                      programs as keys.  The contents of each key are a
                      two element list.  The first list element is the dict
                      that describes the readout program (see
                      <command>listReadoutApps</command> above).
                    </para>
                    <para>
                      The second element of each list is itself a list, one
                      element for each of the runs that was created by the
                      application.  Each run is described by a dict that
                      contains the following keys:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>id</literal></term>
                          <listitem>
                              <para>
                                The primary key of the run table record
                                that populated the dict.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>startTime</literal></term>
                          <listitem>
                              <para>
                                The <command>clock seconds</command> at which
                                the run began.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>runNumber</literal></term>
                          <listitem>
                              <para>
                                The number of the run.  Run numbers should be
                                unique per readout program.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>runTitle</literal></term>
                          <listitem>
                              <para>
                                The title of the run.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                    <para>
                      In addition to the fields available for
                      <command>listReadoutApps</command> filters may make use
                      of the following run specific fields:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>r.id</literal></term>
                          <listitem>
                              <para>
                                Primary key of a run.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>r.start</literal></term>
                          <listitem>
                              <para>
                                Time the run started (<command>clock seconds</command>)
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>r.runNumber</literal></term>
                          <listitem>
                              <para>
                                Run number of the run.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>r.runTitle</literal></term>
                          <listitem>
                              <para>
                                Title of the run.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>queryReadoutStatistics ?filter?</literal></term>
                <listitem>
                    <para>
                      Queries the database for the readout statistics.  These are
                      a set of counters that are periodically emitted by
                      readout programs and associated with  a run that program
                      created.  If the optional <replaceable>filter</replaceable>
                      parameter is supplied, only data that satisfies the filter
                      are returned.
                    </para>
                    <para>
                      The result is a dict indexed by the primary keys of the
                      readout programs.  The contents of each key are a pair.
                      The first element of each pair is the dict that represents
                      the readout program.
                    </para>
                    <para>
                      The second element is a list of pairs, one pair for each
                      run the readout program created.  The first element of
                      each of those pairs is the dict that describes the run.
                      The second element is a list of counter dicts.  The
                      counter dicts have the followign keys:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>id</literal></term>
                          <listitem>
                              <para>
                                Primary key of the statistics entry that populated
                                this dict.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>timestamp</literal></term>
                          <listitem>
                              <para>
                                The <command>clock seconds</command> value
                                when this statistics entry was created.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>elapsedTime</literal></term>
                          <listitem>
                              <para>
                                The number of seconds into the associated run
                                at which this statistics entry was emitted.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>triggers</literal></term>
                          <listitem>
                              <para>
                                The total number of triggers this readout program
                                has responded to so far in the associated run.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>events</literal></term>
                          <listitem>
                              <para>
                                The total number of events this readout program
                                has responded to so far in the associated run.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>bytes</literal></term>
                          <listitem>
                              <para>
                                The total number of bytes of event data this
                                readout program has generated so far in the
                                associated run.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                    <para>
                      In addition to the fields described in
                      <command>listRuns</command>, filters may make use
                      of the following fields:
                    </para>
                    <variablelist>
                      <varlistentry>
                          <term><literal>s.id</literal></term>
                          <listitem>
                              <para>
                                The primary key of a statistics table entry.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>s.timestamp</literal></term>
                          <listitem>
                              <para>
                                The timea at which the statistics entry was
                                produced.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>s.elapsedtime</literal></term>
                          <listitem>
                              <para>
                                The number of seconds into the run at which
                                the statistics entry was produced.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>s.triggers</literal></term>
                          <listitem>
                              <para>
                                The number of triggers a readout program has
                                responded to in the associated run at the
                                time this record is emitted.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>s.events</literal></term>
                          <listitem>
                              <para>
                                The number of events the readout program
                                has generated so far in the associated run.
                              </para>
                          </listitem>
                      </varlistentry>
                      <varlistentry>
                          <term><literal>s.bytes</literal></term>
                          <listitem>
                              <para>
                                The number of bytes the readout program
                                has generated so far in the associated run.
                              </para>
                          </listitem>
                      </varlistentry>
                    </variablelist>
                </listitem>
            </varlistentry>
        

        </variablelist>

  </refsect1>

</refentry>


<!-- /manpage -->

<!-- manpage 3python -->

<refentry id="python3_statusdb">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
        <personblurb><para></para></personblurb>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
   <refentrytitle id='python3_statusdb_title'>nscldaq.status.statusdb</refentrytitle>
   <manvolnum>3python</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
   <refname>nscldaq.status.statusdb.statusdb</refname>
   <refpurpose>Python bindings to the status database API (<classname>CStatusDb</classname>)</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
      from nscldaq.status import statusdb
      from nscldaq.status import statusmessages
      
      api = statusdb.statusdb(filename<optional>, writeable</optional>)
      
      api.addLogMessage(severity, app, src, time, message)
      api.addRingStatistics(severity, app, src, ringid<optional>, clients</optional>)
      api.addStateChange(severity, app, src, timestamp, from, to)
      api.addReadoutStatistics(severity, app, src, start, runNumber, title<optional>, counters</optional>)
      
      result = api.queryLogMessages(<optional>filter</optional>)
      
      result = api.listRings(<optional>filter</optional>)
      result = api.listRingAndClients(<optional>filter</optional>)
      result = api.queryRingStatistics(<optional>filter</optional>)
      
      result = api.listStateApplications(<optional>filter</optional>)
      result = api.queryStateTransitions(<optional>filter</optional>)
      
      result = api.listReadoutApps(<optional>filter</optional>)
      result = api.listRuns(<optional>filter</optional>)
      result = api.queryReadoutStatistics(<optional>filter</optional>)
      
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
   <title>DESCRIPTION</title>
   <para>
    This module contains a Python class that wraps the
    <classname>CStatusDb</classname> API for the status message database.  The
    status message database contains an historical database of status messages
    for a data acquisition system instance.
   </para>
   <para>
    The methods and data structures of this class closely parallel those
    described in
    <link linkend='daq3_CStatusDb' endterm='daq3_CStatusDb_title' />.
    Methods in this class signal errors by raising an exception of the type
    <classname>nscldaq.status.statusdb.exception</classname>.
   </para>
  </refsect1>
  <refsect1>
   <title>
  METHODS
   </title>
   <para>
    Other than the constructor, the methods in this class are divided into
    those that modify the database and those that query it.  
   </para>
   <para>
    The constructor takes
    a single madatory parameter which is the filename that stores the database.
    A second optional parameter is a boolean that, if <literal>False</literal>
    indicates that the database is only open for read access.  If that is
    the case the methods which modify the database will raise an exception
    if called.
   </para>
   <para>
    The methods below are used to insert records into the datahase.  Once
    inserted, the API does not provide methods to delete or modify the database.
    The database is considered write once/read many.
   </para>
   <variablelist>
    <varlistentry>
        <term>
          api.addLogMessage(severity, app, src, time, message)
        </term>
        <listitem>
            <para>
              Adds a log message to the database.
              <parameter>severity</parameter> identifies the message severity and
              should be one of the constants defined in
              <classname>nscldaq.status.statusmessages.SeverityLevels</classname>
            </para>
            <para>
              <parameter>app</parameter> and <parameter>src</parameter>
              identify the application and host from which the status message
              was emitted.
            </para>
            <para>
              <parameter>time</parameter> and <parameter>message</parameter>
              identify the time at which the message was emitted
              and the message text itself.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
          api.addRingStatistics(severity, app, src, ringid<optional>, clients</optional>)
        </term>
        <listitem>
            <para>
              Adds ring statistics entries to the database.
              <parameter>severity</parameter> establishes the message severity.
              Normally this is <literal>nscldaq.status.statusmessages.SeverityLevels.INFO</literal>.
              <parameter>app</parameter> and <parameter>src</parameter>
              identify the application and host from which the message was emitted.
            </para>
            <para>
              <parameter>ringid</parameter> is a dict that describes the ring
              buffer this  messages describes.  The optional <parameter>clients</parameter>
              is an interable that contains dicts that descsribe clients and their
              instantaneous counters.
            </para>
            <para>
              The <parameter>ringid</parameter> dict has the following keys:
            </para>
            <para>
              The dicts that are elements of <parameter>clients</parameter>
              contain the following keys:
            </para>
            <variablelist>
              <varlistentry>
                  <term><literal>timestamp</literal></term>
                  <listitem>
                      <para>
                        This is the value of int(time.time()) at the time the
                        message for this entry was emitted.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>name</literal></term>
                  <listitem>
                      <para>
                        The name of the ringbuffer.  Note that this is a ring name
                        (e.g. <literal>fox</literal>) not a URI
                        (not e.g. <literal>tcp://charlie.nscl.msu.edu/fox</literal>).
                      </para>
                  </listitem>
              </varlistentry>
            </variablelist>
            <para>
              The dicts in the <parameter>clients</parameter> iterable have the
              following keys:
            </para>
            <variablelist>
              <varlistentry>
                  <term><literal>operations</literal></term>
                  <listitem>
                      <para>
                        The number of operations the client has perfromed.
                        For producers, this is the number of put operations
                        performed while for consumers, it is the number of
                        gets done.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>bytes</literal></term>
                  <listitem>
                      <para>
                        The number of bytes of data transferred
                        in (producer) or out of (consumer) the ring by the
                        client.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>backlog</literal></term>
                  <listitem>
                      <para>
                        For consumers, this is the number of bytes of data that
                        are backlogged in the ring buffer.  For producers,
                        this is always zero as producers can't have a backlog.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>producer</literal></term>
                  <listitem>
                      <para>
                        Boolean that is <literal>True</literal> if the
                        client is the ring producer.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>pid</literal></term>
                  <listitem>
                      <para>
                        Process id of the client.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>command</literal></term>
                  <listitem>
                      <para>
                        Iterable containing the command words used to start the
                        client.
                      </para>
                  </listitem>
              </varlistentry>
            </variablelist>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
          api.addStateChange(severity, app, src, timestamp, from, to)
        </term>
        <listitem>
            <para>
              Adds a state change entry to the database.  State changes indicate
              that programs have made a state transition in their own local
              run state machine.  This can happen either because the program
              is participating in a global state transition or because the program
              is in stand-alone mode and has been asked to perform a state
              transition by a local run control.
            </para>
            <para>
              <parameter>severity</parameter> is the message severity which
              should be <literal>nscldaq.status.statusmessages.SeverityLevels.INFO</literal>.
              <parameter>app</parameter> and <parameter>src</parameter> are the
              names and host of the application that performed the state
              transition.
            </para>
            <para>
              <parameter>from</parameter> and <parameter>to</parameter> document
              the state transition.  <parameter>from</parameter> is the state
              being left (the old state).  <parameter>to</parameter> is the
              state being entered (the new state).
            </para>
        </listitem>
    </varlistentry>  
    <varlistentry>
        <term>
          api.addReadoutStatistics(severity, app, src, start, runNumber, title<optional>, counters</optional>)
        </term>
        <listitem>
            <para>
              Readout statistics counters are associated with a run that was
              started by a readout program.  <parameter>severity</parameter>
              is the severity of the message that announced the statistics update.
              It is normally
              <literal>nscldaq.status.statusmessages.SeverityLevels.INFO</literal>.
            </para>
            <para>
               <parameter>app</parameter> and <parameter>src</parameter>
               identify the application and the host which emitted the
               status message.
            </para>
            <para>
              <parameter>start</parameter>, <parameter>runNumber</parameter>
              and <parameter>title</parameter> describe the run that is
              associated with the counters.
              <parameter>start</parameter> is the value of
              <literal>int(time.time())</literal> when the run started.
              <literal>runNumber</literal> is a unique number that was
              assigned to the run.
            </para>
            <para>
              <parameter>title</parameter> is a textual title that is associated with
              the run.
            </para>
            <para>
              <parameter>counters</parameter> is an optional parameter that
              cvontains the actual counter information.  If omitted, the
              method can create entries for the readout application and the
              run.  <parameter>counters</parameter> is a dict with the
              following keys:
            </para>
            <variablelist>
              <varlistentry>
                  <term><literal>timestamp</literal></term>
                  <listitem>
                      <para>
                        The timestamp of the counters.  This is the
                        value of <literal>int(time.time())</literal>
                        at which the counters were emitted.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>elapsed</literal></term>
                  <listitem>
                      <para>
                        The number of seconds into the associated run at which
                        the counters were emitted.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>triggers</literal></term>
                  <listitem>
                      <para>
                        The number of triggers the application responded to in
                        the associated run up to this point in time.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>events</literal></term>
                  <listitem>
                      <para>
                        The number of events emitted by the application in
                        the associated run up to this point in time.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>bytes</literal></term>
                  <listitem>
                      <para>
                        The number of bytes of data emitted by the application
                        in the associated run up to this point in time.
                      </para>
                  </listitem>
              </varlistentry>
            </variablelist>
        </listitem>
    </varlistentry>       
   </variablelist>
   <para>
    The next group of methods perform queries on the database.  Database queries
    can be filter by using objects of the sort defined by the module
    <literal>nscldaq.sqlite.where</literal>.  The filter parameters is always
    optional and, if omitted, no filter is applied.
    In order to build effective filters
    you must know the database fields present in each query.  These will be
    described in the documentation for each database query method.
   </para>
   <variablelist>
    <varlistentry>
        <term>
          result = api.queryLogMessages(<optional>filter</optional>)
        </term>
        <listitem>
            <para>
              Queries the log messages that have been entered in the
              database.  The <varname>result</varname> is a tuple whose elements
              are dicts that each describe one log message.  The keys in this
              dict are
            </para>
            <variablelist>
              <varlistentry>
                  <term><literal>id</literal></term>
                  <listitem>
                      <para>
                        The primary key of the record that populated the dict.
                        Every record in every database table  has a field which
                        is the record's primary key.  This is a uniquely
                        assigned integer value.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>timestamp</literal></term>
                  <listitem>
                      <para>
                        The value of <literal>int(time.time())</literal> at the
                        time the log message was created.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>severity</literal></term>
                  <listitem>
                      <para>
                        The messages severity.  This is one of the constants
                        from
                        <literal>nscldaq.status.statusmessages.SeverityLevels</literal>.
                        It is intended to classify the information in the log
                        message according to how sick things are.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>application</literal></term>
                  <listitem>
                      <para>
                        Name of the application that emitted the message.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>source</literal></term>
                  <listitem>
                      <para>
                        Fully qualified domain name of the host that emitted
                        the message.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>message</literal></term>
                  <listitem>
                      <para>
                        The English text of the message.
                      </para>
                  </listitem>
              </varlistentry>
            </variablelist>
            <para>
              The following fields are available to the filter:
            </para>
            <variablelist>
              <varlistentry>
                  <term><literal>id</literal></term>
                  <listitem>
                      <para>
                        Primary key of each record.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>severity</literal></term>
                  <listitem>
                      <para>
                        The severity.  This is a textual value that is the same
                        as the last bit of the name of the severity value.
                        Thus the value
                        <literal>nscldaq.status.statusmessages.SeverityLevels.INFO</literal>
                        will contain the string <literal>INFO</literal>.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>application</literal></term>
                  <listitem>
                      <para>
                        The name of the application that emitted the message
                        that resulted in the database record.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>source</literal></term>
                  <listitem>
                      <para>
                        The fully qualified domain name of the host from which
                        the message that resulted in the datbabase record
                        was emitted.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>timestamp</literal></term>
                  <listitem>
                      <para>
                        The unix timestamp (same as int(time.time())) at
                        which the log message was emitted.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>message</literal></term>
                  <listitem>
                      <para>
                        The log message text.
                      </para>
                  </listitem>
              </varlistentry>
            </variablelist>
        </listitem>
    </varlistentry>
    <varlistentry>
         <term>
          result = api.listRings(<optional>filter</optional>)
         </term>
         <listitem>
             <para>
              Lists the set of ringbuffers that are known to the status database.
              <varname>result</varname> is a tuple of dicts.  Each element of the
              tuple describes a single ringbuffer known to the message system.
              Ring buffers are described using a dict that has the following
              keys:
             </para>
             <variablelist>
              <varlistentry>
                  <term><literal>id</literal></term>
                  <listitem>
                      <para>
                        The primary key of the record that populated this dict.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>name</literal></term>
                  <listitem>
                      <para>
                        The name of the ring buffer.  Note that proxy rings
                        have names like <literal>remote-ring@remote-host</literal>
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>host</literal></term>
                  <listitem>
                      <para>
                        The host in which the ringbuffer lives.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>fqname</literal></term>
                  <listitem>
                      <para>
                        The fully qualified ringbuffer name.  This is just the
                       <literal>name</literal> value joined to the
                       <literal>host</literal> value with an <literal>@</literal>.
                       Thus the proxy ring for <literal>e1234@spdaq20.nscl.msu.edu</literal>
                       that lives in charlie.nscl.msu.edu
                       will have a fully qualified name of
                       <literal>e1234@spdaq20.nscl.msu.edu@charlie.nscl.msu.edu</literal>
                      </para>
                      <para>
                        <literal>fqname</literal> is a <firstterm>synthetic</firstterm>
                        field.  This means that there is not actually a field in the
                        database named <literal>fqname</literal>.  The
                        value of <literal>fqname</literal> is dynamically
                        generated by the query.
                      </para>
                  </listitem>
              </varlistentry>
             </variablelist>
             <para>
                The field names available to the filter are:
             </para>
             <variablelist>
              <varlistentry>
                  <term><literal>r.id</literal></term>
                  <listitem>
                      <para>
                        The primary key of the record in the database.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>r.name</literal></term>
                  <listitem>
                      <para>
                        Name of the ringbuffer described by a record.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>r.host</literal></term>
                  <listitem>
                      <para>
                        Name of the host the ring buffer of a record
                        lives in.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term>
                    <literal>r_fqname</literal>
                  </term>
                  <listitem>
                      <para>
                        The fully qualified ring name.  Note the
                        <literal>_</literal> is not a typo.
                      </para>
                  </listitem>
              </varlistentry>
             </variablelist>
         </listitem>
     </varlistentry> 
     <varlistentry>
         <term>
           result = api.listRingAndClients(<optional>filter</optional>)
         </term>
         <listitem>
             <para>
              Lists ring buffers and their clients.  Ring buffer clients are
              either producers, programs which put data into a ring buffer,
              or consumers (programs which consume data placed in a ring buffer
              by a producer.).
              Ring buffers need not have clients.  If they do, they may have at
              most one producer and may have many consumers.
             </para>
             <para>
              The <varname>result</varname> of this query a dict whos keys
              are fully qualified ring names.  The contents of each key are
              a two element tuple whose first element contains a dict that
              describes the ring and whose second is a list of dicts that
              describe the clients attached to the ring.
             </para>
             <para>
              The client dicts have the following keys:
             </para>
             <variablelist>
              <varlistentry>
                  <term><literal>id</literal></term>
                  <listitem>
                      <para>
                        The primary key of the client in its table in the
                        database.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>pid</literal></term>
                  <listitem>
                      <para>
                        The process id of the client.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>producer</literal></term>
                  <listitem>
                      <para>
                        A boolean that is <literal>True</literal> in the
                        event the client is a producer. Note that
                        a ringbuffer an only have at most one producer at a time.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>command</literal></term>
                  <listitem>
                      <para>
                        A space separated set of command words that make up the
                        command used to launch the client.
                      </para>
                  </listitem>
              </varlistentry>
             </variablelist>
             <para>
              In addition to the fields described for <methodname>listRings</methodname>,
              filters for this query may make use of the following fields:
             </para>
             <variablelist>
              <varlistentry>
                  <term><literal>c.id</literal></term>
                  <listitem>
                      <para>
                        The primary key of a client record in its table.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>c.pid</literal></term>
                  <listitem>
                      <para>
                        The process ID (PID) of a client.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>c.producer</literal></term>
                  <listitem>
                      <para>
                        The producer flag of a client.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>c.command</literal></term>
                  <listitem>
                      <para>
                        The command used to launch the client.
                      </para>
                  </listitem>
              </varlistentry>
             </variablelist>
         </listitem>
     </varlistentry>
     <varlistentry>
         <term>
          result = api.queryRingStatistics(<optional>filter</optional>)
         </term>
         <listitem>
             <para>
              Returns the ringbuffers, their clients and associated statistics
              counters. The <varname>resulty</varname> is a dict whose keys
              are fully qualified ring buffer names.  The contents are
              a two element tuple.  The first element of each tuple is the
              ring description dictionary.  The second element of each tuple
              is itself a tuple.
             </para>
             <para>
              The elements of the inner tuple are also pairs.  The first element
              of each pair is a client description dict.  The second element is
              a tuple of dicts that contain statistics counters.
              The keys of each of these dicts are:
             </para>
             <variablelist>
              <varlistentry>
                  <term><literal>id</literal></term>
                  <listitem>
                      <para>
                        The primary key of the statistics counter record used
                        to load this dict.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>timestamp</literal></term>
                  <listitem>
                      <para>
                        The value of <literal>int(time.time())</literal> when the
                        message that resulted in the statistics record was emitted.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>operations</literal></term>
                  <listitem>
                      <para>
                        The number of operations that have been performed by the
                        client on the ring buffer.  If the client is a
                        producer, this is the number of puts.  If the client
                        is a consumer, this is the number of gets.  Each ring item
                        transferred requires a put to enter it in the ringbuffer
                        and a get to transfer it to a consumer.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>bytes</literal></term>
                  <listitem>
                      <para>
                        The total number of bytes transferred by the consumer
                        via the ringbuffer.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>backlog</literal></term>
                  <listitem>
                      <para>
                        This value only has meaning for consumers.  It is always
                        zero for producers.  The backlog is the number of bytes
                        queued in the ringbuffer for a specific consumer. 
                      </para>
                  </listitem>
              </varlistentry>
             </variablelist>
             <para>
              In addition to the fields described in
              <methodname>listRingsAndClients</methodname>, the following
              fields can be used in filters for this query:
             </para>
             <variablelist>
              <varlistentry>
                  <term><literal>s.id</literal></term>
                  <listitem>
                      <para>
                        Primary key of the statistics table.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>s.timestamp</literal></term>
                  <listitem>
                      <para>
                        The unix timestamp when the message resulting
                        in the statistics record was emitted.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>s.operations</literal></term>
                  <listitem>
                      <para>
                        The number of operations performe by the client.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>s.bytes</literal></term>
                  <listitem>
                      <para>
                        The number of bytes transferred by the client.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>s.backlog</literal></term>
                  <listitem>
                      <para>
                        The number of bytes queued for the client.
                      </para>
                  </listitem>
              </varlistentry>
             </variablelist>
         </listitem>
     </varlistentry>
     <varlistentry>
         <term>
          result = api.listStateApplications(<optional>filter</optional>)
         </term>
         <listitem>
             <para>
              Lists the state applications.  A state application is one that
              participates in global run state transitions.  These applications
              emit transition messages to log their own local transitions as
              part of a global transition.  They also log local transitions
              when they are in stand alone mode and asked to do a purely
              local state transition.
             </para>
             <para>
              <varname>result</varname> will be a tuple of dicts.  Each tuple
              element will describe a state application.  The keys in these
              dicts are:
             </para>
             <variablelist>
              <varlistentry>
                  <term><literal>id</literal></term>
                  <listitem>
                      <para>
                        Primary key of the record used to stock this
                        dict.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>name</literal></term>
                  <listitem>
                      <para>
                        Name of the application.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>host</literal></term>
                  <listitem>
                      <para>
                        Host the application runs in.
                      </para>
                  </listitem>
              </varlistentry>
             </variablelist>
             <para>
              The following fields can be used when constructing the filter:
             </para>
             <variablelist>
              <varlistentry>
                  <term><literal>a.id</literal></term>
                  <listitem>
                      <para>
                        The primary key of the application in its table.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>a.name</literal></term>
                  <listitem>
                      <para>
                        The name of the application.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><literal>a.host</literal></term>
                  <listitem>
                      <para>
                        The host in which the application runs.
                      </para>
                  </listitem>
              </varlistentry>
             </variablelist>
         </listitem>
     </varlistentry>
      <varlistentry>
          <term>
            result = api.queryStateTransitions(<optional>filter</optional>)
          </term>
          <listitem>
              <para>
                Queries the state transitions.  The result is a tuple of dicts.
                Each dict contains one transition along wth information about
                the application that logged it.  The dict has the following keys:
              </para>
              <variablelist>
                <varlistentry>
                    <term><literal>application</literal></term>
                    <listitem>
                        <para>
                          The contents of this dict are a dict that contains
                          the application information (see
                          <methodname>listStateApplications</methodname>
                          above for the form of this dict).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>appid</literal></term>
                    <listitem>
                        <para>
                          The Id of the application (same as the <literal>id</literal>)
                          field in the <literal>application</literal> dict).
                          This is called a foreign key and is what is used
                          to link tables together.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>transitionid</literal></term>
                    <listitem>
                        <para>
                          The primary key of the transition record in its table.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>timestamp</literal></term>
                    <listitem>
                        <para>
                          The value of <literal>int(time.time())</literal> at
                          the time the transition was logged.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>leaving</literal></term>
                    <listitem>
                        <para>
                          The state being left by the transition
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal></literal></term>
                    <listitem>
                        <para>
                          The state being entered by the transition.
                        </para>
                    </listitem>
                </varlistentry>
              </variablelist>
              <para>
                In addition to the fields described in
                <methodname>listStateApplications</methodname>, the following
                transition specific fields are available when constructing filters:
              </para>
              <variablelist>
                <varlistentry>
                    <term><literal>t.id</literal></term>
                    <listitem>
                        <para>
                          The primary key of the transition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>t.app_id</literal></term>
                    <listitem>
                        <para>
                          In the transition table, this is a foreign key whose
                          value is the primary key of the applicaton that logged
                          the transition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>t.timestamp</literal></term>
                    <listitem>
                        <para>
                          Timestamp;  the <literal>int(time.time())</literal>
                          when the transition was logged.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>leaving</literal></term>
                    <listitem>
                        <para>
                          The state that was left by the transition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>entering</literal></term>
                    <listitem>
                        <para>
                          The state that was being entered by the transition.
                        </para>
                    </listitem>
                </varlistentry>
              </variablelist>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term>
            result = api.listReadoutApps(<optional>filter</optional>)
          </term>
          <listitem>
              <para>
                Lists the set of readout applications. A readout application
                is one that responds to triggers and emits events.  In the
                context of the status distribution system, a readout program
                emits messages with counters providing statistics during
                data taking runs.
              </para>
              <para>
                The hierachy of related data are as follows;  A readout application
                produces many data taking <firstterm>runs</firstterm>.  During
                each data taking run, readout programs periodically emit
                statistics messages describing the triggers, events, data volume
                they have seen.
              </para>
              <para>
                This method, returns the list of readout programs known to the
                system.  The <varname>result</varname> is tuple of dicts.  Each
                dict describes one readout program.  The keys in these dicts are:
              </para>
              <variablelist>
                <varlistentry>
                    <term><literal>id</literal></term>
                    <listitem>
                        <para>
                          The primary key of the application record used to
                          populate the remainder of the dict.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>name</literal></term>
                    <listitem>
                        <para>
                          The name of the application
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>host</literal></term>
                    <listitem>
                        <para>
                          The host in which the application is running.
                        </para>
                    </listitem>
                </varlistentry>
              </variablelist>
              <para>
                The following fields are available when building filters:
              </para>
              <variablelist>
                <varlistentry>
                    <term><literal>a.id</literal></term>
                    <listitem>
                        <para>
                          Record primary key.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>a.name</literal></term>
                    <listitem>
                        <para>
                          Name of the application.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>a.host</literal></term>
                    <listitem>
                        <para>
                          Host in wich this application is running.
                        </para>
                    </listitem>
                </varlistentry>
              </variablelist>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term>
            result = api.listRuns(<optional>filter</optional>)
          </term>
          <listitem>
              <para>
                Each readout application can perform several data taking run.
                This query returns the readout applications and information
                that identifies each data taking run.
              </para>
              <para>
                The <varname>result</varname> is a dict that is keyed by the
                primary keys of the readout applications.  The contents of
                each dict entry are a two element tuple.   The first
                element of the tuple is the dict 
                that describes the readout program
                whose primary key is the index of that entry.  This dict is
                described in <methodname>listReadoutApps</methodname> above.
              </para>
              <para>
                The second element of the tuple is a tuple of dicts.  Each dict
                in this tuple describes a data taking run the readout application
                has initiated.  This dict has the following keys:
              </para>
              <variablelist>
                <varlistentry>
                    <term><literal>id</literal></term>
                    <listitem>
                        <para>
                          Primary key of the run record.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>start</literal></term>
                    <listitem>
                        <para>
                          The <literal>int(time.time())</literal> at which the
                          data taking run started.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>number</literal></term>
                    <listitem>
                        <para>
                          The run number.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>title</literal></term>
                    <listitem>
                        <para>
                          The title string associated with the data taking run.
                        </para>
                    </listitem>
                </varlistentry>
              </variablelist>
              <para>
                In addition to the fields from <methodname>listReadoutApps</methodname>,
                filters can make use of the following run specific fields:
              </para>
              <variablelist>
                <varlistentry>
                    <term><literal>r.id</literal></term>
                    <listitem>
                        <para>
                          The primary key.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>r.start</literal></term>
                    <listitem>
                        <para>
                          The time at which the run started expressed as
                          <literal>int(time.time())</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>r.run</literal></term>
                    <listitem>
                        <para>
                          The run number.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>r.title</literal></term>
                    <listitem>
                        <para>
                          The title of the run.
                        </para>
                    </listitem>
                </varlistentry>
              </variablelist>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term>
            result = api.queryReadoutStatistics(<optional>filter</optional>)
          </term>
          <listitem>
              <para>
                Returns the statistics associated with each run and each
                readout program.  Note that since statistics are periodically
                emitted when a run is active, each run will have more than one
                statistics entry.
              </para>
              <para>
                The <varname>result</varname> will be a dict that is indexed
                by the primary key (id) of readout programs.  The
                contents of each dict entry is a two element tuple.  The first
                element of each tuple is the dict that describes a readout program.
                The second element of the tuple is itself a tuple.
              </para>
              <para>
                Elements of this tuple are themselves two element tuples.  The
                first element of each of these tuples is the run description
                dict.  The second element is a tuple that contains dicts that
                describe the statistics counters at periodic times during the run.
                The statistics dict has the following fields:
              </para>
              <variablelist>
                <varlistentry>
                    <term><literal>id</literal></term>
                    <listitem>
                        <para>
                          The primary key of the statistic record that populated
                          this dict.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>timestamp</literal></term>
                    <listitem>
                        <para>
                          The timestamp that contains the
                          <literal>int(time.time())</literal> at which the
                          statistic entry was emitted.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>elapsed</literal></term>
                    <listitem>
                        <para>
                          The number of seconds into the associated run the
                          statistic item was emitted.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>triggers</literal></term>
                    <listitem>
                        <para>
                          Number of triggers the readout program has responded
                          to by this point in time in the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>events</literal></term>
                    <listitem>
                        <para>
                          The number of events the readout program has emitted by
                          this point in the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>bytes</literal></term>
                    <listitem>
                        <para>
                          The number of bytes the readout program has emitted.
                        </para>
                    </listitem>
                </varlistentry>
              </variablelist>
              <para>
                In addition to the run and application fields, filters may make
                use of the following fields that are specific to its table:
              </para>
              <variablelist>
                <varlistentry>
                    <term><literal>s.id</literal></term>
                    <listitem>
                        <para>
                          Statistics record primary key.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>s.timestamp</literal></term>
                    <listitem>
                        <para>
                          The time at which the record was emitted as
                          <literal>int(time.time())</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>s.elapsedtime</literal></term>
                    <listitem>
                        <para>
                          Number of seconds into the associated run at which
                          the entry was emitted.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>s.triggers</literal></term>
                    <listitem>
                        <para>
                          Number of triggers.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>s.events</literal></term>
                    <listitem>
                        <para>
                          Number of events.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>s.bytes</literal></term>
                    <listitem>
                        <para>
                          Number of bytes of data emitted.
                        </para>
                    </listitem>
                </varlistentry>
              </variablelist>
          </listitem>
      </varlistentry>
   </variablelist>
  </refsect1>
</refentry>     

<!-- /manpage -->