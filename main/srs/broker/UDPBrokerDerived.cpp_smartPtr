// /*
//     This software is Copyright by the Board of Trustees of Michigan
//     State University (c) Copyright 2022.

//     You may use this software under the terms of the GNU public license
//     (GPL).  The terms of this license are described at:

//      http://www.gnu.org/licenses/gpl.txt

//      Authors:
//              Ron Fox
//              Giordano Cerriza
//              Genie Jhang
//              Simon Giraud
// 	     FRIB
// 	     Michigan State University
// 	     East Lansing, MI 48824-1321
// */

#include "UDPBrokerDerived.h"
#include "pcapHeader.h"
#include "datagramHeader.h"
#include "BitMath.h"

#include <chrono>
#include <ctime> //for state change RI
#include <iostream>
#include <stdexcept>
#include <memory>
// #include <CUDPClient.h>
#include <CDataSinkFactory.h>
#include <CDataSink.h>
#include <stdlib.h>
#include <string>
#include <string.h>
#include <DataFormat.h>
#include <CRingItem.h>
#include <CRingStateChangeItem.h>
#include <stdint.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <iomanip>
#include <Exception.h>
#include <bitset>
#include <SRSMaps.h>

UDPBrokerDerived::UDPBrokerDerived() {
}

UDPBrokerDerived::~UDPBrokerDerived() {
}


void UDPBrokerDerived::initialize(short port) {
  UDPBrokerBase::initialize(port); // Call base class initialization
  // Add derived class specificities
  // Set the detector channel mapping
  m_channelsMap = std::make_unique<SRSMaps>();
  m_channelsMap->setChannelsMap("dcS800");
  m_stopMainLoop = false;
  m_pauseMainLoop = true;
}


void UDPBrokerDerived::addSink(std::string sinkType, int sid) {
    std::unique_ptr<CDataSink> dataSink;
    dataSink.reset(CDataSinkFactory().makeSink(sinkType)); 
    if (!dataSink) {
        throw std::runtime_error("UDPBrokerDerived::addSink - Failed to create data sink");
    }
    m_dataSinks[sid] = std::move(dataSink);
}

//...
void UDPBrokerDerived::extractHitTimeStamp(uint8_t sourceId, uint8_t* data)
{
    auto Data1Offset = 0;
    auto Data2Offset = Data1Offset + Data1Size;
    uint32_t data1 = htonl(*reinterpret_cast<uint32_t*>(&data[Data1Offset]));
    uint16_t data2 = htons(*reinterpret_cast<uint16_t*>(&data[Data2Offset]));
    uint8_t vmmid = MaxVMMs +1 ;
    uint16_t idx = MaxFECs * MaxVMMs +1;
    uint8_t triggerOffset = 0;
    uint16_t bcid = 0;

    int dataflag = (data2 >> 15) & 0x1;
    if(dataflag){

        // uint8_t vmmId = (data1 >> 22) & 0x1F;
        // uint8_t chnoRaw = (data2 >> 8) & 0x3f;

        // // Note chno takes only 6 bits (0-63) 
        // uint8_t chnoMapped = channelsMap[fecId][vmmId][chnoRaw]; 


        // printf("data1: 0x%08x, data2: 0x%04x \n", data1, data2);
        // std::cout<<"bit rep of data1: "<<std::bitset<32>( data1 )<<std::endl;
        // std::cout<<"bit rep of data2: "<<std::bitset<16>( data2 )<<std::endl;
        // std::cout<<"bit rep of data1 >> 12: "<<std::bitset<32>( data1 >> 12 )<<std::endl;
        // std::cout<<"bit rep of data1 >> 12: "<<std::bitset<32>( 0x3FF)<<std::endl;
        // std::cout<<"bit rep of data1 >> 12: "<<std::bitset<32>( data1 >> 12 & 0x3FF)<<std::endl;


        vmmid = (data1 >> 22) & 0x1F;
        // if ext. trigger get marker at vmmid +16
        if (m_triggerMode == 1){
            idx = (sourceId - 1) * MaxVMMs + vmmid + 16;
        }
        else {
            idx = (sourceId - 1) * MaxVMMs + vmmid;
        }
        triggerOffset = (data1 >> 27) & 0x1F;
        bcid = BitMath::gray2bin32(data1 & 0xFFF);
        uint8_t chno = (data2 >> 8) & 0x3f;

        //tsAndMappedChno.chnoMapped = channelsMap[sourceId][vmmid][chno]; 
        tsAndMappedChno.chnoMapped = m_channelsMap->getMappedChannel(sourceId, vmmid, chno);

        uint8_t tdc = data2 & 0xff;

        //if (m_extClock == 1){
            //need to get extClock freq/period - actually no information on that from vmmsc - should be provided by user 
        //}

        //commented, only send data no markers, the markers are used to compute a fine time stamp
        //every 65536 clock cycle a new marker is issued, every 4096 clock cycle triggerOffset is increased by 1, bcid max is 4095
        uint64_t fineTS = markerSRS[idx].fecTimeStamp + triggerOffset*4096 + bcid;
        //comment following 2 lines and uncomment previous one if dont want to convert in ns
        //uint64_t fineTS = m_clockPeriod*(markerSRS[idx].fecTimeStamp + triggerOffset*4096 + bcid);

        // ext. trigger, don't need the triggerOffset and bcid
        if (m_triggerMode == 1){
            //for now dont provide fineTS in ns but in clock tick, since with ext. clock the only way to know the frequency would be by user... 
            //kind of risky to convert in ns at this stage, user can provide wrong freq which will impact raw data, should do convertion at analysis stage.
            //fineTS = m_clockPeriod*markerSRS[idx].fecTimeStamp;
            fineTS = markerSRS[idx].fecTimeStamp;
        }

        printf("SRS Data: sourceId: %d, vmm: %d, channel: %d, channelMapped: %d, fecTimeStamp: %llu, fineTS: %llu, bcid: %d, tdc: %d\n",sourceId, vmmid, chno, tsAndMappedChno.chnoMapped, markerSRS[idx].fecTimeStamp, fineTS, bcid, tdc);
        // if (sourceId == 6){
        //     printf("extractHitTimeStamp - fecTimeStamp: %llu, fineTS: %llu \n", markerSRS[idx].fecTimeStamp, fineTS);
        // }
        //if data come before the first markers set TS to 0 and these data will be skipped.
        if (markerSRS[idx].fecTimeStamp == 0)
        {
            m_firstDataCounter++;
            fineTS = 0;
        }
        tsAndMappedChno.hitTimeStamp = fineTS;
    } else {
        // Markers
        vmmid = (data2 >> 10) & 0x1F;
        idx = (sourceId - 1) * MaxVMMs + vmmid;
        uint64_t timestamp_lower_10bit = data2 & 0x03FF;
        uint64_t timestamp_upper_32bit = data1;
        uint64_t timestamp_42bit = (timestamp_upper_32bit << 10) + timestamp_lower_10bit;
        //printf("SRS Marker fecId %d vmmid %d: timestamp lower 10bit %lu, timestamp upper 32 bit %lu, 42 bit timestamp %lu \n", sourceId, vmmid, timestamp_lower_10bit, timestamp_upper_32bit, timestamp_42bit);

        if(markerSRS[idx].fecTimeStamp > timestamp_42bit) {
            if (markerSRS[idx].fecTimeStamp < 0x1FFFFFFF + timestamp_42bit) {
                m_markerErrCounter++;
                //printf( "ParserTimestampSeqErrors:  ts %lu, marker ts %lu \n", timestamp_42bit, markerSRS[idx].fecTimeStamp);
            }
        }
        // if(markerSRS[idx].calcTimeStamp == 0) {
        //     markerSRS[idx].calcTimeStamp = timestamp_42bit;
        // }
        // printf("SRS Marker startedMarker %d, 42 bit timestamp %lu \n", startedMarker[idx], timestamp_42bit);
        if (startedMarker[idx] && timestamp_42bit != 0) {
            markerSRS[idx].fecTimeStamp = timestamp_42bit;
        }
        else if (startedMarker[idx] && timestamp_42bit == 0) {
            //printf( "ParserTimestampSeqErrors:  ts == 0 for not first marker\n");
        }
        else {
            markerSRS[idx].fecTimeStamp = 0;
            startedMarker[idx] = true;
        }
        tsAndMappedChno.hitTimeStamp = 0;
        tsAndMappedChno.chnoMapped = 0;
    }
    return;
}


/**
 * mainLoop
 *    Accepts datagrams from the server object and forwards them to the
 *    sink. Data sent looks like ring items of type FIRST_USER_ITEM_CODE
 *    (or PHYSICS_EVENT?)
 *    The body header will be filled in as:
 *    - timestamp from the routing header.
 *    - sourceid as (detectorId << 8) | (subdetectorId)
 *    - barrier type 0.
 *    The ring item payload will be the complete datagram including
 *    routing header preceded by the IP address and port of the sender.
 *
 */
void UDPBrokerDerived::mainLoop() {
    uint8_t datagram[65536];
    struct sockaddr_in senderAddr;
    socklen_t senderAddrLen = sizeof(senderAddr);


    // Get a reference to the map of data sinks from the base class
    // const std::map<int, std::unique_ptr<CDataSink>>& dataSinks = UDPBrokerBase::getSinks();

    //Specific to SRS
    markerSRS = new VMM3Marker[MaxFECs * MaxVMMs];

    //std::chrono::time_point<std::chrono::high_resolution_clock> start, end;
    //start = std::chrono::high_resolution_clock::now();

    while (!m_stopMainLoop) {
        if (m_pauseMainLoop) continue;
        int bytesReceived = recvfrom(UDPBrokerBase::getSocket(), datagram, sizeof(datagram), 0,
                                     (struct sockaddr*)&senderAddr, &senderAddrLen);//m_socket
        if (bytesReceived < 0) {
            perror("UDPBrokerDerived::mainLoop - Error receiving datagram");
            //throw std::runtime_error("UDPBrokerDerived::mainLoop - Error receiving datagram");
            continue;
        }

        // Process received datagram
        in_addr_t from = senderAddr.sin_addr.s_addr;
        short fromPort = ntohs(senderAddr.sin_port);
        // std::unique_ptr<CRingItem> pRingItem = makeRingItem(from, fromPort, m_sid, datagram, bytesReceived);
        // m_dataSink->putItem(*pRingItem);

        //Simon -  04/01/2024
        //extract the sourceId (=fecId, should it be combination of FECID and VMMID?) from srs header in datagram
        uint8_t* buffer = reinterpret_cast<uint8_t*>(datagram);
        psrshdr hdr = reinterpret_cast<psrshdr>(buffer);
        uint8_t sid = hdr -> fecId;
        // extract all hits (data1&data2) from datagram, encapsulate the hits in ring items (one hit into one RI) and put RI in sink        
        // makeRingItems(from, fromPort, *m_dataSinks.find(sid)->second, sid, buffer, bytesReceived);

        auto it = m_dataSinks.find(sid);
        // Check if data sink for this sid
        if (it != m_dataSinks.end()) {
            std::unique_ptr<CDataSink>& m_dataSinks = it->second;
            makeRingItems(from, fromPort, *m_dataSinks, sid, buffer, bytesReceived);
        } else {
            std::cerr << "UDPBrokerDerived::mainLoop - no data sink for source id (fecId): " << sid << std::endl;
            continue;
        }
        //makeRingItems(from, fromPort, *(UDPBrokerBase::getSinks().find(sid)->second), sid, buffer, bytesReceived);

        m_end = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double, std::nano> elapsed_time = m_end - m_start; 
        auto elapsed_time_s = elapsed_time.count()/1e9; 
        m_datagramCounter++;
        //std::cout<<"bytes received, elapsed_time_s: "<<bytesReceived<<" "<<elapsed_time_s<<std::endl;
       // std::cout<<"Counters: datagram, marker, markerErr, hit, firstData: "<<m_datagramCounter<<" "<<m_markerCounter<<" "<<m_markerErrCounter<<" "<<m_hitCounter<<" "<<m_firstDataCounter<<std::endl;
        //std::cout<<"Rates: datagram, marker, markerErr, hit: "<<m_datagramCounter/elapsed_time_s<<" "<<m_markerCounter/elapsed_time_s<<" "<<m_markerErrCounter/elapsed_time_s<<" "<<m_hitCounter/elapsed_time_s<<std::endl;
        std::cout<<"Counters: dT, datagram, marker, markerErr, hit, firstData: "<<elapsed_time_s<<" "<<m_datagramCounter<<" "<<m_markerCounter<<" "<<m_markerErrCounter<<" "<<m_hitCounter<<" "<<m_firstDataCounter<<std::endl;
        //std::cout<<"Rates: datagram, marker, markerErr, hit: "<<m_datagramCounter/elapsed_time_s<<" "<<m_markerCounter/elapsed_time_s<<" "<<m_markerErrCounter/elapsed_time_s<<" "<<m_hitCounter/elapsed_time_s<<std::endl;

        if (m_stopMainLoop) {
            break;
        }
    }
    m_stopMainLoop = false;
    delete[] markerSRS;

}


/**
 * begin
 */
void UDPBrokerDerived::begin() {
    m_stopMainLoop = false;
    m_pauseMainLoop = false;
    m_hitCounter = 0;
    m_datagramCounter = 0;
    m_markerCounter = 0;
    m_markerErrCounter = 0;
    m_firstDataCounter = 0;
    m_startChrono = true;
    m_start = std::chrono::high_resolution_clock::now();


    std::map<int, std::unique_ptr<CDataSink>>::iterator it = m_dataSinks.begin();

    //std::map<int, std::unique_ptr<CDataSink>>::const_iterator it = UDPBrokerBase::getSinks().begin();
    //while (it != UDPBrokerBase::getSinks().end()) {


    // CRingStateChangeItem begin(BEGIN_RUN, 123, 0, std::time(nullptr), "This is a title");
    // CRingStateChangeItem end(END_RUN, 123, 1, std::time(nullptr), "This is a title");


//     (uint16_t reason,
// uint32_t runNumber,
// uint32_t timeOffset,
// time_t   timestamp,
// std::string title)
    
    while (it != m_dataSinks.end()) {
        // CRingStateChangeItem* pBegin = new CRingStateChangeItem(BEGIN_RUN);
        CRingStateChangeItem* pBegin = new CRingStateChangeItem(BEGIN_RUN, 66, 0, std::time(nullptr), "This is a title");
        it->second->putItem(*pBegin);
        delete pBegin;
        ++it;
    }
}


/**
 * end
 */
void UDPBrokerDerived::end() {
    m_pauseMainLoop = true;

    std::map<int, std::unique_ptr<CDataSink>>::iterator it = m_dataSinks.begin();
    
    while (it != m_dataSinks.end()) {
    //std::map<int, std::unique_ptr<CDataSink>>::const_iterator it = UDPBrokerBase::getSinks().begin();
    //while (it != UDPBrokerBase::getSinks().end()) {
        // CRingStateChangeItem* pEnd = new CRingStateChangeItem(END_RUN);
        CRingStateChangeItem* pEnd = new CRingStateChangeItem(END_RUN, 66, 30, std::time(nullptr), "This is a title");
        it->second->putItem(*pEnd);
        delete pEnd;
        ++it;
    }

    //clear markers 
    for (size_t idx = 0; idx < MaxFECs * MaxVMMs; idx++) {
        markerSRS[idx].fecTimeStamp = 0;
        markerSRS[idx].calcTimeStamp = 0;
        markerSRS[idx].lastTriggerOffset = 0;
        markerSRS[idx].hasDataMarker = false;
        startedMarker[idx] = false;
    }
}

/**
 * stop mainLoop
 */
void UDPBrokerDerived::stop() {
    m_stopMainLoop = true;
}

/**
 * pause mainLoop
 */
void UDPBrokerDerived::pause() {
    std::cout << "UDPBrokerDerived::pause() " << std::endl;
    m_pauseMainLoop = true;
}

/**
 * resume mainLoop
 */
void UDPBrokerDerived::resume() {
    std::cout << "UDPBrokerDerived::resume() " << std::endl;
    m_pauseMainLoop = false;
}



// void UDPBrokerDerived::makeRingItems(in_addr_t from, short port, const CDataSink& sink, int sid, uint8_t* buffer, size_t nBytes) {
void UDPBrokerDerived::makeRingItems(in_addr_t from, short port, CDataSink& sink, int sid, uint8_t* buffer, size_t nBytes) {

    size_t bytes = nBytes;
    int readoutIndex = 0;

    while (bytes >= HitAndMarkerSize) {
        //printf("readoutIndex: %d, bytes %d\n", readoutIndex, bytes);
        // The datagram send from the slow controler has only srsHeader and data
        auto dataOffset = SRSHeaderSize + HitAndMarkerSize * readoutIndex;

        // std::unique_ptr<uint8_t[]> data(new uint8_t[HitAndMarkerSize]);
        std::unique_ptr<uint8_t[]> data(new uint8_t[HitAndMarkerSize + 2]);
        memcpy(data.get(), buffer + dataOffset, HitAndMarkerSize);

        tsAndMappedChno.hitTimeStamp = 0;
        tsAndMappedChno.chnoMapped = 0;
        extractHitTimeStamp(sid, data.get());

        uint16_t chnoMapped = tsAndMappedChno.chnoMapped;
        memcpy(data.get() + HitAndMarkerSize, &chnoMapped, sizeof(chnoMapped));

        // if ((int)chnoMapped > 256)
        //     std::cout<<"makeRingItems bit rep of data3: "<<std::bitset<16>( chnoMapped )<< " " <<(int)chnoMapped<<std::endl;
        
        // testReadData(data.get());

        if (tsAndMappedChno.hitTimeStamp > 0){
            //printf("send ring item \n");
            CRingItem* pResult = new CRingItem(PHYSICS_EVENT, tsAndMappedChno.hitTimeStamp, sid, 0, nBytes + 1024);
            pResult->setBodyCursor(pResult->getBodyCursor()); // Set cursor to beginning of body
            // Copy the 6 bytes of data into the CRingItem's body
            memcpy(pResult->getBodyCursor(), data.get(), HitAndMarkerSize + 2);
            // Update cursor after copy
            pResult->setBodyCursor(reinterpret_cast<uint8_t*>(pResult->getBodyCursor()) + HitAndMarkerSize + 2);
            pResult->updateSize();
            sink.putItem(*pResult); 
            delete pResult;
            //if (m_startChrono){
            //  m_start = std::chrono::high_resolution_clock::now();
            //  m_startChrono = false;
            //}
            m_hitCounter += 1;
        }
        else {
            m_markerCounter +=1 ; 
        }
        bytes -= HitAndMarkerSize;
        readoutIndex++;
    }
}



uint16_t UDPBrokerDerived::invertByteOrder(uint16_t data) {
    uint8_t lowerHalf = data & 0x00FF;
    uint8_t upperHalf = (data & 0xFF00) >> 8;
    return (lowerHalf << 8) | upperHalf;
}


void UDPBrokerDerived::testReadData(uint8_t* data){
    auto Data2Offset = Data1Size;
    auto Data3Offset = Data2Offset + Data2Size;
    uint16_t data2 = htons(*reinterpret_cast<uint16_t*>(&data[Data2Offset]));
    uint16_t data3 = htons(*reinterpret_cast<uint16_t*>(&data[Data3Offset]));
    // uint16_t data3 = ntohs(*reinterpret_cast<uint16_t*>(&data[Data3Offset]));
    int dataflag = (data2 >> 15) & 0x1;

    // printf("testReadData - dataflag: %d \n",dataflag);

    if (dataflag) {
        uint8_t chno = (data2 >> 8) & 0x3f;

        uint16_t chnoNew = invertByteOrder(data3);

        std::cout<<"bit rep of data2: "<<std::bitset<16>( data2 )<<std::endl;
        std::cout<<"bit rep of data3: "<<std::bitset<16>( data3 )<< " " <<(int)data3<<" "<<std::bitset<16>( chnoNew )<< " " <<(int)(chnoNew)<<std::endl;
        // std::cout<<"bit rep data2Copy : "<<std::bitset<16>(data2Copy)<<std::endl;
        // std::cout<<"bit rep data2Copy : "<<std::bitset<16>(data2Copy | ( (data2 >> 8 & 0xC0 | chnoCte) << 8) )<<std::endl;

        printf("testReadData - chno: %d \n",chno);
    }
    // return data;
    return;
}


void UDPBrokerDerived::setTriggerMode(int triggerIn, int invTrigger){
    if (invTrigger==1){
        m_triggerMode = 2;
    }
    else if (triggerIn==1){
        m_triggerMode = 1;
    }
    else {
        m_triggerMode = 0;
    }
    // std::cout<<"setTriggerMode - "<<triggerIn<<" "<<invTrigger<<std::endl;
}

void UDPBrokerDerived::setClockMode(int extClock){
    m_extClock = extClock;
    // std::cout<<"setClockMode - "<<extClock<<std::endl;
}

void UDPBrokerDerived::setClockPeriod(double period){
    m_clockPeriod = period;
    // std::cout<<"setClockPeriod - "<<period<<std::endl;
}
