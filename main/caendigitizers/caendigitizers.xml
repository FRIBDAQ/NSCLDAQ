<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>Support for CAEN digitizers</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>December 26, 2019</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
       <title>Introduction</title>
       <para>
            Support for a limited set of CAEN digitizers running either DPP-PHA
            or DPP-PSD firmware by CAEN and has been contributed back to
            NSCLDAQ as of version 12.0.
            This document describes:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              How to build NSCLDAQ with this optional support included and the
              software pre-requisistes needed to perform this build.
           </para>
        </listitem>
        <listitem>
           <para>
              An overview of the support. 
           </para>
        </listitem>
        <listitem>
           <para>
              How to create a readout program for DPP-PHA digitizers. 
           </para>
        </listitem>
        <listitem>
           <para>
              How to create a readout program for DPP-PSD digitizers
           </para>
        </listitem>
        <listitem>
           <para>
              How to create a readout program that mixes DPP-PHA and DPP-PSD
              digitizers.
           </para>
        </listitem>
        <listitem>
           <para>
              How to configure the ReadoutGUI and event builder to use these
              devices.
           </para>
        </listitem>
        <listitem>
           <para>
              Guidance on writing SpecTcl event processors for this sort of data. 
           </para>
        </listitem>
       </itemizedlist>
    </chapter>
    <chapter>
       <title>Overview</title>
       <para>
            Support for the CAEN digitizers is provided through classes that
            allow the SBSreadout skeleton to read data from synchronized sets
            of these digitizers.  Separate class sets have been made availabl for
            the DPP-PHA and DPP-PSD digitizers.
       </para>
       <para>
        Each of these digitizers has a large number of parameters that must be
        set up properly to optimize pulse processing performed on-board.
        CAEN supplies a setup/acquisition tool called COMPASS which can be
        used to configure these parameters and see the effect of parameter
        set choices on spectra produced by the digitizers.
       </para>
       <para>
        COMPASS is available for free download from <ulink url='http://caen.it' />.
        COMPASS can work with single digitizers or with groups of digitizers and
        can be used to create parameter sets for synchronized sets of digitizers.
        These parameter sets are written to XML configuration files.
       </para>
       <para>
        The NSCLDAQ support classes set up the digitizers they manage by processing
        the XML configuration files that were written by COMPASS.   These configuration
        files are processed at the start of each run, allowing the digitizer settings
        to be modified beteween runs.
       </para>
       <para>
         Data from digitizers consists of a sequence of time ordered events from
         each independent digitizer.  Each digitizer event represents data from
         a single channel.  Channel events are timestamped.  The sorted event
         streams from each digitizer must be merged into a single time ordered
         stream of channel events and then coincident events built into meaningful
         events.
       </para>
       <para>
          The NSCL Event builder was created for exactly that purpose.  THerefore,
          when the SBS readout program has been tailored to read CAEN digitizer
          events, each digitizer card is assigned a unique source id.  This
          allows the NSCL Event builder to merge and glom events across
          all digitizers.  
       </para>
       <para>
        We will say more about the special requirements for using the SBS readout
        program with the NSCLDAQ Event builder in a later chapter.
       </para>
    </chapter>
    <chapter id='dpppha-evtseg'>
       <title id='dpppha-evtseg-title'>Creating event segments for DPP-PHA digitizers</title>
       <para>
        This chapter describes how to create a version of the SBS readout program
        that can setup and read data from the DPP-PHA digitizers.  The steps you
        need to follow are roughly:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              Use CAEN COMPASS to setup the digitizers, including using its
              synchronization wizard to set up several digitizers to run in
              a synchronized manner.  This part of the procedure is beyond the
              scope of this document.
           </para>
        </listitem>
        <listitem>
           <para>
              Obtain a copy of the DPP-PHA skeleton. 
           </para>
        </listitem>
        <listitem>
           <para>
              Edit the skeleton code to include the digitizers you want to
              read.
           </para>
        </listitem>
        <listitem>
           <para>
              Compile and test the code you've written. 
           </para>
        </listitem>
        <listitem>
           <para>
              Configure the ReadoutGUi to run the event builder to build events
              from the channel events that are produced by the Readout.
              This will be described in a later chapter.
           </para>
        </listitem>
       </itemizedlist>
       <para>
        In addition to describing this process we'll also provide a definition
        of the structure of the bodies of ring items produced by the resulting
        readout.
       </para>
       <section>
          <title>Obtaining a copy of the DPP-PHA skeleton.</title>
          <para>
            If you've set up the environment variables for the version of
            NSCLDAQ you are using, you can get a copy of the DPP-PHA skeleton
            code by creating a new empty directory, making it your current working
            directory and issuing the command:
          </para>
          <informalexample>
            <programlisting>
cp $DAQROOT/skeletons/dpp-pha/* .
            </programlisting>
          </informalexample>
          <para>
            This should result in the following files:
          </para>
          <variablelist>
            <varlistentry>
               <term><filename>Skeleton.h</filename></term>
               <listitem>
                   <para>
                    The header for the skeleton application class that
                    defines your event segments scaler banks and triggers.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><filename>Skeleton.cpp</filename></term>
               <listitem>
                   <para>
                    Implementation of the skeleton.  This file will need to
                    be modified by you to match your experimental needs.
                    The modifications you need to make will be described in the
                    next section.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><filename>Makefile</filename></term>
               <listitem>
                   <para>
                    Makefile for the program.  This is a modified version of the
                    SBSReadout Makefile that already includes the directives
                    needed to properly compile and link the skeleton as is with
                    the CAEN DPP-PHA support libraries. 
                   </para>
                   <para>
                    You may need to modify this file if:
                   </para>
                   <itemizedlist>
                    <listitem>
                       <para>
                          You require additional external libraries. 
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          You are combining the readout with DPP-PSD digitizers.
                          This is described in a separate chapter.
                       </para>
                    </listitem>
                   </itemizedlist>
                </listitem>
            </varlistentry>
          </variablelist>
          <caution>
            <title>You cannot mix CAEN DPP digitizers with non CAEN digitizers</title>
            <para>
                The readout requirements of the CAEN DPP digitizers are
                unique enough that you cannot mix reading out the CAEN digitizers
                with non-CAEN digitizers in a single Readout program.  What you
                can do, however is read CAEN Digitizers via the CONET fiber optic
                link and have a second readout program read the non CAEN DPP
                digitizers via a VME controller from the same VME crate using,
                an SBS VME bus bridge or VMUSBReadout with a VM-USB controller.
            </para>
        </caution>
        <para>
                Once you've copied the skeleton, you can optionally build it
                to create an empty readout:
        </para>
        <informalexample>
            <programlisting>
make
            </programlisting>
        </informalexample>
       </section>
       <section>
          <title>Edits you must make to the DPP-PHA skeleton</title>
          <para>
            In this chapter we will take alook at the edits you will have to
            make to the <filename>Skeleton.cpp</filename> file to create an
            actual working Readout program.  As you look at the existing file,
            note that it is an example of a fully functional readout. Therefore
            you'll need to remove/modify existing as well as to add new lines of
            code.
          </para>
          <para>
            Briefly what you will need to do is:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  Create a new <classname>CompassEventSegment</classname>  for
                  each digitzer board in your system. 
               </para>
            </listitem>
            <listitem>
               <para>
                  Create a <classname>CompassMultiModuleEventSegment</classname>
                  and add the
                  <classname>CompasEventSegment</classname> objects you made
                  to it.
               </para>
            </listitem>
            <listitem>
               <para>
                  Create a <classname>CompassTrigger</classname>  object and
                  add all the boards to it.
               </para>
            </listitem>
            <listitem>
               <para>
                  Establish your <classname>CompassMultiModuleEventSegement</classname>
                  as the experiment's event segment and your
                  <classname>CompassTrigger</classname> object as the event
                  trigger.
               </para>
            </listitem>
          </itemizedlist>
          <para>
            Let's take a look at the sample <filename>Skeleton.cpp</filename>'s
          </para>
          <example>
            <title>DPP-PHA's <methodname>SetupReadout</methodname> method.</title>
            <programlisting>
void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
  CReadoutMain::SetupReadout(pExperiment);

  // Create an event segment for each board:
  CompassEventSegment* pBoard1 =                           <co id='phaCompassSegment' />
    new CompassEventSegment("./compass-settings.xml", // Compass config file.
                            1,                     // Module evb source id.
                            CAEN_DGTZ_USB,
                            0, 0, 0x22220000, "cheats.txt");

  CompassMultiModuleEventSegment *mainSegment =           <co id='phaCompassMultiseg' />
    new CompassMultiModuleEventSegment;

  mainSegment-&gt;addModule(pBoard1);                     <co id='phaCompassMultiAddBoard' />



  // Establish your trigger here by creating a trigger object
  // and establishing it.

  // The trigger needs to know about all modules too:

  CompassTrigger* pTrigger = new CompassTrigger;        <co id='phaTrigger' />
  pTrigger-&gt;addModule(pBoard1);                      <co id='phaTriggerAddBoard' />

  // Create and add your event segments here, by creating them and invoking CExperiment's
  // AddEventSegment

  pExperiment-&gt;AddEventSegment(mainSegment);         <co id='phaAddSegment' />
  pExperiment-&gt;EstablishTrigger(pTrigger);           <co id='phaEstTrigger' />


}

            </programlisting>
          </example>
          <calloutlist>
            <callout arearefs='phaCompassSegment' >
                <para>
                    For each CAEN DPP-PHA digitizer board you are using, you
                    must create a <classname>CompassEventSegment</classname>.
                    This class is responsible for configuring the board and
                    reading it out.
                </para>
                <para>
                    Here's the declaration of the constructor for this
                    class:
                </para>
                <constructorsynopsis>
                    <methodname>CompassEventSegment</methodname>
                    <methodparam>
                        <type>std::string</type><parameter>filename</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>int</type><parameter>sourceid</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>CAEN_DGTZ_ConnectionType</type><parameter>linkType</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>int</type><parameter>linknum</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>int</type><parameter>node</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>int</type><parameter>base</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>const char*</type><parameter>pCheatFile</parameter>
                        <initializer>nullptr</initializer>
                    </methodparam>
                </constructorsynopsis>
                <para>
                    These parameters have the following meaning:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><parameter>filename</parameter></term>
                       <listitem>
                           <para>
                            The name of the file created by COMPASS to configure
                            the digitizers. Note that this file, in general,
                            can contain the configuration for several digitizers.
                            The connection parameters that follow
                            will be matched against segments of this file to
                            locate the configuration for this board
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>sourceId</parameter></term>
                       <listitem>
                           <para>
                            From the event builder's perspective, each digitizer
                            is an event source and must be assigned a unique
                            source id.  This parameter provides that source id.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>linkType</parameter></term>
                       <listitem>
                           <para>
                            Defines how the digitizer is connected to the system.
                            The enumerated type provides several values, but in
                            practice only two are useful:
                            <literal>CAEN_DGTZ_USB</literal>  indicates
                            the digitizers are in a VME crate that is controlled by
                            a CAEN V1718 VME bus bridge.  Tempting as it may be,
                            this type does <emphasis>not</emphasis> support
                            VM-USB controllers.  <literal>CAEN_DGTZ_OpticalLink</literal>
                            indicates that the digitizers are either directly
                            connected to a CONET card/daisychain (recommended)
                            or controlled via a V2718 controller (not recommended).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>linkNum</parameter></term>
                       <listitem>
                           <para>
                            The link number connected to the digitizer.  This is
                            <literal>0</literal> if the link type is
                            <literal>CAEN_DGTZ_USB</literal> and the
                            CONET link number if <literal>CAEN_DGTZ_OpticaLink</literal>.
                            For each CONET interface board in the computer, the links
                            are numbered from 0 from the top tab of the
                            board to the bottom of the board.  See e.g.
                            <ulink url='https://www.caen.it/wp-content/uploads/2017/10/A3818_both_big2.jpg' />
                            for a diagram.
                           </para>
                           <para>
                            For multiple CONET board, trial and error may be
                            needed to determine which set of links each board
                            controls.  In any event at that point you might
                            want to use several readout computers so that
                            the I/O and computing bandwidth of the host is
                            not exceeded.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>node</parameter></term>
                       <listitem>
                           <para>
                            This must be <literal>0</literal> for connection
                            type <literal>CAEN_DGTZ_USB</literal>.
                            For <literal>CAEN_DGTZ_OpticaLink</literal>, each
                            link can support a daisy chain of up to targets, or
                            nodes. The nodes are numbered sequentially from 0 to
                            7 as they occur along the daisy chain.  Refer to
                            3.2 of the A3818 user manual for more information
                            about setting up a CONET daisy chain.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>base</parameter></term>
                       <listitem>
                           <para>
                            If the digitizers are controlled via a VME controller,
                            this parameter is their base address in the VME
                            bus.  The module's base addresses are configured
                            via rotary switches on the board. See the user
                            manual for the V1730 or V1725, figure 7.2 for
                            the location and meaning of these rotary switches.
                           </para>
                           <para>
                            Each digitizer must specifiy a unique, non-overlapping
                            address space in its VME bus.
                           </para>
                           <para>
                            If the link type is <literal>CAEN_DGTZ_OpticaLink</literal>,
                            this must be zero.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>cheatFile</parameter></term>
                       <listitem>
                           <para>
                            The Compass XML file specifies how to configure
                            the digitizer.  In some cases, it may be desirable
                            or necessary to tweak register values after the
                            digitizer is initialized but before acquisition
                            is started.  
                           </para>
                           <para>
                            This parameter provides the ability to specify
                            a <firstterm>cheat file</firstterm>. The cheat file
                            allows you to perform these tweaks.  If this parameter
                            is null (the default), no cheats are performed.
                            Otherwise, this specifies the path to the cheat file.
                           </para>
                           <para>
                            The cheat file format id described in the section
                            <xref endterm='cheatfile' linkend='cheatfile' />
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </callout>
            <callout arearefs='phaCompassMultiseg' >
                <para>
                    Digitizer readout is controlled by a 
                    <classname>CompassMultimoduleEventSegment</classname>.
                    This line constructs one of those.  You must put your
                    <classname>CompassEventSegment</classname> instances into
                    one of these, even if you are only reading a single digitizer.
                </para>
            </callout>
            <callout arearefs='phaCompassMultiAddBoard' >
                <para>
                    Shows how to add a board to the
                    <classname>CompassMultiModuleEventSegment</classname>
                    instance.
                </para>
            </callout>
            <callout arearefs='phaTrigger' >
                <para>
                    The event trigger is implemented by polling for data
                    ready in any of the digitizer boards in the system.  This
                    is done by a <classname>CompassTrigger</classname> object
                    that is created here.
                </para>
            </callout>
            <callout arearefs='phaTriggerAddBoard' >
                <para>
                    The <classname>CompassTrigger</classname> object needs
                    to know about all of the boards in order to know how
                    to poll for a trigger.  This line adds the board
                    we created to the trigger. You must do this for every
                    <classname>CompassEventSegment</classname> you created and
                    added to the <classname>CompassMultiModuleEventSegment</classname>.
                </para>
            </callout>
            <callout arearefs='phaAddSegment' >
                <para>
                    The <classname>CompassMultiModuleEventSegment</classname>
                    instance must be set as the event segment for the Readout.
                    You should only create and set one of these otherwise
                    each trigger may produce ring items with several channel hits
                    and those may not build into proper events.
                </para>
            </callout>
            <callout arearefs='phaEstTrigger' >
                <para>
                    Similarly, your <classname>CompassTrigger</classname> object
                    must be set as the experiment's trigger.
                </para>
            </callout>
          </calloutlist>
       </section>
       <section>
          <title>Compiling and testing</title>
          <para>
            The skeleton program comes with a Makefile that is easy to modify
            for your own purposes.  Normally this Makefile does not need to
            be modified as combining CAEN DPP digitizers with other modules
            is not supported by this Readout framework (DPP-PHA and DPP-PSD
            may be combined and we'll get to that later).
          </para>
          <para>
            The lines that cane be modified in the unlikely circumstance that you
            need to are:
          </para>
          <informalexample>
            <programlisting>
USERCCFLAGS=$(CAENCXXFLAGS) 
...
USERLDFLAGS=$(CAENLDFLAGS)

            </programlisting>
          </informalexample>
          <para>
            The <literal>USERCCFLAGS</literal> variable can be modified to add
            more compilation flags.  Do not remove the <literal>$(CAENCXXFLAGS)</literal>
            macro invocation from this definition as this macro supplies flags that
            are necessary to compile the the DPP-PHA readout Skeleton.cpp file.
          </para>
          <para>
            The <literal>USERLDFLAGS</literal> variable can be modified to add
            more linker flags.  Again, do no remove the <literal>$(CAENLDFLAGS)</literal>
            macro invocation.  It supplies loader directives to link in
            the libraries needed by the CAEN DPP-PHA readout program.
          </para>
          <para>
            In the unlikely event that you add more source files to the
            Readout program, modify the <literal>OBJECTS</literal>
            definition, adding your additional desired objects.
            These will be compiled with the USERCCFLAGS and linked into the
            Readout program using the USERLDFLAGS you've defined.
          </para>
          <para>
            Use the command:
          </para>
          <informalexample>
            <programlisting>
make
            </programlisting>
          </informalexample>
          <para>
            To compile and link your program.  Prior to running it be sure the
            compass configuration file(s) you refer to have been created where
            your objects expect them.
          </para>
          <para>
            You can now run the program, either by itself or under the
            NSCL Readout GUI (to use an event builder) and use
            $DAQBIN/dumper to look at some of the events.
            The next section describes the format of the data read out by
            the DPP-PHA event segments.
          </para>
       </section>
       <section>
          <title>Structure of data read by the DPP-PHA skeleton</title>
          <para>
            This section describes the format of the data readout by the DPP-PHA
            readout program.  Note that usually, individual channel hits are
            assembled into events using the NSCL event builder.  The wrapping
            of data by the  NSCL Event builder is beyond the scope of this document.
            See the NSCLDAQ event builder documentation for that information.
          </para>
          <para>
            Before going into the event structure in detail, a note about timestamps.
            The V725 and V730 boards have a different timestamp clock rate.
            The readout framework adjusts the timestamps from both boards
            so that the event is tagged with a timestamp in nanoseconds.  This
            allows the event builder to properly build data from these boards
            (and e.g. XIA DDAS boards as well) correctly).
          </para>
          <para>
            Here's a text picture of the structure of each hit's body:  Note that
            the body header contains the source id, which in turn tells you
            which module this packet comes from.
          </para>
          <example>
            <title>DPP-PHA event structure.</title>
            <programlisting>
+----------------------------------+
| Event Size in bytes (uint32_t)   |
+----------------------------------+
| Channel number (uint32_t)        |
+----------------------------------+
|     Time tag (uint64_t) in ns    |  <co id="dpp-pha-timetag" />
+----------------------------------+
|     Energy (uint16_t)            |  <co id="dpp-pha-packing" />
+----------------------------------+
|     Extras 1  (uint16_t)         |  <co id ="dpp-pha-extras" />
+----------------------------------+
|     Extras 2 (uint16_t)          |
+----------------------------------+
| ... optional waveform data       |  <co id="dpp-pha-optionalwf" />
|       ....                       |
            </programlisting>
          </example>
          <calloutlist>
            <callout arearefs='dpp-pha-timetag' >
                <para>
                    This is not the raw time tag from the digitizer.
                    The digitizer has a 32 bit timestamp with
                    an optional 16 bit extension that could be
                    put in the one of the extras (see below).
                    This timestamp can only cover a relatively short
                    period of time (a few seconds).  Therefore,
                    the readout program tracks wrap arounds (this is
                    fine as long as there are not two wraps between
                    hits), and calibrates the resulting tag to
                    nanoseconds.  This value is the 64 bit nanosecond
                    timestamp that also accounts for raw stamp
                    rollovers.
                </para>
            </callout>
            <callout arearefs='dpp-pha-packing' >
                <para>
                    A quick note that there are no pad words.
                    Event data is tight packed.
                </para>
            </callout>
            <callout arearefs='dpp-pha-extras' >
                <para>
                    In addition to the results of the DPP algorithm,
                    extra words can be included in the data
                    depending on how the digitizer is configured.
                    These two words are called Extras 1 and
                    Extras 2. Their contents depend on how you've
                    configured the digitizer.
                </para>
            </callout>
            <callout arearefs='dpp-pha-optionalwf' >
                <para>
                    Waveform data can be included.  Up to two
                    traces of data can be put into the event
                    depending on the configuration of the digitzer.
                    Waveform data may also be completely
                    suppressed, if that's how the digitizer
                    is configured.  The form of waveform data
                    is shown below:
                </para>
            </callout>
          </calloutlist>
          <example>
            <title>DPP-PHA waveform data</title>
            <programlisting>
+-----------------------------+
| No. of Samples (uint32_t)   |
+-----------------------------+
|  Dual trace flag (uint16_t) |
+-----------------------------+
|  First trace                |   <co id='dpp-pha-trace1' />
    ....
+-----------------------------+
|  Optional second trace      |   <co id='dpp-pha-trace2' />
     ....
+-----------------------------+
            </programlisting>
          </example>
          <para>
            The digitizer can record two waveforms per channel.
            The contents of these waveforms depends on the
            digitizer configuration. The waveform packet
            begins with a uint32_t that contains the number of
            samples in each trace (if there are two traces both
            have the same number of samples).  If no traces
            are recorded, this value is 0.
          </para>
          <para>
            Following the number of samples is a dual trace flag.
            This is present even if no waveforms are being recorded.
            This flag is nonzero if waveforms are being recorded
            and there will be two of them.  Otherwise, this flag
            is zero.
          </para>
          <calloutlist>
            <callout arearefs='dpp-pha-trace1' >
                <para>
                    This packet of contains one uint16_t trace
                    value per sample.  Naturally, if the number of
                    samples is zero, there will be no data words here.
                </para>
            </callout>
            <callout arearefs='dpp-pha-trace2' >
                <para>
                    This packet is only present if the dual trace
                    flag is nonzero.  It contains the second trace.
                    Note, once more this contains a 16 bit integer
                    per trace value.  This is omitted if the  number
                    of samples is zero or the dual trace flag is
                    zero but the number of samples is
                    nonzero.
                </para>
            </callout>
          </calloutlist>
       </section>
       <section>
        <title id='cheatfile'>Cheat files</title>
        <para>
            Sometimes there are tweaks  you will want to make to the
            digitizer configuration that are not supported by
            Compass or not well supported by the implementation at this
            time.  Once the digitizer is configured but before it is
            started, you can optionally process a
            <firstterm>cheat file</firstterm>
        </para>
        <para>
            The cheat file specifies changes to the configuration
            of the digitizer.  The cheat file is optionally
            specified when the digitizer is constructed. If
            omitted, no cheats will be applied.  Each cheat
            file line consists of three space separated fields.
        </para>
        <orderedlist>
            <listitem>
               <para>
                  The first field is a single character that
                  specifies an operation.
               </para>
            </listitem>
            <listitem>
               <para>
                  The second field is an address, usually a register
                  address.
               </para>
            </listitem>
            <listitem>
               <para>
                  The final field is a value. 
               </para>
            </listitem>
        </orderedlist>
        <para>
            Cheat files can also have empty lines and lines that
            begin with a <literal>#</literal>.  These lines are
            ignored.
        </para>
        <para>
            Here are the operations and what they do:
        </para>
        <variablelist>
            <varlistentry>
               <term><literal>.</literal></term>
               <listitem>
                   <para>
                    The address is the address of a register.
                    The value is set into the register.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>|</literal></term>
               <listitem>
                   <para>
                    The address is the address of a register.
                    The value is bitwise ored into the register's
                    current value.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>*</literal></term>
               <listitem>
                   <para>
                    The address is the address of a register.
                    The value is bitwise anded with the register.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>i</literal></term>
               <listitem>
                   <para>
                    The address is a channel number.
                    The value is one of the
                    legal values of its pile up rejection counters
                    in the digitizer. The value can
                    be 128, 1024, or 8192.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>t</literal></term>
               <listitem>
                   <para>
                    The address is ignored. The value is a proposed
                    value for the module's aggregate transfer
                    threshold.  This is the second parameter to
                    the function
                    <function>CAEN_DGTZ_SetDPPEventAggregation</function>
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
       </section>
    </chapter>
    <chapter>
       <title>Creating event segments for DPP-PSD digitizers</title>
       <para>
        The DPP-PSd firmware allows CAEN digitizers to perform
        pulse shape discrimination.  This involves integrating
        the background subtracted pulse within two integration
        windows, a short and a long window.
       </para>
       <para>
        This chapter will describe how to create event segments for
        the DPP-PSD firmware in CAEN x730 and x725 modules.  While
        it is possible to mix DPP-PSD and DPP-PHA modules it is not
        possible to mix CAEN DPP modules with other types of
        modules in the same Readout program.  Mixing
        DPP-PSD and DPP-PHA modules will be described in the
        next chapter.
       </para>
      <para>
            This chapter is divided into the following sections:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  First we describe how to get the skeleton for DPP-PSD
                  readout.
               </para>
            </listitem>
            <listitem>
               <para>
                   Next we describe how to modify the skeleton to readout the
                   set of digitizers you are using.
               </para>
            </listitem>
            <listitem>
               <para>
                  We describe how to build the resulting Readout program.
               </para>
            </listitem>
            <listitem>
               <para>
                  Finally we describe the structure of events readout
                  from the DPP-PSD digitizers.
               </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Obtaining the DPP-PSD skeleton</title>
            <para>
                The DPP-PSD readout is a specialized version of the SBS readout
                skeleton.  An event segment class has been written to support
                individual board and an over-arching event segment manages the
                collection of boards in the system.  
            </para>
            <para>
                To obtain the skeleton readout program create an empty
                directory and cd into it then, if the DAQROOT environment
                variable points to the top level installation directory
                of your NSCLDAQ installation:
            </para>
            <informalexample>
                <programlisting>
cp $DAQROOT/skeletons/dpp-psd/* .
                </programlisting>
            </informalexample>
            <para>
                Copies the skeleton files into the current working directory.
                This comprises the following files:
            </para>
            <variablelist>
                <varlistentry>
                   <term><filename>Skeleton.h</filename></term>
                   <listitem>
                       <para>
                        Header for the skeleton code file.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><filename>Skeleton.cpp</filename></term>
                   <listitem>
                       <para>
                        Skeleton source code you must modify.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><filename>Makefile</filename></term>
                   <listitem>
                       <para>
                        Makefile to build the Readout program.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
           <title>Modifying the DPP-PSD skeleton</title>
           <para>
            Let's start by looking at the skeleton's
            implementation of the <methodname>SetupReadout</methodname>
            method.  Then we'll describe in general what you need to do
            to build a multi-board system.
           </para>
           <example>
            <title>DPP-PSD <methodname>SetupReadout</methodname> skeleton implementation</title>
            <programlisting>
void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
  CReadoutMain::SetupReadout(pExperiment);

  CDPpPsdEventSegment* pSegment =                <co id='psd-board' />
    new CDPpPsdEventSegment(PSDBoardParameters::usb, 0, 0, 0x33330000, 1, "../settings.xml");
  CPsdCompoundEventSegment*  pCompound = new CPsdCompoundEventSegment(); <co id='psd-mgmnt' />
  pCompound-&gt;addModule(pSegment);               <co id='psd-addmodule' />

  pExperiment-&gt;AddEventSegment(pCompound);      <co id='psd-establishsegment' />

  CPsdTrigger* pTrigger = new CPsdTrigger;      <co id='psd-trigger' />
  pTrigger-&gt;addModule(pSegment);                <co id='psd-addtrigger' />
  pExperiment-&gt;EstablishTrigger(pTrigger);      <co id='psd-esttrigger' />

}

            </programlisting>
           </example>
           <para>
            If you've looked at the DPP-PHA skeleton you'll see significant
            differences.  The DPP-PSD skeleton was written second and I tried
            to learn from the experience of building the DPP-PHA skeleton,
            however many of the concepts are identical.
           </para>
           <calloutlist>
            <callout arearefs='psd-board' >
                <para>
                    Every digitizer board in the system must have a
                    corresponding <classname>CDPpPsdEventSegment</classname>
                    object createdto manage it. The parameters to the constructor
                    establish the connection parameters to the digitizer,
                    it's source id and the COMPASS configuration file
                    that contains its configuration.
                </para>
                <para>
                    Here's the formal declaration of that class's constructor>
                </para>
                <constructorsynopsis>
                    <methodname>CDPpPsdEventSegment</methodname>
                        <methodparam>
                            <type>PSDBoardParameters::LinkType </type><parameter>linkType</parameter>
                            <initializer></initializer>
                        </methodparam>
                        <methodparam>
                            <type>int</type><parameter>linkNum</parameter>
                            <initializer></initializer>
                        </methodparam>                    
                        <methodparam>
                            <type>int </type><parameter>nodeNum</parameter>
                            <initializer></initializer>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>base</parameter>
                            <initializer></initializer>
                        </methodparam>   
                        <methodparam>
                            <type>int</type><parameter> sourceid</parameter>
                            <initializer></initializer>
                        </methodparam>
                        <methodparam>
                            <type>const char* </type><parameter>configFile</parameter>
                            <initializer></initializer>
                        </methodparam>
                </constructorsynopsis>
                <para>
                    The parameters of the constructor are as follows:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><parameter>linkType</parameter></term>
                       <listitem>
                           <para>
                            This can be either
                            <literal>PSDBoardParameters::usb</literal> if the
                            connection to the digitizer is either usb to a
                            desktop digitizer or to a CAEN V1718 USB VME
                            controller, or <literal>PSDBoardParameters::conet</literal>
                            if the connection to the digitizer is either
                            direct CONET (optical fiber) or via a CAEN V2718
                            optical CVME crate controller.  For high rate applications,
                            I recommend direct CONET connection.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>linknum</parameter></term>
                       <listitem>
                           <para>
                            If the link type is PSDBoardParameters::usb, this
                            should be zero.  Otherwise, this is the number of the
                            link the fiber optic connecting to either this
                            digitizer or its V2718 crate controller.
                            See <ulink url='https://www.caen.it/wp-content/uploads/2017/10/A3818_both_big2.jpg' />
                            for information that describes how to determine the
                            linkid on a single CONET interface card.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>base</parameter></term>
                       <listitem>
                           <para>
                            If the digitizers are VME cards controlled by either
                            a V1718 or V2718 controller, this parameter is the
                            VME base address assigned to the module via its
                            rotary switches.  Each card must have a unique
                            base address and its address space must not overlap
                            any other cards in the system.  If the digitizers
                            are directly connected to CONET, this must be
                            zero.
                           </para>
                        </listitem>
                    </varlistentry>
                    
                    <varlistentry>
                       <term><parameter>nodeNum</parameter></term>
                       <listitem>
                           <para>
                            Each CONET link can service up to eight digitizers
                            by daisy chaining the fiber optics.  The Tx
                            fiber goes from the interface to the Rx input
                            of the node 0 and the Tx Fiber then goes from
                            the Tx of that board to the Rx of node 1 and
                            so on until the Tx of the last board goes back to the
                            Rx input of the interface board.
                           </para>
                           <para>
                            The nodes on this ring network are numbered from 0
                            to 7 starting with the first board connected to the
                            Tx of the interface board. Refer to
                            3.2 of the A3818 user manual for more information
                            about setting up a CONET daisy chain and how
                            the nodes are numbered along the chain.
                            For USB connections this should also be zero.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>sourceid</parameter></term>
                       <listitem>
                           <para>
                            This is the source id that will be assigned to hits
                            from the channels on this board.  Each board in the
                            entire system must have a unique source id.
                            This source id will be used by the NSCL event builder
                            to weave together hits from several modules into
                            events.
                           </para>
                           <para>
                            If you are mixing data from CAEN digitizers
                            with other data sources, again
                            <emphasis>every</emphasis> data source
                            in the system must have a unique
                            source id.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>configFile</parameter></term>
                       <listitem>
                           <para>
                            Is the path to the configuration file that was
                            used to configure the digitizer in COMPASS.  This
                            configuration file can be used for several digitizers.
                            The connection parameters in the configuration file
                            will be matched against the configuration parameters
                            for this board to determine which board configuration
                            to use.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </callout>
            <callout arearefs='psd-mgmnt' >
                <para>
                    Board readout is managed by a
                    <classname>CPsdCompundEventSegment</classname>.  Therefore
                    you must instantiate exactly one of these to manage the
                    readout from the devices.
                </para>
            </callout>
            <callout arearefs='psd-addmodule' >
                <para>
                    Each module object must be added to the
                    <classname>CPsdCompoundEventSegment</classname>
                    so that it knows it must configure and readout
                    the board.
                </para>
            </callout>
            <callout arearefs='psd-establishsegment' >
                <para>
                    The <classname>CPsdCompoundEventSegment</classname>
                    must then be established as the experiment's
                    event segment.
                </para>
            </callout>
            <callout arearefs='psd-trigger' >
                <para>
                    The trigger for reading data is that at
                    least one digitizer has data available to read.
                    The <classname>CPsdTrigger</classname> class,
                    is therefore instantiated to fairly poll
                    the triggers in the digitizers.
                </para>
            </callout>
            <callout arearefs='psd-addtrigger' >
                <para>
                    <classname>CPsdTrigger</classname> also needs
                    to know about the individual
                    <classname>CDPpPsdEventSegment</classname>
                    objects as it polls data availability by
                    asking each segment if it is ready to be read out.
                </para>
            </callout>
            <callout arearefs='psd-esttrigger' >
                <para>
                    Finally the <classname>CPsdTrigger</classname>
                    object is established as the event trigger
                    for the Readout program.
                </para>
            </callout>
           </calloutlist>
           <para>
            Thus preparing a Skeleton consists of:
           </para>
           <orderedlist>
            <listitem>
               <para>
                  Creating a <classname>CDPpPsdEventSegment</classname>  object
                  for each digitizer.
               </para>
            </listitem>
            <listitem>
               <para>
                  Creating a <classname>CPsdCompoundEventSegment</classname>
                  object to manage all <classname>CDPpPsdEventSegment</classname>
                  objects and adding each of those objects to the
                  <classname>CPsdCompoundEventSegment</classname> object and
                  finally adding the compound event segment to the experiment's
                  event segment.
               </para>
            </listitem>
            <listitem>
               <para>
                  Creating a <classname>CPsdTrigger</classname> object
                  to poll the boards to determine if they can be readout.
               </para>
            </listitem>
            <listitem>
               <para>
                  Add each board to the trigger object. 
               </para>
            </listitem>
            <listitem>
               <para>
                  Establish the <classname>CPsdTrigger</classname>  object
                  as the Readout's trigger.
               </para>
            </listitem>
           </orderedlist>
        </section>
        <section>
           <title>Building the DPP-PSD readout program</title>
           <para>
            Normally the Makefile provided with the skeleton is sufficient and
            does not require modification.  This is because the CAEN digitizers
            are multi-event buffered devices and it's not supported to
            operate them in conjunction with other devices.  An actual
            event might be read out in response to several re-triggerings
            across several channels in the same or different boards.
           </para>
           <para>
            If you do need to modify the skeleton to include additional
            files and, perhaps, include additional libraries, the following
            definitions in the Makefile can be modified:
           </para>
           <variablelist>
            <varlistentry>
               <term><literal>USERCCFLAGS</literal></term>
               <listitem>
                   <para>
                    This definition supplies the compilation
                    flags to the g++ compiler.  You can use
                    this to add include directories or define
                    pre-processor symbols or add any additional
                    compilation flags you need.
                   </para>
                   <para>
                    <emphasis>Do not</emphasis> remove the
                    <literal>$(CAENCXXFLAGS)</literal> from
                    that definition.  It is required for the
                    build to locate headers for the CAEN digitizer
                    support libraries.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>USERLDFLAGS</literal></term>
               <listitem>
                   <para>
                    This definition provides flags to the g++
                    command's dispatch of  <command>ld</command>
                    the linker.  If you need additional libraries,
                    or other link time flags and directives,
                    they can be appended to this definition.
                   </para>
                   <para>
                    <emphasis>Do not</emphasis> remove the
                    <literal>$(CAENLDFLAGS)</literal> from this
                    definition as it specifies the libraries
                    and other link directives needed to
                    link in the CAEN digitizer support libraries.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>OBJECTS</literal></term>
               <listitem>
                   <para>
                    Provides the names of additional objects to link
                    into the final Readout.  Append to this if you
                    have additional source or pre-built object
                    modules you need.  
                   </para>
                   <para>
                    Unless you specify exact build rules for
                    the objects from source, the g++ will be
                    used for files with C++ extensions and
                    gcc for files with C extensions.  The
                    compilation flags will be determined by
                    both rules in the centralized
                    <filename>$DAQROOT/ect/SBSRdoMakeIncludes</filename>
                    file and the <literal>USERCCFLAGS</literal>.
                   </para>
                   <para>
                    If you have other requirements you may, of course
                    specifiy a dependency and associated Makefile
                    build rule.  Doing this is beyond the scope of
                    this document.  See primers on gnumake
                    for more information about how to do that.
                   </para>
                </listitem>
            </varlistentry>
           </variablelist>
           <para>
            Once the Makefile is to your liking:
           </para>
           <informalexample>
            <programlisting>
make
            </programlisting>
           </informalexample>
           <para>
            Will build your tailored Readout program. After you've
            fixed any compilation errors you can either run the
            Readout program directly on the system interfaced to the
            digitizers or set up the program to run as a
            data source with the ReadoutShell
           </para>
        </section>
        <section>
           <title>Event format from the DPP-PSD readout.</title>
           <para>
            This section describes the format for each hit
            (channel event) from the PSD digitizers.  Normally,
            hits are sent to an event builder where they are wrapped
            in event builder headers and bundled into events
            that consist of hits that have occured within some
            time period of a first hit.
           </para>
           <para>
            This section will describe the raw body of hits
            produced by the Readout program prior to event building.
            Each event is a ring item of type
            <literal>PHYSICS_EVENT</literal>.   These events
            have the standard body header that carries the
            timestamp and source id among other things.
            The actual body of the event follows the body header
            and has the following structure:
           </para>
           <example>
            <title>Format of DPP-PSD event bodies</title>
            <programlisting>
+-----------------------------------+
| Size of hit body (uint32_t)       |
+-----------------------------------+
| Raw cumulative timestamp uint64_t |  <co id='psdstruct-stamp' />
+-----------------------------------+
| channel number (uint16_t)         |
+-----------------------------------+
|  Short gate charge (uint16_t)     |
+-----------------------------------+
|  Long gate charge (uint16_t)      |
+-----------------------------------+
|  Baseline (uint16_t)              |
+-----------------------------------+
| Pile up rejection flag (uint16_t) |
+-----------------------------------+
| Wave form data ...  see below     |
       ...
+-----------------------------------+
            </programlisting>
           </example>
            <calloutlist>
                <callout arearefs='psdstruct-stamp' >
                    <para>
                        The timestamp in the raw hit from the digitizer
                        is 32 bits wide and is in digitizer
                        size specific units.   This has two problems.
                        First, 32 bits of timestamp only allow for
                        a few seconds of run time before the timestamp
                        rolls over.  Second, device specific units of
                        the raw timestamp would make event building
                        with a heterogeneous set of digitizers
                        impossible.  The event builder expects
                        all data sources to be running at the same
                        timestamp frequency.
                    </para>
                    <para>
                        The timestamp in the event body is computed
                        using wrap detection and a carry counter to
                        produce a true 64 bit timestamp in the
                        device units.   This timestamp is accurate
                        as long as the channel it comes from
                        does not roll over more than once between
                        hits.
                    </para>
                    <para>
                        The resulting timestamp is then multiplied by
                        the number of nanoseconds per digitizer
                        timestamp tick and the resulting timestamp
                        in nanoseconds is put into the event's body
                        header.   The event builder only cares
                        about the body header.  This allows all digitizers
                        to present timestamps with a common time base
                        (nanosecond units) to the event builder.
                    </para>
                    <para>
                        Note that the software supporting XIA
                        Pixie16 modules also presents body header
                        timestamps in nanosecond units making it
                        possible to directly build XIA and
                        CAEN digital data acquisition system event
                        fragments together.
                    </para>
                </callout>
            </calloutlist>
            <para>
                The remainder of the event structure should be
                self explanatory from the description of the
                digitizer, with the exception of the waveform
                data.  Note that the digitizer this hit came
                from can be deduced from the source id located
                in the hit's body header.
            </para>
            <para>
                The digitizers can be told to acquire waveforms.
                The structure of waveform data is as follows:
            </para>
            
            
            <example>
                <title>DPP-PSD waveform data</title>
                <programlisting>
+-------------------------------------------+
|  sample Size of waveform data (uint32_t)  | <co id='psdfmt-wfsize' />'
+-------------------------------------------+
|  Number of samples     (uint32_t)         | <co id='psdfmt-trlen' />
+-------------------------------------------+
|  Dual trace (uint8_t)                     | <co id='psdfmt-dt' />
+-------------------------------------------+
|  Analog probe selector (uint8_t)          | <co id='psdfmt-aprobe' />
+-------------------------------------------+
|  Trace 1 (no samples * uint16_t)          |
+-------------------------------------------+
|  Optional Trace2 (no samples *uint16_t)   | <co id='psdfmt-tr2' />
+-------------------------------------------+
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='psdfmt-wfsize' >
                    <para>
                        Provides the number of bytes of waveform
                        data.  The size is inclusive of this
                        longword.
                        Note that if there is not waveform
                        data, this will be <literal>sizeof(uint32_t)</literal>.
                        That indicates there is no data following the
                        size word.
                    </para>
                </callout>
                <callout arearefs='psdfmt-trlen' >
                    <para>
                        This  and subsequent words are only present
                        if there is trace data
                        (the prior longword is not sizeof(uint32_t)).
                        In that case, this is the number of samples
                        in each trace.  Note that in dual trace mode,
                        both traces have the same number of samples,
                        making it unecessary to have two trace lengths.
                    </para>
                </callout>
                <callout arearefs='psdfmt-dt' >
                    <para>
                        This byte is non-zero if there are two traces
                        or zero if only one.
                    </para>
                </callout>
                <callout arearefs='psdfmt-aprobe' >
                    <para>
                        This word along with the dual trace flag
                        describes the meaning of the data in the trace(s).
                        This is essentially the value of the
                        board configuration register bits 12,13.
                        The meaning of these bits depends on whether
                        dual trace is enabled.
                    </para>
                    <para>
                        If dual trace is not enabled, a value of zero
                        means the trace is the input waveform.
                        A value of 1 means the trace is the CFD
                        waveform.
                    </para>
                    <para>
                        If dual trace is enabled;
                        A value of zero means the first trace
                        is the input waveform while the second trace
                        is the runnning baseline determination.  A value
                        of 1 means that the first trace is the CFD and
                        the second trace, again the running baseline
                        determination. A value of 2 means that the
                        first trace is the input waveform and the second
                        trace the CFD.
                    </para>
                    <para>
                        If only it were that simple.  The
                        CFD trace is only available if CFD discrimination
                        is enabled.  If it is disabled, then the
                        "CFD" trace is actually the smoothed input
                        trace.
                    </para>
                </callout>
                <callout arearefs='psdfmt-tr2' >
                    <para>
                        Note that the second trace is not present unless
                        the dual trace flag is nonzero.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </chapter>
    <chapter>
        <title>Creating Readouts that mix DPP-PSD and DPP-PHA segments</title>
        <para>
            There are two ways to mix DPP-PSD and DPP-PHA event segments.
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  Use one readout program for the DPP-PHA digitizers
                  and a second for the DPP-PSD digitizers.
               </para>
            </listitem>
            <listitem>
               <para>
                  Use a single readout and combine the data from
                  both digitizers.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that whichever you choose, you must determine which
            of the digitizers is the master timing source on the
            daisy chain and configure both types of digitizers
            accordingly.  Using the COMPASS synchronization
            wizard can help you with this.
        </para>
        <para>
            If you use two readouts, you can stil have a common
            XML configuration file as both programs can locate
            their digitizers from within the XML configuration and
            will ignore digitizers they've not been told about.
        </para>
        <para>
            The remainder of this chapter will describe how to
            merge data from both digitizers into a single readout
            program.  Briefly here are the steps to follow:
        </para>
        <itemizedlist>
           <listitem>
              <para>
                 Obtain the DPP-PSD skeleton. 
              </para>
           </listitem>
           <listitem>
              <para>
                 Add appropriate <literal>#include</literal>
                 definitions to pull in the class headers you need
                 from the DPP-PHA framework.
              </para>
           </listitem>
           <listitem>
              <para>
                 Edit the skeleton to make DPP-PSD event segments
                 and a <classname>CDPpPsdCompoundEventSegment</classname>
                 as you normally would for configuring
                 the the skeleton
              </para>
           </listitem>
           <listitem>
              <para>
                 Add to that configuration the
                 <classname>CompassEventSegment</classname> objects
                 and <classname>CompassMultiModuleEventSegment</classname>
                 as you normally would for the DPP-PHA skeleton.
              </para>
           </listitem>
           <listitem>
              <para>
                Create a <classname>COneOnlyEventSegment</classname>
                object and insert into it both the
                <classname>CDPpPsdCompoundEventSegment</classname>
                and the <classname>CCompassMultiModuleEventSegement</classname>
                you created in the previous steps.
                Register that object as Readout's event segment.
              </para>
           </listitem>
           <listitem>
              <para>
                 Create and fill both <classname>CPsdTrigger</classname>
                 and <classname>CompassTrigger</classname> objects
                 as you would for the DPP-PSD and DPP-PHA
                 skeletons.
              </para>
           </listitem>
           <listitem>
              <para>
                 Create a <classname>CCompoundTrigger</classname>
                 object and insert both the DPP-PHA and DPP-PSD
                 trigger objects into it. Then register
                 this compound trigger object as the event trigger.
              </para>
           </listitem>
           <listitem>
              <para>
                 Note the DPP-PSD skeleton already links both the
                 DPP-PSD and PP-PHA support libraries so no
                 modification should be required.
              </para>
           </listitem>
        </itemizedlist>
        <para>
         The remaining sections of this chapter:
        </para>
        <itemizedlist>
         <listitem>
            <para>
               Show the extra <literal>#include</literal>
               directives you need to add to the top
               of the DPP-PSD <filename>Skeleton.cpp</filename>
            </para>
         </listitem>
         <listitem>
            <para>
               Provide a sample edit of Skeleton.cpp to
               manage a single DPP-PSD and DPP-PHA module.
            </para>
         </listitem>
         <listitem>
            <para>
               Show the Makefile edits required to build
               the resulting Readout program.
            </para>
         </listitem>
        </itemizedlist>
        <section>
            <title>Include additional Headers in the skeleton</title>
            <para>
                In order to merge modules we need to add the
                following preprocessor <literal>#include</literal>
                directives to the top of the Skeleton.cpp amongst
                the other <literal>#include</literal> directives:
            </para>
            <example>
                <title>Combining DPP-PSD and DPP-PSD Skeleton headers</title>
                <programlisting>

#include &lt;COneOnlyEventSegment.h&gt;        <co id='comb-oohdr' />


#include &lt;CompassTrigger.h&gt;
#include &lt;CompassMultiModuleEventSegment.h&gt;
#include &lt;CompassEventSegment.h&gt;         <co id='combo-phahdr'/>
#include &lt;CompassProject.h&gt;
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='comb-oohdr' >
                    <para>
                        This header brings in the class we'll
                        use to combine the two compound event
                        segments for the PHA and PSD boards.
                        We'll have more to say about it when
                        we look at the edits to
                        <methodname>SetupReadout</methodname>
                    </para>
                </callout>
                <callout arearefs='combo-phahdr' >
                    <para>
                        These headers just include the set of
                        class headers included in the
                        DPP-PHA skeleton.  They give us access
                        to the classes we need to create DPP-PHA
                        board, event segment and trigger objects.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
           <title>Editing the <methodname>SetupReadout</methodname> method</title>
           <para>
            Now let's look at the combined
            <methodname>SetupReadout</methodname> implementation.
            If you're not yet familiar with building Readout programs
            that can read DPP-PSD and DPP-PHA modules by themselves,
            become familiar now.  This discussion assumes that
            familiarity.
           </para>
           <example>
            <title>Implementing <methodname>SetupReadout</methodname> combining DPP-PSD and DPP-PHA modules</title>
            <programlisting>
void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
  CReadoutMain::SetupReadout(pExperiment);
                                          <co id='comb-dpp-psd' />
  CDPpPsdEventSegment* pPsdBoard =
    new CDPpPsdEventSegment(PSDBoardParameters::usb, 0, 0, 0x33330000, 1, "../settings.xml");
  CPsdCompoundEventSegment*  pPsd = new CPsdCompoundEventSegment();
  pPsd-&gt;addModule(pPsdBoard);

                                         <co id='comb-dpp-pha' />
  CompassEventSegment* pPhaBoard = 
    new CompassEventSegment("./settings.xml", // Compass config file.
			    1,                     // Module evb source id.
			    CAEN_DGTZ_USB, 
			    0, 0, 0x22220000);
  
  CompassMultiModuleEventSegment *pPha = 
    new CompassMultiModuleEventSegment;

  pPha-&gt;addModule(pPhaBoard);

  COneOnlyEventSegment* pCombined = new COneOnlyEventSegment; <co id='comb-comb-seg' />
  pCombined-&gt;addModule(pPsd);                              <co id='comb-comb-psd' />
  pCombined-&gt;addModule(pPha);                              <co id='comb-comb-pha' />

  pExperiment-&gt;AddEventSegment(pCombined);                <co id='comb-estseg' />

  CPsdTrigger* pPsdTrigger = new CPsdTrigger;                <co id='comb-psdtrig' />
  pPsdTrigger-&gt;addModule(pPsdBoard);
  CompassTrigger* pPhaTrigger = new CompassTrigger;          <co id='comb-pha-trig' />
  pPhaTrigger-&gt;addModule(pPhaBoard);

  CCompoundTrigger* pTrigger = new CCompoundTrigger;       <co id='comb-combtrigger' />
  pTrigger-&gt;addTrigger(pPsdTrigger);                    <co id='comb-combpsd-trig' />
  pTrigger-&gt;addTrigger(pPhaTrigger);                    <co id='comb-combpha-trig' />

  pExperiment-&gt;EstablishTrigger(pTrigger);              <co id='comb-esttrig' />
  
}

            </programlisting>
           </example>
           <calloutlist>
            <callout arearefs='comb-dpp-psd' >
                <para>
                    This section of code creates an event segment with a
                    single DPP-PSD board. You can expand that code to have
                    as many DPP-PSD boards as you need.
                </para>
            </callout>
            <callout arearefs='comb-dpp-pha' >
                <para>
                    Similarly, this section of code creates an event segment
                    with a single DPP-PHA board.  You can expand that cde
                    to have as many DPP-PHA boards as you need.
                </para>
            </callout>
            <callout arearefs='comb-comb-seg' >
                <para>
                    The <classname>COneOnlyEventSegment</classname> class
                    is a container for event segments.  The SBS readout framework
                    supplies a compound event segment already, but that segment
                    glues all contained event segments that have data to supply
                    into a single event. This is not suitable for use
                    here as we want each hit to live in its own ring item.
                </para>
                <para>
                    The <classname>COneOnlyEventSegment</classname>, like the
                    compound event segments for DPP-PHA or DPP-PSD segments
                    stops asking event segments for data once one of them
                    supplies data.   Like the DPP-PHA and DPP-PSD segments,
                    it does a round robbin polling to ensure that
                    DPP-PSD does not starve out DPP-PHA or vica versa.
                </para>
            </callout>
            <callout arearefs='comb-comb-psd' >
                <para>
                    Here we add the DPP-PSD compound event segment we generated
                    to the overall compound segment for the event.
                </para>
            </callout>
            <callout arearefs='comb-comb-pha' >
                <para>
                    Similarly we add the DPP-PHA segment.
                </para>
            </callout>
            <callout arearefs='comb-estseg' >
                <para>
                    Finally the <classname>COneOnlyEventSegment</classname>
                    compound event segement is set as the experiments event
                    segment.  
                </para>
            </callout>
            <callout arearefs='comb-psdtrig' >
                <para>
                    A PSD trigger is created as before and the PSD modules
                    added to it.
                </para>
            </callout>
            <callout arearefs='comb-pha-trig' >
                <para>
                    Similarly a PHA trigger is created and the PHA module
                    added to it.
                </para>
            </callout>
            <callout arearefs='comb-combtrigger' >
                <para>
                    A compound trigger is a container trigger. It's trigger
                    check method will return the OR of all of its component
                    triggers.  Creating this trigger object allows us to
                    combine the trigger for both the PSD and PHA
                    modules.
                </para>
            </callout>
            <callout arearefs='comb-combpsd-trig' >
                <para>
                    Adds the PSD trigger to the compound trigger object.
                </para>
            </callout>
            <callout arearefs='comb-combpha-trig' >
                <para>
                    Similarly adds the PHA trigger to the compound trigger
                    object.
                </para>
            </callout>
            <callout arearefs='comb-esttrig' >
                <para>
                    Establishing the compound trigger as the event trigger
                    allows the Readout to initiate a readout if either a
                    PHA module or a PSD module have data.
                </para>
            </callout>
           </calloutlist>
        </section>
        <section>
           <title>Makefile edits required.</title>
           <para>
            By using the PSD Readout as a starting point, both the DPP-PHA
            and DPP-PSD support libraries are linked into the Readout.
            At this point in time, the same is
            <emphasis>not</emphasis> the case for the PHA readout skeleton.
           </para>
           <para>
            If you use the PSD readout as a starting point, no Makefile
            changes are needed.
           </para>
        </section>
    </chapter>
    <chapter>
       <title>Configuring the Event builder and ReadoutGUI to create events.</title>
       <para>
        CAEN Digitizer Readout programs treat each module in the sysem as a unique
        data source.   Each module produces a time ordered sequence of
        hits.  But the data read across modules does not guarantee a totally
        time ordered set of fragments across all modules in the system.
       </para>
       <para>
        Treating each module as a separate data source requires a few special
        bits of handling when setting up the event builder.
       </para>
       <itemizedlist>
        <listitem>
           <para>
              Since Readout only issues one Begin run and End run ring item, but has
              several data sources, the Readout program must be configured to
              not mark these records with a barrier type.  Otherewise at the
              start and end of each run, the event builder will stall on
              a barrier wait until there's a barrier timeout.
           </para>
        </listitem>
        <listitem>
           <para>
              The source id given to the Readout program should match one of the
              module sourceids.  That ensures that the non physics hit ring items
              (Begin run, end run, pause run, esuem run, scaler, trigger count),
              are emitted with a source id that is one of the module sourceids.
              This is a best practice, you can use an additional source id just
              for those records.  See below, however.
           </para>
        </listitem>
        <listitem>
           <para>
              The ring fragment source(s) for the event builder must be
              configured to accept data from all source ids their Readout's
              emit.
           </para>
        </listitem>
       </itemizedlist>
       <para>
            Let's look at an example where the Readout program has
            three modules, configured for source id 1, 2 and 3.
            The Readout program must haved the following command line options
            specified in its data source specification in the ReadoutShell:
        </para>
        <variablelist>
            <varlistentry>
               <term><option>-ring</option></term>
               <listitem>
                   <para>
                    As usual this must be supplied and should specify
                    a ring buffer into which the raw hit data will be put.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>--sourceid</option></term>
               <listitem>
                   <para>
                    As a best practice, this should specify one of the
                    source ids (e.g. <literal>1</literal>) configured
                    for one of the module event segment objects.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>--no-barriers</option></term>
               <listitem>
                   <para>
                    Turns off barrier synchronization.
                    This must be specified for <emphasis>ALL</emphasis> readout
                    programs in the event builder, not just the CAEN ones.
                    If any Readout program doesn not have this flag, the
                    event builder will stall until a barrier timeout at all
                    run state transitions.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The ReadoutGUI's <filename>ReadoutCallouts.tcl</filename> file
            specifies both the use of the event builder and ring fragment
            sources that will take data from the raw ring item rings, package
            them up and send them off to the event builder.
        </para>
        <para>
            The form of the command used to specify how ring fragment
            sources are started is:
        </para>
        <informalexample>
            <programlisting>
::EVBC::registerRingSource sourceURI tstamplib ids info ?expectHeaders? ?oneshot? ?timeout? ?timeoffset?
            </programlisting>
        </informalexample>
        <para>
            Used with the CAEN Digitizer library, the <parameter>ids</parameter>
            parameter must specify all parameter ids as a well formatted
            Tcl list.  Suppose we have the Readout program described
            above (source ids 1,2,3), putting data in tcp://spdaq20/caenraw.
            We would need to register a ring fragment source as follows:
        </para>
        <example>
            <title>Specifying the ring fragment source for a CAEN digitizer collection</title>
            <programlisting>
::EVBC::registerRingSource tcp://spdaq20:/caenraw "tstamplib"" \
                                    [list 1 2 3] "CAEN_DIGITIZERS" 1 1
            </programlisting>
        </example>
        <para>
            Note how the source ids is a list of the source ids emitted
            by the Readout program.  We've also specified that the ring fragment
            source operates only for a single run.  This is suitable for cases
            when you've specified the event builder will start up fresh for each
            new run.
        </para>
    </chapter>
    <chapter>
        <title>caendump</title>
        <para>
            When troubleshooting a configuration it can sometimes be useful
            to look at the contents of digitizer registers.  <filename>caendump</filename>
            is a program that provide that dump.
        </para>
        <para>
            Here's the usage text you get if you just issue the command
            <command>$DAQBIN/caendump</command>
        </para>
        <informalexample>
            <programlisting>
Can't find registers.txt - register definition file
Usage
   caendump linktype linknum node [base]
     linktype: 0 USB, 1 Optical
     base is needed if the link is to a VME bus bridge and is
     the module's base address
     Note the file registers.txt will be read in in the cwd to
     decide which registers to dump.

            </programlisting>
        </informalexample>
        <para>
            Note the first line.  It says that there must be a file
            named <filename>registers.txt</filename> must exits
             in the current working directory.   This file describes the
             registers you want to dump.  The file is a text file that is
             made up of lines that contain three fields.  In order:
        </para>
        <variablelist>
            <varlistentry>
               <term>The textual name of the register</term>
               <listitem>
                   <para>
                    This should not have any whilespace.  Legal examples:
                    <literal>Acquisition</literal> or
                    <literal>DPP_Control</literal>.
                    <literal>DPP Control</literal> is not legal.
                   </para>
                   <para>
                    This text labels the data dumped for that register.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>The register address.</term>
               <listitem>
                   <para>
                    For VME interfaces, this is the offset from the module
                    base address at which the register is located. You can get this
                    value from the CAEN register level documentation for the
                    module, which you need to interpret the output in any event.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>Per channel flag</term>
               <listitem>
                   <para>
                    Some registers have an instance per channel.  These have
                    base addresses in the CAEN documentation that look like
                    <literal>anbc</literal> where, a,b,c are hex digits
                    and n is the literal n.  For these registers,
                    specify a base address of <literal>a0bc</literal> and set
                    this flag to be 1 to dump all 16 registers.
                   </para>
                   <para>
                    For single registers, whose addresses are given in the form
                    <literal>abcd</literal>  where a,b,c and d are hex digits,
                    give the base address as documented and set the flag to 0.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The command line parameters for <filename>caendump</filename> supply
            the connection parameters to allow the program to access the
            desired digitizer.
        </para>
        <variablelist>
            <varlistentry>
               <term><literal>linktype</literal></term>
               <listitem>
                   <para>
                    Is the manner in which the digitizer is connected to the
                    host computer.  <literal>0</literal> should be used for
                    VME USB controllers or for USB connected desktop digitizers.
                    <literal>1</literal> should be used for optically connected
                    digitizers e.g. VME CONET controllers or digitizers directly
                    connected by fiber optics.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>linknum</term>
               <listitem>
                   <para>
                    The integer link number connected to the digitizer or
                    the VME interface controlling the digitizer crate. Refer
                    to the discussion in 
                    <link linkend='dpppha-evtseg' endterm='dpppha-evtseg-title' />
                    for constructing an event segment to determine the value of
                    this term.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>node</term>
               <listitem>
                   <para>
                    Used only in CONET connections. This is the node number
                    of the target on the CONET daisy chain.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>base</term>
               <listitem>
                   <para>
                    If the module is interfaced via a VME controller, this is
                    its VME base address configured into the module's rotary
                    switches.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        
    </chapter>
    <appendix>
        <title>
            Reference material
        </title>
        <para>
            For the most part, this material can be ignored by end users.
            This section is provided for completeness to document the set of
            classes and structs that form the support code.  
        </para>
        <para>
            This appendix is divided into two sections.  The first documents
            the DPP-PHA support clases and the second, the DPP-PSD support classes.
        
        </para>
        <section>
            <title>DPP-PHA support classes.</title>
            <para>
                The DPP-PHA support classes went through  couple of iterations.
                The first version was built to operate with the configuration files
                used by a discontinued CAEN Product called
                <literal>MC<superscript>2</superscript>A</literal>.  CAEN released the
                more functional COMPASS data acquisition tool.  The original
                customers then requested that the DPP-PHA support operate
                with the XML based configuration files written by that program.
            </para>
            <para>
                The original support therefore mostly still exists as a layer
                of code in this second iteration.  
            </para>
            <para>
                Note tht the pugixml library, included in the CAEN DPP support
                is used to do XML parsing.  For information about this
                library see
                <ulink url='https://pugixml.org/' />
            </para>
            <refentry>
               <refmeta>
                  <refentrytitle>CAENPhaChannelParameters</refentrytitle>
                  <manvolnum>3DPP-PHA</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CAENPhaChannelParameters</refname>
                  <refpurpose>Capture per channel parameters and their parsing.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CAENPhaCHannelParameters.h&gt;

class CAENPhaChannelParameters
{

public:
  CAENPhaChannelParameters(pugi::xml_document&amp; doc);
  CAENPhaChannelParameters() :  m_xml(empty) {}          // Default constructor
  CAENPhaChannelParameters(const CAENPhaChannelParameters&amp; rhs);
  CAENPhaChannelParameters&amp; operator=(const CAENPhaChannelParameters&amp; rhs);


  void unpack();

public:
  typedef enum _Polarity {positive, negative} Polarity;
  typedef enum _Coupling {ac, dc} Coupling;


  bool enabled;


  unsigned  dcOffset;
  unsigned  decimation;
  unsigned  digitalGain;
  Polarity  polarity;
  unsigned  range;


  double    decayTime;
  double   trapRiseTime;
  double   flattopDelay;
  double   trapFlatTop ;
  unsigned BLMean;
  unsigned trapGain;
  unsigned otReject;
  unsigned peakMean;
  double   baselineHoldoff;
  double   peakHoldoff;



  unsigned threshold;
  unsigned rccr2smoothing;
  double   inputRiseTime;
  double   triggerHoldoff;
  double   triggerValidationWidth;    
  bool     coincidenceWindow;        
  double   preTrigger;               



  bool     trResetEnabled;
  unsigned trGain;
  unsigned trThreshold;
  unsigned trHoldoff;


  bool       energySkim;
  unsigned   lld;
  unsigned   uld;
  bool       fastTriggerCorrection;
  bool       baselineClip;
  unsigned   baselineAdjust;
  double     acPoleZero;
  Coupling   inputCoupling;
  double     fineGain;


  bool psdCutEnable;
  double psdLowCut;
  double psdHighCut;
};

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>METHODS</title>
                      <para>
                        The following methods are provided for this class:
                      </para>
                      <variablelist>
                        <varlistentry>
                           <term>
                              <constructorsynopsis>
                                  <methodname>CAENPhaChannelParameters</methodname>
                                  <methodparam>
                                      <type>pugi::xml_document&amp;</type><parameter>doc</parameter>
                                      <initializer></initializer>
                                  </methodparam>
                              </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                  Constructs the object with a PugiXML document
                                  that will be used to parse the channel parameters.
                             </para>
                          </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                              <constructorsynopsis>
                                  <methodname>CAENPhaChannelParameters</methodname>
                                  <void />
                              </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                  Constructs an empty channel parameters object.
                                  This is normally used to create a placeholder
                                  that will be the target of an assignment later.
                             </para>
                          </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CAENPhaChannelParameters</methodname>
                                <methodparam>
                                    <type>const CAENPhaChannelParameters&amp;</type>
                                    <parameter> rhs</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Supports copy construction.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>CAENPhaChannelParameters&amp; </type>
                               <methodname>operator=</methodname>
                               <methodparam>
                                   <type>const CAENPhaChannelParameters&amp;</type>
                                   <parameter> rhs</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Supports assignment from another channel
                                parameters object.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>unpack</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Unpack the XML into the parameters.
                               </para>
                            </listitem>
                        </varlistentry>
                      </variablelist>
                </refsect1>
                <refsect1>
                    <title>
                        PUBLIC DATA and TYPES.
                    </title>
                    <para>
                        The configuration object contains a lot of configurtion
                        data for both the raw digitizer and the DPP algorithm.
                    </para>
                    <formalpara>
                        <title>Polarity enumerated type</title>
                        <para>
                            Provide allowed values for the signal polarity.
                            As you can imagine, the value of this type can be
                            either <literal>positive</literal> indicating the
                            signal has positive polarity or <literal>negative</literal>
                            indicating the signal is a negative going pulse.
                        </para>
                    </formalpara>
                    <formalpara>
                        <title>Copuling enumerated type</title>
                        <para>
                            Provides an enumerated type that specifies the input
                            coupling of the signal.  This can be either
                            <literal>ac</literal> or <literal>dc</literal>.
                        </para>
                    </formalpara>
                    <para>
                        The list below describes the member data that provides
                        the full parameterization of the digitizer channel.
                        Board level parameters are stored elsewhere.
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term><type>bool </type><varname>enabled</varname></term>
                           <listitem>
                               <para>
                                If <literal>false</literal> the channel is
                                completely disabled and will not respond
                                to triggers.  If <literal>true</literal>,
                                the channel is enabled to respond to triggers.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned  </type><varname>dcOffset</varname></term>
                           <listitem>
                               <para>
                                The DC offset that will be applied to the signal.
                                This is a value from <literal>0</literal>
                                through <literal>65535</literal> covering the
                                ADC range. 
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned </type><varname>decimation</varname></term>
                           <listitem>
                               <para>
                                If decimation is enabled, this is a selector
                                that selects the decimation factor.  It is
                                a value in the range [0..3].  A value of
                                <literal>0</literal> disables input decimation.
                                A value of <literal>1</literal> sets the decimation
                                to accept only every other sample.
                                A value of <literal>2</literal> selects a decimation
                                factor of 4 and a value of <literal>3</literal>
                                selects a decimation factor of 8.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned  </type><varname>digitalGain</varname></term>
                           <listitem>
                               <para>
                                Sets the digital gain value.  This is a value in
                                the range [0..3].  Where:
                                <literal>0</literal> means a digital gain of
                                1, <literal>1</literal> means a digital gain
                                of 2, <literal>2</literal> means a digitial gain
                                of 4 and <literal>3</literal> means a digital gain
                                of 8.  Note that the digital gain requires a
                                decimation of at least the gain value. Thuse
                                If you set this value to <literal>3</literal>,
                                the decimation must be either <literal>3</literal>
                                or <literal>4</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>Polarity  </type><varname></varname></term>
                           <term><type>Polarity  </type><varname>polarity</varname></term>
                           <listitem>
                               <para>
                                The input signal polarity.  Note that for
                                negative going signals it's necessary to
                                adjust the DC Offset so that the signal
                                will live in the dynamic range of the ADC.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned  </type><varname>range</varname></term>
                           <listitem>
                               <para>
                                Input range selector for the digitizer.
                                <literal>0</literal> selects 2Vpp range whle
                                <literal>1</literal> selects 0.5Vpp range.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double    </type><varname>decayTime</varname></term>
                           <listitem>
                               <para>
                                Describes the optimized signal decay time in us.
                                This will be converted to register units
                                by the software.  Note that the register units
                                are digitzer type dependent and are set in
                                register <literal>1x68</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double  </type><varname> trapRiseTime</varname></term>
                           <listitem>
                               <para>
                                The rise-time parameter of the trapezoidal filter.
                                The value is represented in microseconds and the
                                software will convert that to digitizer type
                                dependent register values stored in
                                register <literal>1n5c</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double   </type><varname>flattopDelay</varname></term>
                           <listitem>
                               <para>
                                Selects where in the flattop region
                                of the trapezoidal filter the energy
                                value is gotten.  This is expressed in microseconds
                                and converted to digitizer dependent units
                                by the software before being stored in register
                                <literal>0x1n64</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double   </type><varname>trapFlatTop </varname></term>
                           <listitem>
                               <para>
                                The width of the flattop expressed in microseconds.
                                The software will convert this to digitzer
                                dependent units which are stored in register
                                <literal>1n60</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned</type><varname> BLMean</varname></term>
                           <listitem>
                               <para>
                                Selects the baseline averaging window.  This is
                                a value in the range [0..6]:
                                <literal>0</literal> means there's no baseline
                                subtraction. <literal>1</literal> means
                                the baseline is based on a 16 sample running
                                average up until the baseline computation is
                                frozen.  <literal>2</literal> means the
                                baseline is a running average of 64 samples.
                                <literal>3</literal> means the baseline is a
                                running average of 64 samples, <literal>4</literal>
                                means the baseline is a running average of
                                <literal>1024</literal> samples,
                                <literal>5</literal> means the baseline is a
                                running average of 4096 samples an
                                <literal>6</literal> means the baseline
                                is a running average of 16384 samples.
                               </para>
                               <para>
                                This value is programmed into bits 20-22 of
                                register <literal>1n80</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned </type> <varname>trapGain</varname></term>
                           <listitem>
                               <para>
                                Become the value of the <structfield>enf</structfield> field  of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct,
                                the energy renormalization factor,
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned </type><varname>peakMean</varname></term>
                           <listitem>
                               <para>
                                Code selectin gthe nuber of samples for the peak
                                mean.  This is a value in the range [0..3]:
                                0 - 1 sample, 1 4 samples, 2 16 samples, 3 64 samples.
                                This becomes the <structfield>nspk</structfield>
                                field of the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double   </type><varname>baselineHoldoff</varname></term>
                           <listitem>
                               <para>
                                The baseline hold off in nanoseconds.  This becomes the
                                value of the <structfield>blho</structfield> field in
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double   </type><varname>peakHoldoff</varname></term>
                           <listitem>
                               <para>
                                The peak hold off in nanoseconds.  This becomes
                                the value of the <structfield>pkho</structfield>
                                field in
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type> unsigned </type><varname>threshold</varname></term>
                           <listitem>
                               <para>
                                The trigger threshold in digitizer conversion
                                units.  This becomes the
                                value of the <structfield>thr</structfield> 
                                field in
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned </type><varname>rccr2smoothing</varname></term>
                           <listitem>
                               <para>
                                The smootyhing factor for the trigger filter.
                                This is the number of samples averaged to
                                compute the value compared to the trigger
                                threshold.  This  becomes the
                                <structfield>a</structfield> fiedld of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                               </para>
                               <para>
                                This value has one of [value (meaning)]:
                                0 (no smoothing), 1 (2 samples), 4 (8 samples),
                                8 (16 samples), 16 (32 samples), 32 (64 samples),
                                127 (128 samples).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double   </type><varname>inputRiseTime</varname></term>
                           <listitem>
                               <para>
                                The input rise time of the expected pulses
                                in nanoseconds.  This becomes the
                                <structfield>b</structfield> field of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double   </type><varname>triggerHoldoff</varname></term>
                           <listitem>
                               <para>
                                The trigger hold off in nanoseconds.
                                This becomes the <structfield>trgho</structfield>
                                field of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double   </type><varname>triggerValidationWidth</varname></term>
                           <listitem>
                               <para>
                                The zero crossing acceptance window
                                for the Rise Time Discrimminator for pile up
                                rejection in samples.  Become the
                                <structfield>twwt</structfield> field of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double   </type><varname>preTrigger</varname></term>
                           <listitem>
                               <para>
                                Pretrigger in nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>bool </type><varname>energySkim</varname></term>
                           <listitem>
                               <para>
                                Becomes the <structfield>enskip</structfield>
                                field of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                                As of the rev 18 version of the CAENDigitizer library,
                                this is undocumented.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned   </type><varname>lld</varname></term>
                           <listitem>
                               <para>
                                Becomes the <structfield>eskimlld</structfield>
                                field of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                                As of the rev 18 version of the CAENDigitizer library,
                                this is undocumented.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned   </type><varname>uld</varname></term>
                           <listitem>
                               <para>
                                Becomes the <structfield>eskimhld</structfield>
                                field of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                                As of the rev 18 version of the CAENDigitizer library,
                                this is undocumented.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>bool       </type><varname>fastTriggerCorrection</varname></term>
                           <listitem> 
                               <para>
                                Becomes the <structfield>dcomp</structfield> field of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                                As of the rev 18 version of the CAENDigitizer library,
                                this is undocumented.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>bool      </type><varname> baselineClip</varname></term>
                           <listitem>
                               <para>
                                Becomes the <structfield>brlclip</structfield>
                                field of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                                As of the rev 18 version of the CAENDigitizer library,
                                this is undocumented.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned   </type><varname>baselineAdjust</varname></term>
                           <listitem>
                               <para>
                                Becomes the <structfield>trapbsl</structfield>
                                field of
                                the <type>CAEN_DGTZ_PHA_Params_t</type> struct
                                sent to <function>CAEN_DGTZ_SetDPPParameters</function>.
                                As of the rev 18 version of the CAENDigitizer library,
                                this is undocumented.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double     </type><varname>fineGain</varname></term>
                           <listitem>
                               <para>
                                Determines, in conjunction with the
                                desired fine gain, rise time
                                and decay time values, the value of register
                                <literal>1n4c</literal>, the fine gain
                                register.  See the description of ths register
                                 in the CAEN Register description for xx730/xx725
                                 digitizers with PHA firmware.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>

                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CAENPHa</refentrytitle>
                  <manvolnum>3DPP-PHA</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CAENPha</refname>
                  <refpurpose>Control a DPP-PHA digitizer.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CAENPha.h&gt;

class CAENPha
{


public:
  CAENPha(CAENPhaParameters&amp; config, CAEN_DGTZ_ConnectionType linkType, int linknum,
          int node, uint32_t base, CAEN_DGTZ_AcqMode_t startMode,
          bool trgout, unsigned delay, const char* pCheatFile=0);
  void setup();
  void shutdown();
  unsigned Getm_nsPerTick(); //Written by B.Sudarsan
  bool haveData();
  std::tuple&lt;int, const CAEN_DGTZ_DPP_PHA_Event_t*, const CAEN_DGTZ_DPP_PHA_Waveforms_t*&gt; Read();

  bool isMaster();        // True if board is master of chain.
  void startMaster();     // Start the master board (must be last).
  void startSlave();      // Start a slave board -- all must be done before master.


};

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        This class manages a single module.  It provides methods
                        that allow it to setup a module, shutdown
                        a module and get data.  Interfaces for trigger and
                        synchronization are also present.
                      </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CAENPha</methodname>
                                <methodparam>
                                    <type>CAENPhaParameters&amp; </type><parameter>config</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>CAEN_DGTZ_ConnectionType </type><parameter>linkType</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>linknum</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>node</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>uint32_t </type><parameter>base</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>CAEN_DGTZ_AcqMode_t </type><parameter>startMode</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>bool </type><parameter>trgout</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>unsigned </type><parameter>delay</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char*</type><parameter> pCheatFile</parameter>
                                    <initializer>0</initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                 Constructs a module control object. <parameter>config</parameter>
                                 provides the configuration of the digitizer as
                                 a whole as well as for each channel.
                                 <parameter>linkType</parameter>,
                                 <parameter>linknum</parameter>,
                                 <parameter>node</parameter> and
                                 <parameter>base</parameter> describe how the
                                 dgitizer is connected to the host computer.
                               </para>
                               <para>
                                <parameter>startMode</parameter> describes
                                how the digitizer is started.  The master
                                is started by software, all others in
                                a synchronized set are started by hardware
                                and signals triggered by the master startup.
                                <parameter>trgout</parameter> is true if the
                                trigger output will be used.
                                <parameter>delay</parameter> is a start delay.
                                This is used to get precise clock synchronization
                                by compensating for the increasing delays in
                                start propagation as you get more removed
                                down the start daisy chain from the master
                                module.
                               </para>
                               <para>
                                If a cheat file is required to adjust
                                register contents, the
                                <parameter>pCheatFile</parameter> can be provided
                                with the path to that file.  If omitted, no
                                cheat file will be processed.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>setup</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Called to initialize the digitizer. The digitizer
                                is initialized but not started.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type> void </type>
                               <methodname>shutdown</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Disables the digitizer.  This is normally
                                called as a data taking run is ended.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>Getm_nsPerTick</type>
                               <methodname></methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the number of nanoseconds per digitizer
                                clock period.  This is needed to compute
                                digitizer units for several parameters provided
                                by compass in nanosecond units.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>haveData</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Interface to support data based triggering
                                this returns true when the digitizer has
                                at least one hit in its data buffer memories.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::tuple&lt;int, const CAEN_DGTZ_DPP_PHA_Event_t*, const CAEN_DGTZ_DPP_PHA_Waveforms_t*&gt; </type>
                               <methodname>Read</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Reads the next event from the digiitzer.
                                Internal buffering is used. This event is
                                either satisified from the buffer or the
                                digitizer is read to re-fill the internal
                                buffer.  The tuple returned includes
                                the channel number of the hit. The hit
                                event data and any waveforms associated
                                with the hit.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>isMaster</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns true if this board is a master board.
                                This is determined by the start mode.  Master
                                boards haved software start modes.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>startMaster</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Starts the master board.  Prior to this
                                <methodname>startSlave</methodname>
                                must have been called on all the slave boards.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>startSlave</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Arms a slave board to be started when the start
                                signal it's programmed to use is detected.
                                The start sequence needed to get a synchronized
                                start is to start all the slave boards and
                                then start the master board.
                               </para>
                            </listitem>
                        </varlistentry>                        
                    </variablelist>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CAENPhaParameters</refentrytitle>
                  <manvolnum>3DPP-PHA</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CAENPhaParameters</refname>
                  <refpurpose>Encapsulate and parse all module configuration parameters.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CAENPhaParameters.h&gt;

class CAENPhaParameters {


public:
  CAENPhaParameters(
    pugi::xml_document&amp; m_dom,
    std::vector&lt;std::pair&lt;unsigned, pugi::xml_document*&gt;
    &gt;&amp; channelDoms);              // Unused....
  CAENPhaParameters() : m_dom(empty), m_channelDoms(emptyDoms), acqMode(1) {}  
  
public:
  void unpack();            // Unused.

public:
  typedef enum _CoincidenceOp   {
    Or, And, Majority
  } CoincidenceOp;
  typedef enum _TriggerControl {
    internal, external, both
  } TriggerControl;
  typedef enum _GPIOLogic {
    Logic_OR, Logic_AND
  } GPIOLogic;
  typedef enum _GPIODirection {
    input, output
  } GPIODirection;
  typedef enum _OutputSignal {
    On, Off
  } OutputSignal;


  typedef struct _ChannelCoincidenceSettings {
    unsigned            s_channel;
    bool                s_enabled;
    CoincidenceOp       s_operation;
    unsigned            s_mask;
    unsigned            s_majorityLevel;
    unsigned            s_window;
  } ChannelCoincidenceSettings, *pChannelCoincidenceSettings;


  int  acqMode;
  unsigned startDelay;
  double preTriggers;
  int    recordLength;
  std::vector &lt;ChannelCoincidenceSettings&gt; coincidenceSettings;

  bool         waveforms;
  bool         dualTrace;
  unsigned     analogTrace1;
  unsigned     analogTrace2;
  unsigned     digitalTrace1;
  unsigned     digitalTrace2;

  unsigned     maxEvtsBlt;
  unsigned     saveMask;
  unsigned     IOLevel;

  TriggerControl triggerSource;
  GPIOLogic      gpioLogic;
  int            transResetLength;
  int            transResetPeriod;

  typedef struct _GPIOGroupConfig {
    GPIODirection s_direction;
    OutputSignal  s_onoff;
    bool          s_dacinvert;
    int           s_dacoffset;
  } GPIOGroupConfig;

  GPIOGroupConfig groupconfigs[2];
  uint32_t        ioctlmask;        // Bits 16-19 of the FP I/O control reg.

  // With compass:


  CAEN_DGTZ_AcqMode_t s_startMode;
  double              s_timeOffset;    //nanoseconds to subtract from timestamp.

  // Decoded channel parameters.

  bool               m_includeCounters;
  std::vector&lt;std::pair&lt;unsigned, CAENPhaChannelParameters*&gt; &gt; m_channelParameters;


};


                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        This class contains the configuration of one DPP-PHA
                        module.  Note that the processing/parsing parts of this
                        class are obsolete and no longer used. See
                        <classname>CompassProject</classname> instead.
                      </para>
                      <para>
                        <classname>CompassProject</classname> decodes the COMPASS
                        configuration file and fills in this struct as well
                        as the <varname>m_channelParameters</varname> vector
                        that contains the channel configuration parameters
                        for each enabled channel.
                      </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CAENPhaParameters</methodname>
                                <methodparam>
                                    <type>pugi::xml_document&amp;</type><parameter>dom</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>std::vector&lt;std::pair&lt;unsigned, pugi::xml_document*&gt;</type><parameter></parameter>
                                    <initializer>&gt;&amp; channelDoms</initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                In the original support version that was based
                                on <command>MC2Analyzer</command>, only part of the
                                configuration was expressed by the textual
                                configuration files written for that program.
                                The additional configuration was read in via simple
                                XML configuration files.  This constructor
                                was coded for that purpose.  As such it is
                                deprecated.
                               </para>
                               <para>
                                <parameter>dom</parameter> is the parsed XML
                                file for the additional digitizer module level
                                configuration parameters not captured by MC2Analyzer.
                                <parameter>channelDoms</parameter> are the
                                parsed XML files for each enabled channel of the
                                digitizer containing per channel configuration
                                parameters not captured by MC2Analyzer's
                                configuration file.
                               </para>
                               <para>
                                Again, I want to stress that this constructor
                                is no longer used and is deprecated as we use
                                a different method to fill in this configuration
                                from COMPASS configuration files.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CAENPhaParameters</methodname>
                                <void />
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                The default  constructor is now used because
                                the COMPASSS configuration file is parsed
                                externally.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>unpack</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                This method is deprecated and must not be used
                                when the object is constructed using the
                                default constructor.  In the past, it
                                pulled configuration information out of the
                                XML doms constructed into the object and into
                                configuration variables for both the
                                module level and channel level configuration
                                parameters.
                               </para>
                            </listitem>
                        </varlistentry>        
                    </variablelist>
                    <para>
                        See <literal>DATATYPES</literal> and
                        <literal>PUBLIC ATTRIBUTES</literal> for more information
                        about the data we store in this object.
                        Note that this object now does not actually execute
                        code but servers as a data storage object whose data
                        are used at start up time to configure a digitizer.
                    </para>
                </refsect1>
                <refsect1>
                    <title>DATATYPES</title>
                    <para>
                        The data types exported are needed to express the values
                        of various, more complex, configuration parameters.
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term><type> typedef enum ... CoincidenceOp</type></term>
                           <listitem>
                               <para>
                                This enumerated type provides the sorts of
                                coincidence modes that are allowed at the
                                second level board trigger.  Allowed values are
                                <literal>Or</literal> for a trigger from either
                                channel of the couple, <literal>And</literal>
                                for a trigger requirement of both channels of
                                each couple and <literal>Majority</literal> to use
                                the majority level trigger.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type> typedef enum ... TriggerControl</type></term>
                           <listitem>
                               <para>
                                This enumerated type provides for an expression
                                of the trigger source. Valid values are
                                <literal>internal</literal>; in which case only
                                channel based triggers will trigger readout,
                                <literal>external</literal>; in which case
                                only external triggers will trigger readout or
                                <literal>both</literal> in which case either
                                an external or internal trigger will trigger
                                acquisition.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>typedef struct ChannelCoincidenceSettings</type></term>
                           <listitem>
                               <para>
                                Provides channel trigger information. This
                                consists of the following fields:
                               </para>
                               <variablelist>
                                    <varlistentry>
                                       <term><type>unsigned </type><varname>s_channel</varname></term>
                                       <listitem>
                                           <para>
                                            The channel number this struct
                                            describes.  Descriptions are sparse
                                             in the sense that disabled channels
                                             are not described. Thus each per
                                             channel data struct inidicats the
                                             channel it describes and all channels
                                             not described are just disabled.
                                           </para>
                                        </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                       <term><type>bool </type><varname>s_enabled</varname></term>
                                       <listitem>
                                           <para>
                                            This is
                                            <literal>true</literal>if the channel participates
                                             in coincidence/majority level
                                             triggering or <literal>false</literal>
                                             if not.
                                           </para>
                                        </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                       <term><type>CoincidenceOp </type><varname>s_operation</varname></term>
                                       <listitem>
                                           <para>
                                            Describes the type of coincidence
                                            trigger the channel participates in.
                                            This is used to set
                                            bits 8-9 of register 0x8180+4n
                                           </para>
                                        </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                       <term><type>unsigned </type>s_majorityLevel</term>
                                       <listitem>
                                           <para>
                                            The majority level for majority
                                            triggering.  Sets bits
                                            10-12 of register 0x8180+4n
                                           </para>
                                        </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                       <term><type>unsigned</type><varname>s_window</varname></term>
                                       <listitem>
                                           <para>
                                            The coincidence window for
                                            coincidence/majority  triggering.
                                            Used toset bits 20-23 of register
                                            0x810c
                                           </para>
                                        </listitem>
                                    </varlistentry>
                               </variablelist>
                            </listitem>
                        </varlistentry>
                    </variablelist>
    
                </refsect1>
                <refsect1>
                    <title>PUBLIC ATTRIBUTES</title>
                    <para>
                        The public methods of instances of this class are
                        filled in by the compass configuration file processor.
                        Note that several configuration parameters are defined
                        but don't appear to actually have meaning with respect
                        to the current board firmware.  Explanation of those
                        attributes are omitted for brevity.
                    </para>
                    <para>
                        These have the following meanings:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term><type>int </type><varname>acqMode</varname></term>
                           <listitem>
                               <para>
                                Flag that specifies the acquisition mode. Specifically,
                                a <literal>1</literal> here specifies that only
                                processed DPP data will be transferred to the
                                data buffer.   A value of zero means that in
                                addition to processed DPP data, selected trace
                                data will be inluded in the data buffer.
                                See <varname>dualTrace</varname> and
                                <varname>analogTrace1</varname> as well
                                as <varname>analogTrace2</varname> below.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned </type><varname>startDelay</varname></term>
                           <listitem>
                               <para>
                                This is used as the <parameter>delay</parameter>
                                parameter when constructing the
                                <classname>CAENPha</classname> object that
                                will control the board associated with this
                                configuration. This value is in nanoseconds
                                and will be converted to an appropriate
                                register value to program the board
                                start delay (register 08170).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>int</type> <varname>recordLength</varname></term>
                           <listitem>
                               <para>
                                Trace length acquired.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>std::vector &lt;ChannelCoincidenceSettings&gt; </type><varname>coincidenceSettings;</varname></term>
                           <listitem>
                               <para>
                                Per channel coincidence/majority trigger
                                configuration.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>bool </type>waveforms</term>
                           <listitem>
                               <para>
                                Acquire waveforms.  This must be used with
                                the acquisition mode set to mixed to include
                                the acquired waveform data in the data buffer.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>bool </type><varname>dualTrace</varname></term>
                           <listitem>
                               <para>
                                If true, two waveforms, selected by
                                <varname>analogTrace1</varname> and
                                <varname>analogTrace2</varname> are included
                                 in the databuffer for each channel hit.  If
                                 false, only the trace selected by
                                 <varname>analogTrace1</varname> is
                                 included.
                               </para>
                               <para>
                                Note, this requires that the acquisition mode
                                be mixed and that <varname>waveforms</varname>
                                be true.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned </type><varname>analogTrace1</varname></term>
                           <listitem>
                               <para>
                                Selects analog probe 1.  In single trace mode,
                                this is the only trace included, in dual trace
                                mode, this is the first of the two traces.
                                This value is an integer in the range
                                [0..3]. 
                               </para>
                               <para>
                                <literal>0</literal> means the trace is the
                                input waveform. <literal>1</literal> means
                                this trace is first derivative of the input.
                                <literal>2</literal> mean this trace is the
                                second derivative of the input.
                                <literal>3</literal> means this trace is
                                the output of the trapezoid filter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>unsigned     </type><varname></varname></term>
                           <listitem>
                               <para>
                                If dual trace mode is enabled with the inclusion
                                of waveforms in the data buffer, this is a
                                value in the range [0..3] that selects the second
                                trace included in the waveform data.
                               </para>
                               <para>
                                <literal>0</literal> means this trace is the input
                                <literal>1</literal> means this trace is the
                                threshold referred to the waveform second derivative.
                                <literal>2</literal> means this trace is the
                                current Trapezoid baseline.
                                <literal>3</literal> means that this trace is the
                                computed baseline.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>TriggerControl </type><varname>triggerSource</varname></term>
                           <listitem>
                               <para>
                                Describes what triggers the board
                                responds to. See the <type>TriggerControl</type>
                                data type for information about the meanings
                                of this value.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>CAEN_DGTZ_AcqMode_t </type><varname></varname></term>
                           <listitem>
                               <para>
                                provides the start mode parameter to the
                                <classname>CAENPha</classname> constructor.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>double </type><varname>s_timeOffset</varname></term>
                           <listitem>
                               <para>
                                In spite of the best efforts to synchronize
                                digitizer boards, there may be a constant offset
                                between timestamps between different boards.
                                This value is subtracted from the raw
                                time tag values from the board after any rollover
                                has been accounted for to widen the timetag to
                                64 bits and before the timstamp is calibrated
                                to nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><type>std::vector&lt;std::pair&lt;unsigned, CAENPhaChannelParameters*&gt; &gt; </type>
                           <varname>m_channelParameters</varname></term>
                           <listitem>
                               <para>
                                Per channel parameters for enabled channels.
                                The first element of each pair is the channel
                                number.  The second element the per channel
                                parameters.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CompassEventSegment</refentrytitle>
                  <manvolnum>3DPP-PHA</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CompassEventSegment</refname>
                  <refpurpose>Event segment configured by COMPASS</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CompassEventSegment.h&gt;
class CompassEventSegment : public  CEventSegment
{



public:
    CompassEventSegment(
        std::string filename, int sourceId,
        CAEN_DGTZ_ConnectionType linkType, int linkNum, int node, int base,
        const char* pCheatFile=nullptr
    );
    
    
    // A great deal of this could possibly be factored into a common base class.
    
    virtual void initialize();
    virtual void clear();
    virtual void disable();
    virtual size_t read(void* pBuffer, size_t maxwords);
   
    bool checkTrigger();
    
    // Delegations to the module (for synchronized chains).
    
    bool isMaster();
    void startMaster();
    void startSlave();
public:
    bool               m_countersActive;
    uint16_t           m_lastTriggerCount[16];           // overflow
    uint16_t           m_lastMissedTriggerCount[16];     // detectors.
    
    uint32_t           m_triggerCount[16];
    uint32_t           m_missedTriggers[16];  
};
                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        This class is an event segment that encapsulates
                        a <classname>CAENPha</classname> object. The
                        object is configured using a matching module
                        in an XML configuration file produced by the
                        COMPASS data acquisition program from CAEN.
                      </para>
                      <para>
                        Before diving into the methods, a word
                        about COMPASS and COMPASS configuration files.
                        COMPASS is a CAEN data acquisition program
                        that can be used to optimize the configuration
                        of DPP-PHA and DPP-PSD digitizers.
                        COMPASS can run a group of synchronized digitizers
                        simultaneously and includes a wizard for
                        synchronizing the digitizers.
                        It writes
                        XML files that capture the configuration of the
                        digitizers it is running. 
                      </para>
                      <para>
                        COMPASS XML files describe a group of
                        digitizers.  <classname>CompassEventSegment</classname>
                        only operates a single digitizer.  The digitizer
                        in the XML files that matches the connection
                        paramters passed to the constructor of
                        <classname>CompassEventSegment</classname>
                        is used to supply configuration data for
                        the module run by this event segment.
                      </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <para>
                        Note that the virtual methods in
                        <classname>CompassEventSegment</classname>
                        provide and implement the interface to
                        <classname>CEventSegment</classname>.  These
                        will not be descdribed here as they are adequately
                        described in the NSCL documentation set.
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CompassEventSegment</methodname>
                                <methodparam>
                                    <type>std::string </type><parameter>filename</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>sourceId</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>CAEN_DGTZ_ConnectionType </type>
                                    <parameter>linkType</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>linkNum</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>node</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int</type><parameter> base</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char*</type><parameter> pCheatFile</parameter>
                                    <initializer>nullptr</initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                The <parameter>linkType</parameter>,
                                <parameter>linkNum</parameter>,
                                <parameter>node</parameter> and
                                <parameter>baseAddress</parameter>
                                parameters provice the connection information
                                that allows the CAEN digitizer library to
                                talk with the digitizer. These are also
                                compared with the connection parameters
                                in the configuration file to determine which
                                digitizer described in
                                <parameter>filename</parameter>
                                provides the configuration for
                                this module.
                               </para>
                               <para>
                                Finally, the <parameter>pCheatFile</parameter>,
                                if not null provides a cheat file
                                for the <classname>CAENPHa</classname>
                                object enclosed by this class.
                                See the doucmentation for
                                <classname>CAEENPHa</classname>
                                for a description of cheat files.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>checkTrigger</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Interfaces to the multi module CAEN
                                trigger class.  This method returns
                                true if there is either un-submitted
                                internally buffered data or the
                                module has data in its buffers that
                                can be read now.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>isMaster</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Part of the multi-module synchronization
                                support.  If the module is configured
                                as the synchronization/clock master,
                                returns <literal>true</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>startMaster</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If the board is a master,
                                it must be the last board started andyou
                                must use <methodname>startMaster</methodname>
                                to start it.  Normally, if you are using
                                a <classname>CompassMultiModuleEventSegment</classname>,
                                that class takes care of getting everything
                                started in the right order,
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>startSlave</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If the board is a slave on the clock
                                and synchroniziation daisy chain,
                                this this method should be called after
                                configurtion to prime the board to
                                respond to the hardware start signal.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
                <refsect1>
                    <title>PUBLIC Attributes</title>
                    <para>
                        The module has a set of counters, two per channel.
                        These are 16 bit counters that describe the
                        number of triggers and number of missed
                        triggers.  It's possible to arrange for these
                        to be included in the event data.
                    </para>
                    <para>
                        If this feature is enabled,
                        <varname>m_countersActive</varname>
                        will be <literal>true</literal>.  In that
                        case, <varname>m_lastTriggerCounts</varname>
                        is an array of the 16 bit trigger counts
                        for each channel and
                        <varname>m_lastMissedTriggerCount</varname>,
                        the count of missed triggers.
                    </para>
                    <para>
                        Because they can roll over relatively
                        rapidly on a macroscopic time-scale, the 16
                        bit counters are relatively useless.
                        The <varname>m_triggerCount</varname> and
                        <varname>m_missedTirgges</varname> arrays
                        account for rollovers and maintain 32 bit
                        counters
                    </para>
                    <para>
                        One use of this feature is to create
                        a scaler bank from <classname>CAENPHAScalers</classname>
                        to turn these values in to scalers that can be displayed
                        on the NSCLDAQ scaler display program.
                    </para>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CAENPHAScalers</refentrytitle>
                  <manvolnum>3DPP-PHA</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CAENPHAScalers</refname>
                  <refpurpose>Create scaler readouts from DPP-PHA trigger counters.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CAENPHAScalers.h&gt;
class CAENPHAScalers : public CScaler
{
public:
    CAENPHAScalers(CompassEventSegment* pEventSegment, int srcid = 0);
    virtual std::vector&lt;uint32_t&gt; read();
    virtual int sourceId() {return m_nSourceId;}
};
                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        This class associates itslf with the
                        trigger counters of a CAEN DPP-PHA digitizer.
                        The constructor is given the event segment as
                        a pointer and, whenever a scaler readout is
                        triggered, makes two scalers from the trigger
                        count and missed trigger counts for
                        each channel in that order.
                      </para>
                      <para>
                        <parameter>srcid</parameter> in the
                        constructor provides the source id to be
                        associatd with the scaler readouts.
                      </para>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CompassMultiModuleEventSegment</refentrytitle>
                  <manvolnum>3DPP-PHA</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CompassMultiModuleEventSegment</refname>
                  <refpurpose>"Fair" readout of several DPP-PHA digitizers.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CompassMultiModuleEventSegment.h&gt;

class CompassMultiModuleEventSegment : public CEventSegment
{

public:
  CompassMultiModuleEventSegment();
    virtual void initialize();
    virtual void clear();
    virtual void disable();
    virtual size_t read(void* pBuffer, size_t maxwords);
public:
  void addModule(CompassEventSegment* p);
};
                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        This class is a container for
                        <classname>CompassEventSegment</classname>
                        objects.  It supports managing several
                        DPP-PHA modules as a single event segment.
                        There are some tricks that need to be
                        played in order to get a synchronized start
                        and fair readout.  This class plays those tricks.
                      </para>
                      <para>
                        Once constructed, clients can add modules
                        to the event segment by calling
                        <methodname>addModule</methodname>.
                      </para>
                      <para>
                        The remainder of the methods implement the
                        <classname>CEventSegment</classname> interface.
                      </para>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CompassProject</refentrytitle>
                  <manvolnum>3DPP-PHA</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CompassProject</refname>
                  <refpurpose>Parse Compass XML file module definitions.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CompassProject.h&gt;
 
 class CompassProject {
public:
    typedef std::pair&lt;unsigned, CAENPhannelParameters*&gt;  ChannelInfo;
    typedef struct {
        CAEN_DGTZ_ConnectionType s_linkType;
        int                      s_linkNum;
        int                      s_node;
        int                      s_base;
    } ConnectionParameters, *pConnectionParameters;
private:
    std::string m_filename;
    pugi::xml_document m_doc;
    CAENPhaChannelParameters        m_channelDefaults;

public:
    CompassProject(const char* file);    
    void operator()();                    // Parse the configuration.
public:
    std::vector&lt;CAENPhaParameters*&gt; m_boards;
    std::vector&lt;ConnectionParameters&gt; m_connections;    

};

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        This class implements the parser for the
                        COMPASS XML Configuration files.    It
                        accepts the path to the configuration
                        file as the constructor parameter
                        <parameter>file</parameter>.
                        <methodname>operator()</methodname> then
                        processes the file building public
                        data from which the configuration can be pulled.
                      </para>
                </refsect1>
                <refsect1>
                <title>PUBLIC Types and Attributes</title>
                    <para>
                        The  <methodname>opertor()</methodname> processes
                        the enteri configuration file. This results in
                        a set of connection parameters and configurations
                        of the board at each connection.
                    </para>
                    <para>
                        The client software matches up connection parameters
                        with actual board connection parametes and uses the
                        corresponding configuration to configure the board.
                        For the client software to do its job, data
                        are exported.
                    </para>
                    <para>
                        The class defines one public data type of use;
                        the <structname>ConnectionParameters</structname>.
                        The fields of this structure
                        contain the connection parameters that
                        describe how a digitizer is connected to a host system:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <type>CAEN_DGTZ_ConnectionType </type>
                            <structfield>s_linkType</structfield>
                           </term>
                           <listitem>
                               <para>
                                The type of link to the digitizer.
                                See <filename>CAENDigitizerType.h</filename>
                                in the CAEN digitizer library installation
                                include file directory for legal values.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int </type><structfield>s_linkNum</structfield>
                           </term>
                           <listitem>
                               <para>
                                The link number.  This is mainly used for
                                optical links where there may be more than
                                one optical interface per system and selects
                                the specific optical interface daisy chain
                                the board is on.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_node</structfield>
                           </term>
                           <listitem>
                               <para>
                                Indicates the node of the interface system
                                (position on optical daisy chain or USB system),
                                at which the board lives.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_base</structfield>
                           </term>
                           <listitem>
                               <para>
                                For modules controlled via a VME controller,
                                this is the base address configured into the
                                module's rotary switches.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        Two attributes are also exposed to clients:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <type>std::vector&lt;CAENPhaParameters*&gt; </type>
                            <varname>m_boards</varname>
                           </term>
                           <listitem>
                               <para>
                                This vector are the decoded parameters (board and
                                per channel) for each board described
                                in the configuration file.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>std::vector&lt;ConnectionParameters&gt; </type>
                            <varname>m_connections</varname>
                           </term>
                           <listitem>
                               <para>
                                For each element of the
                                <varname>m_boards</varname> configuration
                                array, this array will have a corresonding
                                entry that describes the connection to that
                                board. 
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CompassTrigger</refentrytitle>
                  <manvolnum>3DPP-PHA</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CompassTrigger</refname>
                  <refpurpose>Trigger on DPP-PHA data ready.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CompassTrigger.h&gt;

class CompassTrigger : public CEventTrigger
{

public:
    CompassTrigger();
    void addModule(CompassEventSegment* module);
    virtual bool operator()();
    
};
                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                      <para>
                        <classname>CompassTrigger</classname>
                        provides an event trigger which will
                        be satisfied when any member board has
                        data that can be submitted to Readout's
                        ring buffer. Note that it's not necessary
                        for these data to be held in hardware
                        fifos. Each module contributes several hits
                        per read, but only one hit can be emitted
                        per trigger.  Therefore the event segments
                        hold the remaining hits in internal buffers.
                      </para>
                      <para>
                        A trigger could be responded to by
                        providing a hit from an internal hit buffer
                        that has not yet been emitted or by
                        reading a module, buffering its data and
                        then emitting the first hit from that buffer.
                      </para>
                      <para>
                        The <methodname>addModule</methodname>
                        allows the client to add a module that
                        will be polled during the call to
                        <methodname>operator()</methodname>.
                      </para>
                </refsect1>
            </refentry>
            
        </section>
        <section>
            <title>DPP-PSD support classes.</title>
            <para>
                DPP-PSD support is provided by classes that
                are described in this section.
            </para>
            <refentry>
               <refmeta>
                  <refentrytitle>CCompoundTrigger</refentrytitle>
                  <manvolnum>3DPP-PSD</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CCompoundTrigger</refname>
                  <refpurpose>Mix DPP-PHA and DPP-PSD triggers</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CCompoundTrigger.h&gt;

class CCompoundTrigger : public  CEventTrigger
{

public:

    virtual void setup();
    virtual void teardown();
    virtual bool operator()();
    
    void addTrigger(CEventTrigger* pTrigger);

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                      The <classname>CCompoundTrigger</classname>
                      class aggregates triggers from a variety
                      of sources and performs the logical OR on
                      them when checked.  Thus if any component
                      trigger is set, <classname>CCompoundTrigger</classname>
                      is set.
                    </para>
                    <para>
                        After construction,
                        <classname>addTrigger</classname>
                        can be used to add component triggers to the
                        class.  Once a trigger is raised,
                         it is still the responsibility of the
                         event segment(s) to perform a fair
                         readout so that no single event source
                         can starve any other event source.
                    </para>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CDPpPsdEventSegment</refentrytitle>
                  <manvolnum>3DPP-PSD</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CDPpPsdEventSegment</refname>
                  <refpurpose>Manage a single DPP-PSD module.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CDPpPsdEventSegment.h&gt;

class CDPpPsdEventSegment : public CEventSegment
{

public:
    CDPpPsdEventSegment(
        PSDBoardParameters::LinkType linkType, int linkNum, int nodeNum,
        int base, int sourceid, const char* configFile
    );

    
  virtual void   initialize();
  virtual size_t read(void* pBuffer, size_t maxwords) ;
  bool    checkTrigger();
  void    disable();
  
  // Support for multiple boards:
  
  bool isMaster();
  void startAcquisition();  

};

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                      Manages a single DPP-PSD module. Module
                      configuration comes from the module
                      configuration stanza in a COMPASS configuration
                      file that has connection parameters that match
                      those passed to the constructor of this object.
                    </para>
                    <para>
                        Note that the configuration file is
                        processed every time a run starts so
                        changes to the configuration file made
                        after a run starts will be reflected in
                        the next run.
                    </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <para>
                        In this section we're only going to document the methods
                        that are not part of the
                        <classname>CEventSegment</classname> interface.
                        The <classname>CEventSegment</classname>
                        interface methods are documented sufficiently
                        in the NSCLDAQ documentation.
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CDPpPsdEventSegment</methodname>
                                <methodparam>
                                    <type>PSDBoardParameters::LinkType </type>
                                    <parameter>linkType</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>linkNum</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>nodeNum</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>base</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>sourceid</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char* </type>
                                    <parameter>configFile</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                This constructor establishes
                                the connection parameters for a board
                                and the COMPASS configuration file
                                that will be processed to determine
                                how to configure the board and
                                its channels.
                               </para>
                               <para>
                                <parameter>linkType</parameter>,
                                <parameter>linkNum</parameter>,
                                <parameter>node</parameter> and
                                <parameter>base</parameter> are the
                                link parameters that must exactly
                                match the connection parameters of
                                one of the boads described in the
                                COMPASS configuration file
                                indicated by
                                <parameter>configFile</parameter>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>isMaster</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                This method returns
                                <literal>true</literal> if this board
                                is configured to be the timing master.
                                The timing master board must be started
                                last as it will emit hardware signals
                                to start the slave boards in a
                                synchronized manner.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>startAcquisition</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If this board is configured as a timing master,
                                it is started.  If the board is configured as a timing
                                slave, it is primed to start on receipt
                                of the start signals emitted by the
                                master.
                               </para>
                            </listitem>
                        </varlistentry>                        
                    </variablelist>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>COneOnlyEventSegment</refentrytitle>
                  <manvolnum>3DPP-PSD</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>COneOnlyEventSegment</refname>
                  <refpurpose>Only alow one contribution into an event segment</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                <programlisting>
#include &lt;COneOnlyEventSegment&gt;

class COneOnlyEventSegment : public CEventSegment
{

    COneOnlyEventSegment();
    
    virtual void initialize();
    virtual void clear();
    virtual void disable();
    virtual size_t read(void* pBuffer, size_t maxwords);
    
    void addModule(CEventSegment* p);

};
                    
                </programlisting>

                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        For CAEN Digitizer readouts, each trigger
                        should only produce one hit in a ring item.
                        If you are mixing together several CAEN-DPP
                        event segments, you need to put them
                        together using this compound event segment
                        class.  A typical use case is combining DPP-PHA
                        and DPP-PSD readouts.
                      </para>
                      <para>
                        After constructing the object, use
                        <methodname>addModule</methodname> to
                        add the event segments you need.
                        The <methodname>read</methodname> method
                        responds to the trigger by asking its event segments
                        in a round robin way to contribute data.
                        Once data are contributed,
                        <methodname>read</methodname> stops and
                        remembers where it left off.  Fair
                        readout is done by responding to the next
                        trigger by first asking the next module
                        after the one most recently producing data
                        to contribute.  For this purpose, the
                        modules are treated as if they form a circular
                        list in the order in which they were
                        added to the segment.
                      </para>
                      <para>
                        This round robin scheme should prevent
                        low rate modules from being starved of the
                        opportunity to contribute data to the
                        output ring by higher rate modules.
                      </para>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CPsdCompoundEventSegment </refentrytitle>
                  <manvolnum>3DPP-PSD</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CPsdCompoundEventSegment </refname>
                  <refpurpose>Manage a chain of DPP-PSD modules</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
class CPsdCompoundEventSegment  : public CEventSegment
{
                     m_nextRead;
public:
    CPsdCompoundEventSegment();
    virtual ~CPsdCompoundEventSegment();
    virtual void initialize();
    virtual void clear();
    virtual void disable();
    virtual size_t read(void* pBuffer, size_t maxwords);
    
    void addModule(CDPpPsdEventSegment* p);

};
                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        This class allows you to build an
                        event segment out of a set of DPP-PSD Modules.  THe
                        segment is presumed to be a time-synchronized
                        daisy chain with a timing master and
                        several slaves.  
                      </para>
                      <para>
                        Build the list by constructing the individual
                        module objects, constructing this class
                        and then invoking
                        <methodname>addModule</methodname>
                        to add each module object to the
                        <classname>CPsdCompoundEventSegment</classname>.
                      </para>
                      <para>
                        When <methodname>initialize</methodname>
                        is called, each contained module
                        is asked to initialize.
                        The code then primes all the slave modules
                        to start and finally, starts the
                        timing master module.
                      </para>
                      <para>
                        There is nothing to stop you from building
                        an object consisting entirely of slaves.
                        This will most likely be done when using
                        <classname>COneOnlyEventSegment</classname>
                        to mix both DPP-PSD and DPP-PHA modules.
                        In that case, all slave modules will be
                        synchronized and when the timing master
                        in another segment is started, all will
                        start in a synchronized manner.
                      </para>
                      <para>
                        In a singles experiment, where timing
                        synchonization isn't important, you
                        can just as easily program all modules
                        as masters and all will start up but
                        unsynchronized.
                      </para>
                      <para>
                        When the object's <methodname>read</methodname>
                        method is invokded a fair, round robin
                        scheme is used to request data from
                        modules so that low rate modules will not
                        be starved by high rate modules.
                        This is done by treating the modules as
                        a cirular list and, after a module
                        hit is received, responding to the
                        next
                        <methodname>read</methodname> call by
                        starting to look for data beginning with the next
                        module in the object.
                      </para>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>CPsdTrigger</refentrytitle>
                  <manvolnum>3DPP-PSD</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CPsdTrigger</refname>
                  <refpurpose>Trigger determination for DPP-PSD modules</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CPsdTrigger.h&gt;
class CPsdTrigger : public CEventTrigger {
public:
    virtual bool operator()();
    void addModule(CDPpPsdEventSegment* p);

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        <classname>CPsdTrigger</classname> is <classname>CEventTrigger</classname>
                        that polls a set of <classname>CDPpPsdEventSegment></classname>
                        objects to determine if any of them have data ready to
                        send to the output ring buffer. Note that these objects
                        may have internally buffere data or data buffered in the
                        digitizer module they manage.
                      </para>
                      <para>
                        <methodname>addModule</methodname> is used to incrementally
                        build up the set of objects that will be polled by this
                        trigger object.
                      </para>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>PSDChannelParameters</refentrytitle>
                  <manvolnum>3DPP-PSD</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>PSDChannelParameters</refname>
                  <refpurpose>Hold per channel DPP-PSD configuration</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;PSDChannelParameters.h&gt;

struct PSDChannelParameters {
    double s_channelTimeOffset;            // Ns time offset for timestamps.
    enum {positive, negative}
           s_polarity;                     // Input signal polarity.
    double s_threshold;                    // Trigger threshold in lsb.
    enum {
        fixed,
        samples16,
        samples64,
        samples256,
        samples1024,
        samples4096,
        samples16384
    }      s_blineNsMean;                  // samples to average for baseline:
    double s_cfdDelay;                     // CFD delay parameter.
    bool   s_enabled;                      // Channel is turned on.
    unsigned s_cfdSmoothing;                 // CFD interpolation samples.
    double s_purGap;                           // Pile up rejection gap.
    enum {
        vpp2V, vpphalfV
    }  s_dynamicRange;                    // Input dynamic range.
    double s_shortGate;                   // Short gate in ns.
    enum {
        frac25,
        frac50,
        frac75,
        frac100
    }  s_cfdFraction;                    // CFD Fraction.
    enum {
        led, cfd
    }  s_discriminatorType;             // Leading edge or cfd discriminator.
    double s_fixedBline;               // Baseline if fixed is chosen.
    double s_triggerHoldoff;           // ns of trigger holdoff.
    double s_gateLen;                  // Long gate length in ns.
    double s_dcOffset;                 // Baseline dc offset.
    enum {
        lsb2_5fc,
        lsb10fc,
        lsb40fc,
        lsb160fc,
        lsb640fc,
        lsb2560fc
    } s_coarseGain;                 // Coarse gain in femto coulombs/lsb.
    double s_gatePre;               // integration prior to gate(?).
    double s_preTrigger;            // Waveform capture pre-trigger.
};


                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        This data only struct contains the configuration data that
                        can be applied to a single channel of a DPP-PSD
                        digitizer.  See also
                        <structname>PSDBoardParameters</structname> and
                        <structname>PSDParameters</structname>, which
                        hold the the entire parameters for one board
                        (including a vector of <structname>PSdChannelParmeters</structname>),
                        and parse an entire compass file for DPP-PSD
                        modules.
                      </para>
                </refsect1>
                <refsect1>
                    <title>DATA MEMBERS</title>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_channelTimeOffset</structfield>
                           </term>
                           <listitem>
                               <para>
                                In a syncrhonized system, the start pulse travels down
                                the module daisy chain.  Because of propagation delays,
                                cable lengths and
                                the time it takes each module to output the
                                start after seeing it on the input,
                                each module will get the start pulse a little
                                later than the previous module on the daisy chain.
                               </para>
                               <para>
                                <structfield>s_channelTimeOffset</structfield>
                                allows you to compensate for this timing skew
                                by programming a delay into each module between
                                receiving the start pulse and actually starting
                                (it's the start that zeroes a module's timestamp
                                counter).  By programming successively
                                longer delays as you go towards the
                                master module, you can get a much better
                                synchronization of the timestamp clear
                                in all modules.  Naturally, an external
                                start with a star cabling configuration
                                and measured cables, makes this unecessary
                                at the cost of external hardware.
                               </para>
                               <para>
                                This value is expressed in
                                nanoseconds and converted by the
                                module initialization code to
                                register values.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum </type><structfield>s_polarity</structfield>
                           </term>
                           <listitem>
                               <para>
                                This enumerated field is used to inform the channel
                                of the signal input polarity to expect.
                                Legal values are  either
                                <literal>positive</literal>
                                or <literal>negative</literal>.
                                It is necessary to program tis properly
                                (as well as setting the DC offset for the
                                channel to keep the signal inside the
                                dynamic range of the digitizer), because
                                the DPP algorithms all operate on a positive
                                going pulse.  If a channel has been
                                programmed as <literal>negative</literal>,
                                the signal will be digitally inverted
                                prior to the DPP-PSD algorithm.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_threshold</structfield>
                           </term>
                           <listitem>
                               <para>
                                The leading edge discriminator
                                trigger threshold value.  When the (possibly inverted)
                                digitizer value is above this value, the
                                channel declares a trigger.  Note that
                                better timing on the trigger time can be gotten
                                by enabling the CFD.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum</type><structfield>s_blineNsMean</structfield>
                           </term>
                           <listitem>
                               <para>
                                Contains an enumerated type that selects the
                                number of samples to average when computing he
                                signal baseline value.  Note that after a trigger,
                                baseline computation is, of course disabled and the
                                baseline frozen for a settable period
                                of time.
                               </para>
                               <para>
                                Valid values are:
                               </para>
                               <variablelist>
                                <varlistentry>
                                   <term><literal>fixed</literal></term>
                                   <listitem>
                                       <para>
                                        The baseline is not computed from input
                                        signal but, instead is a programmable
                                        fixed value. 
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>samples16</literal></term>
                                   <listitem>
                                       <para>
                                        A running average of 16 consecutive
                                        samples is used to compue the baseline
                                        value.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>samples64</literal></term>
                                   <listitem>
                                       <para>
                                        The baseline is computed from
                                        a running average of 64 consecutive samples.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>samples256</literal></term>
                                   <listitem>
                                       <para>
                                        A running average of 256 consecutive
                                        samples is used to compute the
                                        baseline.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>samples1024</literal></term>
                                   <listitem>
                                       <para>
                                        A running average of 1K samples
                                        is used to compute the baseline
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>samples4096</literal></term>
                                   <listitem>
                                       <para>
                                        A running average of 4K samples is used
                                        to compute the baseline.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>samples16384</literal></term>
                                   <listitem>
                                       <para>
                                        A running average of 16K samples is used
                                         to compute the baseline.
                                       </para>
                                    </listitem>
                                </varlistentry>
                               </variablelist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_cfdDelay</structfield>
                           </term>
                           <listitem>
                               <para>
                                This parameter is only meaningful if the
                                CFD is enabled.  It is the CFD delay
                                parameter in nanoseconds.
                                Initialization code converts it to
                                register values appropriate to the
                                actual digitizer.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>bool   </type><structfield>s_enabled</structfield>
                           </term>
                           <listitem>
                               <para>
                                If <literal>true</literal> this channel is enabled.
                                If <literal>false</literal>, the channel is
                                disabled. Disabled channels will not buffer
                                data nor participate in module trigger
                                decisions.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>unsigned </type><structfield>s_cfdSmoothing</structfield>
                           </term>
                           <listitem>
                               <para>
                                This value is an integer between
                                <literal>0</literal> and <literal>4</literal>
                                inclusive and selects the input smoothing
                                value. Note that the smoothed input
                                can be used by both the CFD and LED.
                               </para>
                               <para>
                                <literal>0</literal> means input smoothing is disabled.
                                <literal>1</literal> means two samples are averaged to smoothy
                                the input
                                <literal>2</literal> means 4 sample
                                <literal>3</literal> means 8 samples
                                and <literal>4</literal> means 16 samples.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_purGap</structfield>
                           </term>
                           <listitem>
                               <para>
                                Sets the pile up rejection gap. See register
                                <literal>0x1n7c</literal>.  The pi8le up rejection
                                gap determines the threshold at which a
                                pile up is detected when the signal rises
                                again after falling off.  This value is
                                set in digitizer conversion units.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum</type><structfield>s_dynamicRange</structfield>
                           </term>
                           <listitem>
                               <para>
                                The XX725 and XX750 digitizers have dual
                                dynamic ranges.  This parameter selects the
                                channel's dynamic range. Legal values
                                are <literal>vpp2V</literal> which
                                sets a 2V peak to peak range and
                                <literal>vpphalfV</literal> which sets
                                a 0.5V peak to peak range (half).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_shortGate</structfield>
                           </term>
                           <listitem>
                               <para>
                                To provide pulse shape discrimination information,
                                the digitizer integrates the value
                                of the signal over a short gate and a long
                                gate.  <structfield>s_shortGate</structfield>
                                determines the length of the short gate
                                in nanoseconds.  This value is converted to
                                register units by the initialization
                                code.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum</type><structfield>s_cfdFraction</structfield>
                           </term>
                           <listitem>
                               <para>
                                This parameter is only used if the
                                CFD is enabled.  It determines the
                                CFD fraction value.   Legal values are:
                               </para>
                               <variablelist>
                                <varlistentry>
                                   <term><literal>frac25</literal></term> 
                                   <listitem>
                                       <para>
                                        25% scaling factor (1/4).
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>frac50</literal></term>
                                   <listitem>
                                       <para>
                                        50% scaling factor.
                                       </para>
                                    </listitem>
                                </varlistentry><varlistentry>
                                   <term><literal>frac75</literal></term>
                                   <listitem>
                                       <para>
                                        75% scaling factor
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>frac100</term>
                                   <listitem>
                                       <para>
                                        No scaling done (100% scaling factor).
                                       </para>
                                    </listitem>
                                </varlistentry>
                               </variablelist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum </type><structfield>s_discriminatorType</structfield>
                           </term>
                           <listitem>
                               <para>
                                Selects the type of discriminator that will be used.
                                <literal>led</literal> uses a leading edge
                                discriminator while <literal>cfd</literal>
                                employs a constant fraction discriminator.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_fixedBline</structfield>
                           </term>
                           <listitem>
                               <para>
                                If a fixed baseline is used, this is
                                the value of that baseline.  The integerized version
                                of this value will be programmed into
                                the fixed baseline register
                                (0x1n64).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_triggerHoldoff</structfield>
                           </term>
                           <listitem>
                               <para>
                                The trigger hold off in nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_gateLen</structfield>
                           </term>
                           <listitem>
                               <para>
                                Long integration gate length in nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_dcOffset</structfield>
                           </term>
                           <listitem>
                               <para>
                                Channel DC offset value in percentage of full scale
                                (that is 0-100).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum</type><structfield>s_coarseGain</structfield>
                           </term>
                           <listitem>
                               <para>
                                The coarse gain selector expressed as  femto
                                Coulombs per least significant bit of the
                                integration returned.  This is one of:
                               </para>
                               <variablelist>
                                <varlistentry>
                                   <term><literal>lsb2_5fc</literal></term>
                                   <listitem>
                                       <para>
                                        Least significant bit is 2.5 fC
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>lsb10fc</literal></term>
                                   <listitem>
                                       <para>
                                        Least significant bit is 10 fC
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>lsb40fc</literal></term>
                                   <listitem>
                                       <para>
                                        Least significant bit is 40fC
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>lsb160fc</literal></term>
                                   <listitem>
                                       <para>
                                        Least significant bit is 160fC
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>lsb640fc</literal></term>
                                   <listitem>
                                       <para>
                                        Least significant bit is 640fC
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>lsb2560fc</literal></term>
                                   <listitem>
                                       <para>
                                        Least significant bit is 2650fC.
                                       </para>
                                    </listitem>
                                </varlistentry>
                               </variablelist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_gatePre</structfield>
                           </term>
                           <listitem>
                               <para>
                                Nuber of nanoseconds of integration prior to the
                                gate.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_preTrigger</structfield>
                           </term>
                           <listitem>
                               <para>
                                Nanoseconds of waveform capture prior to the
                                trigger.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>PSDBoardParameters</refentrytitle>
                  <manvolnum>3DPP-PSD</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>PSDBoardParameters</refname>
                  <refpurpose>Boad level parameters for DPP-PSD boards/</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
struct PSDBoardParameters
{
    typedef enum _LinkType {
        usb, conet
    } LinkType;
    
    
    
    std::string s_modelName;
    int         s_serialNumber;
    LinkType    s_linkType;
    int        s_linkNum;
    int        s_node;
    int        s_base;
    int        s_psPerSample;
    
    
    
    bool       s_extClock;           
    bool       s_energy;   
    enum {
        disabled,
        couples,
        andOneToAll,
        oneChannelVeto        
    }        s_coincidenceMode;      
    enum {
        software, sIn, firstTrigger
    }   s_startMode;                 
    double s_coincidenceTriggerOut;   
    bool s_timeTag;               
    bool s_calibrateBeforeStart;  
    bool s_softwareTriggerAtStart;
    bool s_includeExtras;        
    double s_recordLength;       
    double s_startDelay;         
    bool   s_waveforms;          
    enum {
        nim, ttl
    }     s_ioLevel;             
    enum {
        level0,
        level1,
        softwareTrigger,
        externalTrigger,
        globalOrTrigger,
        running,
        delayedRunning,
        sampleClock,
        pllClock,
        busy,
        pllUnlocked,
        vProbe,
        syncIn
    } s_triggerOutputMode;       
    double s_eventAggregation;
    
    // per channel parameters - 16 channels.
    
    PSDChannelParameters s_channelConfig[16];
    
};

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>
                            DESCRIPTION
                         </title>
                      <para>
                        This data member only struct contains the
                        data required to configura a single DPP-PSD digitizer
                        module (board).  It includes the per channel
                        configuration data in the <structfield>s_channelConfig</structfield>
                        array.
                      </para>
                </refsect1>
                <refsect1>
                    <title>DATA MEMBERS</title>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <type>std::string </type><structfield>s_modelName</structfield>
                           </term>
                           <listitem>
                               <para>
                                Contains a textual version of the model of the digitzer,
                                e.g. <literal>V1725</literal>.  This is
                                gotten via a call to
                                <function>CAEN_DGTZ_GetInfo</function>
                                once the digitizer has been opened.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int   </type><structfield>s_serialNumber</structfield>
                           </term>
                           <listitem>
                               <para>
                                Contains the module serial number.
                                This is gotten from the module
                                via a call to
                                <function>CAEN_DGTZ_GetInfo</function>
                                once the digitizer has been opened.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>LinkType </type><structfield>s_linkType</structfield>
                           </term>
                           <listitem>
                               <para>
                                Contains the type of connection used to access
                                the digitizer.  <type>LinkType</type>
                                can be either
                                <literal>usb</literal> or
                                <literal>conet</literal>  Note that
                                these two encapsulate both direct
                                connection to the digitizer or connection
                                via a USB/conet VME bus bridge.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_linkNum</structfield>
                           </term>
                           <listitem>
                               <para>
                                The number of the link used to
                                connect the host to the digitizer.
                                This is most often non-zero for
                                <literal>conet</literal> when it
                                selects the specific optical link
                                that connects the host to the digitizer,
                                or the CONET/VME bus bridge controlling
                                the digitizer.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int </type><structfield>s_node</structfield>
                           </term>
                           <listitem>
                               <para>
                                The node number of the digitizer on
                                the interface (link) it's attached to.  For CONET daisychains,
                                his is clear and easy to figure out. For
                                destktop digitizers connected to USB,
                                you'll probably have to probe...and then be sure
                                not to move cables around so that renumertions
                                hold the node numbers constant.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_base</structfield>
                           </term>
                           <listitem>
                               <para>
                                For digitizers that are interfaced to the host
                                over VME interfaces, this is the digitizer's
                                base address.  For all other digitizers,
                                this should be zero.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int </type><structfield>s_psPerSample</structfield>
                           </term>
                           <listitem>
                               <para>
                                Speed of the digitizer ins picoseconds/sample.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>bool </type><structfield>s_extClock</structfield>
                           </term>
                           <listitem>
                               <para>
                                If <literal>true</literal> the
                                digitizer will be enabled to accept
                                an external clock.  In general internal
                                clock should only be used for stand-alone
                                digitizers and for master digitizers in
                                a synchronized daisy chain (though even then
                                an external clock could be used).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>bool </type><structfield>s_energy</structfield>
                           </term>
                           <listitem>
                               <para>
                                If <literal>true</literal> then the list mode,
                                DPP parameters extracted from the waveform
                                will be included in the digitizer output.
                                If <literal>false</literal>, only waveforms
                                will have valid values.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum</type><structfield>s_coincidenceMode</structfield>
                           </term>
                           <listitem>
                               <para>
                                    Selects the module trigger
                                    coincidence mode.  This can
                                    be one of:
                               </para>
                               <variablelist>
                                <varlistentry>
                                   <term><literal>disabled</literal></term>
                                   <listitem>
                                       <para>
                                        No coincidence requirement.  THis is the same as
                                        triggering on the or of a couple
                                        trigger.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>couples</literal></term>
                                   <listitem>
                                       <para>
                                        Both channels in a couple must
                                        fire (couple AND requirement).
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>andOneToAll</literal></term>
                                   <listitem>
                                       <para>
                                        Channel pairs require a motherboard trigger
                                        as well.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>oneChannelVeto </literal></term>
                                   <listitem>
                                       <para>
                                        A single channel can veto the trigger.
                                       </para>
                                    </listitem>
                                </varlistentry>
                               </variablelist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum</type><structfield>s_startMode</structfield>
                           </term>
                           <listitem>
                               <para>
                                Selects the condition required for the
                                digitizer to start accepting triggers.
                                This can be one of
                               </para>
                               <variablelist>
                                <varlistentry>
                                   <term><literal>software</literal></term>
                                   <listitem>
                                       <para>
                                        A software start will zero the timestamp
                                        counter and begin acquisition.
                                        This is suitable for stand-alone
                                        modules and masters on a synchronized
                                        daisy chain of modules.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>sIn</literal></term>
                                   <listitem>
                                       <para>
                                        The module will start taking data
                                        when it senses a true going edge on the
                                        <literal>SIN</literal> front panel
                                        input.  Prior to this, a software
                                        start must have been issued to arm
                                        the module.  This is suitable for slaves
                                         in a synchronized daisy chain
                                         or all modules if an external start is
                                         used to start data taking, rather than
                                         a master module.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>firstTrigger</literal></term>
                                   <listitem>
                                       <para>
                                        Data takings starts on the first external
                                        trigger.  The module must first have been
                                        armed to accept this start via a software start.
                                        This is suitable for slave modules on a
                                        synchronized daisy chain and for all modules
                                        in a synchronized set if an
                                        externally generated start
                                        pulse is used
                                       </para>
                                    </listitem>
                                </varlistentry>
                               </variablelist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_coincidenceTriggerOut</structfield>
                           </term>
                           <listitem>
                               <para>
                                If true, the detection of a valid coincidence
                                trigger will output a pulse on the
                                <literal>TRGOUT</literal> output.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>bool </type><structfield>s_timeTag</structfield>
                           </term>
                           <listitem>
                               <para>
                                Currently this field is not used.
                                Digitizers are always programmed to produce
                                a time tag.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type> bool </type><structfield>s_calibrateBeforeStart</structfield>
                           </term>
                           <listitem>
                               <para>
                                The digitizers have a calibrtaion function.  If
                                this field is <literal>true</literal> the
                                calibration will be performed prior to
                                loading the digitizer configuration.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            '<type>bool</type><structfield> s_softwareTriggerAtStart</structfield>
                           </term>
                           <listitem>
                               <para>
                                Currently unused. I believe the intent is that if
                                <literal>true</literal>, the module will
                                be software triggerred when it is started.
                                We use software start and daisy chain hardware
                                starts instead of this.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>bool </type><structfield>s_includeExtras</structfield>
                           </term>
                           <listitem>
                               <para>
                                Currently unused. The intent is that if true,
                                the so-called extra1 and extra2 data will be
                                included in the data bufferded for each
                                event in the digitizer.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_recordLength</structfield>
                           </term>
                           <listitem>
                               <para>
                                Length of waveform captured in nanoseconds.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_startDelay</structfield>
                           </term>
                           <listitem>
                               <para>
                                Nanoseconds after start pulse or software start
                                the  module actually zeroes its timestamps and is
                                able to take data.  This is used to get 
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>bool</type><structfield>s_waveforms</structfield>
                           </term>
                           <listitem>
                               <para>
                                If <literal>true</literal>, enables waveforms
                                to be recorded in the data buffer along with
                                the results of the DPP computations.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum</type><structfield>s_ioLevel</structfield>
                           </term>
                           <listitem>
                               <para>
                                An enumerated type that selects the signalling
                                level on the front panel.  Legal values are
                                <literal>nim </literal> and <literal>ttl</literal>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>enum</type><structfield>s_triggerOutputMode</structfield>
                           </term>
                           <listitem>
                               <para>
                                Selects which signal will be presented to the
                                <literal>TRG OUT</literal> lemo.  Legal values
                                are:
                               </para>
                               <variablelist>
                                <varlistentry>
                                   <term><literal>level0</literal></term>
                                   <listitem>
                                       <para>
                                        Continuously de-assserted.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>level1</literal></term>
                                   <listitem>
                                       <para>
                                        Continuously asserted.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>softwareTrigger</literal></term>
                                   <listitem>
                                       <para>
                                        Pulses when a software trigger has been
                                        requested of the module.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <literal>externalTrigger</literal>
                                   </term>
                                   <listitem>
                                       <para>
                                        Pulses when an external trigger has been input
                                        to e.g. the <literal>TRG IN</literal>
                                        Lemo connector.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <literal>globalOrTrigger</literal>
                                   </term>
                                   <listitem>
                                       <para>
                                        Pulses when the motherboard generates a
                                        global OR trigger.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <literal>running</literal>
                                   </term>
                                   <listitem>
                                       <para>
                                        Logical true when the board is running.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <literal>delayedRunning</literal>
                                   </term>
                                   <listitem>
                                       <para>
                                        True when the board is running after a
                                        start delay.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>sampleClock</literal></term>
                                   <listitem>
                                       <para>
                                        Echoes the clock sent to the ADCs to
                                        accept samples.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>pllClock</literal></term>
                                   <listitem>
                                       <para>
                                        Echoes the clock input to the PLL clock.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>busy</literal></term>
                                   <listitem>
                                       <para>
                                        Asserted when the digitizer is busy.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>pllUnlocked</literal></term>
                                   <listitem>
                                       <para>
                                        Asserted when the PLL has lost lock.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <literal>vProbe</literal>
                                   </term>
                                   <listitem>
                                       <para>
                                        Presents the selected virtual probe.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>syncIn</literal></term>
                                   <listitem>
                                       <para>
                                        Reflects the S-IN input.
                                       </para>
                                    </listitem>
                                </varlistentry>
                               </variablelist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>PSDChannelParameters </type><structfield>s_channelConfig[16]</structfield>
                           </term>
                           <listitem>
                               <para>
                                Contains the 16 per channel parameter structs.
                                Note that not all of them may be actually used,
                                for example, in desktop digitizers.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>PSDParameters</refentrytitle>
                  <manvolnum>3DPP-PSD</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>PSDParameters</refname>
                  <refpurpose>Parse COMPASS file into parameters.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;PSDParameters.h&gt;

struct PSDParameters {
public:
    std::vector&lt;PSDBoardParameters&gt; s_boardParams;
public:

    void parseConfigurationFile(const char* pFilename);
}
                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                      <title>DESCRIPTION</title>
                      <para>
                        This class is responsible for processing
                        a COMPASS configuration file and producing,
                        as a result a vector of <classname>PSDBoardParameter</classname>
                        objects.  The
                        method <methodname>parseConfigurationFile</methodname>
                        simple takes <parameter>pFilename</parameter>
                        which is a pointer to the character string
                        path to the file to process.
                      </para>
                </refsect1>
            </refentry>
        </section>
    </appendix>
</book>