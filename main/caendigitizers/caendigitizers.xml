<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>Support for CAEN digitizers</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>December 26, 2019</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
       <title>Introduction</title>
       <para>
            Support for a limited set of CAEN digitizers running either DPP-PHA
            or DPP-PSD firmware by CAEN and has been contributed back to
            NSCLDAQ as of version 12.0.
            This document describes:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              How to build NSCLDAQ with this optional support included and the
              software pre-requisistes needed to perform this build.
           </para>
        </listitem>
        <listitem>
           <para>
              An overview of the support. 
           </para>
        </listitem>
        <listitem>
           <para>
              How to create a readout program for DPP-PHA digitizers. 
           </para>
        </listitem>
        <listitem>
           <para>
              How to create a readout program for DPP-PSD digitizers
           </para>
        </listitem>
        <listitem>
           <para>
              How to create a readout program that mixes DPP-PHA and DPP-PSD
              digitizers.
           </para>
        </listitem>
        <listitem>
           <para>
              How to configure the ReadoutGUI and event builder to use these
              devices.
           </para>
        </listitem>
        <listitem>
           <para>
              Guidance on writing SpecTcl event processors for this sort of data. 
           </para>
        </listitem>
       </itemizedlist>
    </chapter>
    <chapter>
       <title>Overview</title>
       <para>
            Support for the CAEN digitizers is provided through classes that
            allow the SBSreadout skeleton to read data from synchronized sets
            of these digitizers.  Separate class sets have been made availabl for
            the DPP-PHA and DPP-PSD digitizers.
       </para>
       <para>
        Each of these digitizers has a large number of parameters that must be
        set up properly to optimize pulse processing performed on-board.
        CAEN supplies a setup/acquisition tool called COMPASS which can be
        used to configure these parameters and see the effect of parameter
        set choices on spectra produced by the digitizers.
       </para>
       <para>
        COMPASS is available for free download from <ulink url='http://caen.it' />.
        COMPASS can work with single digitizers or with groups of digitizers and
        can be used to create parameter sets for synchronized sets of digitizers.
        These parameter sets are written to XML configuration files.
       </para>
       <para>
        The NSCLDAQ support classes set up the digitizers they manage by processing
        the XML configuration files that were written by COMPASS.   These configuration
        files are processed at the start of each run, allowing the digitizer settings
        to be modified beteween runs.
       </para>
       <para>
         Data from digitizers consists of a sequence of time ordered events from
         each independent digitizer.  Each digitizer event represents data from
         a single channel.  Channel events are timestamped.  The sorted event
         streams from each digitizer must be merged into a single time ordered
         stream of channel events and then coincident events built into meaningful
         events.
       </para>
       <para>
          The NSCL Event builder was created for exactly that purpose.  THerefore,
          when the SBS readout program has been tailored to read CAEN digitizer
          events, each digitizer card is assigned a unique source id.  This
          allows the NSCL Event builder to merge and glom events across
          all digitizers.  
       </para>
       <para>
        We will say more about the special requirements for using the SBS readout
        program with the NSCLDAQ Event builder in a later chapter.
       </para>
    </chapter>
    <chapter>
       <title>Creating event segments for DPP-PHA digitizers</title>
       <para>
        This chapter describes how to create a version of the SBS readout program
        that can setup and read data from the DPP-PHA digitizers.  The steps you
        need to follow are roughly:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              Use CAEN COMPASS to setup the digitizers, including using its
              synchronization wizard to set up several digitizers to run in
              a synchronized manner.  This part of the procedure is beyond the
              scope of this document.
           </para>
        </listitem>
        <listitem>
           <para>
              Obtain a copy of the DPP-PHA skeleton. 
           </para>
        </listitem>
        <listitem>
           <para>
              Edit the skeleton code to include the digitizers you want to
              read.
           </para>
        </listitem>
        <listitem>
           <para>
              Compile and test the code you've written. 
           </para>
        </listitem>
        <listitem>
           <para>
              Configure the ReadoutGUi to run the event builder to build events
              from the channel events that are produced by the Readout.
              This will be described in a later chapter.
           </para>
        </listitem>
       </itemizedlist>
       <para>
        In addition to describing this process we'll also provide a definition
        of the structure of the bodies of ring items produced by the resulting
        readout.
       </para>
       <section>
          <title>Obtaining a copy of the DPP-PHA skeleton.</title>
          <para>
            If you've set up the environment variables for the version of
            NSCLDAQ you are using, you can get a copy of the DPP-PHA skeleton
            code by creating a new empty directory, making it your current working
            directory and issuing the command:
          </para>
          <informalexample>
            <programlisting>
cp $DAQROOT/skeletons/dpp-pha/* .
            </programlisting>
          </informalexample>
          <para>
            This should result in the following files:
          </para>
          <variablelist>
            <varlistentry>
               <term><filename>Skeleton.h</filename></term>
               <listitem>
                   <para>
                    The header for the skeleton application class that
                    defines your event segments scaler banks and triggers.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><filename>Skeleton.cpp</filename></term>
               <listitem>
                   <para>
                    Implementation of the skeleton.  This file will need to
                    be modified by you to match your experimental needs.
                    The modifications you need to make will be described in the
                    next section.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><filename>Makefile</filename></term>
               <listitem>
                   <para>
                    Makefile for the program.  This is a modified version of the
                    SBSReadout Makefile that already includes the directives
                    needed to properly compile and link the skeleton as is with
                    the CAEN DPP-PHA support libraries. 
                   </para>
                   <para>
                    You may need to modify this file if:
                   </para>
                   <itemizedlist>
                    <listitem>
                       <para>
                          You require additional external libraries. 
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          You are combining the readout with DPP-PSD digitizers.
                          This is described in a separate chapter.
                       </para>
                    </listitem>
                   </itemizedlist>
                </listitem>
            </varlistentry>
          </variablelist>
          <caution>
            <title>You cannot mix CAEN DPP digitizers with non CAEN digitizers</title>
            <para>
                The readout requirements of the CAEN DPP digitizers are
                unique enough that you cannot mix reading out the CAEN digitizers
                with non-CAEN digitizers in a single Readout program.  What you
                can do, however is read CAEN Digitizers via the CONET fiber optic
                link and have a second readout program read the non CAEN DPP
                digitizers via a VME controller from the same VME crate using,
                an SBS VME bus bridge or VMUSBReadout with a VM-USB controller.
            </para>
        </caution>
        <para>
                Once you've copied the skeleton, you can optionally build it
                to create an empty readout:
        </para>
        <informalexample>
            <programlisting>
make
            </programlisting>
        </informalexample>
       </section>
       <section>
          <title>Edits you must make to the DPP-PHA skeleton</title>
          <para>
            In this chapter we will take alook at the edits you will have to
            make to the <filename>Skeleton.cpp</filename> file to create an
            actual working Readout program.  As you look at the existing file,
            note that it is an example of a fully functional readout. Therefore
            you'll need to remove/modify existing as well as to add new lines of
            code.
          </para>
          <para>
            Briefly what you will need to do is:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  Create a new <classname>CompassEventSegment</classname>  for
                  each digitzer board in your system. 
               </para>
            </listitem>
            <listitem>
               <para>
                  Create a <classname>CompassMultiModuleEventSegment</classname>
                  and add the
                  <classname>CompasEventSegment</classname> objects you made
                  to it.
               </para>
            </listitem>
            <listitem>
               <para>
                  Create a <classname>CompassTrigger</classname>  object and
                  add all the boards to it.
               </para>
            </listitem>
            <listitem>
               <para>
                  Establish your <classname>CompassMultiModuleEventSegement</classname>
                  as the experiment's event segment and your
                  <classname>CompassTrigger</classname> object as the event
                  trigger.
               </para>
            </listitem>
          </itemizedlist>
          <para>
            Let's take a look at the sample <filename>Skeleton.cpp</filename>'s
          </para>
          <example>
            <title>DPP-PHA's <methodname>SetupReadout</methodname> method.</title>
            <programlisting>
void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
  CReadoutMain::SetupReadout(pExperiment);

  // Create an event segment for each board:
  CompassEventSegment* pBoard1 =                           <co id='phaCompassSegment' />
    new CompassEventSegment("./compass-settings.xml", // Compass config file.
                            1,                     // Module evb source id.
                            CAEN_DGTZ_USB,
                            0, 0, 0x22220000, "cheats.txt");

  CompassMultiModuleEventSegment *mainSegment =           <co id='phaCompassMultiseg' />
    new CompassMultiModuleEventSegment;

  mainSegment-&gt;addModule(pBoard1);                     <co id='phaCompassMultiAddBoard' />



  // Establish your trigger here by creating a trigger object
  // and establishing it.

  // The trigger needs to know about all modules too:

  CompassTrigger* pTrigger = new CompassTrigger;        <co id='phaTrigger' />
  pTrigger-&gt;addModule(pBoard1);                      <co id='phaTriggerAddBoard' />

  // Create and add your event segments here, by creating them and invoking CExperiment's
  // AddEventSegment

  pExperiment-&gt;AddEventSegment(mainSegment);         <co id='phaAddSegment' />
  pExperiment-&gt;EstablishTrigger(pTrigger);           <co id='phaEstTrigger' />


}

            </programlisting>
          </example>
          <calloutlist>
            <callout arearefs='phaCompassSegment' >
                <para>
                    For each CAEN DPP-PHA digitizer board you are using, you
                    must create a <classname>CompassEventSegment</classname>.
                    This class is responsible for configuring the board and
                    reading it out.
                </para>
                <para>
                    Here's the declaration of the constructor for this
                    class:
                </para>
                <constructorsynopsis>
                    <methodname>CompassEventSegment</methodname>
                    <methodparam>
                        <type>std::string</type><parameter>filename</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>int</type><parameter>sourceid</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>CAEN_DGTZ_ConnectionType</type><parameter>linkType</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>int</type><parameter>linknum</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>int</type><parameter>node</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>int</type><parameter>base</parameter>
                        <initializer></initializer>
                    </methodparam>
                    <methodparam>
                        <type>const char*</type><parameter>pCheatFile</parameter>
                        <initializer>nullptr</initializer>
                    </methodparam>
                </constructorsynopsis>
                <para>
                    These parameters have the following meaning:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><parameter>filename</parameter></term>
                       <listitem>
                           <para>
                            The name of the file created by COMPASS to configure
                            the digitizers. Note that this file, in general,
                            can contain the configuration for several digitizers.
                            The connection parameters that follow
                            will be matched against segments of this file to
                            locate the configuration for this board
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>sourceId</parameter></term>
                       <listitem>
                           <para>
                            From the event builder's perspective, each digitizer
                            is an event source and must be assigned a unique
                            source id.  This parameter provides that source id.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>linkType</parameter></term>
                       <listitem>
                           <para>
                            Defines how the digitizer is connected to the system.
                            The enumerated type provides several values, but in
                            practice only two are useful:
                            <literal>CAEN_DGTZ_USB</literal>  indicates
                            the digitizers are in a VME crate that is controlled by
                            a CAEN V1718 VME bus bridge.  Tempting as it may be,
                            this type does <emphasis>not</emphasis> support
                            VM-USB controllers.  <literal>CAEN_DGTZ_OpticalLink</literal>
                            indicates that the digitizers are either directly
                            connected to a CONET card/daisychain (recommended)
                            or controlled via a V2718 controller (not recommended).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>linkNum</parameter></term>
                       <listitem>
                           <para>
                            The link number connected to the digitizer.  This is
                            <literal>0</literal> if the link type is
                            <literal>CAEN_DGTZ_USB</literal> and the
                            CONET link number if <literal>CAEN_DGTZ_OpticaLink</literal>.
                            For each CONET interface board in the computer, the links
                            are numbered from 0 from the top tab of the
                            board to the bottom of the board.  See e.g.
                            <ulink url='https://www.caen.it/wp-content/uploads/2017/10/A3818_both_big2.jpg' />
                            for a diagram.
                           </para>
                           <para>
                            For multiple CONET board, trial and error may be
                            needed to determine which set of links each board
                            controls.  In any event at that point you might
                            want to use several readout computers so that
                            the I/O and computing bandwidth of the host is
                            not exceeded.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>node</parameter></term>
                       <listitem>
                           <para>
                            This must be <literal>0</literal> for connection
                            type <literal>CAEN_DGTZ_USB</literal>.
                            For <literal>CAEN_DGTZ_OpticaLink</literal>, each
                            link can support a daisy chain of up to targets, or
                            nodes. The nodes are numbered sequentially from 0 to
                            7 as they occur along the daisy chain.  Refer to
                            3.2 of the A3818 user manual for more information
                            about setting up a CONET daisy chain.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>base</parameter></term>
                       <listitem>
                           <para>
                            If the digitizers are controlled via a VME controller,
                            this parameter is their base address in the VME
                            bus.  The module's base addresses are configured
                            via rotary switches on the board. See the user
                            manual for the V1730 or V1725, figure 7.2 for
                            the location and meaning of these rotary switches.
                           </para>
                           <para>
                            Each digitizer must specifiy a unique, non-overlapping
                            address space in its VME bus.
                           </para>
                           <para>
                            If the link type is <literal>CAEN_DGTZ_OpticaLink</literal>,
                            this must be zero.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>cheatFile</parameter></term>
                       <listitem>
                           <para>
                            The Compass XML file specifies how to configure
                            the digitizer.  In some cases, it may be desirable
                            or necessary to tweak register values after the
                            digitizer is initialized but before acquisition
                            is started.  
                           </para>
                           <para>
                            This parameter provides the ability to specify
                            a <firstterm>cheat file</firstterm>. The cheat file
                            allows you to perform these tweaks.  If this parameter
                            is null (the default), no cheats are performed.
                            Otherwise, this specifies the path to the cheat file.
                           </para>
                           <para>
                            The cheat file format id described in the section
                            <xref endterm='cheatfile' linkend='cheatfile' />
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </callout>
            <callout arearefs='phaCompassMultiseg' >
                <para>
                    Digitizer readout is controlled by a 
                    <classname>CompassMultimoduleEventSegment</classname>.
                    This line constructs one of those.  You must put your
                    <classname>CompassEventSegment</classname> instances into
                    one of these, even if you are only reading a single digitizer.
                </para>
            </callout>
            <callout arearefs='phaCompassMultiAddBoard' >
                <para>
                    Shows how to add a board to the
                    <classname>CompassMultiModuleEventSegment</classname>
                    instance.
                </para>
            </callout>
            <callout arearefs='phaTrigger' >
                <para>
                    The event trigger is implemented by polling for data
                    ready in any of the digitizer boards in the system.  This
                    is done by a <classname>CompassTrigger</classname> object
                    that is created here.
                </para>
            </callout>
            <callout arearefs='phaTriggerAddBoard' >
                <para>
                    The <classname>CompassTrigger</classname> object needs
                    to know about all of the boards in order to know how
                    to poll for a trigger.  This line adds the board
                    we created to the trigger. You must do this for every
                    <classname>CompassEventSegment</classname> you created and
                    added to the <classname>CompassMultiModuleEventSegment</classname>.
                </para>
            </callout>
            <callout arearefs='phaAddSegment' >
                <para>
                    The <classname>CompassMultiModuleEventSegment</classname>
                    instance must be set as the event segment for the Readout.
                    You should only create and set one of these otherwise
                    each trigger may produce ring items with several channel hits
                    and those may not build into proper events.
                </para>
            </callout>
            <callout arearefs='phaEstTrigger' >
                <para>
                    Similarly, your <classname>CompassTrigger</classname> object
                    must be set as the experiment's trigger.
                </para>
            </callout>
          </calloutlist>
       </section>
       <section>
          <title>Compiling and testing</title>
          <para>
            The skeleton program comes with a Makefile that is easy to modify
            for your own purposes.  Normally this Makefile does not need to
            be modified as combining CAEN DPP digitizers with other modules
            is not supported by this Readout framework (DPP-PHA and DPP-PSD
            may be combined and we'll get to that later).
          </para>
          <para>
            The lines that cane be modified in the unlikely circumstance that you
            need to are:
          </para>
          <informalexample>
            <programlisting>
USERCCFLAGS=$(CAENCXXFLAGS) 
...
USERLDFLAGS=$(CAENLDFLAGS)

            </programlisting>
          </informalexample>
          <para>
            The <literal>USERCCFLAGS</literal> variable can be modified to add
            more compilation flags.  Do not remove the <literal>$(CAENCXXFLAGS)</literal>
            macro invocation from this definition as this macro supplies flags that
            are necessary to compile the the DPP-PHA readout Skeleton.cpp file.
          </para>
          <para>
            The <literal>USERLDFLAGS</literal> variable can be modified to add
            more linker flags.  Again, do no remove the <literal>$(CAENLDFLAGS)</literal>
            macro invocation.  It supplies loader directives to link in
            the libraries needed by the CAEN DPP-PHA readout program.
          </para>
          <para>
            In the unlikely event that you add more source files to the
            Readout program, modify the <literal>OBJECTS</literal>
            definition, adding your additional desired objects.
            These will be compiled with the USERCCFLAGS and linked into the
            Readout program using the USERLDFLAGS you've defined.
          </para>
          <para>
            Use the command:
          </para>
          <informalexample>
            <programlisting>
make
            </programlisting>
          </informalexample>
          <para>
            To compile and link your program.  Prior to running it be sure the
            compass configuration file(s) you refer to have been created where
            your objects expect them.
          </para>
          <para>
            You can now run the program, either by itself or under the
            NSCL Readout GUI (to use an event builder) and use
            $DAQBIN/dumper to look at some of the events.
            The next section describes the format of the data read out by
            the DPP-PHA event segments.
          </para>
       </section>
       <section>
          <title>Structure of data read by the DPP-PHA skeleton</title>
          <para>
            This section describes the format of the data readout by the DPP-PHA
            readout program.  Note that usually, individual channel hits are
            assembled into events using the NSCL event builder.  The wrapping
            of data by the  NSCL Event builder is beyond the scope of this document.
            See the NSCLDAQ event builder documentation for that information.
          </para>
          <para>
            Before going into the event structure in detail, a note about timestamps.
            The V725 and V730 boards have a different timestamp clock rate.
            The readout framework adjusts the timestamps from both boards
            so that the event is tagged with a timestamp in nanoseconds.  This
            allows the event builder to properly build data from these boards
            (and e.g. XIA DDAS boards as well) correctly).
          </para>
          <para>
            Here's a text picture of the structure of each hit's body:  Note that
            the body header contains the source id, which in turn tells you
            which module this packet comes from.
          </para>
          <example>
            <title>DPP-PHA event structure.</title>
            <programlisting>
+----------------------------------+
| Event Size in bytes (uint32_t)   |
+----------------------------------+
| Channel number (uint32_t)        |
+----------------------------------+
|     Time tag (uint64_t) in ns    |  <co id="dpp-pha-timetag" />
+----------------------------------+
|     Energy (uint16_t)            |  <co id="dpp-pha-packing" />
+----------------------------------+
|     Extras 1  (uint16_t)         |  <co id ="dpp-pha-extras" />
+----------------------------------+
|     Extras 2 (uint16_t)          |
+----------------------------------+
| ... optional waveform data       |  <co id="dpp-pha-optionalwf" />
|       ....                       |
            </programlisting>
          </example>
          <calloutlist>
            <callout arearefs='dpp-pha-timetag' >
                <para>
                    This is not the raw time tag from the digitizer.
                    The digitizer has a 32 bit timestamp with
                    an optional 16 bit extension that could be
                    put in the one of the extras (see below).
                    This timestamp can only cover a relatively short
                    period of time (a few seconds).  Therefore,
                    the readout program tracks wrap arounds (this is
                    fine as long as there are not two wraps between
                    hits), and calibrates the resulting tag to
                    nanoseconds.  This value is the 64 bit nanosecond
                    timestamp that also accounts for raw stamp
                    rollovers.
                </para>
            </callout>
            <callout arearefs='dpp-pha-packing' >
                <para>
                    A quick note that there are no pad words.
                    Event data is tight packed.
                </para>
            </callout>
            <callout arearefs='dpp-pha-extras' >
                <para>
                    In addition to the results of the DPP algorithm,
                    extra words can be included in the data
                    depending on how the digitizer is configured.
                    These two words are called Extras 1 and
                    Extras 2. Their contents depend on how you've
                    configured the digitizer.
                </para>
            </callout>
            <callout arearefs='dpp-pha-optionalwf' >
                <para>
                    Waveform data can be included.  Up to two
                    traces of data can be put into the event
                    depending on the configuration of the digitzer.
                    Waveform data may also be completely
                    suppressed, if that's how the digitizer
                    is configured.  The form of waveform data
                    is shown below:
                </para>
            </callout>
          </calloutlist>
          <example>
            <title>DPP-PHA waveform data</title>
            <programlisting>
+-----------------------------+
| No. of Samples (uint32_t)   |
+-----------------------------+
|  Dual trace flag (uint16_t) |
+-----------------------------+
|  First trace                |   <co id='dpp-pha-trace1' />
    ....
+-----------------------------+
|  Optional second trace      |   <co id='dpp-pha-trace2' />
     ....
+-----------------------------+
            </programlisting>
          </example>
          <para>
            The digitizer can record two waveforms per channel.
            The contents of these waveforms depends on the
            digitizer configuration. The waveform packet
            begins with a uint32_t that contains the number of
            samples in each trace (if there are two traces both
            have the same number of samples).  If no traces
            are recorded, this value is 0.
          </para>
          <para>
            Following the number of samples is a dual trace flag.
            This is present even if no waveforms are being recorded.
            This flag is nonzero if waveforms are being recorded
            and there will be two of them.  Otherwise, this flag
            is zero.
          </para>
          <calloutlist>
            <callout arearefs='dpp-pha-trace1' >
                <para>
                    This packet of contains one uint16_t trace
                    value per sample.  Naturally, if the number of
                    samples is zero, there will be no data words here.
                </para>
            </callout>
            <callout arearefs='dpp-pha-trace2' >
                <para>
                    This packet is only present if the dual trace
                    flag is nonzero.  It contains the second trace.
                    Note, once more this contains a 16 bit integer
                    per trace value.  This is omitted if the  number
                    of samples is zero or the dual trace flag is
                    zero but the number of samples is
                    nonzero.
                </para>
            </callout>
          </calloutlist>
       </section>
       <section>
        <title id='cheatfile'>Cheat files</title>
        <para>
            Sometimes there are tweaks  you will want to make to the
            digitizer configuration that are not supported by
            Compass or not well supported by the implementation at this
            time.  Once the digitizer is configured but before it is
            started, you can optionally process a
            <firstterm>cheat file</firstterm>
        </para>
        <para>
            The cheat file specifies changes to the configuration
            of the digitizer.  The cheat file is optionally
            specified when the digitizer is constructed. If
            omitted, no cheats will be applied.  Each cheat
            file line consists of three space separated fields.
        </para>
        <orderedlist>
            <listitem>
               <para>
                  The first field is a single character that
                  specifies an operation.
               </para>
            </listitem>
            <listitem>
               <para>
                  The second field is an address, usually a register
                  address.
               </para>
            </listitem>
            <listitem>
               <para>
                  The final field is a value. 
               </para>
            </listitem>
        </orderedlist>
        <para>
            Cheat files can also have empty lines and lines that
            begin with a <literal>#</literal>.  These lines are
            ignored.
        </para>
        <para>
            Here are the operations and what they do:
        </para>
        <variablelist>
            <varlistentry>
               <term><literal>.</literal></term>
               <listitem>
                   <para>
                    The address is the address of a register.
                    The value is set into the register.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>|</literal></term>
               <listitem>
                   <para>
                    The address is the address of a register.
                    The value is bitwise ored into the register's
                    current value.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>*</literal></term>
               <listitem>
                   <para>
                    The address is the address of a register.
                    The value is bitwise anded with the register.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>i</literal></term>
               <listitem>
                   <para>
                    The address is a channel number.
                    The value is one of the
                    legal values of its pile up rejection counters
                    in the digitizer. The value can
                    be 128, 1024, or 8192.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>t</literal></term>
               <listitem>
                   <para>
                    The address is ignored. The value is a proposed
                    value for the module's aggregate transfer
                    threshold.  This is the second parameter to
                    the function
                    <function>CAEN_DGTZ_SetDPPEventAggregation</function>
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
       </section>
    </chapter>
    <chapter>
       <title>Creating event segments for DPP-PSD digitizers</title>
       <para>
        The DPP-PSd firmware allows CAEN digitizers to perform
        pulse shape discrimination.  This involves integrating
        the background subtracted pulse within two integration
        windows, a short and a long window.
       </para>
       <para>
        This chapter will describe how to create event segments for
        the DPP-PSD firmware in CAEN x730 and x725 modules.  While
        it is possible to mix DPP-PSD and DPP-PHA modules it is not
        possible to mix CAEN DPP modules with other types of
        modules in the same Readout program.  Mixing
        DPP-PSD and DPP-PHA modules will be described in the
        next chapter.
       </para>
      <para>
            This chapter is divided into the following sections:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  First we describe how to get the skeleton for DPP-PSD
                  readout.
               </para>
            </listitem>
            <listitem>
               <para>
                   Next we describe how to modify the skeleton to readout the
                   set of digitizers you are using.
               </para>
            </listitem>
            <listitem>
               <para>
                  We describe how to build the resulting Readout program.
               </para>
            </listitem>
            <listitem>
               <para>
                  Finally we describe the structure of events readout
                  from the DPP-PSD digitizers.
               </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Obtaining the DPP-PSD skeleton</title>
            <para>
                The DPP-PSD readout is a specialized version of the SBS readout
                skeleton.  An event segment class has been written to support
                individual board and an over-arching event segment manages the
                collection of boards in the system.  
            </para>
            <para>
                To obtain the skeleton readout program create an empty
                directory and cd into it then, if the DAQROOT environment
                variable points to the top level installation directory
                of your NSCLDAQ installation:
            </para>
            <informalexample>
                <programlisting>
cp $DAQROOT/skeletons/dpp-psd/* .
                </programlisting>
            </informalexample>
            <para>
                Copies the skeleton files into the current working directory.
                This comprises the following files:
            </para>
            <variablelist>
                <varlistentry>
                   <term><filename>Skeleton.h</filename></term>
                   <listitem>
                       <para>
                        Header for the skeleton code file.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><filename>Skeleton.cpp</filename></term>
                   <listitem>
                       <para>
                        Skeleton source code you must modify.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><filename>Makefile</filename></term>
                   <listitem>
                       <para>
                        Makefile to build the Readout program.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
           <title>Modifying the DPP-PSD skeleton</title>
           <para>
            Let's start by looking at the skeleton's
            implementation of the <methodname>SetupReadout</methodname>
            method.  Then we'll describe in general what you need to do
            to build a multi-board system.
           </para>
           <example>
            <title>DPP-PSD <methodname>SetupReadout</methodname> skeleton implementation</title>
            <programlisting>
void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
  CReadoutMain::SetupReadout(pExperiment);

  CDPpPsdEventSegment* pSegment =                <co id='psd-board' />
    new CDPpPsdEventSegment(PSDBoardParameters::usb, 0, 0, 0x33330000, 1, "../settings.xml");
  CPsdCompoundEventSegment*  pCompound = new CPsdCompoundEventSegment(); <co id='psd-mgmnt' />
  pCompound-&gt;addModule(pSegment);               <co id='psd-addmodule' />

  pExperiment-&gt;AddEventSegment(pCompound);      <co id='psd-establishsegment' />

  CPsdTrigger* pTrigger = new CPsdTrigger;      <co id='psd-trigger' />
  pTrigger-&gt;addModule(pSegment);                <co id='psd-addtrigger' />
  pExperiment-&gt;EstablishTrigger(pTrigger);      <co id='psd-esttrigger' />

}

            </programlisting>
           </example>
           <para>
            If you've looked at the DPP-PHA skeleton you'll see significant
            differences.  The DPP-PSD skeleton was written second and I tried
            to learn from the experience of building the DPP-PHA skeleton,
            however many of the concepts are identical.
           </para>
           <calloutlist>
            <callout arearefs='psd-board' >
                <para>
                    Every digitizer board in the system must have a
                    corresponding <classname>CDPpPsdEventSegment</classname>
                    object createdto manage it. The parameters to the constructor
                    establish the connection parameters to the digitizer,
                    it's source id and the COMPASS configuration file
                    that contains its configuration.
                </para>
                <para>
                    Here's the formal declaration of that class's constructor>
                </para>
                <constructorsynopsis>
                    <methodname>CDPpPsdEventSegment</methodname>
                        <methodparam>
                            <type>PSDBoardParameters::LinkType </type><parameter>linkType</parameter>
                            <initializer></initializer>
                        </methodparam>
                        <methodparam>
                            <type>int</type><parameter>linkNum</parameter>
                            <initializer></initializer>
                        </methodparam>                    
                        <methodparam>
                            <type>int </type><parameter>nodeNum</parameter>
                            <initializer></initializer>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>base</parameter>
                            <initializer></initializer>
                        </methodparam>   
                        <methodparam>
                            <type>int</type><parameter> sourceid</parameter>
                            <initializer></initializer>
                        </methodparam>
                        <methodparam>
                            <type>const char* </type><parameter>configFile</parameter>
                            <initializer></initializer>
                        </methodparam>
                </constructorsynopsis>
                <para>
                    The parameters of the constructor are as follows:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><parameter>linkType</parameter></term>
                       <listitem>
                           <para>
                            This can be either
                            <literal>PSDBoardParameters::usb</literal> if the
                            connection to the digitizer is either usb to a
                            desktop digitizer or to a CAEN V1718 USB VME
                            controller, or <literal>PSDBoardParameters::conet</literal>
                            if the connection to the digitizer is either
                            direct CONET (optical fiber) or via a CAEN V2718
                            optical CVME crate controller.  For high rate applications,
                            I recommend direct CONET connection.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>linknum</parameter></term>
                       <listitem>
                           <para>
                            If the link type is PSDBoardParameters::usb, this
                            should be zero.  Otherwise, this is the number of the
                            link the fiber optic connecting to either this
                            digitizer or its V2718 crate controller.
                            See <ulink url='https://www.caen.it/wp-content/uploads/2017/10/A3818_both_big2.jpg' />
                            for information that describes how to determine the
                            linkid on a single CONET interface card.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>base</parameter></term>
                       <listitem>
                           <para>
                            If the digitizers are VME cards controlled by either
                            a V1718 or V2718 controller, this parameter is the
                            VME base address assigned to the module via its
                            rotary switches.  Each card must have a unique
                            base address and its address space must not overlap
                            any other cards in the system.  If the digitizers
                            are directly connected to CONET, this must be
                            zero.
                           </para>
                        </listitem>
                    </varlistentry>
                    
                    <varlistentry>
                       <term><parameter>nodeNum</parameter></term>
                       <listitem>
                           <para>
                            Each CONET link can service up to eight digitizers
                            by daisy chaining the fiber optics.  The Tx
                            fiber goes from the interface to the Rx input
                            of the node 0 and the Tx Fiber then goes from
                            the Tx of that board to the Rx of node 1 and
                            so on until the Tx of the last board goes back to the
                            Rx input of the interface board.
                           </para>
                           <para>
                            The nodes on this ring network are numbered from 0
                            to 7 starting with the first board connected to the
                            Tx of the interface board. Refer to
                            3.2 of the A3818 user manual for more information
                            about setting up a CONET daisy chain and how
                            the nodes are numbered along the chain.
                            For USB connections this should also be zero.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>sourceid</parameter></term>
                       <listitem>
                           <para>
                            This is the source id that will be assigned to hits
                            from the channels on this board.  Each board in the
                            entire system must have a unique source id.
                            This source id will be used by the NSCL event builder
                            to weave together hits from several modules into
                            events.
                           </para>
                           <para>
                            If you are mixing data from CAEN digitizers
                            with other data sources, again
                            <emphasis>every</emphasis> data source
                            in the system must have a unique
                            source id.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><parameter>configFile</parameter></term>
                       <listitem>
                           <para>
                            Is the path to the configuration file that was
                            used to configure the digitizer in COMPASS.  This
                            configuration file can be used for several digitizers.
                            The connection parameters in the configuration file
                            will be matched against the configuration parameters
                            for this board to determine which board configuration
                            to use.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </callout>
            <callout arearefs='psd-mgmnt' >
                <para>
                    Board readout is managed by a
                    <classname>CPsdCompundEventSegment</classname>.  Therefore
                    you must instantiate exactly one of these to manage the
                    readout from the devices.
                </para>
            </callout>
            <callout arearefs='psd-addmodule' >
                <para>
                    Each module object must be added to the
                    <classname>CPsdCompoundEventSegment</classname>
                    so that it knows it must configure and readout
                    the board.
                </para>
            </callout>
            <callout arearefs='psd-establishsegment' >
                <para>
                    The <classname>CPsdCompoundEventSegment</classname>
                    must then be established as the experiment's
                    event segment.
                </para>
            </callout>
            <callout arearefs='psd-trigger' >
                <para>
                    The trigger for reading data is that at
                    least one digitizer has data available to read.
                    The <classname>CPsdTrigger</classname> class,
                    is therefore instantiated to fairly poll
                    the triggers in the digitizers.
                </para>
            </callout>
            <callout arearefs='psd-addtrigger' >
                <para>
                    <classname>CPsdTrigger</classname> also needs
                    to know about the individual
                    <classname>CDPpPsdEventSegment</classname>
                    objects as it polls data availability by
                    asking each segment if it is ready to be read out.
                </para>
            </callout>
            <callout arearefs='psd-esttrigger' >
                <para>
                    Finally the <classname>CPsdTrigger</classname>
                    object is established as the event trigger
                    for the Readout program.
                </para>
            </callout>
           </calloutlist>
           <para>
            Thus preparing a Skeleton consists of:
           </para>
           <orderedlist>
            <listitem>
               <para>
                  Creating a <classname>CDPpPsdEventSegment</classname>  object
                  for each digitizer.
               </para>
            </listitem>
            <listitem>
               <para>
                  Creating a <classname>CPsdCompoundEventSegment</classname>
                  object to manage all <classname>CDPpPsdEventSegment</classname>
                  objects and adding each of those objects to the
                  <classname>CPsdCompoundEventSegment</classname> object and
                  finally adding the compound event segment to the experiment's
                  event segment.
               </para>
            </listitem>
            <listitem>
               <para>
                  Creating a <classname>CPsdTrigger</classname> object
                  to poll the boards to determine if they can be readout.
               </para>
            </listitem>
            <listitem>
               <para>
                  Add each board to the trigger object. 
               </para>
            </listitem>
            <listitem>
               <para>
                  Establish the <classname>CPsdTrigger</classname>  object
                  as the Readout's trigger.
               </para>
            </listitem>
           </orderedlist>
        </section>
        <section>
           <title>Building the DPP-PSD readout program</title>
           <para>
            Normally the Makefile provided with the skeleton is sufficient and
            does not require modification.  This is because the CAEN digitizers
            are multi-event buffered devices and it's not supported to
            operate them in conjunction with other devices.  An actual
            event might be read out in response to several re-triggerings
            across several channels in the same or different boards.
           </para>
           <para>
            If you do need to modify the skeleton to include additional
            files and, perhaps, include additional libraries, the following
            definitions in the Makefile can be modified:
           </para>
           <variablelist>
            <varlistentry>
               <term><literal>USERCCFLAGS</literal></term>
               <listitem>
                   <para>
                    This definition supplies the compilation
                    flags to the g++ compiler.  You can use
                    this to add include directories or define
                    pre-processor symbols or add any additional
                    compilation flags you need.
                   </para>
                   <para>
                    <emphasis>Do not</emphasis> remove the
                    <literal>$(CAENCXXFLAGS)</literal> from
                    that definition.  It is required for the
                    build to locate headers for the CAEN digitizer
                    support libraries.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>USERLDFLAGS</literal></term>
               <listitem>
                   <para>
                    This definition provides flags to the g++
                    command's dispatch of  <command>ld</command>
                    the linker.  If you need additional libraries,
                    or other link time flags and directives,
                    they can be appended to this definition.
                   </para>
                   <para>
                    <emphasis>Do not</emphasis> remove the
                    <literal>$(CAENLDFLAGS)</literal> from this
                    definition as it specifies the libraries
                    and other link directives needed to
                    link in the CAEN digitizer support libraries.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>OBJECTS</literal></term>
               <listitem>
                   <para>
                    Provides the names of additional objects to link
                    into the final Readout.  Append to this if you
                    have additional source or pre-built object
                    modules you need.  
                   </para>
                   <para>
                    Unless you specify exact build rules for
                    the objects from source, the g++ will be
                    used for files with C++ extensions and
                    gcc for files with C extensions.  The
                    compilation flags will be determined by
                    both rules in the centralized
                    <filename>$DAQROOT/ect/SBSRdoMakeIncludes</filename>
                    file and the <literal>USERCCFLAGS</literal>.
                   </para>
                   <para>
                    If you have other requirements you may, of course
                    specifiy a dependency and associated Makefile
                    build rule.  Doing this is beyond the scope of
                    this document.  See primers on gnumake
                    for more information about how to do that.
                   </para>
                </listitem>
            </varlistentry>
           </variablelist>
           <para>
            Once the Makefile is to your liking:
           </para>
           <informalexample>
            <programlisting>
make
            </programlisting>
           </informalexample>
           <para>
            Will build your tailored Readout program. After you've
            fixed any compilation errors you can either run the
            Readout program directly on the system interfaced to the
            digitizers or set up the program to run as a
            data source with the ReadoutShell
           </para>
        </section>
        <section>
           <title>Event format from the DPP-PSD readout.</title>
           <para>
            This section describes the format for each hit
            (channel event) from the PSD digitizers.  Normally,
            hits are sent to an event builder where they are wrapped
            in event builder headers and bundled into events
            that consist of hits that have occured within some
            time period of a first hit.
           </para>
           <para>
            This section will describe the raw body of hits
            produced by the Readout program prior to event building.
            Each event is a ring item of type
            <literal>PHYSICS_EVENT</literal>.   These events
            have the standard body header that carries the
            timestamp and source id among other things.
            The actual body of the event follows the body header
            and has the following structure:
           </para>
           <example>
            <title>Format of DPP-PSD event bodies</title>
            <programlisting>
+-----------------------------------+
| Size of hit body (uint32_t)       |
+-----------------------------------+
| Raw cumulative timestamp uint64_t |  <co id='psdstruct-stamp' />
+-----------------------------------+
| channel number (uint16_t)         |
+-----------------------------------+
|  Short gate charge (uint16_t)     |
+-----------------------------------+
|  Long gate charge (uint16_t)      |
+-----------------------------------+
|  Baseline (uint16_t)              |
+-----------------------------------+
| Pile up rejection flag (uint16_t) |
+-----------------------------------+
| Wave form data ...  see below     |
       ...
+-----------------------------------+
            </programlisting>
           </example>
            <calloutlist>
                <callout arearefs='psdstruct-stamp' >
                    <para>
                        The timestamp in the raw hit from the digitizer
                        is 32 bits wide and is in digitizer
                        size specific units.   This has two problems.
                        First, 32 bits of timestamp only allow for
                        a few seconds of run time before the timestamp
                        rolls over.  Second, device specific units of
                        the raw timestamp would make event building
                        with a heterogeneous set of digitizers
                        impossible.  The event builder expects
                        all data sources to be running at the same
                        timestamp frequency.
                    </para>
                    <para>
                        The timestamp in the event body is computed
                        using wrap detection and a carry counter to
                        produce a true 64 bit timestamp in the
                        device units.   This timestamp is accurate
                        as long as the channel it comes from
                        does not roll over more than once between
                        hits.
                    </para>
                    <para>
                        The resulting timestamp is then multiplied by
                        the number of nanoseconds per digitizer
                        timestamp tick and the resulting timestamp
                        in nanoseconds is put into the event's body
                        header.   The event builder only cares
                        about the body header.  This allows all digitizers
                        to present timestamps with a common time base
                        (nanosecond units) to the event builder.
                    </para>
                    <para>
                        Note that the software supporting XIA
                        Pixie16 modules also presents body header
                        timestamps in nanosecond units making it
                        possible to directly build XIA and
                        CAEN digital data acquisition system event
                        fragments together.
                    </para>
                </callout>
            </calloutlist>
            <para>
                The remainder of the event structure should be
                self explanatory from the description of the
                digitizer, with the exception of the waveform
                data.  Note that the digitizer this hit came
                from can be deduced from the source id located
                in the hit's body header.
            </para>
            <para>
                The digitizers can be told to acquire waveforms.
                The structure of waveform data is as follows:
            </para>
            
            
            <example>
                <title>DPP-PSD waveform data</title>
                <programlisting>
+-------------------------------------------+
|  sample Size of waveform data (uint32_t)  | <co id='psdfmt-wfsize' />'
+-------------------------------------------+
|  Number of samples     (uint32_t)         | <co id='psdfmt-trlen' />
+-------------------------------------------+
|  Dual trace (uint8_t)                     | <co id='psdfmt-dt' />
+-------------------------------------------+
|  Analog probe selector (uint8_t)          | <co id='psdfmt-aprobe' />
+-------------------------------------------+
|  Trace 1 (no samples * uint16_t)          |
+-------------------------------------------+
|  Optional Trace2 (no samples *uint16_t)   | <co id='psdfmt-tr2' />
+-------------------------------------------+
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='psdfmt-wfsize' >
                    <para>
                        Provides the number of bytes of waveform
                        data.  The size is inclusive of this
                        longword.
                        Note that if there is not waveform
                        data, this will be <literal>sizeof(uint32_t)</literal>.
                        That indicates there is no data following the
                        size word.
                    </para>
                </callout>
                <callout arearefs='psdfmt-trlen' >
                    <para>
                        This  and subsequent words are only present
                        if there is trace data
                        (the prior longword is not sizeof(uint32_t)).
                        In that case, this is the number of samples
                        in each trace.  Note that in dual trace mode,
                        both traces have the same number of samples,
                        making it unecessary to have two trace lengths.
                    </para>
                </callout>
                <callout arearefs='psdfmt-dt' >
                    <para>
                        This byte is non-zero if there are two traces
                        or zero if only one.
                    </para>
                </callout>
                <callout arearefs='psdfmt-aprobe' >
                    <para>
                        This word along with the dual trace flag
                        describes the meaning of the data in the trace(s).
                        This is essentially the value of the
                        board configuration register bits 12,13.
                        The meaning of these bits depends on whether
                        dual trace is enabled.
                    </para>
                    <para>
                        If dual trace is not enabled, a value of zero
                        means the trace is the input waveform.
                        A value of 1 means the trace is the CFD
                        waveform.
                    </para>
                    <para>
                        If dual trace is enabled;
                        A value of zero means the first trace
                        is the input waveform while the second trace
                        is the runnning baseline determination.  A value
                        of 1 means that the first trace is the CFD and
                        the second trace, again the running baseline
                        determination. A value of 2 means that the
                        first trace is the input waveform and the second
                        trace the CFD.
                    </para>
                    <para>
                        If only it were that simple.  The
                        CFD trace is only available if CFD discrimination
                        is enabled.  If it is disabled, then the
                        "CFD" trace is actually the smoothed input
                        trace.
                    </para>
                </callout>
                <callout arearefs='psdfmt-tr2' >
                    <para>
                        Note that the second trace is not present unless
                        the dual trace flag is nonzero.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </chapter>
    <chapter>
        <title>Creating Readouts that mix DPP-PSD and DPP-PHA segments</title>
        <para>
            There are two ways to mix DPP-PSD and DPP-PHA event segments.
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  Use one readout program for the DPP-PHA digitizers
                  and a second for the DPP-PSD digitizers.
               </para>
            </listitem>
            <listitem>
               <para>
                  Use a single readout and combine the data from
                  both digitizers.
               </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that whichever you choose, you must determine which
            of the digitizers is the master timing source on the
            daisy chain and configure both types of digitizers
            accordingly.  Using the COMPASS synchronization
            wizard can help you with this.
        </para>
        <para>
            If you use two readouts, you can stil have a common
            XML configuration file as both programs can locate
            their digitizers from within the XML configuration and
            will ignore digitizers they've not been told about.
        </para>
        <para>
            The remainder of this chapter will describe how to
            merge data from both digitizers into a single readout
            program.  Briefly here are the steps to follow:
        </para>
        <itemizedlist>
           <listitem>
              <para>
                 Obtain the DPP-PSD skeleton. 
              </para>
           </listitem>
           <listitem>
              <para>
                 Add appropriate <literal>#include</literal>
                 definitions to pull in the class headers you need
                 from the DPP-PHA framework.
              </para>
           </listitem>
           <listitem>
              <para>
                 Edit the skeleton to make DPP-PSD event segments
                 and a <classname>CDPpPsdCompoundEventSegment</classname>
                 as you normally would for configuring
                 the the skeleton
              </para>
           </listitem>
           <listitem>
              <para>
                 Add to that configuration the
                 <classname>CompassEventSegment</classname> objects
                 and <classname>CompassMultiModuleEventSegment</classname>
                 as you normally would for the DPP-PHA skeleton.
              </para>
           </listitem>
           <listitem>
              <para>
                Create a <classname>COneOnlyEventSegment</classname>
                object and insert into it both the
                <classname>CDPpPsdCompoundEventSegment</classname>
                and the <classname>CCompassMultiModuleEventSegement</classname>
                you created in the previous steps.
                Register that object as Readout's event segment.
              </para>
           </listitem>
           <listitem>
              <para>
                 Create and fill both <classname>CPsdTrigger</classname>
                 and <classname>CompassTrigger</classname> objects
                 as you would for the DPP-PSD and DPP-PHA
                 skeletons.
              </para>
           </listitem>
           <listitem>
              <para>
                 Create a <classname>CCompoundTrigger</classname>
                 object and insert both the DPP-PHA and DPP-PSD
                 trigger objects into it. Then register
                 this compound trigger object as the event trigger.
              </para>
           </listitem>
           <listitem>
              <para>
                 Edit the Makefile so that it will link in the
                 CAENDPP_PHA library in addition to the
                 libraries it already does (that library
                 has the DPP-PHA support code we're using).
                 Then build the resulting code.
              </para>
           </listitem>
        </itemizedlist>
        <para>
         The remaining sections of this chapter:
        </para>
        <itemizedlist>
         <listitem>
            <para>
               Show the extra <literal>#include</literal>
               directives you need to add to the top
               of the DPP-PSD <filename>Skeleton.cpp</filename>
            </para>
         </listitem>
         <listitem>
            <para>
               Provide a sample edit of Skeleton.cpp to
               manage a single DPP-PSD and DPP-PHA module.
            </para>
         </listitem>
         <listitem>
            <para>
               Show the Makefile edits required to build
               the resulting Readout program.
            </para>
         </listitem>
        </itemizedlist>
        <section>
            <title>Include additional Headers in the skeleton</title>
            <para>
                
            </para>
        </section>
        <section>
           <title>Editing the <methodname>SetupReadout</methodname> method</title>
           <para>
           </para>
        </section>
        <section>
           <title>Makefile edits required.</title>
           <para>
           </para>
        </section>
    </chapter>
    <chapter>
       <title>Configuring the Event builder to create events.</title>
       <para>
       </para>
    </chapter>
    <chapter>
        <title>caendump</title>
        <para>
            
        </para>
    </chapter>
    <appendix>
        <title>
            Reference material
        </title>
        <para>
            
        </para>
    </appendix>
</book>