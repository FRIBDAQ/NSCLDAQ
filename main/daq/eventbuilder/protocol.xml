<!-- manpage 5daq -->

<refentry id="daq5-evbprotocol">
    <refentryinfo>
      <author>
          <personname>
              <firstname>Ron</firstname>
              <surname>Fox</surname>
          </personname>
          <personblurb><para></para></personblurb>
      </author>
      <productname>NSCLDAQ</productname>
      <productnumber></productnumber>
    </refentryinfo>
  
  <refmeta>
     <refentrytitle id='daq5-evbprotocol-title'>eventorderer</refentrytitle>
     <manvolnum>5daq</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>eventorderer</refname>
     <refpurpose>Event orderer protocol</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
CONNECT source-name
    </command>
    </cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The NSCL event builder consists of a two stage pipeline. The first stage
        accepts a set of event fragments from an arbitrary number of event sources
        and produces output that is a total ordering of the event fragments
        with respect to the value of a timestamp associated with each fragment.
        The synchronization of the source of this timstamp is beyond the scope of the
        event builder software as that normally must be done by the experimental
        hardware.
     </para>
     <para>
        The event orderer stage operates as a TCP/IP server.  Data sources
        follow a well defined protocol to connect with the server, send data
        and, eventually, disconnect from the server.
     </para>
     <para>
        The server never initiates an interaction with the clients.  Only
        clients initiate interactions through <firstterm>messages</firstterm>.
        Messages consist of a command segment followed by an optional data segment.
        The server responds to each message to indicate how the request has been
        processed.
     </para>
     <para>
        Messages consist of a header followed by an optional body.  The
        Headers are pure ASCII while the bodies consist of binary data.
        Each messages is descdribed fully in the next section: MESSAGES
     </para>
     <para>
        The event orderer uses the NSCL port manager to advertise its
        presence.  The service name used is "ORDERER"
     </para>
  </refsect1>
  <refsect1>
     <title>
        MESSAGES
     </title>
     <para>
        Each subsection describes a specific message.  Messages consist of a header
        and an optional body.  The message type determines if there is a body.
        Each segment consist of a 32 bit little endian size followed by its
        contents.  For headers, the contents are an ASCII string.  For bodies,
        the contents are message specific.  Messages that don't have bodies
        send a body size of 0.
     </para>
     <para>
        The server replies to the client are fully textual.  Each reply is a
        single line of text.  The server replies are success and error replies:
     </para>
     <variablelist>
        <varlistentry>
            <term><literal>OK</literal></term>
            <listitem>
                <para>
                    Successful completion of the request.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><literal>ERROR {text}</literal></term>
            <listitem>
                <para>
                    The request failed.  The <replaceable>text</replaceable>
                    following the <literal>ERROR</literal> return is an
                    English string that gives the reason for the failure.
                </para>
                <para>
                    See ERROR STRINGS below for the various failur reasons
                    that have been anticipated.
                </para>
            </listitem>
        </varlistentry>
        
     </variablelist>
     <refsect2>
        <title>CONNECT</title>
        <para>
            Must be sent by the client immediately following a connection.
            The body contains contains a null terminated string that
            describes the connection.  This is followed by a 
            <type>uint32_t</type> count of the number of
            <type>uint32_t</type> items that follow and contain the source ids
            that will be carried across this connection.
        </para>
        <para>
            This message causes a transition from the CONNECTING to the
            CONNECTED state.
        </para>
     </refsect2>
     <refsect2>
        <title>DISCONNECT</title>
        <para>
            Indicates an orderly, alarm free, disconnect of the client from
            the event builder.  If the client simply closes the socket, the
            connection loss is considered abnormal, and alarms may be raised.
            Therefore clients should properly disconnect rather than just
            letting sockets close on exit e.g.
        </para>
        <para>
            The body of the DISCONNECT message is empty.
            Note that the actual sequence the API software imposes is:
            <orderedlist>
                <listitem><para>
                    Send the DISCONNECT message.
                    </para></listitem>
                <listitem><para>
                    Receive the OK message back from the server
                    </para></listitem>
                <listitem><para>
                    Both close the socket.  The server closes the socket as
                    soon as the OK message has been sent.  The client closes
                    the socket as soon as the server reply message has been
                    sent (note that in the future if the server can send
                    an ERROR, the client will still close after recieving
                    that reply).
                    </para>
                </listitem>
            </orderedlist>
        </para>
     </refsect2>
     <refsect2>
        <title>FRAGMENTS</title>
        <para>
            A <literal>FRAGMENTS</literal> indicates the body is a set of
            fragments from the data source.  Each fragment can be thought of
            as a header followed immediately by its payload.  The payload
            itself is the event fragment.  The header describes the payload.
            Note that the size of the body is still the first 32 bits in the
            entire body.  It is followed immediately by the first header.
        </para>
        <para>
            The header has the following structure:
        </para>
        <informalexample>
            <programlisting>
typedef struct <type>_PacketHeader</type> {
    <fieldsynopsis><type>uint64_t</type> <varname>s_timestamp</varname></fieldsynopsis>;
    <fieldsynopsis><type>uint32_t</type> <varname>s_sourceId</varname></fieldsynopsis>;
    <fieldsynopsis><type>uint32_t</type> <varname>s_size</varname></fieldsynopsis>;
} <type>PacketHeader</type>, *<type>pPacketHeader</type>;
            </programlisting>
        </informalexample>
        <variablelist>
            <varlistentry>
                <term><fieldsynopsis><type>uint64_t</type> <varname>s_timestamp</varname></fieldsynopsis></term>
                <listitem>
                    <para>
                        The timestamp of the event fragment.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><fieldsynopsis><type>uint32_t</type> <varname>s_sourceId</varname></fieldsynopsis></term>
                <listitem>
                    <para>
                        The unique source id of the fragment.  The sourceId is
                        used to determine into which fragment queue the fragment
                        is put.  At this time it is required that data from
                        each source id come in monotonic time order.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><fieldsynopsis><type>uint32_t</type> <varname>s_size</varname></fieldsynopsis></term>
                <listitem>
                    <para>
                        The number of bytes in the payload that follows this
                        struct.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
     </refsect2>
  </refsect1>
  <refsect1>
    <title>CONNECTION STATE</title>
    <para>
        Connections have well defined states.  The connection state changes
        due to a well defined set of events.   If the state machine is violated,
        the server will disconnect from the client immediately without reporting
        an error.
    </para>
  </refsect1>
  <refsect1>
    <title>ERROR STRINGS</title>
    <variablelist>
       <varlistentry>
       <term><literal>Expected CONNECT</literal></term>
       <listitem><para>
         Protocol required a CONNECT message but something else was received.
       </para></listitem>
       </varlistentry>

       <varlistentry>
         <term><literal>Empty Body</literal></term>
         <listitem><para>
           Protocol required a non-empty body but an empty body was received.
         </para></listitem>
       </varlistentry>

       <varlistentry>
          <term><literal>Unexpected header: xxx</literal></term>
          <listitem><para>
              A header was received of a type not expected.
          </para></listitem>
        </varlistentry>

    </variablelist>
  </refsect1>
</refentry>
<refentry>
   <refmeta>
      <refentrytitle>EventBuilder Remote control</refentrytitle>
      <manvolnum>5daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>Event builder RemoteControl</refname>
      <refpurpose>Remote control additions</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
<command>EVBC set <replaceable>parameter value</replaceable></command>        
      </cmdsynopsis>
      <cmdsynopsis>
<command>EVBC get <replaceable>parameter</replaceable></command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
          <title>DESCRIPTION</title>
          <para>
            If the remote control server is enabled when the
            event builder package is loaded, it will add the
            <literal>EVBC</literal> package to the remote control
            server.  This provides the new remote control server
            verb <literal>EVBC</literal> with subcommands
            <literal>set</literal> to set an event builder parameter
            or <literal>get</literal> to return the value of an
            event builder parameter.  
          </para>
          <para>
            For example, to set a new event builder glom assembly window
            of 200 timestamp ticks;
            the remote control server can be sent the command:
          </para>
          <informalexample>
            <programlisting>
EVBC set dt 200
            </programlisting>
          </informalexample>
          <para>
            To enable these new remote control operations, it is necessary
            to ensure that the remote control package is loaded and
            initialized prior to loading the event builder package.
            The <filename>ReadoutCallouts.tcl</filename> fragment
            below shows how to to this:
          </para>
          <informalexample>
            <programlisting>
package require ReadoutGuiRemoteControl
RemoteControlClient::initialize
package require evbcallouts
            </programlisting>
          </informalexample>
          <para>
            If the <command>package require evbcallouts</command>
            command is moved any earlier, the extension will not
            be registered.
          </para>
    </refsect1>
    <refsect1>
      <title>EXTENSION DETAILS</title>
      <para>
        The extension registers as the package <literal>EVBC</literal>/
        Processing the new <command>EVBC</command> verb supports two
        subcommands <command>set <replaceable>parameter value</replaceable></command>
        which modifies the value of a parameter.  Similarly
        <command>get <replaceable>parameter</replaceable></command>
        returns the value of <parameter>parameter</parameter> as
        additional text after the <literal>OK</literal> returned from
        a successful command.
      </para>
      <para>
        The valid parameters are:
      </para>
      <variablelist>
        <varlistentry>
           <term><literal>build</literal></term>
           <listitem>
               <para>
                This parameter is a boolean that specifies whether or
                not the <firstterm>glom</firstterm> stage of the
                event builder pipeline will build events or simply
                pass fragments through.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><literal>dt</literal></term>
           <listitem>
               <para>
                This parameter is a positive integer that specifies
                the coincidence window in timestamp ticks that will be
                used to build events when glom event building is enabled.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><literal>tspolicy</literal></term>
           <listitem>
               <para>
                This enumerated type specifies the policy by which
                glom will assign a timestamp to events it builds.
                It can be one of the following values:
               </para>
               <variablelist>
               <varlistentry>
                  <term><literal>earliest</literal></term>
                  <listitem>
                      <para>
                        The built event will be assigned the timestamp
                        of the earliest (first) fragment in it.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>latest</literal></term>
                  <listitem>
                    <para>
                      The built event will be assigned the timestamp
                      of the latest (last) fragment in it.
                   </para>
                </listitem>
               </varlistentry>
               <varlistentry>
                  <term><literal>average</literal></term>
                  <listitem>
                    <para>
                      Built event will be assigned a timestamp value
                      that is the average of all of the timestamps
                      of the fragments it contains.
                   </para>
                </listitem>
               </varlistentry>
      </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><literal>ring</literal></term>
           <listitem>
               <para>
                Specifies the name of the ring buffer into which the
                event builder pipeline will place events. Note
                that if this is changed, all prior consumers will
                need to detach from the old ringbuffer and attach
                to the new one.  Therefore, modification of this parameter
                is not recommended.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><literal>window</literal></term>
           <listitem>
               <para>
                The fragment ordering stage of the event builder pipeline
                uses a combination of emitting fragments when all fragment
                queues have data and emitting fragments that were received prior
                to some specific interval from now.  This parameter
                specifies the value of this time window in seconds.  Normally, this is
                only required if there are massive rate differences between
                buffered event sources which may result in data lates.
               </para>
               <para>
                The default value for this parameter is 20 seconds.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><literal>xoffthreshold</literal></term>
           <listitem>
               <para>
                If the order has sufficiently many bytes in flight (in fragment
                queues, or in output queues), The orderer will pause
                in accepting fragments to flow control the data rate.
                This value specifies the number of bytes of in flight fragments
                a which this flow control is initiated.  By default this
                is 10Mbytes.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><literal>xonthreshold</literal></term>
           <listitem>
               <para>
                If flow control is initiated the orderer allows fragments to remain
                queued in the data sources and their ring buffers until
                it has fewer than the Xon threshold bytes in flight. This
                parameter sets/gets the Xon threshold size in bytes.
                the value is specified in bytes and defaults to 9Mbytes.
               </para>
               <para>
                The <literal>xonthreshold</literal> must be less than
                the <literal>xoffthreshold</literal> and there should
                be sufficient space between the values to prevent/reduce
                flow control thrashing.
               </para>
            </listitem>
        </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<!-- /manpage -->