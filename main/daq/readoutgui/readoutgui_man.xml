<!-- manpage 3rdogui -->
   <refentry id='rdogui_man'>
    <refentryinfo>
        <author>
                <personname>
                        <firstname>Ron</firstname>
                        <surname>Fox</surname>
                </personname>
                <personblurb><para></para></personblurb>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
    </refentryinfo>
     <refmeta>
          <refentrytitle id='rdogui_man_title'>Introduction</refentrytitle>
          <manvolnum>3rdogui</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>Introduction</refname>
          <refpurpose>ReadoutGUI API introduction</refpurpose>
       </refnamediv>
       
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This section of manual pages describe the API presented by the
            ReadoutGUI.  While you may naturally find additional methods
            if you inspect source code, these are not guaranteed to be stable
            over a major release of NSCLDAQ.  Use them at your peril.
          </para>
       </refsect1>
       <refsect1>
          <title>
         PACKAGES
          </title>
            <para>
                The API is broken up int packages of related functionality.
                These packages are instaled in the <filename>TclLibs</filename>
                directory tree of your NSCLDAQ installation.
                If DAQROOT is an environment variable that points to the top
                level diretory of your NSLCDAQ installation, you can make these
                packages available by first:
            </para>
            <informalexample>
                <programlisting>
set pkghome [file join $::env(DAQROOT) TclLibs]
lappend auto_path $pkghome
                </programlisting>
            </informalexample>
            <para>
                Below are brief descriptions of the API packages with
                pointers to the reference pages that describe them:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>bells</literal></term>
                    <listitem>
                        <para>
                            This package provides the <classname>bells</classname>
                            class.  This can be used to ring alarm bells in accordance with
                            some pattern.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_bells' endterm='rdogui3_bells_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Configuration</literal></term>
                    <listitem>
                        <para>
                            Provides a manager for configuration data.  This
                            package allows you to define configuration variables
                            and their defaults.  It also supports overidding
                            default values with environment variables.
                            Normally this package is used in conjunction with the
                            <literal>StateManager</literal> package to save
                            and restore the state of configuration parameters
                            to the configuration file.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_configuration'
                                  endterm='rdogui3_configuration_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>DAQParameters</literal></term>
                    <listitem>
                        <para>
                            Provides access to parameters that affect data taking.
                            This package provides both query and modify access.
                            It uses the <literal>Configuration</literal> package
                            above.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_daqparameters'
                                  endterm='rdogui3_daqparameters_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>DataSourceManager</literal></term>
                    <listitem>
                        <para>
                            This package manages the data source providers
                            and data sources.  You need to interact with this
                            package if you want to create data sources
                            yourself (e.g. to create an exportable pre-packaged ReadoutGUI
                            for a specific setup).
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_DataSourceManager'
                                  endterm='rdogui3_DataSourceManager_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>DataSourceUI</literal></term>
                    <listitem>
                        <para>
                            This package provides the user interface
                            elements that prompt for data source parameters.
                            It provides at least one useful class
                            <classname>DialogWrapper</classname> which
                            can be  used to build custom prompters for
                            data source providers.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_DatasourceUI'
                                  endterm='rdogui3_DatasourceUI_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Diagnostics</literal></term>
                    <listitem>
                        <para>
                            Provides simple error/warning/info dialogs.
                            See:
                            <link linkend='rdogui3_diagnostics'
                                  endterm='rdogui3_diagnostics_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ExpFileSystemConfig</literal></term>
                    <listitem>
                        <para>
                            Provides read/write access to configuration parameters
                            that determine where event data and related meta-data
                            are stored.
                            See:
                            <link linkend='rdogui3_expfilesystemconfig'
                                  endterm='rdogui3_expfilesystemconfig_title'
                                  />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ReadoutGUI</literal></term>
                    <listitem>
                        <para>
                            Provides the readout GUI application class which
                            strings everything together. See
                            <link
                                  linkend='rdogui3_readoutgui'
                                  endterm='rdogui3_readoutgui_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ReadoutGUIPanel</literal></term>
                    <listitem>
                        <para>
                            Provides a group of API elements that allow you
                            to modify the user interface presented by the
                            <classname>ReadoutGuiApp</classname> application
                            object.
                            See:
                            <link linkend='rdogui3_readoutguipanel'
                                  endterm='rdogui3_readoutguipanel_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>RunstateMachine</literal></term>
                    <listitem>
                        <para>
                            Implements the run state machine.  This also
                            provides the mechanism to register custom
                            callback bundles.
                            See:
                            <link linkend='rdogui3_runstatemachine'
                                  endterm='rdogui3_runstatemachine_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>StateManager</literal></term>
                    <listitem>
                        <para>
                            Provides a package that supports simple Tcl
                            configuration files.  A simple Tcl configuration file
                            is a script with a bunch  of <command>set</command>
                            commands that define configuration variables.
                            The package allows you define variables that
                            are exported/imported from these files and
                            getters and setters for those variables.
                        </para>
                        <para>
                            See
                            <link linkend='rdogui3_statemanager'
                                  endterm='rdogui3_statemanager_title' />
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ui</literal></term>
                    <listitem>
                        <para>
                            Provides access to all elements of the user interface.
                            Before using this package, see if you needs are
                            met by the <literal>ReadoutGUIPanel</literal> package
                            since that tends to be easier to use.
                        </para>
                        <para>
                            See
                            <link linkend="rdogui3_ui" endterm='rdogui3_ui_title' />
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
     </refentry>     

      <refentry id="rdogui3_bells">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id="rdogui3_bells_title">bells</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>bells</refname>
           <refpurpose>Provide audible alarm bells.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
        <command>
package require bells
          </command>
          </cmdsynopsis>
        <cmdsynopsis>
            <command>
bells <replaceable>%AUTO% | name ?options...?</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> configure <replaceable>?options...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> cget <replaceable>option</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> start
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> cancel
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>abell</replaceable> destroy
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides a <literal>snit::type</literal> named
            <classname>bell</classname>.  Instances of <classname>bell</classname>
            produce repeating patterns of beeps.  Typically this is used to
            alert users to conditions of alarm level severity.
           </para>
           <para>
            Bells have a <option>-pattern</option> which determines the interval
            between each beep, and an <option>-interval</option> which determines
            the time between repetitions of the pattern.
            </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-interval</option> <replaceable>msec</replaceable></term>
                <listitem>
                    <para>
                        Determines the time in milliseconds between repetitions of
                        the beep pattern.  If not supplied, this defaults to
                        <literal>1000</literal> (one second).  In the interval
                        between patterns, the event loop is active.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-pattern</option> <replaceable>msec1 ...</replaceable></term>
                <listitem>
                    <para>
                        Determines the interval between beeps in one repetition
                        of the pattern.  The pattern begins with a beep after
                        which there is a delay that is determined by iterating
                        through the <option>-pattern</option> list after which
                        another beep is emitted.
                    </para>
                    <para>
                        The default is a single element of <literal>100</literal>
                        which results in a double beep with the two beeps
                        separated by <literal>0.1</literal> seconds.
                    </para>
                    <para>
                        Note that during the execution of the pattern, the
                        event loop does not execute.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                Instances of a bell are created using the bell command and,
                themselves become commands.  The ways to create a bell command are:
            </para>
            <informalexample>
                <programlisting>
bell <replaceable>bellname ?options...?</replaceable>
set <replaceable>somevar</replaceable> [bell %AUTO% <replaceable>?options...?</replaceable>]
                </programlisting>
            </informalexample>
            <para>
                The first example defines the command <command>bellname</command>
                to represent an object of type <classname>bell</classname>. The
                second example lets the <command>bell</command> command select
                a unique command name and assigns it to he variable
                <varname>somevar</varname>
            </para>
            <para>
                In all cases the remainder of the command (if any) is made up
                of option-value pairs which override the default options
                (See OPTIONS above).
            </para>
            <para>
                Once created, the command representing the object
                can be used to invoke several subcommands (Methods) on the
                bell object.  These are listed and described below:
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>destroy</methodname></term>
                    <listitem>
                        <para>
                            Destroys the object.  Once this is done, the
                            command that represents the objecdt is no longer
                            defined
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>configure</methodname> <replaceable>options...</replaceable></term>
                    <listitem>
                        <para>
                            Change the configuration options for the object.
                            If the bell is currently in the process of ringing,
                            the options are changed and will take effect at the
                            end of the current pattern. See
                            OPTIONS above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>cget</methodname> <replaceable>optname</replaceable></term>
                    <listitem>
                        <para>
                            Returns the value of the configuration option
                            <replaceable>optname</replaceable>.  See
                            OPTIONS above for a list of the legal option names.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>start</methodname></term>
                    <listitem>
                        <para>
                            Starts repetition of the bell pattern. Once started,
                            the pattern will continue as defined by the
                            OPTIONS until the program exits, the bell object is
                            destroyed or the <methodname>cancel</methodname>
                            method is invoked.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>cancel</methodname></term>
                    <listitem>
                        <para>
                            Cancels the executing pattern.  If the pattern
                            is not executing, this is a no-op.
                        </para>
                    </listitem>
                </varlistentry>            
            </variablelist>
        </refsect1>
        <refsect1>
            <title>EXAMPLE</title>
            <para>
                This example shows the full lifecycle of a bell object.
                In this case, the bell is configured to repeat every second,
                with a pattern of two short (50ms) delays and one long (100ms) delay.
            </para>
            <example>
                <title>bell example</title>
                <programlisting>
set abell [bell %AUTO% -pattern [list 50 50 100] -interval 1000]
...
$abell start;
...
$abell cancel
$abell destroy


                </programlisting>
            </example>
        </refsect1>
      </refentry>

      <refentry id="rdogui3_configuration">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_configuration_title'>Configuration</refentrytitle>
           <manvolnum>rdogui3</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>Configuration</refname>
           <refpurpose>Configuration variable management</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
package require Configuration
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
Configuration::Set <replaceable>configname value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Configuration::get  <replaceable>configname ?default?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Configuration::readEnvironment <replaceable>confname envname ?default?</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
Configuration::writeConfigFile <replaceable>channel</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Configuration::readConfigFile <replaceable>path</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package maintains a set of configuration variables.  The
            configuration variables are maintained in a separate namespace
            so that they cannot accidently collide with other existing global
            variables.
           </para>
           <para>
            In addition to simple set and get operations environment variables
            can be checked for existence and used to set the value of
            variables.  Configuration files can also be read and written, however
            it would probably be better to use the
            <link linkend="rdogui3_statemanager"
                  endterm='rdogui3_statemanager_title' /> package for that
            instead.
           </para>
        </refsect1>
        <refsect1>
           <title>
              PROCEDURES
           </title>
           <para>
            The <literal>Configuration</literal> package provides <command>proc</command>s
            in the <literal>::Configuration::</literal> namespace:
           </para>
           <variablelist>
            <varlistentry>
                <term><function>::Configuration::readConfigfile</function> <parameter>path</parameter></term>
                <listitem>
                    <para>
                        The configuration file at <parameter>path</parameter> is
                        read in with the namespace set to the configuration variable
                        namespace.  The file is sourced into the current
                        interpreter (one reason that
                        <link linkend="rdogui3_statemanager"
                            endterm='rdogui3_statemanager_title' /> is a better
                        choice).
                        The source is done at the global level.        
                    </para>
                    <para>
                        The configuration file is presumed to only contain
                        <command>set</command> commands.  This is not enforced however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::Configuration::readEnvironment</function>
                    <parameter>confname envname ?default?</parameter></term>
                <listitem>
                    <para>
                        If the environment variable <parameter>envname</parameter>
                        is defined, the variable <parameter>confname</parameter> in
                        the configuration namespace is set to the value of
                        <parameter>envname</parameter>.
                        If <parameter>envname</parameter> does not exist,
                        then <parameter>confname</parameter> is set to
                        <parameter>default</parameter>.  If the
                        <parameter>default</parameter> parameter is not supplied,
                        and <parameter>envname</parameter> is not defined,
                        the variable is defined, but set to the empty string. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::Configuration::Set</function> <parameter>confname value</parameter></term>
                <listitem>
                    <para>
                        Sets the configuration variable named <parameter>confname</parameter>
                        to <parameter>value</parameter>.   If <parameter>confname</parameter>
                        has not yet been defined this will create it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::Configuration::::get</function> <parameter>confname ?default?</parameter></term>
                <listitem>
                    <para>
                        If <parameter>confname</parameter> is already a defined
                        configuration parameter its value is returned.   If
                        not, the value of <parameter>default</parameter> is returned.
                        If not supplied <parameter>default</parameter> will
                        be the empty string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::Configuration::writeConfigFile</function> <parameter>channel</parameter></term>
                <listitem>
                    <para>
                        Writes the configuration out to the open <parameter>channel</parameter>.
                        What this means is that a .tcl script consisting of simple
                        <command>set</command> commands will be written that can
                        be read in with <function>::Configuration::readConfigFile</function>
                        to restore the state of all defined configuration variables
                        as they are defined at the time <function>::Configuration::writeConfigFile</function>
                        is called.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="rdogui3_daqparameters">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_daqparameters_title'>DAQParameters</refentrytitle>
           <manvolnum>rdogui3</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>Data Acquisition parameters</refname>
           <refpurpose>Cluster of configuration parameters for data acquisition</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require DAQParameters
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::setDefaults
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::environmentOverrides
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getEventLogger
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getEventLoggerRing
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getUseNsrcsFlag
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getAdditionalSourceCount
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getRunNumberOverrideFlag
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::DAQParameters::getUseChecksumFlag
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides a cluster of configuration parameters
            (in the sense of
            <link linkend="rdogui3_configuration"
                  endterm='rdogui3_configuration_title' />).
            Mechanisms to set default values for these parameters are provided
            as well as convenience functions to fetch specific configuration
            values without the need to know the actual configuration variable name.
           </para>
           <para>
            See PROCEDURES below for a description of each command supplied
            by this package.
           </para>
        </refsect1>
        <refsect1>
           <title>
              PROCEDURES
           </title>
           <variablelist>
            <varlistentry>
                <term><function>::DAQParameters::setDefaults</function></term>
                <listitem>
                    <para>
                        Sets default values for each configuration value
                        in this cluster.  See DEFAULT VALUES for information
                        about the default values for these parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::environmentOverrides</function></term>
                <listitem>
                    <para>
                        Applies the environment variables that normally
                        control this part of the configuration to the parameters.
                        See ENVIRONMENT below for more information about the
                        the environment variables used.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getEventLogger</function></term>
                <listitem>
                    <para>
                        Returns the command that will be used to start the
                        event logger.  This is a base command string without
                        any options.  At run time the full command string is
                        computed from this value and the other
                        parameters in this cluster.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getEventLoggerRing</function></term>
                <listitem>
                    <para>
                        Returns the URI of the ring buffer from which the
                        event logger will log data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getUseNsrcsFlag</function></term>
                <listitem>
                    <para>
                        Get the value of the flag that controls whether or not
                        the event logger is started out with the
                        <option>--number-of-sources</option> option on the
                        command line.  If this value is <literal>true</literal>
                        the flag value will be computed from the number of
                        data sources and the value returned by
                        <function>::DAQParameters::getAdditionalSourceCount</function>
                        command and supplied on the command line.  If the
                        value returned from this command is <literal>false</literal>
                        this option will not be used.  Note that this
                        option cannot be used with event loggers from NSCLDAQ
                        earlier than version 11.0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getAdditionalSourceCount</function></term>
                <listitem>
                    <para>
                        Gets the number of additional sources to add to the
                        number of data sources that will be supplied to the
                        <option>--number-of-sources</option> eventlog flag.
                        The purpose of that flag is to tell the event logger how
                        many end run events to expect before considering a run over.
                    </para>
                    <para>
                        This value is meaningless when
                        <function>::DAQParameters::getUseNsrcsFlag</function>
                        returns <literal>false</literal> beause in that case,
                        the <option>--number-of-sources</option> option will not
                        be added to the command line.
                    </para>
                    <para>
                        The dual purpose of this option is to deal with
                        event sources that are not controlled by the ReadoutGUI
                        that contribute end run records (positive value for
                        the parameter), and to handle event sources that
                        <emphasis>are</emphasis> controlled by the ReadoutGUI
                        that don't supply end run records (negative value).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getRunNumberOverrideFlag</function></term>
                <listitem>
                    <para>
                        When true, the event logger is started with the
                        <option>--run</option> flag which is given the value
                        of the run number in the ReadoutGUI.  This is intended
                        for cases when the event logger is used with data sources
                        that don't contribute start of run event records, or
                        contribute start of run records with run number fields
                        that cannot be trusted.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>::DAQParameters::getUseChecksumFlag</function></term>
                <listitem>
                    <para>
                        When true, the event logger is started with the
                        <option>--checksum</option> flag. If the event logger is
                        incompatible with this option (version must be greater than 11.0-rc6),
                        the user will be presented with an error message.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        
        <refsect1>
            <title>DEFAULT VALUES</title>
            <para>
                The call to <function>::DAQParameters::setDefaults</function>
                sets the values of the configuration variables as follows:
            </para>
            <variablelist>
                <varlistentry>
                    <term>Event logger command</term>
                    <listitem>
                        <para>
                            <replaceable>DAQROOT</replaceable>/bin/eventlog
                            where <replaceable>DAQROOT</replaceable> is the
                            top level installation difectory of NSCLDAQ.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Event logger ring URI</term>
                    <listitem>
                        <para>
                            <literal>tcp://localhost//$::tcl_platform(user)</literal>
                            Note that the Tcl global array <varname>::tcl_platform</varname>'s
                            <literal>user</literal> element contains the name
                            of the logged in user.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Use <option>--number-of-sources</option></term>
                    <listitem>
                        <para>
                            <literal>true</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Additional data sources</term>
                    <listitem>
                        <para>
                            <literal>0</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Use <option>--run</option> run number override</term>
                    <listitem>
                        <para>
                            <literal>false</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Use <option>--checksum</option></term>
                    <listitem>
                        <para>
                            <literal>true</literal>
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            <para>
                These defaults are suitable for the case of a single event
                source compatible with NSCLDAQ-11.x
            </para>
        </refsect1>
        
        <refsect1>
            <title>ENVIRONMENT</title>
            <para>
                Invoking <function>::DAQParameters::environmentOverrides</function>
                looks for the following environment variables:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>EVENTLOGGER</literal></term>
                    <listitem>
                        <para>
                            Overrides the default event logger program with
                            its value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_RING</literal></term>
                    <listitem>
                        <para>
                            Overrides the event logger ringbuffer URI.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_NSRCSFLAGS_SUPPORTED</literal></term>
                    <listitem>
                        <para>
                            If true then <option>--number-of-sources</option>
                            will be used with the eventlog program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_UNCONTROLLED_SOURCE_COUNT</literal></term>
                    <listitem>
                        <para>
                            If provided contains an additional source count for
                            use when computing the value of
                            <option>--number-of-sources</option>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_USE_GUI_RUNNUM</literal></term>
                    <listitem>
                        <para>
                            If true the <option>--run</option> option will be
                            used to override run numbers in begin run records or,
                            alternatively provide run numbers where none are
                            avaialble.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_USE_CHECKSUM_FLAG</literal></term>
                    <listitem>
                        <para>
                            If true the <option>--checksum</option> option will be 
                            used to compute an sha512 hash for the entirety of the 
                            logged data.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
       

      </refentry>
      <refentry id="rdogui3_DataSourceManager">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_DataSourceManager_title'>DataSourceManager</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>DataSourceManager</refname>
           <refpurpose>Data source manager and its API</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require DataSourceManager
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>singleton</replaceable> [DataSourcemanagerSingleton %AUTO%]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>providers</replaceable> [DataSourceManager::enumerateProviders]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singelton</replaceable> load <replaceable>provider-name</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>params</replaceable> \
[<replaceable>$singleton</replaceable> parameters <replaceable>provider-name</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>caps</replaceable> \
[<replaceable>$singleton</replaceable> capabilities <replaceable>provider-name</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>caps</replaceable> \
[<replaceable>$singleton</replaceable> systemCapabilities]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> addSource <replaceable>provider-name param-dict</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>sourceid</replaceable> \
[<replaceable>$singleton</replaceable> removeSource <replaceable>id</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>status</replaceable> [<replaceable>$singleton</replaceable> check]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>source-descriptions</replaceable> [<replaceable>$singleton</replaceable> sources]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> stop <replaceable>id</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> stopAll
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> startAll
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> begin <replaceable>run-number title</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> end
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> pause
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> resume
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> init 
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$singleton</replaceable> initall
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>DataSourceManager</literal> is in charge of maintaining
            knowledge of the data source providers and active data sources.
            The <literal>DataSourceManager</literal> as used in the ReadoutGUI
            is a
            <ulink url='http://en.wikipedia.org/wiki/Singleton_pattern'>singleton object</ulink>.
            Rather than directly instantiating a <classname>DataSourceManager</classname>
            your code should instantiate a
            <classname>DataSourcemanagerSingleton</classname>.
            Doing so generates a
            <ulink url='http://en.wikipedia.org/wiki/Facade_pattern'>Facade object</ulink>
            that wraps the one and only data source manager the ReadoutGUI
            uses.   The resulting object exports and delegates all
            methods to the underlying singleton.
           </para>
        </refsect1>
        <refsect1>
           <title>
              TYPE METHODS
           </title>
           <variablelist>
            <varlistentry>
                <term><methodname>DataSourceManager::enumerateProviders</methodname></term>
                <listitem>
                    <para>
                        Returns a list of the names of the data source providers
                        known at the time of the call.  For more information
                        on data source providers see
                        <link linkend='provider3_intro' endterm='provider3_intro_title' />
                        and the interaces its related pages describe...
                    </para>
                    <para>
                        The set of providers is determined by the set of packages
                        that can be located and loaded with names appropriate
                        to that of a data source provider.  No attempt is made
                        to determine if these packages contain code that actually
                        meets all the requirements of a data source provider.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                The public methods provided by the data source manage are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>load</methodname> <parameter>provider-name</parameter></term>
                    <listitem>
                        <para>
                            Loads a data source provider package.  Note that:
                            <itemizedlist>
                                <listitem>
                                    <para><parameter>provider-name</parameter> is the
                                          name of the provider not the name of the
                                          provider's package (e.g
                                          <literal>SSH</literal> not <literal>SSH_Provider</literal>).
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>For the load to be successful the provider's
                                    package must be locatable via the normal Tcl
                                    <command>package require</command> command.
                                    For custom providers this may necessitate changes
                                    to the <varname>::auto_path</varname> variable.
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </para>
                        <para>
                            Until a package is loaded nothing can be done with it.
                            You must use the <methodname>load</methodname> method
                            rather than directly doing a <command>package require</command>
                            as the data source manager maintains a list of registered packages.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>parameters</methodname> <parameter>provider-name</parameter></term>
                    <listitem>
                        <para>
                            Returns a dict that describes the parameterization
                            required by data sources that <parameter>provider-name</parameter>
                            manages. See
                            <link linkend='provider3_intro' endterm='provider3_intro_title' />
                            for a description of this dict.
                        </para>
                        <para>
                            If you are not familiar with Tcl dicts see
                            <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/dict.htm'>
                                http://www.tcl.tk/man/tcl8.5/TclCmd/dict.htm</ulink>
                            for a description of dicts and the command ensemble that
                            acts on them.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>capabilities</methodname> <parameter>provider-name</parameter></term>
                    <listitem>
                        <para>
                            Returns a dict that describes the capabilities of
                            <parameter>provider-name</parameter>.  The form of
                            this dict is described in
                            <link linkend='provider3_intro' endterm='provider3_intro_title' />.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>systemCapabilities</methodname></term>
                    <listitem>
                        <para>
                            Returns the minimal set of capabilities the
                            data sources have.  This is the intersection of
                            the capabilities of all providers that are represented
                            by data sources that have been added to the manager.
                        </para>
                        <para>
                            Another way to look at this method is that it returns
                            a dict of capabilities that all sources have.  For
                            example, if two data sources have been added to the manager,
                            one of them capable of pausing a run and the other not,
                            the resulting dict will show that the system cannot
                            pause runs.
                            The form of this dict is described in
                            <link linkend='provider3_intro' endterm='provider3_intro_title' />.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>addSource</methodname> <parameter>provider-name params</parameter></term>
                    <listitem>
                        <para>
                            Adds a data source to the manager.  
                            <parameter>provider-name</parameter> defines the name
                            of the data source provider that will manage the
                            source.  <parameter>params</parameter> is a dict
                            that defines the actual parameterization of this
                            source.  The keys in this dictionary are determined
                            by the result of <methodname>parameters</methodname>
                            for the provider.
                        </para>
                        <para>
                            Note that the
                            source is not yet started.  See
                            <methodname>startAll</methodname> below.
                            Note as well that this method allocates and
                            defines the source id for the data source. That
                            implies that if the <parameter>params</parameter> dict
                            has a <literal>sourceid</literal> key its value
                            will be overwritten when the parameterization
                            is stored internally by the manager.
                        </para>
                        <para>
                            The result of this method is a unique source id
                            which can be used to identify this source
                            when calling methods that work on a single
                            source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>removeSource</methodname> <parameter>source-id</parameter></term>
                    <listitem>
                        <para>
                            Removes a source (the inverse of <methodname>addSource</methodname>)
                            from the manager.  If the soure is running, it is
                            stopped first.
                            <parameter>source-id</parameter> is the source
                            id returned from the call to <methodname>addSource</methodname>
                            that added the source to the manager.
                        </para>
                        <para>
                            It is an error to attempt to remove a nonexsitent
                            source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>check</methodname></term>
                    <listitem>
                        <para>
                            Checks the liveness of all data sources.
                            This returns a dict whose keys are data source ids
                            and whose values are the results of check on those
                            data sources.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>sources</methodname></term>
                    <listitem>
                        <para>
                            Returns information about all of the sources
                            that have been added to the manager.
                            The result is a list ofr dicts.  Each
                            dict contains the parameterization of the data
                            source as well as keys for
                            <literal>sourceid</literal> which has the source
                            id as a value and <literal>provider</literal>
                            which is the name of the provider that manages
                            this source when it is running.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>stop</methodname> <parameter>source-id</parameter></term>
                    <listitem>
                        <para>
                            Stops the single source identified by <parameter>source-id</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>stopAll</methodname></term>
                    <listitem>
                        <para>
                            Stops all data sources.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>startAll</methodname></term>
                    <listitem>
                        <para>
                            Starts all data sources that have been added.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            <para>
                In addition to the data source manipulation methods described
                above, the manager also exports run control methods.  It is
                better, however to force run state transitions to happen via
                the
                <link linkend='rdogui3_runstatemachine'
                      endterm='rdogui3_runstatemachine_title' />.
                In that way other actions associated with run state transitions
                can occur.
            </para>
            <para>
                For completeness, the run state control methods
                are described below.  The operate by iterating over the
                running data sources and delegating the method to their
                provider.
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>begin</methodname> <parameter>run-number title</parameter></term>
                    <listitem>
                        <para>
                            Starts a run in all of the providers.  The
                            <parameter>run-number</parameter> and
                            <parameter>title</parameter> parameters are
                            passed without interpretation to the provider's
                            <command>begin</command> command for each data source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>end</methodname></term>
                    <listitem>
                        <para>
                            Iterates over all data sources calling 
                            <command>end</command> for them in their
                            data source provider.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>pause</methodname></term>
                    <listitem>
                        <para>
                            Iterates over all data sources pausing them in
                            the middle of an active run. Before invoking
                            this method, the caller must ensure all data sources
                            implement the <command>pause</command> operation by
                            using <methodname>systemCapabilities</methodname>
                            to get the intersection of all data source capabilites.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>resume</methodname></term>
                    <listitem>
                        <para>
                            Iterates over all data sources resuming the paused
                            run.   
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                  <term><methodname>init</methodname></term>
                    <listitem>
                        <para>
                          Calls the init proc for the provider whose index is <replaceable>id</replaceable>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                  <term><methodname>initall</methodname></term>
                    <listitem>
                        <para>
                          Iterates through all of the data sources and calls their respective init procs.
                        </para>
                    </listitem>
                </varlistentry>
                
                
            </variablelist>
            
        </refsect1>

      </refentry>

      <refentry id="rdogui3_DatasourceUI">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id="rdogui3_DatasourceUI_title">DataSourceUI</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>DataSourceUI</refname>
           <refpurpose>Data source parameter user interface</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require DataSourceUI
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>providerChooser</replaceable> [ChooseProvider <replaceable>path</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>dsrcprompter</replaceable> [PromptDataSource <replaceable>path</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>dialog</replaceable> [DialogWrapper <replaceable>path</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>provider</replaceable> [DataSourceUI::getProvider <replaceable>provider-list</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>params</replaceable> [DataSourceUI::getParameters <replaceable>provider-name param-dict</replaceable>]
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides a set of mega-widgets and <command>proc</command>s
            that support prompting for information about data sources (providers and
            parameterization).  In addtion a generic dialog wrapper megawidget is
            supplied that allows you to wrap any form inside a dialog with
            <guibutton>Ok</guibutton> and optional <guibutton>Cancel</guibutton>
            buttons with the capability of going modal.
           </para>
           <para>
            The <classname>ChooseProvider</classname> megawidget along with the
            <command>DataSourceUI::getProvider proc</command> allow you to prompt
            for a data source provider.  <classname>ChooseProvider</classname>
            is the prompting form, and <command>DataSourceUI::getProvider</command>
            wraps that form with a <classname>DialogWrapper</classname> and uses
            that to modally prompt for a data source provider.
           </para>
           <para>
            The <classname>PromptDataSource</classname> megawidget understands
            how to produce a generic prompter given the parameterization
            dict of a provder.  <command>DataSourceUI::getParameters</command>
            wraps <classname>PromptDataSource</classname> in a
            <classname>DialogWrapper</classname> and modally waits for the user
            to set the parameterization which is returned to the caller.
           </para>
           <para>
            See MEGAWIDGETS for documentation about the widgets themselves.
            See PROCS for documentation about the commands.
           </para>
        </refsect1>
        <refsect1>
           <title>
              MEGAWIDGETS
           </title>
           <refsect2>
            <title>ChooseProvider</title>
            <para>
                This megawidget provides a scrolling list box.  The
                <option>-providers</option> option is the list of
                data source provider names that will stock the list.
                <option>-command</option> if not null is a script that will
                be called at the global level if an item in the list box is clicked.
            </para>
            <para>
                The <methodname>selected</methodname> method returns the text
                of the list box element that is currently selected.  If no item
                is selected, the empty string is returned.
            </para>
           </refsect2>
           <refsect2>
            <title>PromptDataSource</title>
            <para>
                This megawidet provides a very generic form that prompts for
                the parameterization of a data source.  The
                <option>-parameters</option> option should be set with the parameterization
                dict for the data source provider.  The dict is the dict
                that is returned from the <command>parameters</command> proc of
                a data source provider.  The form consists of a set of lines
                each line has a label widget, that displayse the long textual
                desription of the parameter, and an entry the user fills in to
                set that parameter's value.
            </para>
            <para>
                The <methodname>getForm</methodname> method of the
                <classname>PromptDataSource</classname> megawidget returns a
                dict whose keys are short parameter names (from the data source
                parameterization) and whose values are a list containing in order:
                <itemizedlist>
                    <listitem>
                        <para>The parameter prompt string</para>
                    </listitem>
                    <listitem>
                        <para>The path to the prompting widget for ths parameter.
                        </para>
                    </listitem>
                    <listitem>
                        <para>The contents of the entry widget.
                        </para>
                    </listitem>
                </itemizedlist>
                </para>
           </refsect2>
           <refsect2 id='rdogui3_dialogwrapper'>
            <title id='rdogui3_dialogwrapper_title'>DialogWrapper</title>
            <para>
                <classname>DialogWrapper</classname> is a helper widget that
                assists in building modal dialogs.  A dialog is typically
                composed of two sections.  The top section, the control area,
                contains a form with input controls, or possibly just a message.
                The bottom section, the action area, contains one or two buttons.
                The first button <guibutton>Ok</guibutton> accepts the form
                values while the second button <guibutton>Cancel</guibutton> 
                can optionally be displayed and indicates the user wants to
                dismiss the dialog without making choices.
            </para>
            <para>
                The <classname>DialogWrapper</classname> allows you to create an Tcl widget
                (usually a frame) and establish it as the control area of a dialog.
                The control area widget must be the child of an appropriate
                subwidget of the dialog.  That widget is returned from the
                <methodname>controlarea</methodname> method call.
            </para>
            <para>
                Once the control area widget hierarchy has been constructed and
                interally laid out, its top level frame should be configured
                to be the <option>-form</option> option of the dialog.  The
                dialg widget itself can gen generally be managed into a toplevel
                widget which displays it.
            </para>
            <para>
                To block for user interaction with the dialog (make it modal),
                invoke the <methodname>modal</methodname> method.  That method will
                return one of:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>Ok</literal></term>
                    <listitem>
                        <para>
                            The user clicked the Ok button.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Cancel</literal></term>
                    <listitem>
                        <para>
                            The user clicked the Cancel button.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Destroy</literal></term>
                    <listitem>
                        <para>
                            The user destroyed the dialog using the window
                            manager control for that.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            <para>
                Note that if the return is either <literal>Ok</literal> or
                <literal>Cancel</literal> it is still possible to retrieve
                items for the form (in the case of <literal>Cancel</literal>
                your application might use these values to default fields
                in future instances of the dialog).
            </para>
            <para>
                If the return value is <literal>Destroy</literal> the
                form widget tree has already been destroyed and therefore
                cannot be used.
            </para>
            <para>
                The <option>-showcancel</option> option is a boolean that
                controls whether or not the <guibutton>Cancel</guibutton>
                button is displayed.
            </para>
            <para>
                The normal lifecycle of this widget is to
                <itemizedlist>
                    <listitem><para>Create a toplevel widget for the dialog</para></listitem>
                    <listitem><para>Create the dialog as a child of the toplevel</para></listitem>
                    <listitem><para>Invoke the <methodname>controlarea</methodname> method to get the control areay container</para></listitem>
                    <listitem><para>Create a frame under the control area</para></listitem>
                    <listitem><para>Create the control area input form and lay it out in the frame above</para></listitem>
                    <listitem><para>Configure the dialog so that it's <option>-form</option> option is the frame above.</para></listitem>
                    <listitem><para>Invoke the <methodname>modal</methodname> method to wait for the user to interact with the form</para></listitem>
                </itemizedlist>
            </para>
            <para>
                If <methodname>modal</methodname> returned <literal>Ok</literal>
                the data from the user are fetched from the controls in the
                controlarea and the toplevel is destroyed.  If <methodname>modal</methodname>
                returns <literal>Cancel</literal> the toplevel is destroyed.
                If <methodname>modal</methodname> returned <literal>Destroy</literal>
                nothing is done because this happens when the toplevel gets destroyed by
                the user.
            </para>
           </refsect2>
        </refsect1>
        <refsect1>
            <title>PROCS</title>
            <para>
                Two of the forms described in the MEGAWIDGETS section above have
                associated convenience functions.    These convenience functions
                wrap their megawidget in a <classname>DialogWrapper</classname>
                invoke <methodname>modal</methodname> and return the
                results of the user interaction with the dialog to the caller.
            </para>
            <variablelist>
                <varlistentry>
                    <term><function>::DataSourceUI::getProvider</function> <parameter>providers</parameter></term>
                    <listitem>
                        <para>
                            Prompts for a data source provider.  <parameter>providers</parameter>
                            is a list of the providers to choose from.
                            If the user selected a provider its name is returned
                            as the value of this proc.  If the user clicked
                            <guibutton>Cancel</guibutton> or destroyed the
                            dialog an empty string is returned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>::DataSourceUI::getParameters</function> <parameter>provider-name parameters</parameter></term>
                    <listitem>
                        <para>
                            Prompts for the parameterization of an instance
                            (data source) of a <parameter>provider-name</parameter>.
                            <parameter>parameters</parameter> is the
                            dict that defines the parameterization of the
                            provider's instances.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
        <refsect1>
            <title>EXAMPLES</title>
            <para>
                The example below shows how to use the <classname>DialogWrapper</classname>.
                In this case, the widgets that make up the control area are just
                constructed in line.  In general it makes sense to build
                a megawidget for the conotrolarea using snit or itk and
                provide that megawidget with methods to fetch form elements.
            </para>
            <example>
                <title>Sample use of the <classname>DialogWrapper</classname></title>
                <programlisting>
 
toplevel .dialog
DialogWrapper .dialog.wrapper                          <co id='dlgwrapper_toplevel' />

set controlArea [.dialog.wrapper controlarea]
set f [ttk::frame $controlArea.frame]                  <co id='dlgwrapper_ctlarea' />

ttk::label $f.namelabel -text {What is your name}
ttk::entry $f.name

ttk::label $f.colorlabel -text {What is your favorite color}
ttk::combobox $f.colors  -values [list red green "red no green"]
                                                     <co id='dlgwrapper_form1' />
ttk::label $f.vlabel \
    -text {What is the air speed velocity of a fully laden swallow}
ttk::combobox $f.v        -values [list African English]

grid $f.namelabel $f.name
grid $f.colorlabel $f.colors                         <co id='dlgwrapper_form2' />
grid $f.vlabel    $f.v

.dialog.wrapper configure -form $f
pack .dialog.wrapper                                 <co id='dlgwrapper_display' />

set result [.dialog.wrapper modal]                   <co id='dlgwrapper_modal' />

if {$result eq "Ok"} {
    set name [$f.name get]
    set color [$f.color get]                         <co id='dlgwrapper_ok' />
    set velocity [$f.v get]

    destroy .dialog

    bridgeOfDeath $name $color $velocity
    

} elseif {$result eq "Cancel"} {
   destroy .dialog                                   <co id='dlgwrapper_cancel' />
}
                                                    <co id='dlgwrapper_destroy' />
               </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='dlgwrapper_toplevel'>
                    <para>
                        These two commands make a top level widget that will
                        hold the dialog and the dialog wrapper itself.  The
                        dialog wrapper is not yet managed into the top level.
                        If it is packed now, before it knows the shape of its
                        control are there might be an unpleasant jitter as it
                        comes up and then re-computes the geometry.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_ctlarea'>
                    <para>
                        These two commands ask the dialog wrapper to tell us
                        which widget should be the parent of our control area.
                        A frame is created and its full path is stored in the
                        variable f for convenience.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_form1'>
                    <para>
                        This makes some rather silly labels and inputs that
                        comprise the part of the dialog (control area) that
                        the user interacts with.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_form2'>
                    <para>
                        The <command>grid</command> geometry manager is then
                        used to arrange the labels and input controls into
                        <varname>f</varname>.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_display'>
                    <para>
                        The dialog widgets <option>-form</option> is set
                        to <varname>f</varname>. At that time the dialog frame
                        manages the control area and therefore comes to know
                        its size and shape.  The <command>pack</command> command
                        makes the dialog visible inside the top level widget.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_modal'>
                    <para>
                        The <methodname>modal</methodname> method blocks until
                        the user clicks <guibutton>Ok</guibutton>,
                        <guibutton>Cancel</guibutton> or destroys the widget
                        via the window manager controls.
                    </para>
                    <para>
                        The action peformed by the user to complete his or her
                        interaction with the dialog is saved in
                        <varname>result</varname>
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_ok'>
                    <para>
                        If the user clicked the <guibutton>Ok</guibutton> button
                        in the dialog actinon area, <varname>result</varname> will
                        be <literal>Ok</literal>. In that case, the values of
                        the input controls are pulled out of the control area
                        widgets before the dialogt is destroyed.
                    </para>
                    <para>
                        <function>bridgeOfDeath</function> is just symbolic of
                        some <command>proc</command> that then operates on the
                        results of the dialog.  Equally easily, this could be
                        embedded in a proc and the results provided to the caller.
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_cancel'>
                    <para>
                        If the user clicked the <guibutton>Cancel</guibutton> button,
                        <varname>result</varname> will be <literal>Cancel</literal>.
                        In this case we are going to ignore the data in the form
                        and just destroy the dialog
                    </para>
                </callout>
                <callout arearefs='dlgwrapper_destroy'>
                    <para>
                        If the user destroyed the dialog using the window manager
                        controls, the value of <varname>result</varname> will be
                        <literal>Destroy</literal>.  In this case, since the
                        top level is already destroyed or well on its way to being
                        destroyed, we just do nothing.
                    </para>
                </callout>
            </calloutlist>
        </refsect1>
      </refentry>

      <refentry id="rdogui3_readoutguiapplauncher">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Jeromy</firstname>
                            <surname>Tompkins</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_readoutguiapplauncher_title'>ReadoutGUIAppLauncher</refentrytitle>
           <manvolnum>1tcl</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>ReadoutGUIAppLauncher</refname>
           <refpurpose>Simplify the process of adding application launcher buttons to a ReadoutGUI</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require ReadoutGUIAppLauncher
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIAppLauncher <replaceable>name widget_name <optional>nCols 1</optional></replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> destroy
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
                  <replaceable>name</replaceable> appendButton <replaceable>label commandString</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
                  <replaceable>name</replaceable> disableButton <replaceable>buttonName</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
                  <replaceable>name</replaceable> enableButton <replaceable>buttonName</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
                  <replaceable>name</replaceable> addViewToParentGUI <replaceable><optional>parent .</optional></replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
             The ReadoutGUIAppLauncher provides a convenient tool for adding buttons to a ReadoutGUI
             or any parent widget. The intention is to support users who want to add buttons
             on a ReadoutGUI that launch programs for configuring hardware in their DAQ. For example, one
             might have a Mesytec MCFD-16 in his/her system to configure. Rather than running
             the MCFD16Control program from the command line and having to remember all of the arguments
             to pass, a button could be added to launch the program the same way
             every time. Such an implementation makes it easier for people to use a system and also makes
             it more robust.
           </para>

           <para>
             The ReadoutGUIAppLauncher is a snit::type, so usage of it follows all of the same semantics
             of other snit::types. Also, the ReadoutGUIAppLauncher that gets instantiated is not the
             actual widget to be displayed. Instead, the object is simply an interface to the widget it manages
             (a.k.a. the view)
             and handles all of the logic for it. This is written just so that you understand there is 
             a difference at the most fundamental level between the ReadoutGUIAppLauncher and the widget
             displayed. However, it is best to treat the launcher object as though it were the view itself.
             The expectation is that you should need no direct access to the view.
           </para>

           <para>
             The ReadoutGUIAppLauncher assumes that the parent widget its view is being added to has a layout
             managed by the grid algorithm. It will be DISASTROUS to use this class if the parent
             widget's layout is being managed by the pack algorithm. There is no problem if you are
             planning to use this with the ReadoutGUI, because that uses the grid algorithm. 
           </para>
        </refsect1>
        <refsect1>
           <title>
             COMMANDS
           </title>
           <variablelist>
                <varlistentry>
                  <term><command>ReadoutGUIAppLauncher</command> <replaceable>name view_name <optional>nCols 1</optional></replaceable></term>
                    <listitem>
                        <para>
                          Construct an instance of the ReadoutGUIAppLauncher snit::type. After invoking this
                          command, a new command ensemble will be created that begins with <parameter>name</parameter>.
                          The following items in this list of commands explain the various subcommands made available
                          in that newly created ensemble. This method will also create a new widget called 
                          <parameter>view_name</parameter> that will be managed by the ReadoutGUIAppLauncher object.
                          The application launcher will be a set a buttons arranged as a grid in a frame. By default,
                          the number of columns in that grid will be 1, but the user can specify otherwise. The
                          <parameter>nCols</parameter> can be used to set the number of columns. Once this is 
                          constructed, there is no support for changing the number of columns displayed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                  <term><replaceable>name</replaceable> <command>destroy</command></term>
                    <listitem>
                        <para>
                          The destructor should be called when the user is done with the object. It will 
                          destroy the view widget that it manages.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                  <term><replaceable>name</replaceable> <command>appendButton</command> <replaceable>label commandString</replaceable></term>
                    <listitem>
                        <para>
                          A new button will be appended to the view. Buttons are added in a left to right, top to bottom fashion. 
                          If the user intends to enable or disable the button that is created, he/she should use the
                          value returned by this class to do so. The value returned by this class is the name of the newly created
                          ttk::button.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                  <term><replaceable>name</replaceable> <command>disableButton</command> <replaceable>buttonName</replaceable></term>
                    <listitem>
                        <para>
                          Disabling the button is the same as setting the state of the button to disabled. The user
                          should use the value returned by the appendButton method to pass as the <parameter>buttonName</parameter>.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                  <term><replaceable>name</replaceable> <command>enableButton</command> <replaceable>buttonName</replaceable></term>
                    <listitem>
                        <para>
                          Enabling the button is the same as setting the state of the button to !disabled. The user
                          should use the value returned by the appendButton method to pass as the <parameter>buttonName</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                
                <varlistentry>
                  <term><replaceable>name</replaceable> <command>addViewToParentGUI</command> <replaceable><optional>parent .</optional></replaceable></term>
                    <listitem>
                        <para>
                          This effectively grids the view widgets to a parent. The placement of the view on the parent is 
                          fairly simple. It makes it span the full number of columns of the parent and then sets as a new
                          row. A very important point to make is that this assumes the parent's layout is being managed
                          by the grid algorithm. If that is not the case, DO NOT USE THIS!!
                        </para>
                    </listitem>
                </varlistentry>

           </variablelist>

        </refsect1>
        <refsect1>
          <title>EXAMPLE</title>

          <example>
            <title>Simple usage of the ReadoutGUIAppLauncher package</title>

            <programlisting>
              package require ReadoutGUIAppLauncher


              # construct the launcher with a view called .launcher and 2 columns
              ReadoutGUIAppLauncher launcher .launcher 2

              # add 3 buttons
              launcher appendButton "Launch Program0" "/path/to/program0 -option0 asdf"
              launcher appendButton "Launch Program1" "/path/to/program1 -option0 asdf -bool-flag"
              set btn2 [launcher appendButton "Launch Program2" "/path/to/program2"]


              # grid the widget on the ReadoutGUI
              launcher addViewToParentGUI

              # disable the button for /path/to/program2
              # by default, all buttons are enabled to start
              launcher disableButton $btn2

              # make sure the GUI updates before waiting 10 seconds
              update

              # wait 10 seconds before enabling it again
              after 10000

              # reenable the button for /path/to/program2
              launcher enableButton $btn2
            </programlisting>
          </example>

        </refsect1>
      </refentry>
      
      <refentry id="rdogui3_diagnostics">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_diagnostics_title'>Diagnostics</refentrytitle>
           <manvolnum>1tcl</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>Diagnostics</refname>
           <refpurpose>Provide error warning and message dialogs</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require Diagnostics
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::Diagnostics::Dialog <replaceable>title message icon exit-option</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
::Diagnostics::Error <replaceable>error-message</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::Diagnostics::Info <replaceable>info-message</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::Diagnostics::Warning <replaceable>warning-msg</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides some simple mechanisms for reporting
            errors, warnings and information to users.  The main proc
            is <function>::Diagnostics::Dialog</function>.  It is written to
            operate in either Tk or Tcl only environments.
           </para>
           <para>
            In
            Tcl mode the error <parameter>message</parameter> is output to <literal>stderr</literal> and,
            if the <parameter>exit-option</parameter> is true, theuser given
            a yes no prompt to exit the program.  If the user chooses yes, the
            program exits otherwise the function returns.
           </para>
           <para>
            In Tk mode, a 
            <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/dialog.htm'>tk_dialog</ulink>
            is used to output the error message.
            The <parameter>title</parameter> parameter is used as the dialog title
            (displayed in the to level's title bar).
            The <parameter>message</parameter> text is displayed in the dialog body.
            <parameter>icon</parameter> identifies a bitmap that will be displayed
            to the left of the message.  This is normally one of
            <literal>errro</literal>, <literal>info</literal> or <literal>warning</literal>,
            although any Tk bitmap object can be used.l
           </para>
           <para>
            In Tk mode, regardless, the dialog contains a <guibutton>Continue</guibutton>
            button which returns control to the application.  If
            <parameter>exit-option</parameter> is boolean true, an additional
            <guibutton>Exit</guibutton> button is displayed and the application
            exits if that was clicked.
           </para>
            <para>
                The remainder of the procs defined by this package are simply
                convenience commands that build pre-defined dialog types:
            </para>
            <variablelist>
                <varlistentry>
                    <term><function>::Diagnostics::Error</function> <parameter>message</parameter></term>
                    <listitem>
                        <para>
                            This is equivalent to
                            <programlisting>::Diagnostics::Dialog Error $message error 1</programlisting>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>::Diagnostics::Info</function> <parameter>message</parameter></term>
                    <listitem>
                        <para>
                            Equivalent to
                            <programlisting>::Diagnostics::Dialog Information $message info 0</programlisting>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>::Diagnostics::Warning</function> <parameter>message</parameter></term>
                    <listitem>
                        <para>
                            Equivalent to:
                            <programlisting>::Diagnostics::Dialog Warning $message warning 1</programlisting>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
                
      </refentry>
      
      <refentry id="rdogui3_expfilesystemconfig">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_expfilesystemconfig_title'>ExpFileSystemConfig</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>ExpFileSystemConfig</refname>
           <refpurpose>Configuration cluster for event directory tree</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
package require ExpFileSystemConfig            
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ExpFileSystemConfig::setDefaults
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ExpFileSystemConfig::environmentOverrides
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ExpFileSystemConfig::getStageArea
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ExpFileSystemConfig::getExperimentDirectory
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This cluster of configuration options is built on top of the
            <link linkend='rdogui3_configuration'
                  endterm='rdogui3_configuration_title' /> package.
             Commands have been defined to initialize the variables supplied
             by this system to default values and to process environment
             variable overrides to those defaults.  In addition to the normal
             <command>get</command> and <command>Set</command> methods supplied
             by the <literal>Configuration</literal> package, this package
             also provides convenience commands to fetch specific
             configuration options.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
                <varlistentry>
                    <term><command>::ExpFileSystemConfig::setDefaults</command></term>
                    <listitem>
                        <para>
                            Set the configuration variables to their default values.
                            Note that this is done by the readout GUI automatically.
                            Only call this if you want to reinitialize these configuration
                            values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ExpFileSystemConfig::environmentOverrides</command></term>
                    <listitem>
                        <para>
                            Applies environment variables to the configuration
                            values.  See ENVIRONMENT below for information about
                            the environment variables that drive this command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ExpFileSystemConfig::getStageArea</command></term>
                    <listitem>
                        <para>
                            Returns the path  to the top level directory of the
                            directory tree that contains the event data and its metadata.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ExpFileSystemConfig::getExperimentDirectory</command></term>
                    <listitem>
                        <para>
                            Returns the path to the top level of the directory tree
                            that contains the event metadata (run directories).
                        </para>
                    </listitem>
                </varlistentry>
                
           </variablelist>
        </refsect1>
        <refsect1>
            <title>DEFAULTS</title>
            <para>
                The defaults are as follows:
                <variablelist>
                    <varlistentry>
                        <term><varname>StageArea</varname></term>
                        <listitem>
                            <para>
                                The stage area default is set to
                                <filename>~/stagearea</filename> this is
                                usually a symbolic link to the real stage area.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>Experiment</varname></term>
                        <listitem>
                            <para>
                                The experiment meta data directory defaults to
                                <filename>~/experiment</filename> this is normally
                                a symbolic link to
                                <filename>~/stagearea/experiment</filename>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>ENVIRONMENT</title>
            <para>
                The following environment variables override default values
                for the configuration variables:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>EVENTS</literal></term>
                    <listitem>
                        <para>
                            The value of this environment variable overrides
                            the Stage area default
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EXPDIR</literal></term>
                    <listitem>
                        <para>
                            The value of this environment variable overrides
                            the Experiment metadata default value.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>

      </refentry>

      <refentry id="rdogui3_readoutgui">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_readoutgui_title'>ReadoutGui</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>ReadoutGui</refname>
           <refpurpose>ReadoutGui elements.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutGui
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
            <command>
ProviderList  <replaceable>widget-path ?options?</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>provider-list method ?args?</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
ProviderListDialog <replaceable>widget-path ?options?</replaceable>
                </command>
            </cmdsynopsis>
             <cmdsynopsis>
                 <command>
<replaceable>pld method ?args?</replaceable>
                 </command>
             </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>ProviderSelectDialog widget-path ?args?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>psd method ?args?</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
ReadoutGuiApp <replaceable>%AUTO% | app-name</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            the ReadoutGUI package provides a set of dialog widgets for
            interrogating/selecting the running data sources as well
            as an 'overall application' class that, when instantiated
            creates the entire ReadoutShell's GUI and threads together all of
            the components that make up the system.
           </para>
           <para>
            Normally,  you only need the <classname>ReadoutGuiApp</classname>
            and then only if you need a  highly customized start up.
            The other widgets are documente for the sake of completeness.
           </para>
        </refsect1>
        <refsect1>
           <title>
              MEGAWIDGETSS
           </title>
           <para>
            Subsections of this section provide reference material for the
            megawidgets that are provided by this package:
           </para>
           <variablelist>
            <varlistentry>
                <term><classname>ProviderList</classname></term>
                <listitem>
                    <para>
                        A megawidget that displays the data sources in a
                        scrollable list.  The list displays the source id,
                        the provider name and the parameterization of that instance
                        of the data source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>ProviderListDialog</classname></term>
                <listitem>
                    <para>
                        Encapsulate the <classname>ProviderList</classname>
                        in a dialog for display purposes only.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>ProviderSelectDialog</classname></term>
                <listitem>
                    <para>
                        Encapsulates <classname>ProviderList</classname>
                        in a dialog that also permits selection of a data
                        source from the list.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
           <refsect2>
            <title>ProviderList</title>
            <para>
                This megawidget provides a four column scrolling table that
                lists data sources and their descriptions.  The columns provided
                are:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        The id of the source.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The provider name (source type).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Parameter names for each parameter in the source
                        parameterization.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Parametr values for each parameter in the source
                        parameterization.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                Since each source can have several parameters in its parameterization,
                a data source will show up as several lines in the table.
                The first line is just the source id and source type while
                subsequent lines give parameter name/value pairs.
            </para>
            <refsect3>
                <title>
                    OPTIONS
                </title>
                <variablelist>
                    <varlistentry>
                        <term><option>-sources</option> <replaceable>list-of-source-dicts</replaceable></term>
                        <listitem>
                            <para>
                                The data in this option determines what the
                                widget displays.  See
                                the <methodname>sources</methodname> method
                                of
                                <link linkend='rdogui3_DataSourceManager'
                                      endterm='rdogui3_DataSourceManager_title' />
                                for the form of this data.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect3>
            <refsect3>
                <title>METHOD</title>
                <variablelist>
                    <varlistentry>
                        <term><methodname>getSelected</methodname></term>
                        <listitem>
                            <para>
                                The widget allows for single items to be selected.
                                This method returns the source Id of the
                                selected data source.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect3>
           </refsect2>
           <refsect2>
            <title>ProviderListDialog</title>
            <para>
                This megawidget wraps a <classname>ProviderList</classname>
                in a dialog that is suited for inspecting the list of data
                sources.  The dialog has an <guibutton>Ok</guibutton> button
                which dismisses the dialog.  No access is provided to the
                selected item.  
            </para>
            <para>
                If you want to allow the user to select a data source for you
                to operate on in your code, see the <classname>ProviderSelectDialog</classname>
                below.
            </para>
            <refsect3>
                <title>OPTIONS</title>
                <para>
                    The <option>-sources</option> list from the <classname>ProviderList</classname>
                    widget is exposed and has the same meaning.
                </para>
            </refsect3>
            <refsect3>
                <title>METHODS</title>
                <para>
                    All methods from the <classname>DialogWrapper</classname>
                    megawidget described in
                    <link linkend='rdogui3_ui' endterm='rdogui3_ui_title' />
                    are supported.  Use the <methodname>modal</methodname> method
                    to block until the dialog is either destroyed by the user
                    or you need to destroy it due to an <guibutton>Ok</guibutton>
                    click.
                </para>
            </refsect3>
           </refsect2>
           <refsect2>
            <title>ProviderSelectDialog</title>
            <para>
                This dialog wraps a <classname>ProviderList</classname>
                widget in a dialog that provides an <guibutton>Ok</guibutton>
                and a <guibutton>Cancel</guibutton> button.  Access to the
                selected data source is provided to allow you to retrieve
                and operate on the selected data source in the event the
                user clicks the <guibutton>Ok</guibutton> button.
            </para>
            <refsect3>
                <title>OPTIONS</title>
                <para>The <option>-sources</option> option from the wrapped
                    <classname>ProviderList</classname> widget is exposed
                    and has the same meaning as for that widget.
                </para>
            </refsect3>
            <refsect3>
                <title>METHODS</title>
                <para>
                    All methods of the <classname>DialogWrapper</classname>
                    megawidget described in
                    <link linkend='rdogui3_ui' endterm='rdogui3_ui_title' />
                    are supported.  Use the <methodname>modal</methodname> method
                    to block until the user clicks <guibutton>Ok</guibutton> or
                    <guibutton>Cancel</guibutton> or simply destroys the
                    widget.
                </para>
                <para>
                    The <methodname>getSelected</methodname> method of the
                    <classname>ProviderList</classname>
                    is also exposed.  Normally if the <methodname>modal</methodname>
                    method returns <literal>Ok</literal> your application would
                    use <methodname>getSelected</methodname> to determine
                    which data source was selected prior to destroying the
                    dialog widget.
                </para>
            </refsect3>
           </refsect2>
        </refsect1>
        <refsect1>
            <title>APPLICATION CLASSS</title>
            <para>
                The application class <classname>ReadoutGuiApp</classname> is
                not a widget, however it does instantiate the entire widget
                tree that makes up the ReadoutShell application and
                ensures that it has the appropriate default behavior.
            </para>
            <para>
                <filename>ReadoutShell</filename> is simply a script that
                creates an instance of <classname>ReadoutGuiApp</classname>
            </para>  
        </refsect1>
      </refentry>

      <refentry id="rdogui3_readoutguipanel">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_readoutguipanel_title'>ReadoutGUIPanel</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>ReadoutGUIPanel</refname>
           <refpurpose>ReadoutGUI Convenience commands</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require ReadoutGUIPanel                
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::addUserMenu <replaceable>ident label</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getRunIdInstance
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::ghostWidgets
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::unghostWidgets
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getTitle
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::setTitle <replaceable>title-string</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getRun
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::setRun <replaceable>run-number</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::incrRun
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::recordOff
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::recordOn
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::recordData
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getRunTime
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::isTimed
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::setTimed <replaceable>state</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::getRequestedRunTime
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::setRequestedRunTime
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::isRecording
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::notRecording
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::normalColors
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::outputText
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::ReadoutGUIPanel::log <replaceable>source class message</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            <literal>ReadoutGUIPanel</literal> is a collection of simple
            commands that provide access to the readout GUI and its components.
            The commands all live in the <literal>::ReadoutGUIPanel</literal>
            namespace.  In many cases they provide compatibility with
            functions that were provided by the NSCLDAQ-10.x and earlier
            ReadoutShell.  There are no plans, however to deprecate/remove
            these functions unless their functionality becomes obsolete
            in future (NSCLDAQ-12.0 or later) versions of NSCLDAQ's
            readout shell.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::addUserMenu</command> <replaceable>ident label</replaceable></term>
                    <listitem>
                        <para>
                            Adds a new menu to the menubar of the ReadoutGUI.
                            The <parameter>ident</parameter> is required
                            but ignored (it was used in NSCLDAQ-10.x and earlier).
                            <parameter>label</parameter> is the label for the
                            menu in the menu bar.
                        </para>
                        <para>
                            The command returns the widget that is the menu.
                            This allows you to populate the menu for example:
                        </para>
                        <informalexample>
                            <programlisting>
set mymenu [::ReadoutGUIPanel::addUserMenu ignored Special]
$mymenu add command -label "a command" -command handleACommand
...
                            </programlisting>
                        </informalexample>
                        <para>
                            Adds a menu labeled <literal>Special</literal>
                            to the menu bar and puts a command entry labelled
                            <literal>a command</literal> on it that invokes
                            the command <command>handleACommand</command>
                            when clicked.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getRunIdInstance</command></term>
                    <listitem>
                        <para>
                            The Readout GUI is composed of several megawidgets.
                            These are established as singleton objects.
                            The <classname>RunIdentification</classname>
                            megawidget (see
                            <link linkend='rdogui3_ui' endterm='rdogui3_ui_title' />)
                            provides a cluster of widgets that identify the run
                            in progress or run about to start.  This command
                            returns the widget id of the run identification
                            singleton object.
                        </para>
                        <para>
                            Note that several commands below offer access to the
                            most common pieces of this widget, so you may not
                            ever actually need to use this command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::ghostWidgets</command></term>
                    <listitem>
                        <para>
                            Some widgets in the ReadoutGUI must be disabled while
                            the run is not in the halted state.  This
                            command disables those widgets.  See also
                            <command>::ReadoutGUIPanel::unghostWidgets</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::unghostWidgets</command></term>
                    <listitem>
                        <para>
                            Enable the widgets that must be disabled when the
                            run is not in the halted state. See also
                            <command>::ReadoutGUIPanel::ghostWidgets</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getTitle</command></term>
                    <listitem>
                        <para>
                            Returns the title from the title section of the
                            run identification megawidget.  If the run is active
                            or paused,
                            this will be the title of the current run.  Otherwise,
                            this will be the title of the next run, assuming the
                            user does not change it. 
                        </para>
                        <para>
                            It is recommended that applications access this when
                            the run is active or about to be.  This can be done
                            by using the appropriate <filename>ReadoutCallouts.tcl</filename>
                            proc or by creating a Run state machine callback bundle
                            and using the appropriate state transition to
                            capture the title.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::setTitle</command> <replaceable>new-title</replaceable></term>
                    <listitem>
                        <para>
                            Makes <parameter>new-title</parameter> the new title
                            string in the Run identification megawidget.
                            Note that this should only be done when the run
                            is not in one of the active states (<literal>Active</literal>
                            or <literal>Paused</literal>).  This sets the title
                            that will be associated with the next run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getRun</command></term>
                    <listitem>
                        <para>
                            Returns the value of the run number in the run
                            identification megawidget.  If the run is active
                            (state in <literal>Active</literal> or <literal>Paused</literal>),
                            this will be the current run number.  If not, this
                            will be the run number of the next run started, unless
                            the user modifies it.
                        </para>
                        <para>
                            It is recommended that applications access this when
                            the run is active or about to be.  This can be done
                            by using the appropriate <filename>ReadoutCallouts.tcl</filename>
                            proc or by creating a Run state machine callback bundle
                            and using the appropriate state transition to
                            capture the title.
                        </para>                        
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::setRun</command> <replaceable>new-run</replaceable></term>
                    <listitem>
                        <para>
                            Sets the run number in the run identification
                            megawidget to be <parameter>new-run</parameter>.
                            <parameter>new-run</parameter> must be a positive
                            integer.    This should only be modified when the
                            run is not active (in neither the
                            <literal>Active</literal> nor <literal>Paused</literal>
                            states).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::incrRun</command></term>
                    <listitem>
                        <para>
                            Adds one to the run number in the run identification
                            megawidget. This should only be done when the
                            run is not active (in neither the
                            <literal>Active</literal> nor <literal>Paused</literal>
                            states).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::recordOff</command></term>
                    <listitem>
                        <para>
                            Turns off the record checkbutton in the run control
                            megawidget.  This determines whether or not the
                            next run will be recorded to disk.  Note that
                            this does not change the rendition of the
                            output area of the widget. See
                            <command>::ReadoutGUIPanel::isRecording</command>,
                            <command>::ReadoutGUIPanel::notRecording</command>
                            and <command>::ReadoutGUIPanel::normalColors</command>
                            to modify display renditions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::recordOn</command></term>
                    <listitem>
                        <para>
                            Turns on the record checkbutton in the run control
                            megawidget. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::recordData</command></term>
                    <listitem>
                        <para>
                            Returns the state of the record checkbutton in the
                            run control megawidget.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getRunTime</command></term>
                    <listitem>
                        <para>
                            Returns the number of seconds the current run has
                            been active (a paused run is not active for this
                            computation).  If the run is not active this returns
                            <literal>0</literal> if the ReadoutGUI has not yet
                            started a run or the length of the previous run if
                            it has.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::isTimed</command></term>
                    <listitem>
                        <para>
                            Returns boolean <literal>true</literal> if the timed
                            run button is on and <literal>false</literal> if not.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::setTimed</command> <replaceable>state</replaceable></term>
                    <listitem>
                        <para>
                            Checks or unchecks the timed run checkbutton according
                            to <parameter>state</parameter>.  If checked at the
                            start of the run, the run has a timed duration
                            (unless manually halted).  See
                            <command>::ReadoutGUIPanel::getRequestedRunTime</command>
                            and <command>::ReadoutGUIPanel::setRequestedRunTime</command>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::getRequestedRunTime</command> </term>
                    <listitem>
                        <para>
                            Returns the number of seconds in the requested run
                            time.  This is only meaningful if the timed run
                            checkbox is checked.   The requested run time is the
                            active time (time paused does not count).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::setRequestedRunTime</command> <replaceable>time-in-seconds</replaceable></term>
                    <listitem>
                        <para>
                            Sets the number of seconds in the requested run time
                            to <parameter>time-in-seconds</parameter>.  If the
                            timed run checkbutton is checked, then the next run
                            will be a time duration run that will automatically
                            stop after <parameter>time-in-seconds</parameter> of
                            active time elapse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::isRecording</command></term>
                    <listitem>
                        <para>
                            Sets the rendition of the text widget to be consistent
                            with the run being recorded.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::notRecording</command></term>
                    <listitem>
                        <para>
                            Sets the rendition of the text widget to be consistent
                            with the run being not recorded.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::normalColors</command></term>
                    <listitem>
                        <para>
                            A synonym for <command>::ReadoutGUIPanel::notRecording</command>
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::outputText</command> <replaceable>message</replaceable></term>
                    <listitem>
                        <para>
                            Outputs <parameter>message</parameter> to the output
                            text widget.  The message is output without interpretation
                            or filtering using the default rendition.
                            See also <command>::ReadoutGUIPanel::Log</command>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::ReadoutGUIPanel::Log</command> <replaceable>source class message</replaceable></term>
                    <listitem>
                        <para>
                            Formats a log message to be output on the text widget.
                            <parameter>source</parameter> identifies the subsystem
                            the message is coming from.
                            <parameter>class</parameter> is the class of message
                            being output.  See the documentation of the
                            <classname>OutputWindow</classname> in
                            <link linkend='rdogui3_ui' endterm='rdogui3_ui_title' />
                            for more information about what the <parameter>class</parameter>
                            is and how it influences the output. 
                        </para>
                        <para>
                            For now just know that unless reconfigured,
                            <parameter>class</parameter> represents a message
                            severity that can be one of:
                            <literal>output</literal>, <literal>log</literal>,
                            <literal>error</literal>, <literal>warning</literal>
                            or <literal>debug</literal> and note that
                            <literal>debug</literal> messages are, by default, not
                            displayed.
                        </para>
                        <para>
                            <parameter>message</parameter> is the body of the
                            message to be logged.  The message is timestamped
                            and potentially output to the text terminal along
                            with the severity and data source. For example,
                            when starting data source, the following log
                            message will appear (with an appropriate timestamp).
                        </para>
                        <informalexample>
                            <screen>
                            <computeroutput>
01/08/2014 08:50:08 : log : Run State changed : NotReady -> Starting
                            </computeroutput>
                            </screen>
                        </informalexample>
                        <para>
                            In this case <literal>log</literal> is the class,
                            <literal>Run State changed</literal> is the source
                            and <literal>NotReady -> Starting</literal> the
                            message.
                        </para>
                    </listitem>
                </varlistentry>               
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="rdogui3_runstatemachine">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_runstatemachine_title'>RunStateMachine</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>RunStateMachine</refname>
           <refpurpose>Run control state machine</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require RunstateMachine
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>sm</replaceable> [RunstateMachineSingleton %AUTO%]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$sm method</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides the run control state machine singleton.  Constructing
            a <classname>RunstateMachineSingleton</classname> encapsulates
            a single instance of a <classname>RunStateMachine</classname> so
            that all clients are assured of interacting with the same
            state machine object.
           </para>
           <para>
            The state machine object has a well defined set of states and
            allowed transitions between those states.  See STATES below
            for the set of allowed states and transitions.
           </para>
           <para>
            By itself the state machine is not worth very much.  The value comes
            from the ability to register <firstterm>Callout bundles</firstterm>
            with the state machine.  See the CALLOUT BUNDLES for more about
            what a callback bundle is and how to create one.
           </para>
        </refsect1>
        <refsect1>
           <title>
              METHODS and TYPEMETHODS
           </title>
           <para>
            The <classname>RunstateMachineSingleton</classname> object wraps
            a single application wide <classname>RunstateMachine</classname> and
            exposes all of its methods to its client.  The methods described here
            are therefore actually <classname>RunstateMachine</classname> methods.
           </para>
           <para>
            The methods below designated as TYPEMETHODS do not require an object
            to invoke.
           </para>
           <variablelist>
            <varlistentry>
                <term><methodname>::RunstateMachine::listStates</methodname></term>
                <listitem>
                    <para>
                        This typemethod returns a Tcl list whose elements
                        are the legal states the
                        machine can be in.  These are described in the
                        STATES section below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>::RunstateMachine::listTransitions</methodname>
                    <parameter>state</parameter></term>
                <listitem>
                    <para>
                        This typemethod accepts  the name of a
                        <parameter>state</parameter> returned from
                        <methodname>::RunstateMachine::listState</methodname>
                        and returns a list consisting of the names of the
                        valid state that can be reached from that
                        <parameter>state</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>getState</methodname></term>
                <listitem>
                    <para>
                        Return the current state of the state machine.
                        This will be a state in the list returned by
                        <methodname>::RunstateMachine::listStates</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>listCalloutBundles</methodname></term>
                <listitem>
                    <para>
                        Returns a list consisting of the names of the currently
                        registererd callout bundles.  See
                        CALLOUT BUNDLES below for more information about
                        callout bundles.   The list is provided in registration
                        order which also correspondes to the callout order.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>addCalloutBundle</methodname> <parameter>bundle-name ?before-bundle?</parameter></term>
                <listitem>
                    <para>
                        Registers a new callout bundle with the state machine.
                        See CALLOUT BUNDLES below for information about
                        what a callout bundle is. The <parameter>bundle-name</parameter>
                        is considerd to be the name of a namespace relative
                        to the global namespace (e.g MyBundle is considered to
                        be the namespace ::MyBundle).  
                    </para>
                    <para>
                        The namespace
                        is checked for the existence and proper parameterization of
                        the required callback bundle procs as described in
                        CALLOUT BUNDLES.  An error is thrown if the namespace
                        is determined to not be a valid callout bundle.
                    </para>
                    <para>
                        If <parameter>before-bundle</parameter> is provided it must
                        be the name of an existing bundle (one that would
                        be returned from <command>listCalloutBundles</command>).
                        The bundle will be registerd just before <parameter>before-bundle</parameter>
                        in the ordered list of bundles.  This allows action depenencies
                        between bundles to be properly scheduled.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>removeCalloutBundle</methodname> <parameter>bundle-name</parameter></term>
                <listitem>
                    <para>
                        Removes the named callout bundle from the list of
                        registered bundles.  It is an error if <parameter>bundle-name</parameter>
                        does not correspond to a registered callout bundle.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>transition</methodname> <parameter>new-state</parameter></term>
                <listitem>
                    <para>
                        Attempts a transition from the current state
                        to <parameter>new-state</parameter>.  The
                        <command>leave</command> and <command>enter</command>
                        procs for the registered callback bundles are invoked.
                    </para>
                    <para>
                        <command>leave</command> is invoked prior to making the
                        transition while <command>enter</command> is invoked
                        after the transition has occurerd.
                    </para>
                    <para>
                        If <parameter>new-state</parameter> is not an allowed
                        state transition, an error is thrown.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>
                STATES
            </title>
            <para>
                The <classname>RunstateMachine</classname> has a well defined
                set of state and allowed transtion between those states.
                The finite state automaton that is defined by these states and
                their allowed transitions is shown in simplified form in
                <link linkend='rdogui_statediagram' endterm='rdogui_statediagram_title' />
            </para>
            <para>
                These states and their allowed transitions are described textually
                below.
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>NotReady</literal></term>
                    <listitem>
                        <para>
                            The system is not ready for use.  In this state,
                            data sources have not yet been started.   You must
                            also be in this state to modify the set of data
                            sources known to the application.
                        </para>
                        <para>
                            Allowed target states for the <methodname>transition</methodname>
                            method are; <literal>NotReady</literal> and
                            <literal>Starting</literal>.  <literal>Starting</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Starting</literal></term>
                    <listitem>
                        <para>
                            This state is entered to start the data sources
                            that have been defined for use with the application.
                            <literal>NotReady</literal> is an allowed target state
                            and is normally entered if one or more data sources
                            failed to tart up.  <literal>Halted</literal> is the
                            other valid target state and is
                            entered if all data sources started correctly.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Halted</literal></term>
                    <listitem>
                        <para>
                            This state indicates the system is ready for
                            use but there is no current data taking run.
                            Valid transition targets are;
                            <literal>NotReady</literal>, if a data source fails
                            or <literal>Active</literal> if a run is successfully
                            started.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Active</literal></term>
                    <listitem>
                        <para>
                            This state indicates data taking is ongoing.
                            Valid transitions are:
                            <literal>Paused</literal> if the run is paused,
                            <literal>Halted</literal> if the run is ended and
                            <literal>NotReady</literal> if a data source fails.
                        </para>
                        <para>
                            Note that while not all data source providers support
                            a <literal>Paused</literal> state this is not known
                            or supported directly by the run state machine.
                            Instead, the ReadoutGUI interrogates the data
                            sources defined and removes the GUI elements that
                            can trigger a transition to the <literal>Paused</literal>
                            state if not all data sources support paused runs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>Paused</literal></term>
                    <listitem>
                        <para>
                            Indicates a data taking run is temporarily paused.
                            This state can transition to:
                            <literal>Halted</literal> if the run is stopped,
                            <literal>Active</literal> if the run is resumed or
                            <literal>NotReady</literal> if a data source fails.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <note>
                <title>NOTE</title>
                <para>
                    In the transition diagram above, the text <literal>if a data source fails</literal>
                    means a data source provider's <command>check</command> for
                    that data source returns boolean <literal>false</literal>.
                    Thus failure is defined by and limited to the ability of the data source
                    provider to detect the failure.
                </para>
            </note>
        </refsect1>
        <refsect1>
            <title>CALLOUT BUNDLES</title>
            <para>
                The true value of the run state machine is the ability of
                components of the ReadoutGUI (including your extensions) to
                register <firstterm>Callout Bundles</firstterm>.  You can think
                of a callout bundle as a generalization of the ReadoutShell's
                <filename>ReadoutCallouts.tcl</filename> mechanism.
            </para>
            <para>
                A Callout bundle is a Tcl namespace.  The namespace must
                contain three exported<command>proc</command> definitions:
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>attach</command> <parameter>current-state</parameter></term>
                    <listitem>
                        <para>
                            This proc is called when the bundle is registered
                            with the state machine via
                            <methodname>addCalloutBundle</methodname>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>leave</command> <parameter>from-state to-state</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just before the state machine makes
                            a transition from <parameter>from-state</parameter> to
                            <parameter>to-state</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>enter</command> <parameter>from-state to-state</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just after the state machine has
                            made a transition from <parameter>from-state</parameter>
                            to <parameter>to-state</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The <command>enter</command> and <command>leave</command> procs
                for the callout bundles are invoked in the order in which the
                bundles were registered.
            </para>
        </refsect1>
        <refsect1>
            <title>EXAMPLES</title>
            <para>
                The sample code below shows the creation and registration of
                a callout bundle that does nothing.  You can rename the namespace
                and fill in the procs shown below to build and register your own
                callout bundles.
            </para>
            <example>
                <title>A do nothing <classname>RunstateMachine</classname> callout bundle</title>
                <programlisting>
                    
package require RunstateMachine                         <co id='callout_bundle_require' />
                    
namespace eval ::MyBundle  {
    variable  sm
    namespace export attach enter leave                 <co id='callout_bundle_namespace' />
}

proc ::MyBundle::attach currentState {
                                                       <co id='callout_bundle_attach' />
}

proc ::MyBundle::leave {from to} {
                                                      <co id='callout_bundle_leave' />
}

proc ::MyBundle::enter {from to} {
                                                       <co id='callout_bundle_enter' />
}

set ::MyBundle::sm [RunstateMachineSingleton %AUTO]   <co id='callout_bundle_smget' />
$::MyBundle::sm    addCalloutBundle MyBundle          <co id='callout_bundle_register' />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='callout_bundle_require'>
                    <para>
                        Requires the run state machine package.  This is needed
                        to get access to the state machine and then to register
                        the bundle we're creating.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_namespace'>
                    <para>
                        This code creates the namespace <literal>::MyBundle</literal>
                        it defines a variable <varname>sm</varname> to live in that
                        namespace (to hold the state machine object command) and
                        exports the required proc names from the namespace.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_attach'>
                    <para>
                        Defines the <command>enter</command> proc of the
                        bundle. This will be called when the bundle is registered
                        with the state machine. When called, <parameter>currentState</parameter>
                        will be the state at the time the attach was done.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_leave'>
                    <para>
                        Defines the <command>leave</command> proc of the bundle.
                        This will be called just before the state machine
                        begins a transition.  <parameter>from</parameter> will
                        be the state at the time the transition is being started
                        and <parameter>to</parameter> will be the target state.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_enter'>
                    <para>
                        Defines the <command>enter</command> proc of the bundle.
                        This is called after the state machine completes its state
                        transition. <parameter>from</parameter> is the old state
                        and <parameter>to</parameter> is the new state.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_smget'>
                    <para>
                        Obtains the run state machine singleton and assigns
                        it to the variable <varname>::MyBundle::sm</varname>.
                        This allows it to be used from within the bundle procs
                        as well as for bundle registration purposes.
                    </para>
                </callout>
                <callout arearefs='callout_bundle_register'>
                    <para>
                        Registers the bundle with the state machine.  Prior to
                        returning from this call, <command>::MyBundle::attach</command>
                        will be called.  From now on state transitions will result
                        in calls first to the bundle's <command>::MyBundle::leave</command>
                        and then to the bundle's <command>::MyBundle::enter</command>
                        procs.
                    </para>
                </callout>
            </calloutlist>
        </refsect1>
      </refentry>
      <refentry id="rdogui3_statemanager">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_statemanager_title'>StateManager</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>StateManager</refname>
           <refpurpose>Save restore program state variables.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require StateManager
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>state</replaceable> StateManager %AUTO% <replaceable>?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$state</replaceable> method <replaceable>?parameters?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set singleton [StateManagerSinleton %AUTO% <replaceable>?options?</replaceable>]
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            While packaged with the ReadoutGUI this is actually a general purpose
            utility that provides support for Tcl script to save and restore
            state variables.  A state variable can be pretty much anything that
            might define the state of a program or control how a program operates.
           </para>
           <para>
            State is saved to and restored from Tcl scripts that consist entirely
            of <command>set</command> commands.  These scripts are sourced into
            a safe interpreter in order to ensure they cannot damage or inject
            insecure code into the application itself.
           </para>
           <para>
            Only pre-declared state variables will be saved or restored
            from the file, further securing the application script from malicious
            or erroneous restores.
           </para>
           <para>
            Note that if an application has several independent components
            that wish to share a single configuration file, the
            <classname>StateManagerSingleton</classname> can be used to provide
            access to an application speciric singleton state manager object.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <para>
            <classname>StateManager</classname> objects include the
            standard <methodname>configure</methodname> and
            <methodname>cget</methodname> methods.  These operate on
            the object option(s) described below.
           </para>
           <variablelist>
            <varlistentry>
                <term><option>-file</option> <parameter>file-path</parameter></term>
                <listitem>
                    <para>
                        Provides the path to the file that will be used by
                        <methodname>save</methodname> and
                        <methodname>restore</methodname> operations.
                    </para>
                    <para>
                        See METHODS below.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>

        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                In addtion to the <methodname>configure</methodname> and
                <methodname>cget</methodname> methods described in
                OPTIONS above, the following methods are provided by
                <classname>StateManager</classname> objects
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>destroy</methodname></term>
                    <listitem>
                        <para>
                            Destroys the object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>addStateVariable</methodname> <parameter>name getter setter</parameter></term>
                    <listitem>
                        <para>
                            Defines a state variable that will be saved/restored
                            by the state manager. <parameter>name</parameter> is
                            the name of the variable as it will be defined in
                            the file (e.g. <command> set <replaceable>name value</replaceable></command>).
                        </para>
                        <para>
                            <parameter>getter</parameter> is a command to which <parameter>name</parameter>
                            will be appended that will be used by <methodname>save</methodname>
                            to obtain the variable value.
                            <parameter>setter</parameter> is a command which will be called by
                            <methodname>restore</methodname> to restore the value of <parameter>name.
                            </parameter><parameter>name</parameter>
                            and <parameter>value</parameter> will be appended to
                            the setter command.
                        </para>
                        <para>
                            If this business of getters and setters is not clear
                            see <methodname>save</methodname> and
                            <methodname>restor</methodname> and finally
                            the EXAMPLES section below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>listStateVariables</methodname></term>
                    <listitem>
                        <para>
                            Returns a list of the state variables.  The return
                            value is a Tcl list of triplets.  Each triplet conisists
                            of a variable name, its getter and setter in that order.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>save</methodname></term>
                    <listitem>
                        <para>
                            Saves the variables to <option>-file</option>.
                            If the <option>-file</option> option is blank an
                            error is thrown. 
                        </para>
                        <para>
                            The save operates by iterating over all registered
                            variables and writing a command that is something like
                            <informalexample>
                                <programlisting>
set <replaceable>varname</replaceable> [<replaceable>getter varaname</replaceable>]
                                </programlisting>
                            </informalexample>
                            to the file.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>restore</term>
                    <listitem>
                        <para>
                            Creates a secure slave interpreter and sources
                            <option>-file</option> into that interpreter.
                            For each variable in the list of state variables,
                            if the slave interpreter has a definition for that
                            variable, the setter for that variable is called in
                            code something like this:
                            <informalexample>
                                <programlisting>
$setter $varname $value-in-safe-interp
                                </programlisting>
                            </informalexample>  
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
        <refsect1>
            <title>EXAMPLES</title>
            <para>
                The example below shows how to define two state variables
                <varname>::State::var1</varname> and <varname>::State::var2</varname>
                and their associated getter/setter procs.
            </para>
            <example>
                <title>Getters and setters for StateManager</title>
                <programlisting>
namespace eval ::State {
    variable var1                                  <co id='statemgr_vars' />
    variable var2
}
...
proc ::State::getter name {
    return [set ::State::$name]                    <co id='statemgr_getter' />
}
proc ::State::setter {name  value}
{
    set ::State::$name $value                      <co id='statemgr_setter' />
}

set sm [StateManagerSingleton %AUTO%]
$sm addStateVariable var1 ::State::getter ::State::setter  <co id='statemgr_register' />
$sm addStateVariable var2 ::State::getter ::State::setter

...
$sm configure -file /path/to/configuration/file.tcl  <co id='statemgr_configfile' />
$sm save                                             <co id='statemgr_save' />
...
$sm restore                                          <co id='statemgr_restore' />

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='statemgr_vars'>
                    <para> Creates a namespace for the state variables
                        and declares <varname>var1</varname> and
                        <varname>var2</varname> which will be saved and restored.
                    </para>
                </callout>
                <callout arearefs='statemgr_getter'>
                    <para>
                        The getter uses the name passed to it, and the fact
                        that the <command>set</command> command without a value
                        just returns the current value of the variable to
                        return the value of the named variable within the
                        <literal>::State::</literal> namespace.  Tcl rules
                        for substitution prevent the straightforward use of
                        <command>return $::State::$name</command>
                    </para>
                </callout>
                <callout arearefs='statemgr_setter'>
                    <para>
                        The setter similarly uses the name and value to update
                        the named variable in the <literal>::State</literal>
                        namespace.
                    </para>
                </callout>
                <callout arearefs='statemgr_register'>
                    <para>
                        After getting the state manager singleton,
                        <varname>var1</varname> and <varname>var2</varname>
                        are registered with getters and setters defined
                        as described above so that each variable is bound to
                        the corresponding variable in the <literal>::State</literal>
                        namespace.
                    </para>
                    <para>
                        It's worth nothing that more interesting setter and getter
                        functions are possible.  For example, a setter could
                        load a piece of a graphical user interface, and a getter
                        could retrieva a value from an element of a graphical user
                        interface.   The ReadoutShell does this in a few places.
                    </para>
                </callout>
                <callout arearefs='statemgr_configfile'>
                    <para>
                        Before doing saves and restores, the <option>-file</option>
                        must be configured to point at a file (or specify a writable file
                        for save) that is used as the target for the save or source for
                        the restore.  <option>-file</option> can be freely configured
                        many times.  For example your application might prompt the user
                        for a filename into which some configuration information
                        can be written/read.
                    </para>
                </callout>
                <callout arearefs='statemgr_save'>
                    <para>
                        Saves the values of <varname>::State::var1</varname>
                        and <varname>::State::var2</varname> to the last configured
                        <option>-file</option>.  This is done by invoking the
                        getter registered for each of those variables (and any other
                        variables that were added for that matter) in turn passing in
                        <literal>var1</literal> and <literal>var2</literal> to
                        retrieve their values.
                    </para>
                </callout>
                <callout arearefs='statemgr_restore'>
                    <para>
                        <command>source</command>s the last configured <option>-file</option>
                        into a slave safe interpreter and queries that interpreter
                        to see if each registered variable is defined.  For each
                        defined variable, the value is fetched out of the interpreter
                        and that variable's setter is invoked to update whatever
                        in the application is bound to that configuration variable.
                    </para>
                </callout>
            </calloutlist>
        </refsect1>
      </refentry>
      <refentry id="rdogui3_ui">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_ui_title'>ui</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>ui</refname>
           <refpurpose>ReadoutGUI graphical user interface elements.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ui
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides all of the graphical user interface elements
            that are part of the standard ReadoutGUI.  It is possible for
            a custom control interface to be written using some, all or none
            of these elements. 
           </para>
           <para>
            This package can also be used to access elements of the ReadoutGUI
            from within extensions to the standard ReadoutShell.
            The package consists of a rather large set of component megawidgets
            and singleton implementations of those megawidgets.  The remainder
            of this section will briefly describe the purpose of each of those megawidgets.
            Subsequent sections will provide more detailed reference information
            about each megawidget.
           </para>
           <variablelist>
            <varlistentry>
                <term><link linkend='rdogui3_ui_readoutMenubar' endterm='rdogui3_ui_readoutMenubar_title' />
                </term>
                <listitem>
                    <para>
                        Provides the menu bar for the application.  This can
                        be used as a genric menu bar handling class for
                        your own applications distinct from the ReadoutShell
                        as well.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='rdogui3_ui_RunIdentification'
                    endterm='rdogui3_ui_RunIdentification_title' /></term>
                <listitem>
                    <para>
                        Provides a megawidget that identifies runs.  This contains
                        an entry/display of a title string and an entry for a
                        run number.  The run number entry is constrained to
                        hold positive integers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_ui_RunControl' endterm='rdogui3_ui_RunControl_title' />
                </term>
                <listitem>
                    <para>
                        Provides a megawidget that contains the controls for a run.
                        These are buttons intended to drive the
                        <link linkend='rdogui3_runstatemachine'
                              endterm='rdogui3_runstatemachine_title' />.
                        Buttons that can appear include a <guibutton>Start</guibutton>
                        button, a <guibutton>Begin/End</guibutton> button a
                        <guibutton>Pause/Resume</guibutton> button that can be
                        disabled and a <guibutton>Record</guibutton> checkbutton.
                    </para>
                    <para>
                        The widget is linked to the run state machine
                        singleton so that button presses create the appropriate
                        state transitions.  An associated callout bundle
                        allows the widget to track state machine transitions
                        that it does not initiate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_ui_StopWatch'
                          endterm='rdogui3_ui_StopWatch_title' />
                </term>
                <listitem>
                    <para>
                        This is a non graphical element that implements
                        a simple stopwatch.  The stop watch can be started,
                        stopped and reset. Furthermore,
                        alarms can be added which invoke application specific
                        commands when they are reached.
                    </para>
                    <para>
                        This is used to implement timed runs, and to maintain
                        the elapsed run time, but also can be used in your
                        own application whenever you need this functionality.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend="rdogui3_ui_ElapsedTimeDisplay"
                          endterm='rdogui3_ui_ElapsedTimeDisplay_title' />
                </term>
                <listitem>
                    <para>
                        Works with an embedded stopwatch object to provide
                        elapsed run display.  The stopwatch is fully exposed
                        allowing application specific code to be invoked
                        when a specific elapsed run time is reached (this is how
                        timed runs work).
                    </para>
                    <para>
                        A callout bundle is provided so that the timer
                        starts, stops and resets at the appropriate times.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_ui_TimedRunControls'
                          endterm='rdogui3_ui_TimedRunControls_title' />
                </term>
                <listitem>
                    <para>
                        Provides a GUI element that prompts for timed
                        run information.  This consists of elements that
                        allow users to specify the length of a timed run,
                        as well as a checkbox that allows users to enable/disabled
                        timed runs.
                    </para>
                    <para>
                        An associated callout bundle hooks the singleton
                        instance to the Run state machine and the
                        elapsed run time implementing the semantics of
                        timed runs.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_ui_OutputWindow'
                          endterm='rdogui3_ui_OutputWindow_title' />
                </term>
                <listitem>
                    <para>
                        Provides a scrollable text widget and methods to output
                        data into that widget.  The widget also supports
                        formatted log entries that are very configurable.
                        A singleton and associated callout bundle supports
                        logging basic state transitions.
                    </para>
                    <para>
                        An associated
                        <link linkend='rdogui3_outputwindowsettings'
                              endterm='rdogui3_outputwindowsettings_title' />
                        provides a dialog that allows several settings of the
                        output window singleton to be modified.  Note that this
                        is a bit specialized, while the output widow itself is not.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='rdogui3_StatusArea'
                          endterm='rdogui3_StatusArea_title' />
                </term>
                <listitem>
                    <para>
                        Provides a support for a vertically stacked set of
                        widgets and convenience functions for these to be
                        simple labels.  These are intended to provide
                        status information about components of the
                        system.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1 id='rdogui3_ui_readoutMenubar'>
            <title id='rdogui3_ui_readoutMenubar_title'>readoutMenuBar</title>
            <para>
                This object manages a menu.  Once created it can be
                turned into a menu bar for a toplevel by using it's path as
                the <option>-menu</option> option of that toplevel. The
                delegation of all unknown options and methods to the underying
                menu makes this indistinguishable from a menu created
                via <command>menu</command>.  Convenience methods have been
                added to make simple things simpler.
            </para>
            <refsect2>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                        <term><methodname>addMenu</methodname> <parameter>label-text</parameter></term>
                        <listitem>
                            <para>
                                Adds a new submenu (cascade objet and associated menu)
                                to the menu.  The menubutton that triggers the
                                submenu will be labeled <parameter>label-text</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>lookupMenu</methodname> <parameter>label-text</parameter></term>
                        <listitem>
                            <para>
                                Returns the menu widget associated with a sub-menu
                                created via <methodname>addMenu</methodname>.
                                <parameter>label-text</parameter> is the label
                                that was passed in to <methodname>addMenu</methodname>
                                when the submenu was created.
                            </para>
                            <para>
                                This relies on an internal data structure
                                that maintains the correspondence between
                                sub-menu labels and their menu widget paths.
                                Therefore this method can only be used to
                                look up submenus created with <methodname>addMenu</methodname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>listMenus</methodname></term>
                        <listitem>
                            <para>
                                Returns the list of menu labels created via
                                <methodname>addMenu</methodname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>addSeparator</methodname> <parameter>label-text</parameter></term>
                        <listitem>
                            <para>
                                Adds a separator to the end of the menu
                                whose label is <parameter>label-text</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>addCommand</methodname>
                            <parameter>menu-label command-label command</parameter></term>
                        <listitem>
                            <para>
                                Adds a command item to the menu identified by
                                <parameter>menu-label</parameter>.  The
                                command item's label will be <parameter>command-label</parameter>.
                                When clicked the <parameter>command</parameter> will
                                be run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>addMenuItem</methodname> <parameter>menu-label itemtype args</parameter></term>
                        <listitem>
                            <para>
                                Adds an arbitrary menu item to <parameter>menu-label</parameter>
                                The type of the item is <parameter>itemtype</parameter>.
                                The allowed values for <parameter>itemtype</parameter>
                                are the menu item types defined in
                                <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/menu.htm'>
                                    The man page for the <command>menu</command></ulink>
                                command.
                            </para>
                            <para>
                                The <parameter>args</parameter> parameter is pasted
                                on the back end of the <command>menu add</command> command
                                and normally consists of a list of option value pairs
                                (you can use the Tcl <command>list</command> command to build it).
                                The valid options for each menu type are also
                                described in the <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/menu.htm'>
                                    The man page for the <command>menu</command></ulink>
                                command.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </refsect2>
        </refsect1>
        <refsect1 id='rdogui3_ui_RunIdentification'>
            <title id='rdogui3_ui_RunIdentification_title'>RunIdentification</title>
            <para>
                This megawidget consists of two entries and associated labels.
                The entries provide mechanisms for users to supply a run number
                and a title string.  The run number entry is validated so that
                it must be a positive integer.
            </para>
            <refsect2>
                <title>OPTIONS</title>
                <para>
                    The megawidget supports the standard
                    <command>configure</command> and <command>cget</command>
                    methods.  These operate on the following set of options:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><option>-haverun</option> <replaceable>boolean-value</replaceable></term>
                        <listitem>
                            <para>
                                If false, the run number label and entry widgets
                                are unmanaged.  This can be done if no data
                                sources support run numbers.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-havetitle</option> <replaceable>boolean-value</replaceable></term>
                        <listitem>
                            <para>
                                If false, the title entry and label are unmanaged.
                                This can be done if no data sources support
                                run titles.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-state</option> <replaceable>normal | disabled | readonly</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the state that will be applied to all
                                entry widgets.  This is normally used to make
                                the entries read-only when the run is
                                <literal>Active</literal> or
                                <literal>Paused</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-title</option> <replaceable>title-string</replaceable></term>
                        <listitem>
                            <para>
                                Sets/gets the value of the title string.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-run</option> <replaceable>run-number</replaceable></term>
                        <listitem>
                            <para>
                                Sets/gets the value of the run number.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
        </refsect1>
        <refsect1 id='rdogui3_ui_RunControl'>
            <title id='rdogui3_ui_RunControl_title'>RunControl</title>
            <para>
                This is a megawidget that contains the controls needed
                to drive the run state machine through its state transitions.
                See
                <link linkend='rdogui3_runstatemachine'
                      endterm='rdogui3_runstatemachine_title' />
                for information about the run state machine.
            </para>
            <para>
                Associated with this widget is a singleton implementation
                and a callout bundle that hooks the widget into the
                run state machine singleton so that it can maintain a state
                that is consistent with the state of the run even in the face
                of state transitions it does not initiate.
            </para>
            <refsect2>
                <title>OPTIONS</title>
                <para>
                    The megawidget understands the standard
                    <command>configure</command> and
                    <command>cget</command> methods for configuring and
                    querying options.  The set of options understood by
                    the <classname>RunControl</classname> widget are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><option>-pauseable</option> <replaceable>boolean</replaceable></term>
                        <listitem>
                            <para>
                                Set this to boolean <literal>true</literal> if the system as a whole
                                can support paused runs.  <literal>False</literal> if not.  If
                                the value of this option is  <literal>false</literal>,
                                the <guibutton>Pause</guibutton> button removed
                                from the megawidget making it impossible for the
                                user to initiate a transition to
                                <literal>Paused</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-recording</option> <replaceable>boolean</replaceable></term>
                        <listitem>
                            <para>
                                If true the recording checkbutton is on indicating
                                the run is either now being recorded (if in
                                one of the active states), or the next run
                                will be recorded if the run is not in an active
                                state.
                            </para>
                            <para>
                                Active states are
                                <literal>Active</literal> and <literal>Paused</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
            <refsect2>
                <title>SINGLETON IMPLEMENTATION</title>
                <para>
                    In the context of the standard ReadoutShell/ReadoutGUI,
                    the run control megawidget is attached to the run state
                    machine so that it can always reflect the state of the
                    system.   This is done by providing a singleton implementation
                    of the widget and registering a callout bundle with the
                    state machine singleton that manipulates the widget's appearance:
                </para>
                <informalexample>
                    <programlisting>
set <replaceable>rctl</replaceable> ::RunControlSingleton::getInstance <replaceable>?path ?args??</replaceable>
                    </programlisting>
                </informalexample>
                <para>
                    The first time <function>::RunControlSingleton::getInstance</function>
                    is called it must be given a widget <parameter>path</parameter> and
                    optionally addtional configuration parmaeters <parameter>args</parameter>.
                    When initially called, the singleton is created and the callout bundle
                    registered.
                </para>
                <para>
                    All calls return the widget path of the singleton.  Thus,
                    if you know the singleton has already been created the
                    code fragment below will turn on the recording checkbutton:
                </para>
                <informalexample>
                    <programlisting>
[::RunControlSingleton::getInstance] configure -recording 1
                    </programlisting>
                </informalexample>
            </refsect2>
        </refsect1>
        <refsect1 id='rdogui3_ui_StopWatch'>
            <title id='rdogui3_ui_StopWatch_title'>StopWatch</title>
            <para>
                The <classname>StopWatch</classname> class provides a timekeeper
                that can stop, start, be reset and have alarms fire and specific
                elapsed times.  An alarm is a script that is associated
                with an elapsedtime via the <methodname>addAlarm</methodname>
                method.
            </para>
            <para>
                <classname>StopWatch</classname> is not a megawidget, but does
                require applications that normally run in an event loop as it
                uses the
                <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/after.htm'><command>after</command></ulink>
                command to schedule clock ticks.  Constructing an object creates
                an object command ensemble which provides access to the object
                methods.  The constructor returns the name of the command.
            </para>
            <para>
                You can either specify the command explicitly:
            </para>
            <informalexample>
                <programlisting>
StopWatch <replaceable>myStopwatch</replaceable>;     # Command named <literal>myStopwatch</literal>
myStopwatch <replaceable>some-method</replaceable>...
                </programlisting>
            </informalexample>
            <para>
                or you can ask the constructor to allocated a unique command
                name using the special object name %AUTO%:
            </para>
            <informalexample>
                <programlisting>
set <replaceable>myStopwatch</replaceable> [StopWatch %AUTO%];
...
$myStopWatch <replaceable>some-method</replaceable> ...
                </programlisting>
            </informalexample>
            <refsect2>
                <title>METHODS</title>
                <para>Stop watch objects have the following methods:</para>
                <variablelist>
                    <varlistentry>
                        <term><methodname>start</methodname></term>
                        <listitem>
                            <para>
                                Starts the stop watch.  When the event loop is
                                active, every .25 seconds, a tick will be declared.
                                The elapsed time is maintained in milliseconds.
                                via that counter.  If the application does not
                                often enter the event loop, clearly the stopwatch
                                will run slow.
                            </para>
                            <para>
                                Note that <methodname>start</methodname> does not
                                clear the timer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>stop</methodname></term>
                        <listitem>
                            <para>
                                Stops the stopwatch.  If the stopwatch is already
                                halted, an error is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>reset</methodname></term>
                        <listitem>
                            <para>
                                Sets the elapsed time to 0 milliseconds.
                                It is legal to do this while the stopwatch is
                                running.  Note that this does not remove alarm
                                scripts.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>addAlarm</methodname> <parameter>when script</parameter></term>
                        <listitem>
                            <para>
                                Schedules a <parameter>script</parameter> to be run when the elapsed time
                                is  <parameter>when</parameter> seconds.
                                Note that <parameter>when</parameter>  must be a positive integer.
                                If the elapsed time in integer seconds is already
                                past <parameter>when</parameter>, the script won't run.
                            </para>
                            
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>removeAlarm</methodname> <parameter>when script</parameter></term>
                        <listitem>
                            <para>
                                Removes the matching script from the set of scheduled scripts.
                                It is an error to remove a script that has not been
                                registered.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>isRuning</methodname></term>
                        <listitem>
                            <para>
                                Returns true if the stopwatch is running.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>elapsedTime</methodname></term>
                        <listitem>
                            <para>
                                Returns the elapsed time in milliseconds.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
        </refsect1>
        <refsect1 id="rdogui3_ui_ElapsedTimeDisplay">
            <title id='rdogui3_ui_ElapsedTimeDisplay_title'>ElapsedTimeDisplay</title>
            <para>
                Makes use of a
                <link linkend='rdogui3_ui_StopWatch'
                      endterm='rdogui3_ui_StopWatch_title' /> to provide
                a visual elapsed time megawidget.  This is normally used by
                the ReadoutGUI to provide a visual indication of the elapsed active
                time within a data taking run.  The stopwatch methods are
                exposed so that given one  of these widgets anything that can
                be done to a stopwatch can be done to it.
            </para>
            <para>
                Within the context of the ReadoutGUI, a singleton object is
                available which hooks a callout bundle to the state machine
                singleton to ensure that the timer starts, stops and
                resets at the appropriate time.
            </para>
            <para>
                Application code can get access to this singleton by
            </para>
            <informalexample>
                <programlisting>
set <replaceable>elapsedTime</replaceable> [::ElapsedTime::getInstance]
                </programlisting>
            </informalexample>
            <para>
                This is typically done when application code wants to perform
                an action at a specific elapsed run time (alamr).  For example,
                timed runs are implemented by setting an alarm for the desired
                length of the run.  The alarm proc simply forces a state transition
                to <literal>Halted</literal>.
            </para>
        </refsect1>
        <refsect1 id='rdogui3_ui_TimedRunControls'>
            <title id='rdogui3_ui_TimedRunControls_title'>TimedRunControls</title>
            <para>
                <classname>TimedRunControls</classname> is a megawidget that
                allows user to specify timed run durations and to enable/disable
                timed runs.  A singleton is implemented which hooks itself into
                both the State machine singleton (via a callback bundle)
                and the Elapsed time singelton (via alarms) when a timed
                run is begin.
            </para>
            <refsect2>
                <title>OPTIONS</title>
                <para>
                    The <classname>TimedRunControls</classname> megawidget
                    provides the standard <methodname>configure</methodname>
                    and <methodname>cget</methodname> methods that
                    operate on the following options:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><option>-state</option> <replaceable>disabled | normal | readonly</replaceable></term>
                        <listitem>
                            <para>
                                Controls the appearance and ability of the user to
                                interact with the controls.   <literal>normal</literal>
                                provides a 'normal' ui appearance and allows
                                users to interact with the widget, changing values.
                                <literal>readonly</literal> provides a normal appearance
                                but the user cannot change the values of the widget.
                                <literal>disabled</literal> ghosts the controls
                                and prevents user interaction.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-timed</option> <replaceable>boolean</replaceable></term>
                        <listitem>
                            <para>
                                If <literal>true</literal> the timed run checkbox
                                is checked if <literal>false</literal> it is not
                                checked.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-days</option> <replaceable>integer</replaceable></term>
                        <term><option>-hours</option> <replaceable>integer [0-23]</replaceable></term>
                        <term><option>-minutes</option> <replaceable>integer [0-59] </replaceable></term>
                        <term><option>-seconds</option> <replaceable>integer [0-52]</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the desired active duration of the
                                run when a timed run is performed.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
            <refsect2>
                <title>SINGLETON IMPLEMENTATION</title>
                <para>
                    The ReadoutGUI/ReadoutShell manages access to the
                    timed run instance it uses via the singleton pattern.
                    If your extensions to ReadoutShell need access
                    to the duration they can access the singleton
                    via <function>::TimedRun::getInstance</function>.
                    
                </para>
                <para>
                    The code fragment below turns on timed runs and sets the
                    duration to 2hours:
                </para>
                <informalexample>
                    <programlisting>
[::TimedRun::getInstance] configure -timed true \
    -days 0 -hours 2 -minutes 0 -seconds 0
                    </programlisting>
                </informalexample>
            </refsect2>
        </refsect1>
        <refsect1 id='rdogui3_ui_OutputWindow'>
            <title id='rdogui3_ui_OutputWindow_title'>OutputWindow</title>
            <para>
                The <classname>OutputWindow</classname> megawidget is a megawidget
                that is based on a Tk
                <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/text.htm'><command>text</command></ulink>
                widget coupled to vertical and horizontal scroll bars.  As
                the name implies, while the <command>text</command> widget
                can be used for input and output, the <classname>OutputWindow</classname>
                is intended only for output.  
            </para>
            <para>
                The ReadoutGUI/ReadoutShell uses an <classname>OutputWindow</classname>
                to report output from data sources as well as to inform the user
                of various events (e.g state transitions).  The <command>text</command>
                widget is a very complex entity.  The <classname>OutputWindow</classname>
                has a much simpler programmatic interface.
            </para>
            <para>
                Before providing the reference information, it is worth pointing
                out that the <classname>OutputWindow</classname> as support for
                log like  messages.  A log message is a message that has a severity.
                Log messages are automatically output with timestamps.  It is
                possible to instruct the <classname>OutputWindow</classname>
                to render differnet severities using different renditions.
                It is also possible to suppress the display of some message
                severities.  The log capabilitie is used extensively by the
                ReadoutGUI/ReadoutShell.  It is also possible to make the
                <classname>OutputWindow</classname> record all output
                to a log file for later review and analysis.
            </para>
            <para>
                The <classname>OutputWindow</classname> megawidget has
                a singleton associated with the instance that is used by the
                ReadoutGUI.  There is also a state machine singleton
                callout bundle that is used to log state transition
                messages.
            </para>
            <refsect2>
                <title>OPTIONS</title>
                <para>
                    <classname>OutputWindow</classname> instances support
                    the usual <methodname>configure</methodname> and
                    <methodname>cget</methodname> operations to interact with
                    configuration options.   The configuration options supported
                    are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><option>-foreground</option>   <replaceable>color-spec</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the default text color.  The <parameter>color-spec</parameter>
                                can be  a color name recognized by Tk or it can
                                be an #rrggbb color value.  This option is
                                actually delegated directly to the underlying
                                <command>text</command> widget without
                                interpretation.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>background</option> <replaceable>color-spec</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the background color of the
                                <classname>OutputText</classname> <command>text</command>
                                widget.  This is passed without interpretation to
                                the <command>text</command> widget.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-width</option> <replaceable>characters-wide</replaceable></term>
                        <term><option>-height</option> <replaceable>lines-tall</replaceable></term>
                        <listitem>
                            <para>
                                Specifies the width and height of the
                                <command>text</command> widget in characters.
                                These options are passed without interpretation
                                to the <command>text</command> widget.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-history</option> <replaceable>lines</replaceable></term>
                        <listitem>
                            <para>
                                The number of lines of historical data that are
                                kept in the scrolling buffer.  If the number
                                of output lines exceeds <replaceable>lines</replaceable>,
                                the oldest lines are removed from the history
                                until the number of lines remaining is at most
                                <replaceable>lines</replaceable>.
                            </para>
                            <para>
                                The default value for this is <literal>1000</literal>.
                                Note that log files do not have a line limit other
                                than the amount of disk space available.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-logclasses</option> <replaceable>list-of-severities</replaceable></term>
                        <listitem>
                            <para>
                                Determines the set of legal logging classes
                                (severities) that are accepted by the
                                log message (see METHODS below).  This, in
                                addition to the value of <option>-showclass</option>
                                (see below) determine how log messages are handled
                                by the output widget.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><option>-monitorcmd</option> <replaceable>script</replaceable></term>
                        <listitem>
                            <para>
                                Provides a script that is invoked whenever output is added to
                                the window.  The ouptut is appended quoted into
                                a single word at the end of the <replaceable>script</replaceable>.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                    <varlistentry>
                        <term><option>-showlog</option> <replaceable>dict-of-option-lists</replaceable></term>
                        <listitem>
                            <para>
                                Determines for each log class value in the
                                <option>-logclasses</option> option what is
                                done with messages submitted with that log class.
                                Note that changes to this value affect the display
                                of old log messages with the exception of suppressed
                                classes which will only display new entries.
                            </para>
                            <para>
                                The form of the value for this option is a dict
                                with keys that are log classes defined
                                in the <option>-logclasses</option> option value.
                                The values are lists of tag options as defined
                                <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/text.htm#M26'>
                                    TAGS section of the Tcl/Tk text widget manpage </ulink>.
                                These options are applied to log entries with these
                                classes.
                            </para>
                            <para>
                                If a log class is omitted fromthe dict it will
                                not be displayed.  One use for this is to provide
                                a <literal>debug</literal> log class for debugging
                                information which can be suppressed by omitting
                                it from the <option>-showlog</option> dict.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                    
            </refsect2>
            <refsect2>
                <title>METHODS</title>
                <para>
                    This section describes the public methods for the
                    <classname>OutputWindow</classname> widget.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodname>puts</methodname> <option>?-nonewline?</option> <parameter>message</parameter></term>
                        <listitem>
                            <para>
                                Outputs <parameter>message</parameter> to the
                                <classname>OutputWindow</classname> displaying it
                                using the current values of
                                the <option>-foreground</option> and
                                <option>-background</option> options to determine
                                the text's rendition.
                            </para>
                            <para>
                                If the optional <option>-nonewline</option> is
                                provided, the text is not output with
                                a trailing newline.  This can be used to
                                build up a one-line message in several
                                <methodname>puts</methodname> calls.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>log</methodname> <parameter>class message</parameter></term>
                        <listitem>
                            <para>
                                Creates and outputs a log <parameter>message</parameter>.
                                <parameter>class</parameter> determines
                                the rendition of the message via
                                the values of the <option>-showlog</option>
                                option.  It is an error for <parameter>class</parameter>
                                to be a value not in the <option>logclasses</option>
                                option value.
                            </para>
                            <para>
                                The <parameter>messge</parameter> is output
                                preceded by a timestamp and class name.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>clear</methodname></term>
                        <listitem>
                            <para>
                                Clears the contents of the window.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>get</methodname></term>
                        <listitem>
                            <para>
                                Returns the textual contents of the window.
                                Note that no hints are provided to enable the
                                caller to determine the rendition of the text.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>open</methodname> <parameter>filename</parameter></term>
                        <listitem>
                            <para>
                                Opens the file <parameter>filename</parameter> as
                                an output log file.  From this point on all
                                output (<methodname>log</methodname> and
                                <methodname>puts</methodname>)
                                to the <classname>OutputWindow</classname> will be
                                recorded in that file.
                            </para>
                            <para>
                                The file is opened for append.  If there was
                                a previously open log file it is closed first.
                                See <methodname>close</methodname> below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>close</methodname></term>
                        <listitem>
                            <para>
                                Closes any open log file.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>                    
            </refsect2>
            <refsect2>
                <title>SINGLETON IMPLEMENTATION</title>
                <para>
                    The application level singleton is implemented via the
                    <function>::Output::getInstance</function> method.
                    This proc is declared as follows:
                </para>
                <informalexample>
                    <programlisting>
proc Output::getInstance { {win {}} args} {
...
}
                    </programlisting>
                </informalexample>
                <para>
                    The <parameter>win</parameter> parameter is required only
                    on the first call and is the window path to be used for
                    the object.  Similarly any trailing parameters to the
                    first invocation contain configuration option/value pairs.
                    Creation register the run state machine callout bundle that
                    maintains the foreground/background appearance of the window
                    as runs start and stop.
                </para>
                <para>
                    The proc returns the widget path.
                </para>
            </refsect2>
        </refsect1>
        
      </refentry>
      <refentry id="rdogui3_outputwindowsettings">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_outputwindowsettings_title'>OutputWindowSettings</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>OutputWindowSettings</refname>
           <refpurpose>Prompter for <classname>OutputWindow</classname> settings.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
OutputWindowSettings <replaceable>widget-path ?options...?</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This megawidget provides a prompter for options that can be applied to
            a
            <link linkend='rdogui3_ui_OutputWindow' endterm='rdogui3_ui_OutputWindow_title' />
            widget.  A convenience proc is also provided that wraps this widget
            in a dialog and, when the user accepts the state of the dialog,
            changes the configuration options of the
            <classname>OutputWindow</classname> singleton appropriately.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <para>
            The widget accepts the standard <methodname>configure</methodname>
            and <methodname>cget</methodname> methods.  These operate on the
            following set of options:
           </para>
            <variablelist>
             <varlistentry>
                 <term><option>-rows</option> <replaceable>row-count</replaceable></term>
                 <listitem>
                     <para>
                         Sets/gets the number of rows requested from the
                         prompter (this is controlled by a spinbox widget).
                     </para>
                 </listitem>
             </varlistentry>
             <varlistentry>
                 <term><option>-columns</option> <replaceable>column-count</replaceable></term>
                 <listitem>
                     <para>
                         Sets/gets the number of columns requested from the
                         prompter.   This is controlled by a spinbox widget.
                     </para>
                 </listitem>
             </varlistentry>
             <varlistentry>
                 <term><option>-history</option> <replaceable>history-lines</replaceable></term>
                 <listitem>
                     <para>
                         Sets/gets the number of lines of history information
                         requested from the prompter.  This is controlled
                         by a spinbox widget.
                     </para>
                 </listitem>
             </varlistentry>
             <varlistentry>
                 <term><option>-debug</option> <replaceable>1 | 0</replaceable></term>
                 <listitem>
                     <para>
                         Gets/sets the state of the checkbutton widget that is
                         labeled <literal>Show debugging Output</literal>.
                     </para>
                 </listitem>
             </varlistentry>
             
            </variablelist>
        </refsect1>
        <refsect1>
            <title>CONVENIENCE PROC</title>
            <para>
                <function>::Output::promptSettings</function> displays a
                <classname>OutputWindowSettings</classname> widget wrapped in a
                <link linkend='rdogui3_dialogwrapper' endterm='rdogui3_dialogwrapper_title' />.
                If the user clicks <guibutton>Ok</guibutton>, the proc fetches
                the singleton <classname>OutputWindow</classname> and sets its
                options accordingly. 
            </para>
            <para>
                The <literal>Show debugging Output</literal> checkbox is handled
                by making or removing a debug entry in the <classname>OutputWindow</classname>'s
                <option>-showlog</option> dict for the <literal>debug</literal> class.
                The contents of this entry, when present, are empty resulting
                in default text rendition.
            </para>
        </refsect1>
      </refentry>
      
      <refentry id="rdogui3_StatusArea">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='rdogui3_StatusArea_title'>StatusArea</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>StatusArea</refname>
           <refpurpose>Status area megawidget</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
StatusArea <replaceable>window-path</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            <classname>StatusArea</classname> is a megawidget that is a container
            for status items.  Status items, sometimes called
            <firstterm>status bars</firstterm> are arranged as a set of vertically
            stacked widgets inside the <classname>StatusArea</classname>.
           </para>
           <para>
            In most but not all cases, status items will be simple label
            widgets intended to provide textual information about the status
            of some facet of the program.  The <classname>StatusArea</classname>
            provides methods that simplify the creation and management of these
            labels.
           </para>
           <para>
            A singleton implementation is also available.
           </para>
        </refsect1>
        <refsect1>
           <title>
              METHODS
           </title>
           <variablelist>
            <varlistentry>
                <term><methodname>addWidget</methodname> <parameter>args</parameter></term>
                <listitem>
                    <para>
                        This adds an arbitrary widget to the status area.
                        The <parameter>args</parameter> should be a widget creation
                        command without the window path (This gets generated by
                        <methodname>addWigdget</methodname>).  For example:
                    </para>
                    <informalexample>
                        <programlisting>
$statusBar addWidget checkbutton -onvalue 1 -offvalue 0 -variable myvar -text {A checkbutton}
                        </programlisting>
                    </informalexample>
                    <para>
                        Adds a checkbutton control to the status bar.  To add
                        frames containing multiple widgets to the status bar,
                        create a megawidget (with snit or itk for example) and
                        pass the megawidget constructor name to the
                        <methodname>addWidget</methodname> method.
                    </para>
                    <para>
                        The widget will be added to the bottom of the status
                        area.  The actual widget path is returned by
                        this method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>addMessage</methodname> <parameter>?initial-text?</parameter></term>
                <listitem>
                    <para>
                        Adds a message to the bottom of the status window.
                        Messages are implemented as label widgets.
                        If provided the optional
                        <parameter>initial-text</parameter> argument is the
                        text initially displayed by the widget.
                    </para>
                    <para>
                        The method returns a <firstterm>message handle</firstterm>.
                        The message handle is <emphasis>not</emphasis> the widget
                        path of the label widget.  It can be used in other
                        message related methods (e.g. <methodname>addMessage</methodname>)
                        however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>setMessage</methodname> <replaceable>handle text args</replaceable></term>
                <listitem>
                    <para>
                        Changes the message text displayed by the message
                        referred to by <parameter>handle</parameter> to
                        <parameter>text</parameter>.  If additional parameters
                        are supplied the must be option/value pairs that are
                        valid for configuring a
                        <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/ttk_label.htm'>
                            ttk::label
                        </ulink>
                        widget.
                    </para>
                    <para>
                        The example below creates a message widget and
                        outputs some text in it colored green:
                    </para>
                    <informalexample>
                        <programlisting>
set msg [$status addMessage]
$status setMessage $msg {Some text} -foreground green
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>statusItems</methodname></term>
                <listitem>
                    <para>
                        Returns a list of the widget paths that
                        of the widgets in the status area.  This includes
                        the message widgets as well as the other widgets you
                        may have added with <methodname>addMessage</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>messageHandles</methodname></term>
                <listitem>
                    <para>
                        Slightly mis-named method returns the widget paths
                        of the <command>ttk::label</command> widgets
                        created by the <methodname>addMessage</methodname>
                        command.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>SINGLETON IMPLEMENTATION</title>
            <para>
                <function>::StatusBar::getInstance</function> returns the
                widget path for the singleton status area widget.
                The first time it is called, the otherwise optional
                widget path for the status area must be passed in, and
                the actual <classname>StatusArea</classname> widget
                will be created.
            </para>
        </refsect1>
      </refentry>

<!-- /manpage -->
<!-- manpage 3provider -->
      <refentry id="provider3_intro">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_intro_title'>Introduction</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>Introduction</refname>
           <refpurpose>Data source providers</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package provide <replaceable>providerName</replaceable>_Provider <replaceable>version-string</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
namespace eval <replaceable>providerName</replaceable> {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::parameters {} {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::start params {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::check sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::stop sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::begin {sourceId runNumber title} {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::pause sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::resume sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::end sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::init sourceId {...}
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
proc ::<replaceable>providerName</replaceable>::capabilities {} {...}
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Data source providers are Tcl loadable packages that provide
            code that understands how to maniuplate a specific type of
            data source.  NSCLDAQ comes with two pre-built data source providers;
            <link linkend="provider3_sshpipe" endterm='provider3_sshpipe_title' />
            which understands how to run command line readout programs on the end
            of a SSH pipeline to a (possibily) remote system, and
            <link linkend='provider3_s800' endterm='provider3_s800_title' /> which
            knows how to connect to and send appropriate commands to the
            S800 data acquisition readout program.
           </para>
           <para>
            If a Source provider supplies the code for a type of data source,
            a specific data source is identified by a <parameter>sourceId</parameter>
            this is assigned by the code that creates data sources.  In general
            while it's a good idea to define data source ids that are unique across
            all data source providers (that's what the ReadoutGUI data source
            manager does), it is only required that source ids be unique within
            a specific provider.
           </para>
           <para>
            This section of man pages provides:
            <itemizedlist>
                <listitem><para>Reference material on the API a data source provider must export.</para></listitem>
                <listitem><para>Reference information that describes the SSHPipe provider.</para></listitem>
                <listitem><para>Reference information that describes the S800 provider.</para></listitem>
            </itemizedlist>
           </para>
        </refsect1>
        <refsect1>
           <title>
              CREATING A DATA SOURCE PROVIDER
           </title>
           <para>
                Data source providers are Tcl packages with names that end in
                <literal>_Provider</literal> for example, the SSHPipe provider
                is a package named <literal>SSHPipe_Provider</literal>. The
                section of the package name before the trailing <literal>_Provider</literal>
                is called the <emphasis>provider name</emphasis>.
           </para>
           <para>
                Data source providers are expected to define a specific set
                of named procedures in a namespace that matches their
                provider name.   Thus the SSHPipe provider defines procs in the
                <literal>::SSHPipe::</literal> namespace.  These procs need not
                be exported from the namespace.
           </para>
           <para>
            The code fragment below shows a simplified version of how the
            package and namespace are defined and a definition for the
            <literal>parameters</literal> proc is made within that namespace
           </para>
           <informalexample>
            <programlisting>
package provide MyDataSource_Provider 1.0 

namespace eval ::MyDataSource {}

proc ::MyDataSource::parameters {} {
  # Actual implementation omitted
  #  ...
}
            </programlisting>
           </informalexample>
           <para>
            While only the API functions described in this manpage need to be
            in the provider's namespace, it is good programming practice to
            put any utility functions either in that namespace or in some
            other namespace that is specific to the data source provider
            (e.g.  <replaceable>providerName</replaceable>_private).
            This minimizes the chances that your definitions will re-define
            some previously defined proc in the global namespace.
           </para>
           <para>
            For information on Tcl namespaces, see the documentation for the
            <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/namespace.htm'>
                Tcl namespace command</ulink>.
           </para>
        </refsect1>
        <refsect1>
            <title>API FUNCTIONS</title>
            <para>
                This section provides a brief overview of each API function
                a data provider must implement along with a pointer to the
                detailed documentation for that function.  In the documentation
                below, the namespace for the API function is omitted for the sake
                of brevity.
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>parameters</command></term>
                    <listitem>
                        <para>
                            Each data source a data source provider starts may
                            require some parameterization.  For example, the
                            S800 provider needs to know the host on which the
                            S800 readout program is running along with the
                            TCP/IP port on which that program is listening for
                            command connections.
                            <link linkend='provider3_parameters'
                                  endterm='provider3_parameters_title' />
                            returns information about the parameterization of
                            the provider.  The information returned is sufficient
                            for calling code to produce a very simple prompter
                            for those parameters.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>start</command> <replaceable>params</replaceable></term>
                    <listitem>
                        <para>
                            The <command>start</command> command of a data source
                            provider start a data source given a specific
                            parameterization.
                            The
                            <link linkend='provider3_start'
                                  endterm='provider3_start_title' />
                            describes this command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>check</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            Whatever code is managing a set of data providers
                            needs to know when one of the active sources
                            has exited.
                            <link linkend='provider3_check'
                                  endterm='provider3_check_title' />
                            returns a true value if a source is still running and
                            false if not.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>stop</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            <link linkend='provider3_stop'
                                  endterm='provider3_stop_title' />
                            Stops the specified data source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>begin</command> <replaceable>sourceId runNumber title</replaceable></term>
                    <listitem>
                        <para>
                            Starts data taking for a new run.
                            See <link linkend='provider3_begin'
                                endterm='provider3_begin_title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>pause</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            If your data source implements pause/resume functionality
                            you must define this command to pause the run.
                            See the 
                            <link linkend='provider3_pause'
                                  endterm='provider3_pause_title' />
                            reference material for more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>resume</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            If your data source implements pause/resume functionality
                            you must implement
                            <link linkend='provider3_resume'
                                  endterm='provider3_resume_title' />
                            to resume paused runs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>end</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            The
                            <link linkend='provider3_end'
                                  endterm='provider3_end_title' />
                            ends a run in a data source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>init</command> <replaceable>sourceId</replaceable></term>
                    <listitem>
                        <para>
                            The
                            <link linkend='provider3_init'
                                  endterm='provider3_init_title' />
                            causes an initialize procedure in the data source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>capbilities</command></term>
                    <listitem>
                        <para>
                            Describes the data
                            <link linkend='provider3_capabilities'
                                  endterm='provider3_capabilities_title' />
                            source capabilities.  
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
      </refentry>

      <refentry id="provider3_parameters">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_parameters_title'>parameters</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>parameters</refname>
           <refpurpose>Describe data source parameterization</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::parameters {} {
  ...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Each data source managed by a data source provider is specified
            by means of some set of data source specific parameters.
            The <command>parameters</command> proc of each data source
            returns a Tcl
            <ulink url='dict'>dict</ulink> that describes the set of parameters
            expected.
           </para>
           <para>
            The keys of the dict are short parameter names (used by the
            data source to look up the parameter in the dict).  The value
            of each dict element is is a human-readable description of the
            parameter.  Normally a graphical user interface would use this
            string to prompt the user for a value.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_start">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_start_title'>start</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>start</refname>
           <refpurpose>Start a data source</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
::<replaceable>providerName</replaceable>::start <replaceable>param-dict</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Starts a data source for the provider.   The
            <parameter>param-dict</parameter> parameter is a Tcl
            <ulink url='dict'>dict</ulink>.  The keys for the dict are the
            same as the keys for the dict returned from
            <link linkend='provider3_parameters'
                  endterm='provider3_parameters_title' />.
            Key values are the parameter values.  An additional key
            <literal>sourceid</literal> is always added to this dict and it
            represents a unique identifier that will be used
            to refer to this data source from now on.
           </para>
        </refsect1>
 
      </refentry>
      <refentry id="provider3_check">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_check_title'>check</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>check</refname>
           <refpurpose>Check Data Source Liveness</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::check <replaceable>sourceId</replaceable> {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <command>check</command> proc can be called once a data source
            has been started.  The <parameter>sourceId</parameter> parameter is
            the value of the <literal>sourceid</literal> dict element passed to the
            <link linkend='provider3_start' endterm='provider3_start_title' />
            command.
           </para>
           <para>
            This command should return a boolean true value if the data source
            identified by <parameter>sourceId</parameter> is still running or
            a boolean false value if the data source is no longer running.
            Boolean values are those accepted by the C function
            <ulink url='http://www.tcl.tk/man/tcl8.5/TclLib/GetInt.htm'>
                Tcl_GetBoolean</ulink>.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_stop">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_stop_title'>stop</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>stop</refname>
           <refpurpose>Stop data sources</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
proc ::<replaceable>providername</replaceable>::stop <replaceable>sourceId</replaceable> {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Called to stop the data source identified by
            <parameter>sourceId</parameter>.
            The <parameter>sourceId</parameter> parameter is
            the value of the <literal>sourceid</literal> dict element passed to the
            <link linkend='provider3_start' endterm='provider3_start_title' />
            command.
           </para>
           <para>r
            Once this command is executed, the data source provider should invalidate
            the <parameter>sourceId</parameter>, and take whatever steps are needed
            to release any resources the data source has used.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_begin">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_begin_title'>begin</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>begin</refname>
           <refpurpose>Start data taking in a data source</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
proc ::<replaceable>providerName</replaceable>::begin {sourceId runNumber title} {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Starts data taking at the beginning of a run for the
            source identified by <parameter>sourceId</parameter>.  The
            <parameter>runNumber</parameter> and <parameter>title</parameter>
            parameters are the run number and title of the run.  They
            can be ignored if the data source has specified that it does not
            have the capability of associatig run numbers and titles with
            data taking runs.
           </para>
           <para>
            The <parameter>sourceId</parameter> parameter is, as usual,
            the value of the <literal>sourceid</literal> dict element passed to the
            <link linkend='provider3_start' endterm='provider3_start_title' />
            command.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3_pause">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_pause_title'>pause</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>pause</refname>
           <refpurpose>Pause a data taking run (optional)</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::pause <replaceable>sourceId</replaceable> {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Pauses a data taking run in the data source identified by
            <parameter>sourceId</parameter>.
            The <parameter>sourceId</parameter> parameter is
            the value of the <literal>sourceid</literal> dict element passed to the
            <link linkend='provider3_start' endterm='provider3_start_title' />
            command.
           </para>
           <para>
            This proc is optional.  Specifically, if the data source provider's
            <link linkend='provider3_capabilities'
                  endterm='provider3_capabilities_title' /> specifies  the
            provider is unable to pause runs, the provider need not implement
            either this proc or the
            <link linkend='provider3_resume' endterm='provider3_resume_title' />
            proc.  Similarly, the data source manager should not invoke the
            <command>pause</command> or <command>resume</command> commands on
            data sources that cannot support it.
           </para>
           <para>
            The ReadoutGUI data source manager and GUI will prevent an invocation
            of the <command>pause</command> and <command>resume</command>
            operations on any data of the data sources
            unless all data sources specified able to perform these
            operations.
            </para>
        </refsect1>

      </refentry>
     
      <refentry id="provider3_resume">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
          <refentrytitle id='provider3_resume_title'>resume</refentrytitle>
          <manvolnum>3provider</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
          <refname>resume</refname>
          <refpurpose>Resume a Paused Run</refpurpose>
        </refnamediv>

        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
proc ::<replaceable>providerName</replaceable>::resume <replaceable>sourceId</replaceable> {
...
}
          </command>
        </cmdsynopsis>

      </refsynopsisdiv>
      <refsect1>
        <title>DESCRIPTION</title>
        <para>
          Resumes a run that is paused in the data source identified by
          <parameter>sourceId</parameter>.
          This proc is optional.  Specifically, if the data source provider's
          <link linkend='provider3_capabilities'
            endterm='provider3_capabilities_title' /> specifies  the
          provider is unable to pause runs, the provider need not implement
          either this proc or the
          <link linkend='provider3_pause' endterm='provider3_pause_title' />
          proc.  Similarly, the data source manager should not invoke the
          <command>pause</command> or <command>resume</command> commands on
          data sources that cannot support it.
        </para>
        <para>
          The ReadoutGUI data source manager and GUI will prevent an invocation
          of the <command>pause</command> and <command>resume</command>
          operations on any data of the data sources
          unless all data sources specified able to perform these
          operations.
        </para>
      </refsect1>
    </refentry>

        <refentry id="provider3_end">
            <refentryinfo>
                <author>
                        <personname>
                                <firstname>Ron</firstname>
                                <surname>Fox</surname>
                        </personname>
                        <personblurb><para></para></personblurb>
                </author>
                <productname>NSCLDAQ</productname>
                <productnumber></productnumber>
            </refentryinfo>
          <refmeta>
            <refentrytitle id='provider3_end_title'>end</refentrytitle>
            <manvolnum>3provider</manvolnum>
            <refmiscinfo class='empty'></refmiscinfo>
          </refmeta>
          <refnamediv>
            <refname>end</refname>
            <refpurpose>End a Data Taking Run</refpurpose>
          </refnamediv>

          <refsynopsisdiv>
            <cmdsynopsis>
              <command>
                proc ::<replaceable>providerName</replaceable>::end <replaceable>sourceId</replaceable> {
                ...
                }
              </command>
            </cmdsynopsis>

          </refsynopsisdiv>
          <refsect1>
            <title>DESCRIPTION</title>
            <para>
              Ends a data taking run in the data source <parameter>sourceId</parameter>.
              The <parameter>sourceId</parameter> is the value of the
              <literal>sourceid</literal> key in the dict passed to the
              provider's
              <link linkend='provider3_start' endterm='provider3_start_title' />
              proc was called to start the data source.
            </para>
          </refsect1>
        </refentry>
    
      <refentry id="provider3_init">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_init_title'>init</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>init</refname>
           <refpurpose>On-demand initialize procedure</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::init <replaceable>sourceId</replaceable> {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
             Initiates an on-demand initialization procedure for data source <parameter>sourceId</parameter>.
             The <parameter>sourceId</parameter> is the value of the
             <literal>sourceid</literal> key in the dict passed to the
             provider's
             <link linkend='provider3_start' endterm='provider3_start_title' />
             proc was called to start the data source.
             The initialization is only possible when in the Halted state.
           </para>
         </refsect1>
       </refentry>

      <refentry id="provider3_capabilities">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_capabilities_title'>capabilities</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>capabilities</refname>
           <refpurpose>Get Provider Capabilities Dict</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
proc ::<replaceable>providerName</replaceable>::capabilities {} {
...
}
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Not all data source providers are created equal.  This command
            is expected to return a dict that describes the data source's
            capabilities.  The keys to this dict are capability names.
            The values generally are booleans that indicate whether that
            capability is supported.
           </para>
        </refsect1>
        <refsect1>
            <title>CAPABILITIES</title>
            <para>
                At present the following capabilities are defined:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>canPause</literal></term>
                    <listitem>
                        <para>
                            If true the provider implements the
                            <command>pause</command> and
                            <command>resume</command> procs and they
                            do what they are advertised to do.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>runsHaveTitles</literal></term>
                    <listitem>
                        <para>
                            If true the provider will honor the
                            <parameter>title</parameter> parameter passed to the
                            <link linkend='provider3_begin'
                                  endterm='provider3_begin_title' />
                            command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>runsHaveNumbers</literal></term>
                    <listitem>
                        <para>
                            If true the provider will honer the
                            <parameter>runNumber</parameter> parameter
                            passed to the
                            <link linkend='provider3_begin'
                                  endterm='provider3_begin_title' />
                            command.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
      </refentry>
      
      <refentry id="provider3_sshpipe">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_sshpipe_title'>SSHPipe</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>SSHPipe</refname>
           <refpurpose>SSHPipe data source provider.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require SSHPipe_Provider
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>SSHPipe_Provider</literal> implements a
            data source provider (see
            <link linkend='provider3_intro' endterm='provider3_intro_title' />)
            that controls command driven programs on the end of an SSH Pipe
            into a remote (or local) system.
           </para>
           <para>
            To use the ssh pipe provider:
           </para>
           <orderedlist>
            <listitem><para>NSCLDAQ-11.x must be installed on the target system
                in the same installation directory try as in the host system.
                </para></listitem>
            <listitem><para>The path to the remote program must be valid on the remote system.
                For the most part this works best when the local and remote systems
                share filesystems.
                </para></listitem>
            <listitem><para>Password-less logins have been set up between
                the local and remote systems.  A procedure for this can be
                found by googling <literal>ssh without password</literal>.
                One hit that is valid as of today is:
                <ulink url='http://www.thegeekstuff.com/2008/11/3-steps-to-perform-ssh-login-without-password-using-ssh-keygen-ssh-copy-id/'>
                       http://www.thegeekstuff.com/2008/11/3-steps-to-perform-ssh-login-without-password-using-ssh-keygen-ssh-copy-id/
                </ulink>
                </para></listitem>
           </orderedlist>
        </refsect1>
        <refsect1>
           <title>
              PARAMETERIZATION
           </title>
           <para>
            The parameters required for the <literal>SSHPipe</literal> data source
            provider are:
           </para>
           <variablelist>
            <varlistentry>
                <term><literal>host</literal></term>
                <listitem>
                    <para>
                        The host on which the readout runs.  The readout
                        host must resolve via DNS or alternatively
                        can be a dotted IP number.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>path</literal></term>
                <listitem>
                    <para>
                        The full path to the Readout program in the remote host.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>wdir</literal></term>
                <listitem>
                    <para>
                        The working directory in the remote host
                        desired for the readout program.  This defaults to the
                        remote home directory.  Often, if <replaceable>readoutPath</replaceable>
                        is the path to the readout program, what is desired is:
                        <programlisting>file dirname $readoutPath</programlisting>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>parameters</literal></term>
                <listitem>
                    <para>
                        Parameters that will be passed on the command line
                        to the Readout program when it is run.  For eample for
                        NSCL Readout programs,
                        <literal>--ring=</literal><replaceable>some-non-default-ring</replaceable>
                        is often used.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>READOUT PROGRAM REQUIREMENTS</title>
            <para>
                Readout programs are sent specific commands in specific ways.
                This places
                the following requirements on Readout program that will be controlled
                via SSHPipe:
            </para>
            <orderedlist>
                <listitem><para>
                    Readout programs must be command drive and expect comands
                    on their <literal>stdin</literal> file descriptor.
                    </para></listitem>
                <listitem><para>
                    Readout program output you want seen by the user must be
                    sent to either <literal>stdout</literal> or
                    <literal>stderr</literal>
                    </para></listitem>
                <listitem><para>An endfile on the <literal>stdin</literal> pipe
                    must exit the program.
                    </para></listitem>
                <listitem><para>The <command>exit</command> command must exit
                    the program.
                    </para></listitem>
                <listitem><para>The <command>set <replaceable>varname value</replaceable></command>
                    command must be defined for the variables <varname>title</varname>
                    and <varname>run</varname> and set the run number and title
                    accordingly.
                    </para></listitem>
                <listitem><para>The <command>begin</command> command must start
                    a new run.
                    </para></listitem>
                <listitem><para>The <command>end</command> command must end an
                    active run.
                    </para></listitem>
                <listitem><para>The <command>pause</command> command must pause
                    an active run.
                    </para></listitem>
                <listitem><para>The <command>resume</command> command must resume
                     paused run.
                     </para></listitem>
                     <listitem><para>The <command>init</command> command must cause
                         an on-demand initialization procedure, e.g. loading firmware.
                     </para></listitem>
            </orderedlist>
        </refsect1>
        <refsect1>
            <title>TRICKS FOR TICKY READOUTS</title>
            <para>
                If your Readout program meets most of the requirements in the
                section <literal>READOUT PROGRAM REQUIREMENTS</literal> above,
                you may still be able to use the SSHPipe provider by wrapping
                it appropriately.  For example:
            </para>
            <formalpara>
                <title>Readout cannot pause/resume</title>
                
                    <para>
                        Make a new provider that implements all of its API
                        entries by calling the <literal>::SSHPipe::</literal>
                        entry, however your capabilities <command>proc</command>
                        will force the value of the <literal>canPause</literal>
                        capability to false.
                    </para>
            </formalpara>
        </refsect1>
      </refentry>

      <refentry id="provider3_s800">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_s800_title'>s800</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>s800</refname>
           <refpurpose>s800 data source provider.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require s800
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This data source provider provides the command and control over the
            S800 data acquisition system Readout.  The S800 uses a Readout
            program that is an TCP/IP server.
           </para>
           <para>
            Note that the provider only manages the run control of the S800.
            The <filename>s800toring</filename> utility described below must
            be started as well from your <filename>ReadoutCallouts.tcl</filename>
            script. See <literal>S800TORING</literal> below.
           </para>
        </refsect1>
        <refsect1>
           <title>
              PARAMETERIZATION
           </title>
           <variablelist>
                <varlistentry>
                    <term><literal>host</literal></term>
                    <listitem>
                        <para>
                            The IP DNS name or dotted IP address of the
                            host that is running the S800 readout program.
                            Note that this software cannot star the readout program.
                            What it does on a <function>start</function> operation
                            is to connect to an already running readout program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>port</literal></term>
                    <listitem>
                        <para>
                            The port on which the S800 readout program
                            is listening for connections.
                        </para>
                    </listitem>
                </varlistentry>
                
                
           </variablelist>
        </refsect1>
        <refsect1>
            <title>S800TORING</title>
            <para>
                The S800 Readout program is not an NSCLDAQ readout program.
                It does not put data into ring buffers but instead supplies
                data via a TCP/IP connection.  Furthermore the data format
                is that of NSCLDAQ-8.x.
            </para>
            <para>
                The <literal>s800toring</literal>
                program connects to the S800 data transfer socket,
                translates events into ring items and puts those items into a
                ring buffer from which they can be fetched by other programs.
            </para>
            <para>
                In the sample startup below, we are assuming the existence
                of an environment variable, <literal>DAQROOT</literal>,
                that points to the top level directory of the NSCLDAQ-11
                installation.
            </para>
            <informalexample>
                <cmdsynopsis>
                    <command>
$DAQROOT/bin/s800toring <replaceable>host port ring</replaceable>
                    </command>
                </cmdsynopsis>
            </informalexample>
            <para>
                The <replaceable>host</replaceable> and
                <replaceable>port</replaceable> command line parameters
                are the host and port on which the s800 is listening for event
                service connections (this is not in general the same value
                as the s800 command port).  The <replaceable>ring</replaceable>
                parameter is the name of the ring buffer into which data
                should be placed. If the ring buffer does not yet exist,
                <literal>s800toring</literal>  will create it.
            </para>
        </refsect1>
      </refentry>
                
      <refentry id="provider3_delay">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Jeromy</firstname>
                            <surname>Tompkins</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='provider3_delay_title'>Delay</refentrytitle>
           <manvolnum>3provider</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>delay</refname>
           <refpurpose>Inserts a delay between data provider begins</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require Delay_Provider
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This data source provider does nothing more than wait for a specified
            amount of time when it is told to begin. It is intended to serve as
            an adjustable delay between the time the begin commands are sent to the
            neighboring data providers.
           </para>
        </refsect1>
        <refsect1>
           <title>
              PARAMETERIZATION
           </title>
           <variablelist>
                <varlistentry>
                    <term><literal>delay</literal></term>
                    <listitem>
                        <para>
                            The number of milliseconds to wait at begin.
                        </para>
                    </listitem>
                </varlistentry>
                
                
           </variablelist>
        </refsect1>
      </refentry>

<!-- /manpage -->
<!-- manpage 1daq -->

      <refentry id="manpage_readoutshell">
        <refentryinfo>
            <author>
                    <personname>
                            <firstname>Ron</firstname>
                            <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
            </author>
            <productname>NSCLDAQ</productname>
            <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle>ReadoutShell</refentrytitle>
           <manvolnum>1daq</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>ReadoutShell</refname>
           <refpurpose>Shell wrapper for readout programs.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
$DAQROOT/bin/ReadoutShell
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a graphical use interface wrapper around readout programs.
            This command takes no parameters or options.  It does maintain
            a memory of the most recent configuration for its internal components
            as well as providing a scheme for extensions to add to this configuration.
            See FILES for more information about the configuration.
           </para>
        </refsect1>
        <refsect1>
           <title>
              ENVIRONMENT
           </title>
            <variablelist>
                <varlistentry>
                    <term><literal>EVENTLOGGER</literal></term>
                    <listitem>
                        <para>
                            Overrides the default event logger program with
                            its value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_RING</literal></term>
                    <listitem>
                        <para>
                            Overrides the event logger ringbuffer URI.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_NSRCSFLAGS_SUPPORTED</literal></term>
                    <listitem>
                        <para>
                            If true then <option>--number-of-sources</option>
                            will be used with the eventlog program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_UNCONTROLLED_SOURCE_COUNT</literal></term>
                    <listitem>
                        <para>
                            If provided contains an additional source count for
                            use when computing the value of
                            <option>--number-of-sources</option>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EVENTLOGGER_USE_GUI_RUNNUM</literal></term>
                    <listitem>
                        <para>
                            If true the <option>--run</option> option will be
                            used to override run numbers in begin run records or,
                            alternatively provide run numbers where none are
                            avaialble.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            
             <variablelist>
                <varlistentry>
                    <term><literal>EVENTS</literal></term>
                    <listitem>
                        <para>
                            The value of this environment variable overrides
                            the Stage area default
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>EXPDIR</literal></term>
                    <listitem>
                        <para>
                            The value of this environment variable overrides
                            the Experiment metadata default value.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
             
             
        </refsect1>
        <refsect1>
            <title>FILES</title>
            <variablelist>
                <varlistentry>
                    <term><filename>~/stagearea</filename></term>
                    <listitem>
                        <para>
                            A symbolic link to the work area used by the ReadoutShell
                            to maintain its directory structure.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagearea/current</filename></term>
                    <listitem>
                        <para>
                            Directory containing the
                            event file currently being recorded.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagearea/complete</filename></term>
                    <listitem>
                        <para>
                            Directory containing symbolic links to all
                            event files that have been completely acquired.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagerea/experiment/run*</filename></term>
                    <listitem>
                        <para>
                            Directories containing event files and metadata
                            for all completely acquired runs.  The wild-carded
                            part of the directory string is the run number, e.g.
                            <filename>~/stagerea/experiment/run1234</filename>
                            contains the event file and metadata for run
                            number <literal>1234</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagearea/experiment/current</filename></term>
                    <listitem>
                        <para>
                            Directory containing the metadata for the current run.
                            The data in this directory will be copied into the
                            run directory at the end of the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>~/stagearea/.settings.tcl</filename></term>
                    <listitem>
                        <para>
                            File from which saved settings are restored
                            and into which saved settings are written.
                            This file is just a bunch of Tcl
                            <command>set</command> commands that are
                            read/written by
                            the
                            <link linkend='rdogui3_statemanager'
                                  endterm='rdogui3_statemanager_title' />
                            via its singleton implementation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>ReadoutCallouts.tcl</filename></term>
                    <listitem>
                        <para>
                            File that contains extensions to the ReadoutShell.
                            This file is searched for in order in:
                            <filename>~</filename>,
                            <filename>!/stagearea/experiment/currnet</filename>
                            and the current worknig directory.  The first found
                            file and only the first of these is loaded.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
      </refentry>
        <refentry id="rdogui3_readoutguioutputclient">
            <refentryinfo>
                <author>
                        <personname>
                                <firstname>Ron</firstname>
                                <surname>Fox</surname>
                        </personname>
                        <personblurb><para></para></personblurb>
                </author>
                <productname>NSCLDAQ</productname>
                <productnumber></productnumber>
            </refentryinfo>
          <refmeta>
             <refentrytitle id="rdogui3_readoutguioutputclient_title">ReadoutGUIOutputClient</refentrytitle>
             <manvolnum>3rdogui</manvolnum>
             <refmiscinfo class='empty'></refmiscinfo>
          </refmeta>
          <refnamediv>
             <refname>ReadoutGUIOutputClient</refname>
             <refpurpose>Readout gui output monitor client.</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
            <cmdsynopsis>
                <command>
ReadoutGUIOutputClient <replaceable>name ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name method params</replaceable>                    
                </command>
            </cmdsynopsis>

          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                <classname>ReadoutGUIOutputClient</classname> provides a packaged
                client for the output  monitor for applications that use the event
                loop.  Note that Tcl/Tk applications by default use the event loop.
                When a client object is constructed, it creates a new command ensemble
                whose sub commands are the method names of the object.  The command
                name can either be specified or a unique one can be assigned by
                specifying the special object name <literal>%AUTO%</literal>.
                Regardless the constructor returns the name of the command as its
                result.  Thus e.g.:
             </para>
             <informalexample>
                <programlisting>
set outputMonitor [ReadoutGUIOutputClient %AUTO%]
$outputMonitor configure -host spdaq123.nscl.msu.edu
                </programlisting>
             </informalexample>
             <para>
                is a pretty common pattern.
             </para>
          </refsect1>
          <refsect1>
             <title>
                OPTIONS
             </title>
             <para>
                <classname>ReadoutGUIOutputClient</classname> objects include
                the <command>configure</command> and <command>cget</command>
                commands that manipulate and query configuration options of the
                object.  Normally one configures the object and then invokes
                the <command>connect</command> method to start processing
                data.  See METHODS for more about <command>connect</command>.
             </para>
             <variablelist>
                <varlistentry>
                    <term><option>-host</option></term>
                    <listitem>
                        <para>
                            Specifies the name or IP address of the host that
                            is running the server.  The default value, if not
                            explicitly configured is <literal>localhost</literal>
                            which corresponds to the system running the application.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-user</option></term>
                    <listitem>
                        <para>
                            Specifies the user that is running the server application.
                            If not configured, the default value is the current
                            logged in user; <literal>$::tcl_platform(user)</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>-outputcmd</command></term>
                    <listitem>
                        <para>
                            The value of this option is a script that is executed
                            whenever something was output to the server's output
                            window.  The text that was output is passed as an
                            additional argument to the script.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-closecmd</option></term>
                    <listitem>
                        <para>
                            The value of this option is a script that is executed
                            when the object loses connection with the command server.
                        </para>
                    </listitem>
                </varlistentry>
                
                
             </variablelist>
          </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    There is only one method <methodname>connect</methodname>
                    it has no additional parameters and should be invoked once
                    the object is configured.  <methodname>connect</methodname>
                    attempts to make the connection with the server and
                    sets up the fileevents to invoke the <option>-outputcmd</option>
                    and <option>-closecmd</option> scripts at appropriate times.
                </para>
                <para>
                    Failures result in an error signal.
                </para>
            </refsect1>
        </refentry>
         <refentry>
            <refmeta>
                <refentrytitle>evbwizard</refentrytitle>
                <manvolnum>1tcl</manvolnum>
            </refmeta>
            <refnamediv>
                <refname>evbwizard</refname>
                <refpurpose>Set up readout GUI and event builder.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <synopsis>
$DAQBIN/evbwizard
                </synopsis>
            </refsynopsisdiv>
            <refsect1>
                <title>DESCRIPTION</title>
                <para>
<command>evbwizard</command>  is a GUI tool that sets up ReadoutGUI data sources
and an event builder start script.  The tools is intended to be self documented.
                </para>
            </refsect1>
            <refsect1>
              <title>FILES</title>
              <simplelist>
               <member>
                  <filename>ReadoutCallouts.tcl</filename> is written by this tool/
                  it is a starting point for the experiment's
                  <filename>ReadoutCallouts.tcl</filename> file.  It initializes
                  and starts the event builder as well as setting up all data sources.
               </member>
               <member>
                <filename>settings.tcl</filename> contains the ReadoutGUI data
                source definitions.  In most cases this is just copied to
                <filename>~/stagearea/.setttings.tcl</filename>. Note that if
                that file exists, it may be better to append the contents of
                <filename>settings.tcl</filename> to the end of the existing
                file.
               </member>
              </simplelist>
            </refsect1>
        </refentry>
<!-- /manpage -->
