#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

#    This software is Copyright by the Board of Trustees of Michigan
#    State University (c) Copyright 2014.
#
#    You may use this software under the terms of the GNU public license
#    (GPL).  The terms of this license are described at:
#
#     http://www.gnu.org/licenses/gpl.txt
#
#    Authors:
#             Ron Fox
#             Jeromy Tompkins 
#	     NSCL
#	     Michigan State University
#	     East Lansing, MI 48824-1321



##
# @file SPData.test
# @brief Tests for StateProgramData
# @author Ron Fox <fox@nscl.msu.edu>
#

package require tcltest
package require snit

set here [file dirname [info script]]
source [file join $here StateProgramData.tcl]
source [file join $here StateProgram.tcl]
source [file join $here ringBufferObject.tcl]

set bindir $::env(BINDIR)

proc getValue {obj propname} {
    set pl [$obj getProperties]
    set p [$pl find $propname]
    return [$p cget -value    ]
}

proc setValue {obj propname value} {
    set pl [$obj getProperties]
    set p [$pl find $propname]
    $p configure -value $value
}

# Test fixtures used in the connectability tests.


snit::type notring {
    method type {} {return not-ring}
    
}

tcltest::test construct-1 {Construction enable is true} \
-setup {
    set obj [StateProgramData %AUTO%]
    
} \
-cleanup {
    $obj destroy
} \
-body  {
    getValue $obj enable
} -result true

tcltest::test construct-2 {Construction standalone false} \
-setup {
    set obj [StateProgramData %AUTO%]
    
} \
-cleanup {
    $obj destroy
} \
-body  {
    getValue $obj standalone
} -result false

tcltest::test construct-3 {path is empty} \
-setup {
    set obj [StateProgramData %AUTO%]
    
} \
-cleanup {
    $obj destroy
} \
-body  {
    getValue $obj path
} -result ""

tcltest::test construct-4 {host is empty} \
-setup {
    set obj [StateProgramData %AUTO%]
    
} \
-cleanup {
    $obj destroy
} \
-body  {
    getValue $obj host
} -result ""

tcltest::test construct-5 {input ring empty} \
-setup {
    set obj [StateProgramData %AUTO%]
    
} \
-cleanup {
    $obj destroy
} \
-body  {
    getValue $obj {Input Ring}
} -result ""

tcltest::test construct-6 {output ring is empty} \
-setup {
    set obj [StateProgramData %AUTO%]
    
} \
-cleanup {
    $obj destroy
} \
-body  {
    getValue $obj {Output Ring}
} -result ""

tcltest::test clone-1 {clone keeps path.} \
-setup {
    set obj [StateProgramData %AUTO%]
    
    setValue $obj path "/some/program"
    setValue $obj host "charlie.nscl.msu.edu"
    setValue $obj {Input Ring} "fox"
    setValue $obj {Output Ring} "outring"
    
    set newobj [$obj clone]
    
} \
-cleanup {
    $obj destroy
    $newobj destroy
} \
-body  {
    getValue $obj path
} -result /some/program

tcltest::test clone-2 {Clone keeps host} \
-setup {
    set obj [StateProgramData %AUTO%]
    
    setValue $obj path "/some/program"
    setValue $obj host "charlie.nscl.msu.edu"
    setValue $obj {Input Ring} "fox"
    setValue $obj {Output Ring} "outring"
    
    set newobj [$obj clone]
    
} \
-cleanup {
    $obj destroy
    $newobj destroy
} \
-body  {
    getValue $obj host
} -result charlie.nscl.msu.edu

tcltest::test clone-3 {Clone keeps input ring} \
-setup {
    set obj [StateProgramData %AUTO%]
    
    setValue $obj path "/some/program"
    setValue $obj host "charlie.nscl.msu.edu"
    setValue $obj {Input Ring} "fox"
    setValue $obj {Output Ring} "outring"
    
    set newobj [$obj clone]
    
} \
-cleanup {
    $obj destroy
    $newobj destroy
} \
-body  {
    getValue $obj {Input Ring}
} -result fox

tcltest::test clone-4 {Clone keeps output ring} \
-setup {
    set obj [StateProgramData %AUTO%]
    
    setValue $obj path "/some/program"
    setValue $obj host "/charlie.nscl.msu.edu"
    setValue $obj {Input Ring} "fox"
    setValue $obj {Output Ring} "outring"
    
    set newobj [$obj clone]
    
} \
-cleanup {
    $obj destroy
    $newobj destroy
} \
-body  {
    getValue $obj {Output Ring}
} -result outring

##
#  Connection tests.
#

tcltest::test  isconnectable-1 {Initially can source connections} \
-setup {
    set obj [StateProgram %AUTO%]
} \
-cleanup {
    $obj destroy
} \
-body {
    $obj isConnectable from
} -result 1

tcltest::test isconnectable-2 {Initially can sink connections} \
-setup {
    set obj [StateProgram %AUTO%]
} \
-cleanup {
    $obj destroy
} \
-body {
    $obj isConnectable to
} -result 1

tcltest::test isconnectable-3 {If a we have a source we can't have another} \
-setup {
    set obj [StateProgram %AUTO%]
    set ring [RingBufferObject %AUTO%]
} \
-cleanup {
    $obj destroy
    $ring destroy
} \
-body {
    $obj connect from  $ring
    $obj isConnectable from
} -result 0
 
tcltest::test isconnectable-4 {If we have a sink we can't have anohter} \
-setup {
    set obj [StateProgram %AUTO%]
    set ring [RingBufferObject %AUTO%]
} \
-cleanup {
    $obj destroy
    $ring destroy
} \
-body {
    $obj connect to  $ring
    $obj isConnectable to
} -result 0


tcltest::test connect-1 {Connection of non-ring should fail} \
-setup {
    set obj [StateProgram %AUTO%]
    set nr [notring %AUTO%]
} \
-cleanup {
    $obj destroy
    $nr destroy
} \
-body {
    lappend result [catch {$obj connect from $nr}]
    lappend result [catch {$obj connect to $nr}]
} -result [list 1 1]
tcltest::test disconnnect-1 {If a to is connected we can connect as a to.} \
-setup {
    set obj [StateProgram %AUTO%]
    set ring [RingBufferObject %AUTO%]
    $obj connect to  $ring
} \
-cleanup {
    $obj destroy
    $ring destroy
} \
-body {
    $obj disconnect $ring
    $obj isConnectable to
} -result 1

tcltest::test disconnect-2 {If a from is disconnected we can connect as a from} \
-setup {
    set obj [StateProgram %AUTO%]
    set ring [RingBufferObject %AUTO%]
    $obj connect from  $ring
} \
-cleanup {
    $obj destroy
    $ring destroy
} \
-body {
    $obj disconnect $ring
    $obj isConnectable from
} -result 1

tcltest::test changecmd-1 {If data are changed we should get notified} \
-setup {
    set sd [StateProgramData %AUTO% -changecmd [list lappend changelog [list %N %V]]]
    set changelog [list]
} \
-cleanup {
    $sd destroy
} \
-body {
     set plo [$sd getProperties]
     set ps  [$plo get]
     
     foreach p $ps value [list \
        test charlie false true /usr/bin/test  $bindir tcp://localhost/test fox StateProgram --help] {
        $p configure -value $value
     }
     set changelog
     
} -result [list [list name test] [list host charlie] [list enable false] [list standalone true] \
    [list path /usr/bin/test]  [list wd $bindir] [list "Input Ring" tcp://localhost/test]  \
    [list "Output Ring" fox] [list type StateProgram]                   \
    [list "Program Parameters" --help]] 

tcltest::test changecmd-2 {If data are changed in the packaged object we get notified} \
-setup {
    set sd [StateProgram %AUTO% -changecmd [list lappend changelog [list %N %V]]]
    set changelog [list]
} \
-cleanup {
    $sd destroy
} \
-body {
     set plo [$sd getProperties]
     set ps  [$plo get]
     
     foreach p $ps value [list \
        test charlie false true /usr/bin/test  $bindir tcp://localhost/test fox StateProgram --help] {
        $p configure -value $value
     }
     set changelog
     
} -result [list [list name test] [list host charlie] [list enable false] [list standalone true] \
    [list path /usr/bin/test]  [list wd $bindir] \
    [list "Input Ring" tcp://localhost/test] [list "Output Ring" fox]        \
    [list type StateProgram]  [list "Program Parameters" --help]]


tcltest::test readout-1 {Readout has and can access properties from base} \
-setup {
    set obj [ReadoutProgram %AUTO%]
} \
-cleanup {
    $obj destroy
} \
-body {
    set p [$obj getProperties];         # Tests method delegation.
    [$p find enable] cget -value
} -result true


tcltest::test readout-2 {Readout has  additional properties created} \
-setup {
    set obj [ReadoutProgram %AUTO%]
} \
-cleanup {
    $obj destroy
} \
-body {
    set p [$obj getProperties];         # Tests method delegation.
    [$p find sourceid] cget -value
} -result 0

tcltest::test eventlog-1 {Event log has and can access base properties} \
-setup {
    set obj [EventLogProgram %AUTO%]
} \
-cleanup {
    $obj destroy
} \
-body {
    set p [$obj getProperties];         # Tests method delegation.
    [$p find enable] cget -value
} -result true    

tcltest::test eventlog-2 {Event log has new properties} \
-setup {
    set obj [EventLogProgram %AUTO%]
} \
-cleanup {
    $obj destroy
} \
-body {
    set p [$obj getProperties];         # Tests method delegation.
    [$p find segmentsize] cget -value
} -result 2g

tcltest::test eventlog-3 {Valid segment sizes are ok} \
-setup {
    set obj [EventLogProgram %AUTO%]
} \
-cleanup {
    $obj destroy
} \
-body {
    set p [$obj getProperties];         # Tests method delegation.
    set segsize [$p find segmentsize]
    $segsize configure -value 100m
    set values [$segsize cget -value]
    $segsize configure -value 10000000
    lappend values [$segsize cget -value]
    set values 
} -result [list 100m 10000000]

tcltest::test eventlog-4 {Invalid segment sizes are not ok} \
-setup {
    set obj [EventLogProgram %AUTO%]
} \
-cleanup {
    $obj destroy
} \
-body {
    set p [$obj getProperties];         # Tests method delegation.
    catch {[$p find segsize] configure -value onegig}
} -result 1

# End/summarize the tests - note the magic below is intended to ensure that
# a failed test fails the makefile test target too.

set exitCode 0
proc tcltest::cleanupTestsHook {} {
    variable numTests
    set ::exitCode $::tcltest::numTests(Failed)
}


##
# this pulls in Tk and cleanupTests exist in that case without reporting
#  our error code so we need this little artifice:

rename exit myexit

proc exit {} {}


tcltest::cleanupTests

myexit $::exitCode
