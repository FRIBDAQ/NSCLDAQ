#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

#    This software is Copyright by the Board of Trustees of Michigan
#    State University (c) Copyright 2014.
#
#    You may use this software under the terms of the GNU public license
#    (GPL).  The terms of this license are described at:
#
#     http://www.gnu.org/licenses/gpl.txt
#
#    Authors:
#             Ron Fox
#             Jeromy Tompkins 
#	     NSCL
#	     Michigan State University
#	     East Lansing, MI 48824-1321



##
# @file properties.test
# @brief Test for the property 'class'.
# @author Ron Fox <fox@nscl.msu.edu>
#

set here [file dirname [info script]]
package require tcltest
source [file join $here properties.tcl]

tcltest::test property-needs-name {Making a property without a name is an error} \
-body {
catch {property %AUTO%} 
} -result 1

tcltest::test property-construct-ok {Construct a property properly} \
-body {
    set p [property %AUTO% -name test]
    lappend result [$p cget -name]
    lappend result [$p cget -value]
    lappend result [$p cget -validate]
    lappend result [$p cget -editable]
    
    set result
} -result [list test "" "" 1]


tcltest::test property-set {unvalidated set} \
-setup {
    set p [property %AUTO% -name test]
} \
-body {
    set value {just about anything is legal}
    $p configure -value $value
    
    expr {$value eq [$p cget -value]}
} -result 1

tcltest::test property-set-validator1 {Set with validator - ok value} \
-setup {
    set p [property %AUTO% -name test -validate [snit::integer %AUTO% -min 0 -max 10 ]]
} \
-body {
    catch {$p configure -value 2}
} -result 0
    
tcltest::test property-set-validator2 {Set with validator - bad value} \
-setup {
    set p [property %AUTO% -name test -validate [snit::integer %AUTO% -min 0 -max 10 ]]
} \
-body {
    catch {$p configure -value 20}
} -result 1

tcltest::test property-editable-1 {Editable can be set false} \
-setup {
    set p [property %AUTO% -name test]
} \
-cleanup {
    $p destroy
} \
-body {
    $p configure -editable 0
    $p cget -editable
} -result 0

tcltest::test property-editable-2 {editable can be set true} \
-setup {
    set p [property %AUTO% -name test -editable 0]
} \
-cleanup {
    $p destroy
} \
-body {
    $p configure -editable 1
    $p cget -editable
} -result 1

tcltest::test property-editable-3 {editable can't be set a non bool value} \
-setup {
    set p [property %AUTO% -name test -editable 0]
} \
-cleanup {
    $p destroy
} \
-body {
    catch {$p configure -editable george}
} -result 1

tcltest::test property-dispatch {Can dispatch a command on property change} \
-setup {
    set p [ property %AUTO% -name test -changecmd]
    $p configure -changecmd [list set ::a [list %N %V]]
    set ::prop $p

} \
-cleanup {
    $p destroy
    unset ::a
    
} \
-body {
    $p configure -value 1234
    set ::a
} -result [list  test 1234]


tcltest::test integer-property-1  {Integer property with valid integer} \
-setup {
    set p [IntegerProperty %AUTO% -name test -value 1]
} \
-cleanup {
    $p destroy
} \
-body {
    catch {$p configure -value -1234};       # ok value
   
} -result 0

tcltest::test integer-property-1 {Integer property with invalid ineger} \
-setup {
    set p [IntegerProperty %AUTO% -name test -value 1]
} \
-cleanup {
    $p destroy
} \
-body {
    catch {$p configure -value 3.14159};       # ok value
   
} -result 1

tcltest::test signed-property1 {Test signed integer property with valid integer} \
-setup {
    set p [IntegerProperty %AUTO% -name test -value 1 -signed 1]
} \
-cleanup {
    $p destroy
} \
-body {
    catch {$p configure -value 1234};       # ok value
   
} -result 0

tcltest::test enumerated-1  {Check that enumerated type is ok} \
-setup {
    set p [EnumeratedProperty %AUTO% -name test -values [list on off] -value on]
} \
-cleanup {
    $p destroy
} -body {
    catch {$p configure -value off}
} -result 0

tcltest::test enumerated-2 {Check bad enumerated type is an error} \
-setup {
    set p [EnumeratedProperty %AUTO% -name test -values [list on off] -value on]
} \
-cleanup {
    $p destroy
} -body {
    catch {$p configure -value bad}
} -result 1

tcltest::test list-1  {Check that valid lists are valid for ListProperty} \
-setup {
    set p [ListProperty %AUTO% -name test]
} \
-cleanup {
    $p destroy
} \
-body {
    catch {$p configure -value [list 1 2 3 4 5]}
} -result 0

tcltest::test list-2 {Invalid list format for list property} \
-setup {
    set p [ListProperty %AUTO% -name test]
} \
-cleanup {
    $p destroy
} \
-body {
    catch {$p configure -value "1 2 3 4 5 \{"}
} -result 1

tcltest::test list-3 {Set minimum elements in list} \
-setup {
    set p [ListProperty %AUTO% -name test -minlen 20] 
} \
-cleanup {
    $p destroy
} \
-body {
    catch {$p configure -value [list 1 2 3 4 5]}
} -result 1

tcltest::test list-4 {Set maximum elements in a list} \
-setup {
    set p [ListProperty %AUTO% -name test -maxlen 2] 
} \
-cleanup {
    $p destroy
} \
-body {
    catch {$p configure -value [list 1 2 3 4 5]}
} -result 1

# End/summarize the tests - note the magic below is intended to ensure that
# a failed test fails the makefile test target too.

proc tcltest::cleanupTestsHook {} {
    variable numTests
    set ::exitCode $numTests(Failed)
}


tcltest::cleanupTests
exit $::exitCode