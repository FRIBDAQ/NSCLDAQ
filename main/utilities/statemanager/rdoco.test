#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

#    This software is Copyright by the Board of Trustees of Michigan
#    State University (c) Copyright 2014.
#
#    You may use this software under the terms of the GNU public license
#    (GPL).  The terms of this license are described at:
#
#     http://www.gnu.org/licenses/gpl.txt
#
#    Authors:
#             Ron Fox
#             Jeromy Tompkins 
#	     NSCL
#	     Michigan State University
#	     East Lansing, MI 48824-1321



##
# @file rdoco.test
# @brief test suite for the readout callouts package in the database state mgr.
# @author Ron Fox <fox@nscl.msu.edu>
#
package require tcltest
package require varmgr
package require portAllocator
package require stateclient


##
# waitService
#   Wait for a service to poof into being.  No timeout is done.
#   The port allocator is polled every 100ms.
#
# @param host    - host to check in.
# @param service - name of the service.
# @param user    - User that requested the service.
#
proc waitService {host service user} {
    portAllocator create pa -hostname $host
    set found 0
    while {!$found} {
        set services [pa listPorts]
        foreach s $services {
            set name [lindex $s 1]
            set u    [lindex $s 2]
            if {($name eq $service) && ($user eq $u)} {
                set found 1
            }
        }
        if {!$found} {
            after 100;                 # Poll every 100ms.
        }
    }
    pa destroy
}

##
# setup - common set proc;
#   - Create a new database file.
#   - Create the run control database schema
#   - Add a program named 'test'.
#   - Start a database server on that database.
# @return a dict containing:
#        -  dbfile - database file path.
#        -  pid    - server pid.
# @note  Global variables named after the keys above are also created.
#        that allows cleanup to be 'unparameterized'
proc setup {} {
    #
    #  Create the database file.
    #
    set ::dbfile [tcltest::makeFile "" test.db]
    varmgr::create $::dbfile
    
    # put the run control schema in it along with a program named test.
    
    exec $::env(DAQBIN)/vardbsh file://$::dbfile <$::env(DAQBIN)/MakeRunControl.tcl
    
    exec $::env(DAQBIN)/addrdo file://$::dbfile --path /bin/ls --host localhost \
        --name test
        
    # Start a database server on it:
    
    set ::pid [exec $::env(DAQBIN)/vardbServer -f $::dbfile & ]
    waitService localhost vardb-changes $::tcl_platform(user)
    waitService localhost vardb-request $::tcl_platform(user)
    return [dict create dbfile $::dbfile pid $::pid]  
}

##
# cleanup
#   Perform common cleanup tasks:
#    - Kill the database server.
#    - Destroy the database file.
#
proc cleanup {} {
    exec kill -9 $::pid
    tcltest::removeFile test.db
}

##
# startTestProgram
#   Runs a test program (tcl script) with output directed to a pipe file.
#   The environment is set up to allow StateManagerControl to
#   operate as follows:
#     - Global state is set to Readying
#     - test Program state is set to Readying
#     - Environment variables: REQ_URI, SUB_URI and PROGRAM are set up so that
#       the server URI is the local host and the program name is 'test'
#  Furthermore, when the test program state is Ready, the Global state is also
#  set to Ready.
#
# @param script - test script (file path).
# @return list - first element of the list is the file descriptor open for read
#                on the program's stdout.
#                second element of the list is the process's PID.
#

proc startTestProgram script {
    set h [varmgr::open tcp://localhost]
    
    # Assuming the global state is 0Initial: -- need to set everything to readying
    # since that's what the harness expects.
    varmgr::var set $h /RunState/State NotReady
    varmgr::var set $h /RunState/test/State NotReady
    
    varmgr::var set $h /RunState/State Readying
    varmgr::var set $h /RunState/test/State Readying
    
    set ::env(REQ_URI) tcp://localhost
    set ::env(SUB_URI) tcp://localhost
    set ::env(PROGRAM) test
    
    set fd [open "| tclsh $script" r]
    set pid [pid $fd]
    fconfigure $fd -buffering line

    #  Wait for the program to become ready for at most 5 seconds.
    #  error if failed, and set state to Ready on success:
    
   
    set n 0

    while {[varmgr::var get $h /RunState/test/State] ne "Ready"} {
        
        incr n
        if {$n > 50} {
            error "test program transition to Ready timed out."
        }
        after 100;                # poll in 100ms chunks.
        
    }

    varmgr::var set $h /RunState/State Ready
    varmgr::close $h
    
    #
    
    return [list $fd $pid]
}
##
# killTestProgram
#    Kills a test program.
#    - The pid associated with the program is given the 9 signal
#    - The fd is then closed.
#
# @param pid - pid of the program.
# @param fd  - File descriptor attached to program's stdout.
#
proc killTestProgram {pid fd} {
    fconfigure $fd -blocking 0
    if {[catch {close $fd} msg]} {
        puts "Test program error : $msg"
    }
    catch {exec kill -9 $pid}

}

##
#  setupWithScript
#    Do a setup with a script.
# @param script - the script text.
# @return [list fd pid]
#
proc setupWithScript {script} {
    setup    
    set ::scriptFile [tcltest::makeFile $script atest.tcl]
    set procinfo [startTestProgram $::scriptFile]
    return $procinfo
}
##
# Do cleanup with a script subprocess
#
# @param pid - pid of the subprocess.
# @param fd - File descdriptor open on the subprocess's stdout.
proc cleanupWithScript {pid fd} {
    killTestProgram $pid $fd
    cleanup
    tcltest::removeFile $::scriptFile    
}

##
# Test base callout handlers for state transitions:
#
tcltest::test OnPreBegin {Test call of OnPreBegin} \
-setup {
    set procinfo [setupWithScript {
        proc OnPrebegin run {
            puts "prebegin $run"
            flush stdout
        }
        package require ReadoutCalloutsHarness
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    set output [gets $fd]
    list $tresult $output
} -result [list 1 "prebegin 0"]

tcltest::test OnBegin {Test call of OnBegin} \
-setup {
    set procinfo [setupWithScript {
        proc OnBegin run {
            puts "begin $run"
            flush stdout
        }
        package require ReadoutCalloutsHarness
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    mgr setGlobalState Active
    lappend tresult [mgr waitTransition]
    if {$tresult == [list 1 1]} {
        set output [gets $fd]
    } else {
        set output "transition timeout"
    }
    list $tresult $output
} -result [list [list 1 1] "begin 0"]

tcltest::test OnPrepause {Check that prepause gets called}  \
-setup {
    set procinfo [setupWithScript {
        proc OnPrepause run {
            puts "prepause $run"
            flush stdout
        }
        package require ReadoutCalloutsHarness
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    mgr setGlobalState Active
    lappend tresult [mgr waitTransition]
    
    # Start pausing the run:
    
    mgr setGlobalState Pausing
    lappend tresult [mgr waitTransition]
    set output [gets $fd]
    list $tresult $output
} -result [list [list 1 1 1] {prepause 0}]

tcltest::test OnPause {Check that OnPause is invoked} \
-setup {
    set procinfo [setupWithScript {
        proc OnPause run {
            puts "pause $run"
            flush stdout
        }
        package require ReadoutCalloutsHarness
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    mgr setGlobalState Active
    lappend tresult [mgr waitTransition]
    mgr setGlobalState Pausing
    lappend tresult [mgr waitTransition]
    
    #  Complete the pause:
    
    mgr setGlobalState Paused
    lappend tresult [mgr waitTransition]
    set output [gets $fd]
    
    list $tresult $output
} -result [list [list 1 1 1 1] "pause 0"]

tcltest::test OnPreresume {Ensure that OnPreresume is invoked} \
-setup {
    set procinfo [setupWithScript {
        proc OnPreresume run {
            puts "preresume $run"
            flush stdout
        }
        package require ReadoutCalloutsHarness
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    mgr setGlobalState Active
    lappend tresult [mgr waitTransition]
    mgr setGlobalState Pausing
    lappend tresult [mgr waitTransition]
    mgr setGlobalState Paused
    lappend tresult [mgr waitTransition]
    
    #  Start a resume:
    
    mgr setGlobalState Resuming
    lappend tresult [mgr waitTransition]
    set output [gets $fd]
    list $tresult $output
} -result [list [list 1 1 1 1 1] "preresume 0"]

tcltest::test OnResume {Ensure OnResume is invoked} \
-setup {
    set procinfo [setupWithScript {
        proc OnResume run {
            puts "resume $run"
            flush stdout
        }
        package require ReadoutCalloutsHarness
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    mgr setGlobalState Active
    lappend tresult [mgr waitTransition]
    mgr setGlobalState Pausing
    lappend tresult [mgr waitTransition]
    mgr setGlobalState Paused
    lappend tresult [mgr waitTransition]
    mgr setGlobalState Resuming
    lappend tresult [mgr waitTransition]

    # finish the resume:
    
    mgr setGlobalState Active
    lappend tresult [mgr waitTransition]
    set output [gets $fd]
    list $tresult $output
} -result [list [list 1 1 1 1 1 1] "resume 0"]

tcltest::test OnPreend {Ensure OnPreend is called} \
-setup {
    set procinfo [setupWithScript {
        proc OnPreend run {
            puts "preend $run"
            flush stdout
        }
        package require ReadoutCalloutsHarness
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    mgr setGlobalState Active
    lappend tresult [mgr waitTransition]
    
    # start ending the run:
    
    mgr setGlobalState Ending
    lappend tresult [mgr waitTransition]
    set output [gets $fd]
    list $tresult $output
} -result [list [list 1 1 1] "preend 0" ]

tcltest::test OnEnd {Ensure the OnEnd proc is called} \
-setup {
    set procinfo [setupWithScript {
        proc OnEnd run {
            puts "onend $run"
            flush stdout
        }
        package require ReadoutCalloutsHarness
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    mgr setGlobalState Active
    lappend tresult [mgr waitTransition]
    mgr setGlobalState Ending
    lappend tresult [mgr waitTransition]
    
    # Complete the end:
    
    mgr setGlobalState Ready
    lappend tresult [mgr waitTransition]
    set output [gets $fd]
    list $tresult $output
} -result [list [list 1 1 1 1] "onend 0"]

#-----------------------------------------------------------------------------
#  Tests for API in ::ReadoutState::

tcltest::test title {Set/Get title} \
-setup {
    set procinfo [setupWithScript {
        proc OnPrebegin run {
            ::ReadoutState::setTitle {This is a new title}
        }
        proc OnBegin run {
            puts [::ReadoutState::getTitle]
            flush stdout
        }
        package require ReadoutCalloutsHarness
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    # Prestarting a run will set the title and starting it
    # will output it:
    
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    mgr setGlobalState Active
    lappend tresult [mgr waitTransition]
    
    set title [gets $fd]
    list $tresult $title
} -result [list [list 1 1] "This is a new title"]
    
tcltest::test setrun {Setting the run changes the run number to callbacks} \
-setup {
    set procinfo [setupWithScript {
        proc OnPrebegin run {
            puts "Run is $run"
            flush stdout
        }
        
        package require ReadoutCalloutsHarness
        ReadoutState::setRun 1234
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    # Prebegin will output the run number:
    
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    set output [gets $fd]
    list $tresult $output
} -result [list 1 "Run is 1234"]

tcltest::test getrun {Scripts should be able to get the run number} \
-setup {
    set procinfo [setupWithScript {
        proc OnPrebegin run {
            puts "Run is [::ReadoutState::getRun]"
            flush stdout
        }
        
        package require ReadoutCalloutsHarness
        ReadoutState::setRun 1234
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    # Prebegin will output the run number:
    
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    set output [gets $fd]
    list $tresult $output
} -result [list 1 "Run is 1234"]
  
tcltest::test incrun {Can increment the run number} \
-setup {
    set procinfo [setupWithScript {
        proc OnPrebegin run {
            
            puts "Run is $run"
            flush stdout
        }
        
        package require ReadoutCalloutsHarness
        ::ReadoutState::incRun
        vwait forevermore
    }]
    
    set fd [lindex $procinfo 0]
    set testpid [lindex $procinfo 1]
    nscldaq::statemanager mgr tcp://localhost tcp://localhost
} \
-cleanup {
    nscldaq::statemanager -delete mgr
    cleanupWithScript $testpid $fd
} \
-body {
    # Prebegin will output the run number:
    
    mgr setGlobalState Beginning
    set tresult [mgr waitTransition]
    set output [gets $fd]
    list $tresult $output
} -result [list 1 "Run is 1"]
#------------------------------------------------------------------
#
# Magic to exit with errors if there are test failures:

proc ::tcltest::cleanupTestsHook {} {
    variable numTests
    set ::exitCode $numTests(Failed)
}


tcltest::cleanupTests
exit $::exitCode
