<!-- chapter libraries -->
<chapter>
    <title>
        State Manager API.
    </title>
    <para>
        State manager programs are those that force global state transitions.
        This chapter provides:
    </para>
    <itemizedlist>
        <listitem><para>
            Background information about state manager programs and what they
            can do.
        </para></listitem>
        <listitem><para>
            A small sample state manager program.
        </para></listitem>
        <listitem><para>
            The State manager ReadoutGUI is described.
        </para></listitem>
    </itemizedlist>
    <para>
        Reference information is available:
    </para>
    <variablelist>
        <varlistentry>
            <term>
                <link linkend='daq3_cstatemanager'
                      endterm='daq3_cstatemanager_title' />
            </term>
            <listitem>
                <para>
                    The C++ <classname>CStateManager</classname> class
                    which makes up the API.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='tcl3_statemanager'
                      endterm='tcl3_statemanager_title' />
            </term>
            <listitem>
                <para>
                    Documents the Tcl bindings to the
                    <classname>CStateManager</classname> class.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='python3_statemanager'
                      endterm='python3_statemanager_title' />
            </term>
            <listitem>
                <para>
                    Documents the pyhon bindings to the
                    <classname>CStateManager</classname>
                    class.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='daq1_readoutgui'
                      endterm='daq1_readoutgui_title' />
            </term>
            <listitem>
                <para>
                    Describes how to use the state manager Run control GUI.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        The C++ header that defines the state manager API is
        <filename>&lt;CStateManager.h&gt;</filename>.
        The library you must link to is
        <filename>$DAQLIB/libstateclient</filename>.
    </para>
    <section>
        <title>State managers and what they can do</title>
        <para>
            State managers can perform the following functions:
        </para>
        <itemizedlist>
            <listitem><para>
                The can create/delete and edit the definition of programs
                known to the state management system.
            </para></listitem>
            <listitem><para>
                They can enable, disable programs.
            </para></listitem>
            <listitem><para>
                They can set or clear program standalong flags.
            </para></listitem>
            <listitem><para>
                They can set run global parameters.
            </para></listitem>
            <listitem><para>
                Most importantly, they can initiate global or program
                state transitions and, in the case of global transitions,
                know when and if they have succeeded.
            </para></listitem>
        </itemizedlist>
        <para>
            State manager programs play a central role in defining and running
            the experiment.            
        </para>
        <para>
            During program definition and setup,
            the program/dataflow editor defines state
            sensitive programs and links them together by means of ring
            buffers. 
        </para>
        <para>
            During setup the program manager can select the set of programs
            that actually participate in global state transitions.  The
            program manager can also select programs that run in stand-alone
            mode for debuggin/testing and development.
        </para>
        <para>
            The Run control panel, together with the boot manager
            initiate global and local state transitions.  The boot manager
            ensures that the right set of programs are running while
            the run control panel performs state changes, displays the
            local and global states and ensures that global state
            transitions have correctly completed.
        </para>
    </section>
    <section>
        <title>A Sample state manager program</title>
        <para>
            This simple sample program starts a run, first incrementing
            the run number and setting the title to <literal>This is a test title</literal>.
        </para>
        <para>
            The remainder of this section shows sample code fragments that:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Create a new <classname>CStateManager</classname>
                    object.
                </para>
            </listitem>
            <listitem><para>
                Begin the run.
            </para></listitem>
            <listitem><para>
                Ensure the run  starts correctly while outputting messages
                that track the participant state transitions.
            </para></listitem>
        </itemizedlist>
        <section>
            <title>Creating the CStateManager object.</title>
            <para>
                In writing this code we are going to assume the state manager
                program is run with environment variables:
            </para>
            <variablelist>
                <varlistentry>
                    <term>VARMGR_REQ</term>
                    <listitem>
                        <para>
                            The URI of the variable database
                            server's REQ port.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>VARMGR_SUB</term>
                    <listitem>
                        <para>
                            The URI of the variable database server's SUB port.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            <example>
                <title>Createing a CStateManager Object</title>
                <programlisting>
#include &lt;stdlib.h&gt;
#include &lt;CStateManager.h&gt;                      <co id='make_statemgr_hdr' />

CStateManager*
makeStateManager()
{
   const char* reqUri = getenv("VARMGR_REQ");        <co id='make_statmgr_getenv' />
   const char* subUri = getenv("VARMGR_SUB");
   
   return new CStateManager(reqUri, subUri);         <co id='make_statemgr_new' />
}
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='make_statemgr_hdr'>
                    <para>
                        To use the <classname>CStateManager</classname> within
                        a program unit, the <filename>CStateManager.h</filename>
                        header must be included.  This file defines the
                        class sufficiently for the compiler.
                    </para>
                </callout>
                <callout arearefs='make_statmgr_getenv'>
                    <para>
                        Translate the environment variables.  This is not
                        production quality code.  The code should protect
                        itself against return values of
                        <literal>NULL</literal>, which indicate the
                        environament variable was not defined.
                        Error handling was removed for clarity.
                    </para>
                </callout>
                <callout arearefs='make_statemgr_new'>
                    <para>
                        Create and return a new state manager object.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Starting the run.</title>
            <para>
                The sample code in this section:
            </para>
            <itemizedlist>
                <listitem><para>
                    Sets a new run title.
                </para></listitem>
                <listitem><para>
                    Increments the run number.
                </para></listitem>
                <listitem><para>
                    Initiates a state change to start taking data.
                </para></listitem>
            </itemizedlist>
            <para>
                Note that no effort is made to ensure that the
                system is in a state where data taking can be started.
                If the global state is not compatible with a transition
                to the <literal>Beginning</literal> state the
                function below will propagate an exception.
            </para>
            <example>
                <title>
                    Starting a run.
                </title>
                <programlisting>
#include &lt;CStateManager.h&gt;

void
startRun(CStateManager* pStateManager, const char* title) <co id='sm_begrun_sig' />
{
    pStateManager->title(title);                          <co id='sm_begrun_title' />
    pStateManager->runNumber(runNumber() + 1);            <co id='sm_begrun_incrun' />
    
    pStateManager->setGlobalState("Beginning");           <co id='sm_begrun_beg' />
}
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='sm_begrun_sig'>
                    <para>
                        The first functino parameter is a pointer to the
                        <classname>CStateManager</classname> object
                        we created in the previous section. The second parameter
                        is a new title string.
                    </para>
                </callout>
                <callout arearefs='sm_begrun_title'>
                    <para>
                        Sets the new title string.
                    </para>
                </callout>
                <callout arearefs='sm_begrun_incrun' >
                    <para>
                        Increments the run number.
                    </para>
                </callout>
                <callout arearefs='sm_begrun_beg'>
                    <para>
                        The <literal>Begining</literal> state indicates
                        to all participants that they must start a
                        data taking run.  The full description of
                        what participants must do and the tracking
                        of the start of the run is shown in the next
                        section.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Tracking the state transition</title>
            <para>
                In the previous section, we had made a global state
                transtion to <literal>Beginning</literal>.  In response
                to this transition, participants are expected to:
            </para>
            <orderedlist>
                <listitem><para>
                    Make a local transition to <literal>Beginning</literal>.
                </para></listitem>
                <listitem><para>
                    Perform all initialization required to begin data
                    taking.
                </para></listitem>
                <listitem><para>
                    Make a local state transition to <literal>Active</literal>.
                </para></listitem>
                <listitem><para>
                    When the global state transitions to <literal>Active</literal>,
                    programs are supposed to start taking data.
                </para></listitem>
            </orderedlist>
            <para>
                If at any point in this process, a participant program
                encounters an error it cannot recover from, it must
                set its state to <literal>NotReady</literal> and exit.
                This will result in a global state transition to
                <literal>NotReady</literal> which, in turn, will eventually
                cause all participants to go <literal>NotReady</literal>
                and exit.
            </para>
            <example>
                <title>Tracking the state changes to start a run</title>
                <programlisting>
#include &lt;CStateManager.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

void reportTransition(                      <co id='sm_mon_cbsig' />
    CStateManager&amp; mgr, std::string program, std::string state,
    void* cd
)
{
    std::cout &lt;&lt; program &lt;&lt; " transitioned to  " 
        &lt;&lt; state &lt;&lt; std::endl; 
}

void monitorTransition(CStateManager* pMgr)
{
    try {
        pMgr->waitTransition(reportTransition, NULL);   <co id='sm_mon_mon' />
    }
    catch (std::exception&amp; e) {                    <co id='sm_mon_fail' />
        std::cerr &lt;&lt; " Transition failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}

                </programlisting>
            </example>
            <calloutlist>
                <callout  arearefs='sm_mon_mon'>
                    <para>
                        <methodname>waitTransition</methodname> waits for
                        a transition to complete, time out or fail.  Transitions
                        timeout when the state manager is table for longer than
                        the number of seconds in
                        <filename>/RunState/Timeout</filename>.
                        Transitions fail if one or more participants declare
                        themselves as <literal>NotReady</literal>
                    </para>
                    <para>
                        <methodname>waitTransition</methodname> can call a callback
                        function every time a participant reports a state change.
                        In this case we've specified <function>reportTransition</function>
                        as our callback.
                    </para>
                </callout>
                <callout arearefs='sm_mon_cbsig'>
                    <para>
                        Our state transition callback will just output
                        the program and its new state so that our
                        users can see the progress of that transition.
                    </para>
                </callout>
                <callout arearefs='sm_mon_fail'>
                    <para>
                        A failed or timed out transition throws an exception
                        which is caught and reported here.
                    </para>
                </callout>
            </calloutlist>
            
        </section>
    </section>
    <section>
        <title>The ReadoutGui</title>
        <para>
            The ReadoutGUI is used with the service manager to provide a
            graphical user interface that controls the startup and shutdown
            of a DAQ system as well as guiding the system through state changes
            (beginning, ending, pausing and resuming runs).  Using the
            ReadoutGUI essentially allows you control over almost all of the content
            in the <filename>/RunState</filename> directory.
        </para>
        <para>
            To use the ReadoutGUI you must first:
        </para>
        <itemizedlist>
            <listitem><para>
                Configure the variable database server as a service
            </para></listitem>
            <listitem><para>
                Configure the boot manager as a service.
            </para></listitem>
            <listitem><para>
                Run the service manager and start all services.
            </para></listitem>
        </itemizedlist>
        <para>
            Once the above steps ahve been accomplished you can run
            the ReadoutGui:
        </para>
        <informalexample>
            <cmdsynopsis><command>
$DAQBIN/ReadoutGui <replaceable>requestUri subscriptionUri</replaceable>
            </command></cmdsynopsis>
        </informalexample>
        <para>
            Where <parameter>requestUri</parameter> and
            <parameter>subscriptionUri</parameter> are the URIs of the
            request and subscription services advertised by the variable
            database server you started via the service manager.
            
        </para>
        <para>
            The GUI of the ReadoutGUi is a tabbed widget with a pair of tabs.
            The <literal>RunControl</literal> tab supplies the user interface
            for controlling the runs.  On the other hand, the
            <literal>Program states</literal> tab provides information about the
            states of the state sensitive programs being controlled.
        </para>
        <para>
            The ReadoutGUI works via the variable database.  You can run as many
            instances as you like.  The ReadoutGui uses variable change
            subscription/notification to update its appearance.  This means that
            changes performed in one ReadoutGUI instance will be reflected in all
            instances that are connected to the same variable database.
        </para>
        <para>
            Some features of note about the GUI:
        </para>
        <itemizedlist>
            <listitem><para>
                The Top section of the <literal>Run Control</literal> tab
                allow you to set information about the next run.   In addition
                to the title and the run number there is a checkbox to enable
                or disable recording.  This check button assumes there is a state
                aware event logger that will log data to disk when this box is
                checked.
            </para>
            <para>
                When the run is active, these controls are replaced by labels so
                that they cannot be modified.
            </para></listitem>
            <listitem>
                <para>
                    The global state is always displayed below the run information
                    section.   The global state will determine which controls will
                    be displayed below it.
                </para>
            </listitem>
            <listitem>
                <para>
                    There is always either a <guibutton>Boot</guibutton> or
                    <guibutton>Shutdown</guibutton> button at the bottom of the
                    UI.  When the system is in <literal>NotReady</literal> state
                    the <guibutton>Boot</guibutton> button changes the global
                    state to <literal>Readying</literal> which instructs the
                    boot manager to start the state sensitive programs and
                    complete the transition to Ready.
                </para>
                <para>
                    When the state sensitive programs are running, the
                    <guibutton>Boot</guibutton> button is removed and
                    replaced with a <guibutton>Shutdown</guibutton> button.
                    The <guibutton>Shutdown</guibutton> button
                    sets the global state to <literal>NotReady</literal>
                    which instructs
                    the boot manager to kill off the state sensitive programs.
                </para>
            </listitem>
            <listitem>
                <para>
                    Above the <guibutton>Boot</guibutton> and
                    <guibutton>Shutdown</guibutton> area is an area where run
                    control buttons approprate to the run state will be displayed.
                    The buttons that can be displayed are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><guibutton>Begin</guibutton></term>
                        <listitem>
                            <para>
                                This button appears only in the <literal>Ready</literal>
                                state.  Clicking on it sets the global state to
                                <literal>Beginning</literal>.  State sensitive
                                programs then do what they need to do to start a
                                new run completing the transition to
                                <literal>Active</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <guibutton>End</guibutton>
                        </term>
                        <listitem>
                            <para>
                                Appears only in the <literal>Active</literal>
                                and <literal>Paused</literal> states.  Clicking the
                                button sets the global state to <literal>Ending</literal>.
                                State sensitive programs then shut down data taking, if
                                active,
                                end their runs and complete the state transition to
                                <literal>Ready</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guibutton>Pause</guibutton></term>
                        <listitem>
                            <para>
                                Appears only in the <literal>Active</literal>
                                state.  When clicked sets the global state to
                                <literal>Pausing</literal>.  State sensitive
                                programs temporarily pause data taking and complete
                                the transition to the <literal>Paused</literal>
                                state.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guibutton>Resume</guibutton></term>
                        <listitem>
                            <para>
                                Only present in the <literal>Paused</literal> state.
                                This button transitions to the <literal>Resuming</literal>
                                state.  State sensitive programs continue taking data
                                after a pause in the run and complete a state
                                transition to <literal>Active</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
            <listitem><para>
                The <literal>Program States</literal> tab consists of a table
                that is periodically updated.  The table has a line for each
                state sensitive program that is registered in the variable
                database.  The line for a program displays the program's name,
                individual state and the state of the <literal>Enabled</literal>
                and <literal>Standalone</literal> flags.
            </para></listitem>
        </itemizedlist>
    </section>
</chapter>
<!-- /chapter -->

<!-- manpage 1daq -->
      <refentry id="daq1_readoutgui">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='daq1_readoutgui_title'>ReadoutGui</refentrytitle>
           <manvolnum>1daq</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>ReadoutGui</refname>
           <refpurpose>Run control via variable database</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
$DAQBIN/ReadoutGui <replaceable>requestURI subscriptionURI</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Runs the ReadoutGui program.  This program interacts with a variable
            database server to visually maintain the state of the system as
            well as to request changes to the state of the system.
           </para>
           <para>
            <parameter>requestURI</parameter> and <parameter>subscriptionURI</parameter>
            are URIs that respectively
            specify the request and subscription ports of the
            a variable database server.  By using the subscription mechanims,
            all instances of the ReadoutGui that specify the same
            <parameter>requestURI</parameter> and <parameter>subscriptionURI</parameter>
            values will be synchronized with each other.
           </para>
        </refsect1>
        
      </refentry>

<!-- /manpage -->

<!-- manpage 3daq -->

<refentry id="daq3_CStateProgram">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_CStateProgram_title'>CStateProgram</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CStateProgram</refname>
     <refpurpose>API for manipulating state sensitive program definitions</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CStateProgram.h&gt;
class <ooclass><classname>CStateProgram</classname></ooclass>
{
public:
    typedef struct _ProgramDefinition {
        bool        s_enabled;
        bool        s_standalone;
        std::string s_path;
        std::string s_host;
        std::string s_outRing;
        std::string s_inRing;
    } ProgramDefinition, *pProgramDefinition;

public:
    <constructorsynopsis>
       <methodname>CStateProgram</methodname>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>uri</parameter>
       </methodparam>
    </constructorsynopsis>
    <constructorsynopsis>
       <methodname>CStateProgram</methodname>
       <methodparam>
        <modifier></modifier><type>CVarMgrApi*</type>
            <parameter> pApi</parameter>
       </methodparam>
    </constructorsynopsis>

    <methodsynopsis>
        <modifier></modifier>
        <type>std::string</type>
        <methodname>getProgramParentDir</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setProgramParentDir</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter> path</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>addProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>pProgramDefinition</type>
                <parameter> def</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>ProgramDefinition </type>
        <methodname>getProgramDefinition</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>modifyProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>pProgramDefinition </type>
                <parameter>def</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>setEditorPosition</methodname>
        <methodparam>
            <modifier>const</modifier><type>char*</type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>int</type>
                <parameter>x</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>int</type>
                <parameter>y</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>int</type>
        <methodname>getEditorXPosition</methodname>
        <methodparam>
            <modifier>const</modifier><type> char*</type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>int</type>
        <methodname>getEditorYPosition</methodname>
        <methodparam>
            <modifier>const</modifier><type> char*</type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>enableProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname> disableProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool</type>
        <methodname>isProgramEnabled</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setProgramStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>setProgramNoStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>bool</type>
        <methodname>isProgramStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listPrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listEnabledPrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listStandalonePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listInactivePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listActivePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>deleteProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        <classname>CStateProgram</classname> provides an API that allows you to
        define and modify the definitions of state sensitive programs.  By state
        sensitive, we mean programs that participate in global state transitions
        (see <link linkend='daq3_cstatemanager' endterm='daq3_cstatemanager_title' />).
     </para>
     <para>
        The <classname>CStateManager</classname> class provides this functinoality
        as well, however its instantitation requires providing a PUB/SUB
        URI in addition to a request URI.  This class only requires a request
        URI and can, therefore, operate directly on a database file.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CStateProgram</methodname>
                   <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>uri</parameter>
                   </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Normal constructor of for <classname>CStateProgram</classname>
                    objects.  The <parameter>uri</parameter> parameter provides
                    a URI that indicates how to connect with the database.
                    A <literal>file:</literal> protocol URI will directly open
                    the database file.  A <literal>tcp:</literal> protocol
                    URI will connect to a database server.
                </para>
                <para>
                    If there are programs running
                    that subscribe to changes in the program
                    configuration, the server must be used to provide these
                    notifications.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CStateProgram</methodname>
                   <methodparam>
                    <modifier></modifier><type>CVarMgrApi*</type>
                        <parameter> pApi</parameter>
                   </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    This is the constructor used by the
                    <link linkend='daq3_cstatemanager'
                          endterm='daq3_cstatemanager_title' /> class.  It uses
                    this constructor to be able to implement its state
                    program API as mostly a thin wrapper around the
                    <classname>CStateProgram</classname> api.
                </para>
                <para>
                    <parameter>pApi</parameter> points to an instance of
                    a variable manager API.  Obviously this can also be
                    used to share api instances between a program that uses
                    several APIs.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string</type>
                    <methodname>getProgramParentDir</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    All program definitions are directories that live beneath
                    a parent directory.  This method returns the path to the
                    program parent directory.
                 </para>
             </listitem>
         </varlistentry>   
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setProgramParentDir</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter> path</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Changes the parent directory in which program definitions are
                    made.  Note that no existing definitions are copied over.
                    This allows you to configure several state sensitive
                    configurations which you can then easily switch between.
                    <parameter>path</parameter> will be the path to the new
                    parent directory. This should be an absolute path.
                 </para>
             </listitem>
         </varlistentry>       
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>addProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>pProgramDefinition</type>
                            <parameter> def</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                     Adds a new state sensitive program.  <parameter>name</parameter>
                     provides a name for the program which can be used to refer
                     to it in subsequent API calls.  <parameter>def</parameter>
                     describes the configuration of the program.
                     See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                     for information about the <type>pProgramDefinition</type>
                     type which is a pointer to a <type>ProgramDefinition</type>
                     struct.
                 </para>
             </listitem>
         </varlistentry>       
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>ProgramDefinition </type>
                    <methodname>getProgramDefinition</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
             </term>
             <listitem>
                 <para>
                    Returns the <type>ProgramDefinition</type> struct for
                    an already defined program; <parameter>name</parameter>.
                 </para>
             </listitem>
         </varlistentry>       
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>modifyProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>pProgramDefinition </type>
                            <parameter>def</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
             </term>
             <listitem>
                 <para>
                    Modifies the definition of an existing program; <parameter>name</parameter>
                    to bring it in line with the description in
                    <parameter>def</parameter>.
                    To only partially modify a program definition, first use
                    <methodname>getPogtramDefinition</methodname> to get its
                    definition, then simply change the fields you want modified
                    and pass a pointer to the resulting <type>ProgramDefinition</type>
                    struct to <methodname>modifyProgram</methodname>.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>
                   <modifier></modifier>
                   <type>void</type>
                   <methodname>setEditorPosition</methodname>
                   <methodparam>
                       <modifier>const</modifier><type>char*</type>
                           <parameter>name</parameter>
                   </methodparam>
                   <methodparam>
                       <modifier></modifier><type>int</type>
                           <parameter>x</parameter>
                   </methodparam>
                   <methodparam>
                       <modifier></modifier><type>int</type>
                           <parameter>y</parameter>
                   </methodparam>
                   <modifier></modifier>
               </methodsynopsis>
               
             </term>
             <listitem>
                 <para>
                    Saves the position of an existing state sensitive program
                    on the experiment editor canvas.  This position is used to
                    layout the experiment components if when an experiment is
                    restored for further editing or viewing.
                 </para>
                 <para>
                    <parameter>name</parameter> is the name of the program being
                    modified, while <parameter>x</parameter> and <parameter>y</parameter>
                    are the new coordinates to save.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>                   
                       <modifier></modifier>
                       <type>int</type>
                       <methodname>getEditorXPosition</methodname>
                       <methodparam>
                           <modifier>const</modifier><type> char*</type>
                               <parameter>name</parameter>
                       </methodparam>
                       <modifier></modifier>
                   </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Returns the X coordinate of the editor canvas position
                    saved with the state sensitive program <parameter>name</parameter>.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>int</type>
                    <methodname>getEditorYPosition</methodname>
                    <methodparam>
                        <modifier>const</modifier><type> char*</type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>                
             </term>
             <listitem>
                 <para>
                    Returns the Y coordinate of the editor canvas position
                    saved with the state sensitive program <parameter>name</parameter>.
                 </para>
             </listitem>
         </varlistentry>       

         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>enableProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
             </term>
             <listitem>
                 <para>
                    Sets the <literal>enable</literal> flag 
                    for the program <parameter>name</parameter> to
                    <literal>true</literal>.  If this flag is <literal>false</literal>,
                    the program is not expected to participate in global state
                    transitions.  If <literal>true</literal> it is expected
                    to participate.  See also <methodname>disableProgram</methodname>.
                 </para>
             </listitem>
         </varlistentry>       
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname> disableProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
             </term>
             <listitem>
                 <para>
                    Sets the <literal>enable</literal> flag for the
                    program <parameter>name</parameter> to
                    <literal>false</literal>.If this flag is <literal>false</literal>,
                    the program is not expected to participate in global state
                    transitions.  If <literal>true</literal> it is expected
                    to participate.  See also <methodname>enableProgramm</methodname>
                 </para>
             </listitem>
         </varlistentry>           
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool</type>
                    <methodname>isProgramEnabled</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Examines the <literal>enable</literal> flag for the program
                    <parameter>name</parameter>.  Returns
                    <literal>true</literal> if the program is enabled and
                    <literal>false</literal> if not.  See
                    <methodname>enableProgram</methodname> and
                    <methodname>disableProgram</methodname> which modify
                    the state of this flag.  It is, of course, also possible
                    to modify the state of the flag using
                    <methodname>modifyProgram</methodname> as well.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setProgramStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Sets the program <parameter>name</parameter>'s
                    <literal>standalone</literal>
                    flag to <literal>true</literal>.  Programs whose
                    <literal>standalone</literal> flag is <literal>true</literal>
                    are
                 </para>
                 <itemizedlist>
                    <listitem><para>
                        Not expected to partipate in global state transitions.
                    </para></listitem>
                    <listitem><para>
                        Are expected to take their state transition requests
                        from their local state variable rather than the
                        global state variable.   This allows them to be
                        controlled independently of the global state control
                        system.
                    </para></listitem>
                 </itemizedlist>
                 <para>
                    If the <literal>standalone</literal> flag for a program
                    is <literal>false</literal>, its enable state follows the
                    state of its <literal>enable</literal> flag and is
                    expected to take state transition requests from the global
                    state variable.
                 </para>
                 <para>
                    See also <methodname>setProgramNoStandalone</methodname>
                    below
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void</type>
                    <methodname>setProgramNoStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Sets the <literal>standalone</literal> flag for the program
                    <parameter>name</parameter> to <literal>false</literal>.
                    See <methodname>setProgramStandalone</methodname> for a
                    discussion of this flag and what its possible values imply.
                 </para>
             </listitem>
         </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool</type>
                    <methodname>isProgramStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the state of the <literal>standalone</literal> flag
                    for the program <parameter>name</parameter>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listPrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector containing the name of all programs defined
                    in the current program directory. 
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listEnabledPrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector containing the name of all programs for
                    which the <literal>enabled</literal> flag is
                    <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listStandalonePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector containing the names of all programs
                    that have <literal>standalone</literal> flag set to
                    <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listInactivePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector of the names of programs that won't
                    participate in global state transitions.  These
                    are programs for which either the <literal>enable</literal>
                    flag is <literal>false</literal> or the
                    <literal>standalone</literal> flag is <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listActivePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector of the names of programs that will participate
                    in state transitions.  These are programs that have their
                    <literal>enable</literal> flag <literal>true</literal> and
                    their <literal>standalone</literal> flag <literal>false</literal>.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>deleteProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Removes the program definition for the program
                    <parameter>name</parameter>.
                </para>
            </listitem>
        </varlistentry>               
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        The <classname>CStateProgram</classname> class defines a nested struct
        type  <type>CStateProgram::ProgramDefinition</type> and a typedef for a
        pointer to that struct <type>CStateProgram::pProgramDefinition</type>.
        The <type>CStateProgram::ProgramDefinition</type> strut has the following
        fields:
      </para>
      <variablelist>
        <varlistentry>
            <term>
                <type>bool</type> <structfield>s_enabled</structfield>
            </term>
            <listitem>
                <para>
                    The program's <literal>enabled</literal> flag.  See
                    the description of e.g. <methodname>enableProgram</methodname>
                    for a description of what this flag does.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>bool</type> <structfield>s_standalone</structfield>
            </term>
            <listitem>
                <para>
                    The program's <literal>standalone</literal> flag.
                    See the description of
                    <methodname>setProgramStandalone</methodname> for a description
                    of this flag.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>std::string</type> <structfield>s_path</structfield>        
            </term>
            <listitem>
                <para>
                    Contains the filesystem path to the program image.  When
                    the boot manager starts boots the data acqusition system,
                    this field describes what it actually runs for this
                    program.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>std::string</type> <structfield>s_host</structfield>        
            </term>
            <listitem>
                <para>
                    Contains the name or IP address of the host in which the
                    program will be started by the boot manager.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>std::string</type> <structfield>s_outRing</structfield>
            </term>
            <listitem>
                <para>
                    If non empty, the program will be the producer for the
                    ring name contained by this variable.  Note this must be
                    the name of a ring in the same host as the program.
                    The experiment editor will enforce this constraint.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>std::string</type> <structfield>s_inRing</structfield>        
            </term>
            <listitem>
                <para>
                    If non empty, the program will consume data from the'
                    ring whose URI is in this field.  Note that while it's
                    legal for a program to consume data from more than one
                    ring, at present this cannot be described in this schema.
                </para>
                <para>
                    Note that programs can be ring to ring filters in the
                    sense that a program can have both an input an an output
                    ring.
                </para>
            </listitem>
        </varlistentry>
        
    

      </variablelist>
   </refsect1>
</refentry>     

<refentry id="daq3_cstatemanager">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cstatemanager_title'>CStateManager</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CStateManager</refname>
     <refpurpose>API for state manager programs.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CStateManager&gt;
       class <ooclass><classname>CStateManager</classname></ooclass>
{
    typedef struct _ProgramDefinition {
        bool        s_enabled;
        bool        s_standalone;
        std::string s_path;
        std::string s_host;
        std::string s_outRing;
        std::string s_inRing;
    } ProgramDefinition, *pProgramDefinition;

   typedef void (*TransitionCallback)(
        CStateManager&amp; mgr, std::string program, std::string state, void* cd
    );
    typedef void (*BacklogCallback)(
        CStateManager&amp; mgr, CStateTransitionMonitor::Notification Notification,
        void* cd
    );
    <constructorsynopsis>
       <methodname>CStateManager</methodname>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>requestUri</parameter>
       </methodparam>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>subscriptionUri</parameter>
       </methodparam>
       
    </constructorsynopsis>    
    <methodsynopsis>
        <modifier></modifier>
        <type>std::string       </type>
        <methodname>getProgramParentDir</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setProgramParentDir</methodname>
        <methodparam>
            <modifier>const</modifier><type>char* </type>
                <parameter>path</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>addProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>pProgramDefinition </type>
                <parameter>def</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>ProgramDefinition </type>
        <methodname>getProgramDefinition</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>modifyProgram(</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>pProgramDefinition </type>
                <parameter>def</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>enableProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>disableProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter>char* name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool  </type>
        <methodname>isProgramEnabled</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>setProgramStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>setProgramNoStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>bool   </type>
        <methodname>isProgramStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter> name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listPrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listEnabledPrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listStandalonePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listInactivePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listActivePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>deleteProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setGlobalState</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>newState</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::string </type>
        <methodname>getGlobalState</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; </type>
        <methodname>getParticipantStates</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::string </type>
        <methodname>title</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>title</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter>newTitle</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>unsigned </type>
        <methodname>timeout</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>timeout</methodname>
        <methodparam>
            <modifier></modifier><type>unsigned</type>
                <parameter> newValue</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool </type>
        <methodname>recording</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>bool </type>
        <methodname>recording</methodname>
        <methodparam>
            <modifier></modifier><type>bool</type>
                <parameter>state</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>runNumber</methodname>
        <methodparam>
            <modifier></modifier><type>unsigned </type>
                <parameter>newValue</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>runNumber</methodname>
        <void />
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>waitTransition</methodname>
        <methodparam>
            <modifier></modifier><type>TransitionCallback </type>
                <parameter>cb </parameter><initializer>0</initializer>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>void* </type>
                <parameter>clientData</parameter><initializer>0</initializer>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>processMessages</methodname>
        <methodparam>
            <modifier></modifier><type>BacklogCallback</type>
                <parameter> cb</parameter><initializer>0</initializer>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>void* </type>
                <parameter>clientData </parameter><initializer>0</initializer>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool </type>
        <methodname>isActive</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setProgramState</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>state</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::string </type>
        <methodname>getProgramState</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        <classname>CSateManager</classname> provides an API to the state
        management part of the variable database.  Since it requires
        notifications of changes to that part of the database, this class
        is meant to be used with a variable database server.
     </para>
     <para>
        The class addresses the following needs:
     </para>
     <itemizedlist>
        <listitem><para>
            Need to define, re-define, list and delete programs.
        </para></listitem>
        <listitem><para>
            Need to modify the enable and standalone flags for programs.
        </para></listitem>
        <listitem><para>
            Need to initiate and monitor global state transitions as well
            as initiating local state transitions for standalone programs.
        </para></listitem>
        <listitem><para>
            Need to process notification messages that can occur when state
            transitions are not in progress (e.g. program failures to
            <literal>NotReady</literal>).
        </para></listitem>
     </itemizedlist>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CStateManager</methodname>
                   <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>requestUri</parameter>
                   </methodparam>
                   <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>subscriptionUri</parameter>
                   </methodparam>
                   
                </constructorsynopsis>    
            </term>
            <listitem>
                <para>
                    The constructor requires
                    <parameter>requestUri</parameter>, the URI for the
                    request (REQ) port of a database server that is serving the
                    variable database whose state management system
                    we're going to manipulate.  It also requires
                    <parameter>subscriptinoUri</parameter> the URI
                    for the same server's subscription (SUB) port.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string       </type>
                    <methodname>getProgramParentDir</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Programs that are state aware are registered
                    with the state management system via variables in
                    directories that are children of a specific parent.
                    This method returns the path to that parent
                    directory.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setProgramParentDir</methodname>
                    <methodparam>
                        <modifier>const</modifier><type>char* </type>
                            <parameter>path</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    See <methodname>getProgramParentDir</methodname>,
                    this sets the parent directory for the state aware
                    program registry.  Note that use of ths allows several
                    data acquisition system configuration to co-exist in
                    the same database.   
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>addProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>pProgramDefinition </type>
                            <parameter>def</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Adds a new program to the state aware program registry.
                    The registry used is the one pointed to by the
                    curretn program parent directory.  <parameter>name</parameter>
                    is the name of the program and must be unique within that
                    registry.  <parameter>def</parameter> points to the
                    program definitions.  See
                    <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    below for a description of the
                    <type>ProgramDefinition</type>
                    struct which <type>pProgramDefinition</type> points to
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>ProgramDefinition </type>
                    <methodname>getProgramDefinition</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the definition of a specified program
                    given its <parameter>name</parameter>.
                    See
                    <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    for a description of the <type>ProgramDefinition</type>
                    struct.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>modifyProgram(</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>pProgramDefinition </type>
                            <parameter>def</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Modifies the definition of a specific program.
                    Normally this is used by first
                    invoking <methodname>getProgramDefinition</methodname>
                    both to ensure the program exists and to get it current
                    definition. The desired fields are then  modified
                    and passed to <parameter>modifyProgram</parameter>.
                </para>
                <para>
                    <parameter>name</parameter> is the name of the program
                    to modify.  This must exist in the current program registry.
                    <parameter>def</parameter> is a
                    <type>ProgramDefinition</type> pointer that points to the
                    new description of that program.
                    See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    for a description of the <type>ProgramDefinition</type>
                    struct.
                </para> 
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>enableProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Enables the program <parameter>name</parameter>.
                    Enabled non-standalone programs participate in
                    global state transitions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>disableProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter>char* name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Disables the program specified by <parameter>name</parameter>.
                    Disabled programs do not take part in state transitions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool  </type>
                    <methodname>isProgramEnabled</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns <literal>true</literal> if the program
                    <parameter>name</parameter> is enabled or
                    <literal>false</literal> otherwise.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>setProgramStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Sets a program selected by
                    <parameter>name</parameter> into standalone mode.
                    Standalone programs perform state transitions when
                    directed by their local state rather than the global
                    state.  This allows them to operate independently of the
                    system as a whole during development, testing and setup.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>setProgramNoStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Turn off the program <parameter>name</parameter>'s
                    standalone flag. with the standalone flag turned off,
                    the program, if enabled, will participate in global
                    state transitons.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool   </type>
                    <methodname>isProgramStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter> name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns <literal>true</literal> if the program
                    <parameter>name</parameter>'s standalone flag
                    is set.  If not, returns <literal>false</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listPrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a vector that contains the name of all
                    programs that are defined in the current state
                    aware programs registry.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listEnabledPrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a vector that contains the nanmes of all
                    programs that have their enable flag set to
                    <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listStandalonePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a vector that contains the names of all
                    programs that have their standalone flags
                    set to <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listInactivePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    An inactive program is one that is either
                    not enabled or has its standalone flag true.
                    This method returns a vector containing the
                    names of all inactive programs.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listActivePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector containing the names of all
                    programs that are not inactive (see
                    <methodname>listInactivePrograms</methodname>), that is
                    all programs that are active.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>deleteProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Deletes the program <parameter>name</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setGlobalState</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>newState</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Sets the global state to <parameter>newState</parameter>.
                    In general this initiates a state transition.  All
                    participating (active) programs will perform a set of
                    operations that, if successful will bring them and the
                    global state into the next steady state.
                </para>
                <para>
                    See <methodname>waitStateTransition</methodname> for information
                    on how to monitor the global state transition and know if
                    it succeeded, timed out or failed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string </type>
                    <methodname>getGlobalState</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the current global state name.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; </type>
                    <methodname>getParticipantStates</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    For each active program returns a pair containing in order the
                    program's name and its local state.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string </type>
                    <methodname>title</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the current title string.  This string is global
                    data that active programs can associate with data taking
                    runs.  The use of this string is entirely up to the program.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>title</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter>newTitle</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Changes the global title string.  This should normally
                    only be done when the system is not in the middle
                    of a data taking run.  This includes the states:
                    <literal>0Initial</literal>, <literal>NotReady</literal>
                    <literal>Readying</literal>, and <literal>Ready</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>unsigned </type>
                    <methodname>timeout</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Global state transitions must settle to the
                    proper final state within a timeout.  This
                    method returns the number of seconds in that timeout.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>timeout</methodname>
                    <methodparam>
                        <modifier></modifier><type>unsigned</type>
                            <parameter> newValue</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Sets the new state transition timeout to
                    <parameter>newValue</parameter> seconds.  This
                    must be a number that is at least <literal>1</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool </type>
                    <methodname>recording</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the state of the global recording flag.  Participant
                    programs that are data loggers can use this to determine
                    whether or not to record data from a run.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool </type>
                    <methodname>recording</methodname>
                    <methodparam>
                        <modifier></modifier><type>bool</type>
                            <parameter>state</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Sets the new state of the global recording flag.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>runNumber</methodname>
                    <methodparam>
                        <modifier></modifier><type>unsigned </type>
                            <parameter>newValue</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Modifies the value of the global run number. The run number
                    is an integer that participant programs can associate with
                    a data taking run.  The new run number, which must be
                    a positive integer is <parameter>newValue</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>runNumber</methodname>
                    <void />
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the current value of the global run number.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>waitTransition</methodname>
                    <methodparam>
                        <modifier></modifier><type>TransitionCallback </type>
                            <parameter>cb </parameter><initializer>0</initializer>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>void* </type>
                            <parameter>clientData</parameter><initializer>0</initializer>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Waits for a state transition to either complete, time
                    out or fail.  If <parameter>cb</parameter> is supplied
                    and non null, it must be a function pointer. The
                    function is invoked for each program state transition.
                    The <parameter>clientData</parameter> parameter is
                    passed to that callback without interpretation.
                </para>
                <para>
                    See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    for a description of the <type>TransitionCallback</type>
                    function type and how it is called.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>processMessages</methodname>
                    <methodparam>
                        <modifier></modifier><type>BacklogCallback</type>
                            <parameter> cb</parameter><initializer>0</initializer>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>void* </type>
                            <parameter>clientData </parameter><initializer>0</initializer>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Each state manager has a thread that is responsible
                    for processing subscription messages into a queue.
                    These messages, among other things, inform the program
                    of state transitions.
                </para>
                <para>
                    When called, this method processes all messages in the
                    message queue backlog.  If a <parameter>cb</parameter>
                    is supplied it is called for each message.
                    See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    for a description of the <type>BacklogCallback</type> function
                    pointer data type and how those functions are called.
                    The <parameter>clientData</parameter> parameter is
                    passed to the callback without any interpretation.
                </para>
                <para>
                    It is important to call this from time to time to ensure
                    that the message queue does not expand without bound.
                    If your application is interested in knowing about
                    programs joining, leaving or failing supplying the
                    <parameter>cb</parameter> parameter makes that possible.   
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool </type>
                    <methodname>isActive</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    If the program <parameter>name</parameter> is active
                    this method returns <literal>true</literal> otherwise
                    it returns <literal>false</literal>,
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setProgramState</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>state</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Used to set the state of a specific program. This is
                    normally used when either the program is standalone,
                    to drive it, or if it was detected that the program
                    exited without setting its state to <literal>NotReady</literal>.
                </para>
                <para>
                    <parameter>name</parameter> is the name of the program and
                    <parameter>state</parameter> is the desired new state.
                    Naturally the legal values for <parameter>state</parameter>
                    are constrained by the legal state transitions from the
                    program's current state.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string </type>
                    <methodname>getProgramState</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the current local state of the program
                    <parameter>name</parameter>
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
        <para>
            The <classname>CStateManager</classname> defines
            three types.  Two of these are callback function
            prototypes, the last is a structure definition that
            describes a program.
        </para>
        <refsect2>
            <title>TransitionCallback</title>
            <para>
                This function prototype specifies the call signature
                of functions called back from the
                <methodname>waitTransition</methodname> method.
                The callback function must be of type <type>void</type>
                and takes parameters in the following order:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>CStateManager&amp;</type> <parameter>mgr</parameter></term>
                    <listitem>
                        <para>
                            Reference to the state manager that is doing
                            the callback.  This allows the callaback to
                            access the featurs and services of that
                            state manager.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <parameter>program</parameter></term>
                    <listitem>
                        <para>
                            The name of the program that has just taken
                            a local state transition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <parameter>state</parameter></term>
                    <listitem>
                        <para>
                            That program's new state.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>void*</type> <parameter>cd</parameter></term>
                    <listitem>
                        <para>
                            The callback data parameter passed to
                            <methodname>waitTransition</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
        <refsect2>
            <title>BacklogCallback</title>
            <para>
                This function prototype represents functions that can be
                called back from <methodname>processMessages</methodname>.
                This function is of type <type>void</type> and has, in order,
                the following parameters:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>CStateManager&amp;</type> <parameter>mgr</parameter></term>
                    <listitem>
                        <para>
                            The <classname>CStateManager</classname> that is
                            performing this callback.  This allows the called
                            function to make use of the services of this class.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>CStateTransitionMonitor::Notification</type> <parameter>not</parameter></term>
                    <listitem>
                        <para>
                            The notification structure that describes the message
                            that is being processed. See
                            <link linkend='daq3_cstatetransitionmonitor'
                                  endterm='daq3_cstatetransitionmonitor_title'
                                  />
                            for more information about this struct.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>void*</type> <parameter>cd</parameter></term>
                    <listitem>
                        <para>
                            Callback data passed to
                            <methodname>processMessages</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
        <refsect2>
            <title>ProgramDefinition</title>
            <para>
                This data type is a struct that defines a program.
                It has the following fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>bool</type> <structfield>s_enabled</structfield></term>
                    <listitem>
                        <para>
                            This is true if the program is enabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>bool</type> <structfield>s_standalone</structfield></term>
                    <listitem>
                        <para>
                            This should be true if the program runs in standalone
                            mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_path</structfield></term>
                    <listitem>
                        <para>
                            Path to the program to run.  This is used by he boot
                            manager to start the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_host</structfield></term>
                    <listitem>
                        <para>
                            The host in wich the program runs.  This is used by the
                            boot manager to start the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_outRing</structfield></term>
                    <listitem>
                        <para>
                            If the program is a ring buffer producer, this
                            should be set to the desired output ring name.
                            The program should honor this so that the
                            data flow can be set up by the experiment
                            defnition editor.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_inRing</structfield></term>
                    <listitem>
                        <para>
                            If the program is a consumer of ring buffer data,
                            this should be set to the URI of the ring from
                            which data is taken.   The program should honor
                            this setting so that the data flow can be setup
                            by the experiment definition editor.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
   </refsect1>
</refentry>     

<!-- /manpage -->

<!-- manpage 3tcl -->

      <refentry id="tcl3_statemanager">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='tcl3_statemanager_title'>statemanager</refentrytitle>
           <manvolnum>3tcl</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>statemanager</refname>
           <refpurpose>Tcl Bindings to the CStateManager class.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <synopsis>
lappend auto_path [file join $::env(DAQROOT) TclLibs]
package require stateclient

::nscldaq::statemanager mgr requri ?suburi?
::nscldaq::statemanager -delete mgr

mgr programParentDir ?newpath?
mgr setProgramState  name newstate

mgr addProgram       name programDict
set programDict [mgr getProgram name]
mgr modifyProgram    name programDict

mgr setEditorPosition name x y
set x [mgr getEditorXPosition name]
set y [mgr getEditorYPosition name]

mgr enableProgram    name
mgr disableProgram   name
if {[mgr isProgramEnabled name]} {...}

mgr setStandalone    name
mgr setNoStandalone  name
if {[mgr isStandalone name]} {...}

foreach program [mgr listPrograms] {...}
foreach program [mgr listEnabledPrograms] {...}
foreach program [mgr listStandalonePrograms] {...}
foreach program [mgr listActivePrograms] {...}
foreach program [mgr listInactivePrograms] {...}

mgr deleteProgram name

mgr setGlobalState newState
set state [mgr getGlobalState]

set partDict [mgr getParticipantStates]

mgr title ?newTitle?
mgr timeout ?newTimeout?
mgr recording ?newRecordingState?
mgr runNumber ?newRunNumber?

mgr waitTransition ?callback?

mgr processMessages ?callback?

if {[mgr isActive name]} {...}
set state [mgr getProgramState name]

          </synopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides a Tcl binding to
            <link linkend='daq3_cstatemanager'
                  endterm='daq3_cstatemanager_title' />
            The binding is implemented via a construction command
            which produces a command ensemble that wraps an instance
            of a <classname>CStateManager</classname>.
            Subcommands of he ensemble base command map directly to
            methods in the underlying <classname>CStateManager</classname>
            object.
           </para>
           <para>
            An ensemble is constructed via a command of the form:
           </para>
           <informalexample>
            <cmdsynopsis>
            <command>
::nscldaq::statemanager <replaceable>mgr requri ?suburi?</replaceable>
            </command>
            </cmdsynopsis>
           </informalexample>
           <para>
            <parameter>mgr</parameter> is the name of a new command
            that is created by this command.
            <parameter>requri </parameter> and <parameter>suburi</parameter>
            are the URI's that describe the REQ and SUB ports respectively
            of a variable database server that is managing the variable
            database that we want to connect to.
           </para>
           <para>
            If only the REQ URI is provided, the api ensemble can connect to
            a <literal>file:</literal> URI designating the database file.
            If only the REQ URI is provided
            only some of the subcommands described are legal.
            See <literal>ENSEMBLE SUBCOMMANDS</literal> for information
            about which commands are not legal when a single URI is used.
           </para>
           <para>
            An ensemble created in this way is destroyed by:
           </para>
           <informalexample>
            <cmdsynopsis>
                <command>
::nscldaq::statemanager -delete <replaceable>mgr</replaceable>
                </command>
            </cmdsynopsis>
           </informalexample>
           <para>
            Where <parameter>mgr</parameter> is the name of the command
            ensemble previously created by the
            <command>::nscldaq::statemanager</command> command.
           </para>
        </refsect1>
        <refsect1>
           <title>
              ENSEMBLE SUBCOMMANDS
           </title>
           <variablelist>
            <varlistentry>
                <term>
                    <command>mgr programParentDir ?newpath?</command>
                </term>
                <listitem>
                    <para>
                        Without the <parameter>newpath</parameter> optional
                        parameterk this returns the path to the current
                        program parent diretory.  With the parameter it
                        sets a new program parent path.
                        <parameter>newpath</parameter> must be a path
                        to an existing directory in the variable database.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setProgramState  name newstate</command>
                </term>
                <listitem>
                    <para>
                        Changes the local state of a specific program.
                        The program is <parameter>name</parameter>
                        which is assigned the <parameter>newstate</parameter>.
                        Naturally <parameter>newstate</parameter> must
                        be compatible with the set of target states
                        allowed given the current state.
                    </para>
                    <para>
                        This is normally used to modfiy the state of
                        standalone programs or, if a program has crashed,
                        to set its state to <literal>NotReady</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>mgr addProgram       name programDict</command></term>
                <listitem>
                    <para>
                        Adds a new program; <parameter>name</parameter> to
                        the system. <parameter>name</parameter> must be
                        unique.  The <parameter>programDict</parameter>
                        is a dict that describes the new program.
                        It has the following key/value pairs:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>path</literal> (required)</term>
                            <listitem>
                                <para>
                                    The path to the program to run.  This is
                                    used by the boot manager to start the
                                    program.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>host</literal> (required></term>
                            <listitem>
                                <para>
                                    The host in which the program should be run.
                                    This is used by the boot manager to starty
                                    the program.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>enabled</literal></term>
                            <listitem>
                                <para>
                                    Optional parameter that defaults to
                                    <literal>true</literal>.  Determines the
                                    initial enable state of the program.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>standalone</literal></term>
                            <listitem>
                                <para>
                                    Optional parameter that defaults to
                                    <literal>false</literal>.  Determines
                                    the initial state of the standalone flag
                                    of the program.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>outring</literal></term>
                            <listitem>
                                <para>
                                    Optional parameter that defaults to an
                                    empty string.  If the program is data
                                    producer for a ring buffer this should be the
                                    name of that ring (not URI).
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>inring</literal></term>
                            <listitem>
                                <para>
                                    Optional parameter that defaults to an
                                    empty string.  If the program is a data
                                    consumer froma  ring, this shold
                                    be the URI of that ring.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr getProgram name</command>
                </term>
                <listitem>
                    <para>
                        Returns a dict that describes the program
                        <parameter>name</parameter>.  The dict is described
                        in <command>addProgram</command> above.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr modifyProgram    name programDict</command>
                </term>
                <listitem>
                    <para>
                        Modifies the program <parameter>name</parameter>
                        in accordance with the <parameter>programDict</parameter>
                        parameter.  This dictionary is described in
                        <command>addProgram</command> above.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setEditorPosition name x y</command>
                </term>
                <listitem>
                    <para>
                        Sets the canvas position associated with the program
                        <parameter>name</parameter> to <parameter>x</parameter>,
                        <parameter>y</parameter>.  This position is normally saved
                        by the experiment dataflow editor and used when restoring
                        a setup to layout the diagram elements as they were
                        before.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>set x [mgr getEditorXPosition name]</command>                    
                </term>
                <listitem>
                    <para>
                        Retrieves the x coordinate of the editor canvas
                        position for the program <parameter>name</parameter>.
                        See <command>setEditorPosition</command> for more
                        about this value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>set y [mgr getEditorYPosition name]</command>
                </term>
                <listitem>
                    <para>
                        Retrieves the y coordinate of the editor canvas position
                        for the program <parameter>name</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr enableProgram    name</command>
                </term>
                <listitem>
                    <para>
                        Enables the program <parameter>name</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr disableProgram   name</command>
                </term>
                <listitem>
                    <para>
                        Disables the program <parameter>name</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr isProgramEnabled name</command>
                </term>
                <listitem>
                    <para>
                        Returns true if <parameter>name</parameter>
                        is an enabled program.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setStandalone    name</command>
                </term>
                <listitem>
                    <para>
                        Set the program <parameter>name</parameter>
                        to standalone mode.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setNoStandalone  name</command>
                </term>
                <listitem>
                    <para>
                        Take the program <parameter>name</parameter>
                        out of standalone mode.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr isStandalone name</command>
                </term>
                <listitem>
                    <para>
                        Returns true if the program <parameter>name</parameter>
                        is in standalone mode.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listPrograms</command>
                </term>
                <listitem>
                    <para>
                        Returns a list of the names of all programs
                        in the current program directory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listEnabledPrograms</command>
                </term>
                <listitem>
                    <para>
                        Returns a list of the names of all programs
                        that are enabled.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listStandalonePrograms</command>
                </term>
                <listitem>
                    <para>
                        Returns a list of the names of programs that are
                        standalone.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listActivePrograms</command>
                </term>
                <listitem>
                    <para>
                        Returns a list of the names of programs  that
                        are active.  A program is active if it is enabled
                        and not standalone; that is it will participate in
                        global state transitions.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listInactivePrograms</command>
                </term>
                <listitem>
                    <para>
                        Return a list of the names of programs that are
                        not active.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr deleteProgram name</command>
                </term>
                <listitem>
                    <para>
                        Deletes the program <parameter>name</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setGlobalState newState</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Set the global state to <parameter>newState</parameter>.
                        The <parameter>newState</parameter> must be a legal
                        next state for the current global state value.
                        In general, this command will initiate a global
                        state transition.  See <command>waitTransition</command>
                        for information about how to monitor that
                        state transition for success and progress.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr getGlobalState</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Returns the current value of the global state
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr getParticipantStates</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Returns a dict.  The dict keys are the
                        names of participant (active) programs.
                        Their values are the states of those programs.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr title ?newTitle?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        If <parameter>newTitle</parameter> is not supplied,
                        this returnst the current title string. If
                        <parameter>newTitle</parameter> is supplied, that
                        becomes the new title string..
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr timeout ?newTimeout?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        If <parameter>newTimeout</parameter> is not
                        supplied, the command returns the current state
                        transition timeout in seconds.  If
                        <parameter>newTimeout</parameter> is supplied,
                        it must be an integer greater than zero and
                        becomes the new state transition timeout.
                        
                    </para>
                    <para>
                        Note that state transition timeouts are enforced
                        by <command>waitTransition</command>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr recording ?newRecordingState?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        If <parameter>newRecordingState</parameter> is
                        supplied it becomes the new recording state flag (must
                        be a boolean).  If not, this command returns the
                        value of the current recording state..
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr runNumber ?newRunNumber?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        If <parameter>newRunNumber</parameter> is supplied
                        it becomes the new run number.  If not this command
                        returns the current run number value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr waitTransition ?callback?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Waits for an in progress transition to complete.
                        The command returns a true value if the transition
                        completed successfully and a false value if not.
                    </para>
                    <para>
                        If <parameter>callback</parameter> is supplied it must
                        be a script that is invoked for every program
                        state transition that is observed.  The name of the
                        program and its new state are appended to the
                        callback.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>
                        mgr processMessage ?callback?    
                    </command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Drains the message queue of subscribed messages.
                        If <parameter>callback</parameter> is supplied,
                        it is invoked for each messsage.
                    </para>
                    <para>
                        A dict is appended to the callback that contains
                        the some of following key value pairs:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>type</literal></term>
                            <listitem>
                                <para>
                                    The type of message.  This is one of
                                    <literal>GlobalStateChange</literal>,
                                    <literal>ProgramStateChange</literal>
                                    <literal>ProgramJoins</literal> or
                                    <literal>ProgramLeaves</literal> with
                                    pretty obvious meanings.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>state</literal></term>
                            <listitem>
                                <para>
                                    This is present for either
                                    <literal>GlobalStateChange</literal> or
                                    <literal>ProgramStateChange</literal>.
                                    It contains the new state (global or program).
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>program</literal></term>
                            <listitem>
                                <para>
                                    Contains the name of the program involved.
                                    This is present for:
                                    <literal>ProgramStateChange</literal>
                                    <literal>ProgramJoins</literal> or
                                    <literal>ProgramLeaves</literal>.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>mgr isActive name</command></term>
                <listitem>
                    <para>
                        Retruns true if the program <parameter>name</parameter>
                        is active.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>getProgramState name</command></term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Returns the current program state for
                        <parameter>name</parameter>.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>


<!-- /manpage -->


<!-- manpage 3python -->

<refentry id="python3_statemanager">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='python3_statemanager_title'>statemanager</refentrytitle>
     <manvolnum>3python</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>statemanager</refname>
     <refpurpose>Python bindings for CStateManager class.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
import nscldaq.vardb.statemanager
mgr = nscldaq.vardb.statemanager.Api(reqUri[, subUri])
mgr.getProgramParentDir()
mgr.setProgramParentDir(path)
mgr.addProgram(name, description)
mgr.getProgramDefinition(name)
mgr.modifyProgram(name, description)
mgr.setEditorPosition(name, x, y)
mgr.getEditorXPosition(name)
mgr.getEditorYPosition(name)
mgr.enableProgram(name)
mgr.disableProgram(name)
mgr.isProgramEnabled(name)
mgr.setProgramStandalone(name)
mgr.setProgramNoStandalone(name)
mgr.isProgramStandalone(name)
mgr.listPrograms()
mgr.listEnabledPrograms()
mgr.listStandalonePrograms()
mgr.listInactivePrograms()
mgr.listActivePrograms()
mgr.deleteProgram(name)
mgr.setGlobalState(newState)
mgr.getGlobalState()
mgr.getParticipantStates()
mgr.getTitle()
mgr.setTitle(title)
mgr.getTimeout()
mgr.setTimeout(timeout)
mgr.isRecording()
mgr.setRecording(flag)
mgr.getRunNumber()
mgr.setRunNumber(number)
mgr.waitTransition(callable, arg)
mgr.processMessages(callable, arg)
mgr.isActive(name)
mgr.setProgramState(name, state)
mgr.getProgramState(name)


   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This module provides a Python binding to the
        <link linkend='daq3_cstatemanager'
              endterm='daq3_cstatemanager_title' />.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                nscldaq.vardb.statemanager.Api(reqUri[, subUri])
            </term>
            <listitem>
                <para>
                    Constructs a new state manager API object.
                    <parameter>reqUri</parameter> is the URI
                    of a variable manager's REQ port.
                    <parameter>subUri</parameter> is the
                    URI of the same variable manager's SUB port.
                </para>
                <para>
                    If the optional <parameter>subURI</parameter> is missing
                    several methods will be disabled (an exception raised if used).
                    In that case, the state manager object can specify a
                    <literal>file:</literal> protocol URI, and directly access
                    the database file, or a <literal>tcp:</literal> protocol
                    URI and access the database through a server.
                </para>
                <para>
                    Methods that are disabled with a single URI in the constructor
                    will be flagged in their descriptions below.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getProgramParentDir()
            </term>
            <listitem>
                <para>
                    Return the path to the current program parent directory.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setProgramParentDir(path)
            </term>
            <listitem>
                <para>
                    Sets the path to the new program parent directory to be
                    <parameter>path</parameter>.  This should be the path to an
                    already existing directory in the variable database.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.addProgram(name, description)
            </term>
            <listitem>
                <para>
                    Adds a program named <parameter>name</parameter>
                    to the system.  <parameter>description</parameter>
                    is a dictionary that describes the program.
                    <parameter>description</parameter> has the following key
                    value pairs.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>enabled</literal></term>
                        <listitem>
                            <para>
                                Defaults to true.  If true the
                                program is created enabled.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>standalone</literal></term>
                        <listitem>
                            <para>
                                Defaults to false.  If true, the program
                                is created standalone.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>path</literal></term>
                        <listitem>
                            <para>
                                Required.  The path to the program to run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>host</literal></term>
                        <listitem>
                            <para>
                                Required.  The host in which the program runs.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>outring</literal></term>
                        <listitem>
                            <para>
                                Optional.  If the program is to produce output
                                into a ringbuffer, this is the name of the
                                ringbuffer into which that data should be put.
                                Default value is the empty string.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>inring</literal></term>
                        <listitem>
                            <para>
                                Optional.  If the program is to consume data from
                                a ringbuffer, this is the URI of the ring.
                                Default value is the empty string.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <command>mgr.setEditorPosition(name, x, y)</command>
            </term>
            <listitem>
                <para>
                    Saves the canvas position of the program selected by
                    <parameter>name</parameter>.  The saved coordinates
                    will be <parameter>x</parameter>,<parameter>y</parameter>.
                    This is normally used by the experiment editor to allow it
                    to restore a diagram to the original layout rather than
                    having to compute a layout.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <command>mgr.getEditorXPosition(name)</command>
            </term>
            <listitem>
                <para>
                    Returns the X coordinate of the editor position currently
                    held by <parameter>name</parameter>.   See
                    <command>setEditorPosition</command> for more information on
                    this value and what it means.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <command>mgr.getEditorYPosition(name)</command>
            </term>
            <listitem>
                <para>
                    Return the Y coordinate of the currently saved editor position
                    for <parameter>name</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getProgramDefinition(name)
            </term>
            <listitem>
                <para>
                    Returns the program definition dictionary that
                    describes the program <parameter>name</parameter>.
                    The keys and values are described in
                    <methodname>addProgram</methodname> above.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.modifyProgram(name, description)
            </term>
            <listitem>
                <para>
                    Modifies the descriptionof a program.  <parameter>name</parameter>
                    names the program and <parameter>description</parameter>
                    is a dict that provides a new program definition.
                    The dict is described in
                    <methodname>addProgram</methodname>.
                </para>
                <para>
                    A very normal usage pattern is to first use
                    <methodname>getProgramDefinition</methodname> to obtain
                    the definition of the program.  Second change the specifid
                    items you want to change and finally, use
                    <methodname>modifyProgram</methodname> to update the
                    program definition.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.enableProgram(name)
            </term>
            <listitem>
                <para>
                    Enables the program <parameter>name</parameter>.  Enabled
                    programs participate in  state changes.  If they are
                    not standalone, they participate in global tate changes.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.disableProgram(name)
            </term>
            <listitem>
                <para>
                    Disables the program <parameter>name</parameter>.
                    Disabled programs don't participate in state changes.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.isProgramEnabled(name)
            </term>
            <listitem>
                <para>
                    Returnes <literal>True</literal> if
                    <parameter>name</parameter> is enabled else returns
                    <literal>False</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setProgramStandalone(name)
            </term>
            <listitem>
                <para>
                    Sets the program <parameter>name</parameter> into standalone mode
                    Enabled programs in standalone mode only take state transitions
                    from their local state variable.  This allows them to be
                    run in isolation, without participating in global state
                    transitions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setProgramNoStandalone(name)
            </term>
            <listitem>
                <para>
                    Sets the program <parameter>name</parameter> out of
                    standalone mode.  This means that if the program is enabled
                    it will participate in global state transitions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.isProgramStandalone(name)
            </term>
            <listitem>
                <para>
                    Returns <literal>True</literal> if the program
                    <parameter>name</parameter> is in standalone mode
                    else returns <literal>False</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                 mgr.listPrograms()
            </term>
            <listitem>
                <para>
                    Returns a list that contains the names of all the
                    programs that are known to the state transition system.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.listEnabledPrograms()
            </term>
            <listitem>
                <para>
                    Returns a list of the names of all enabled programs. 
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.listStandalonePrograms()
            </term>
            <listitem>
                <para>
                    Returns a list of the names of all standalone programs.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.listInactivePrograms()
            </term>
            <listitem>
                <para>
                    Return a list of the names of all inactive programs.
                    A programs is inactive if it does not participate in
                    global state transitions.  This can be either because
                    it is disabled or because it is standalone.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.listActivePrograms()
            </term>
            <listitem>
                <para>
                    Returns a list of the names of all programs that are
                    active.  Active programs are those that participate in
                    global state transitions because they are both
                    enabled an <emphasis>not</emphasis> standalone.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.deleteProgram(name)
            </term>
            <listitem>
                <para>
                    Deletes the definition for the program <parameter>name</parameter>.
                    This action is irreversible.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setGlobalState(newState)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the new global state value to <parameter>newState</parameter>.
                    This value must be a valid next state for the current state.
                    If successful, in general, this initiates a global state
                    transition in which all active programs participate.
                    You can determine the success of this transition as well
                    as monitor its progress via <methodname>waitTransition</methodname>
                    described below.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getGlobalState()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the current global state.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getParticipantStates()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns a dict whose keys are program names and whose values
                    are the state that program is in.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getTitle()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the current title string.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setTitle(title)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the title string to the new value <parameter>title</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getTimeout()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the global state transition timeout value in seconds.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setTimeout(timeout)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the global state transition timeout to <parameter>timeout</parameter>
                    seconds.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.isRecording()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns <literal>True</literal> if the recording flag
                    is true.  <literal>False</literal> otherwise.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setRecording(flag)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the recording flag to the state of the
                    boolean <parameter>flag</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getRunNumber()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the current integer value of the run number.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setRunNumber(number)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Set the run number to the unsigned positive value
                    <parameter>number</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.waitTransition(callable, arg)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Waits for global transitions to either succeed, fail or
                    timeout.  If the <parameter>callable</parameter> is
                    supplied, it is called for each participant state
                    transition.  The callable is passed:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>Api</term>
                        <listitem>
                            <para>
                                The api object that is doing the
                                <methodname>waitTransition</methodname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>program</term>
                        <listitem>
                            <para>
                                The name of the transitioning program.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>state</term>
                        <listitem>
                            <para>
                                That program's new state.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            arg
                        </term>
                        <listitem>
                            <para>
                                The <parameter>arg</parameter> passed
                                to the <methodname>waitTransition</methodname>
                                method.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
                <para>
                    The method returns <literal>True</literal> if the
                    transition succeeded or <literal>False</literal> if not.
                    Transitions can fail due to a timeout or can fail if a
                    program changes state to <literal>NotReady</literal>
                    indicating it could not complete its part of the
                    global state transition.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.processMessages(callable, arg)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Process all messages in the subscription message backlog.
                    If <parameter>callable</parameter> is provided it is
                    called for each message processed and receives the
                    following parameters:
                    
                </para>
                <variablelist>
                    <varlistentry>
                        <term>api</term>
                        <listitem>
                            <para>
                                The api object that is executing the
                                <methodname>processMessages</methodname>
                                method.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>notDict</term>
                        <listitem>
                            <para>
                                A notification dictionary (see
                                <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                                for more information about this).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>arg</term>
                        <listitem>
                            <para>
                                The <parameter>arg</parameter> parameter
                                passed to <methodname>processMessages</methodname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.isActive(name)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns <literal>True</literal> if the program
                    <parameter>name</parameter> is active.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setProgramState(name, state)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the program state for <parameter>name</parameter>
                    to <parameter>state</parameter>.  The <parameter>state</parameter>
                    parameter must be a valid next state for the
                    program's current state. 
                </para>
                <para>
                    This method is normally used to make a state transition
                    in a standalone program
                    and to make the state of a program that crashed badly
                    <literal>NotReady</literal> once that has been noticed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>mgr.getProgramState(name)</term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the name of the program <parameter>name</parameter>'s
                    current state.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        This class offers two dictionary types that are important, the
        notification dictionary and the program description dictionary.
      </para>
        <refsect2>
            <title>Notification dictionary</title>
            <para>
                Dictionaries of this type are passed in to the
                notification callback callable in calls to
                <methodname>processMessages</methodname>.  These dicts
                represent the information in a notification message.
            </para>
            <para>
                The <literal>type</literal> key is always present
                and contains a string that describes the notification
                type.  The notification type determines which other keys
                are present.  The possible other keys are
                <literal>state</literal> which is either the global state
                or a program state, and <literal>program</literal>
                which is a program name.
            </para>
            <para>
                Here are the notification types and the keys that are provided
                with them.
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>GlobalStateChange</literal></term>
                    <listitem>
                        <para>
                            The message notifies you of a global state change.
                            <literal>state</literal> is the only other key
                            in the dictionary and it represents the new state.
                            This may mean some other program is forcing a
                            state transition. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <literal>ProgramStateChange</literal>
                    </term>
                    <listitem>
                        <para>
                            A program's state has changed.
                            <literal>program</literal> will contain the
                            name of the program and <literal>state</literal>
                            the new state name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ProgramJoins</literal></term>
                    <listitem>
                        <para>
                            Indicates a new program is being added to the
                            system.  <literal>program</literal> is the
                            name of the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>PorgramLeaves</literal></term>
                    <listitem>
                        <para>
                            A program has left the system (been deleted).
                            <literal>program</literal> is the name of the
                            program that left.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Program description dictionary</title>
            <para>
                This dictionary is used to describe programs.  It is used
                by <methodname>addProgram</methodname> and
                <methodname>modifyProgram</methodname>
                and also is returned by <methodname>getProgramDefinition</methodname>.
                The dictionary has the following keys:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>enabled</literal></term>
                    <listitem>
                        <para>
                            Boolean value that is the state of the enable
                            flag for the program.  If the user does not
                            provide this it defaults to <literal>True</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>standalone</literal></term>
                    <listitem>
                        <para>
                            Boolean value that is the state of the
                            standalone flag for the program.  If the user
                            does not provide this it defaults to
                            <literal>False</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>path</literal></term>
                    <listitem>
                        <para>
                            A string value that is the filesystem path
                            in which the program is installed.  This
                            is required and is used by the boot manager
                            to start the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>host</literal></term>
                    <listitem>
                        <para>
                            A string which is either the IP address or the
                            DNS hostname of the system on which the program
                            should run.  Again this is used by the boot manager
                            when starting the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>outring</literal></term>
                    <listitem>
                        <para>
                            This defaults to an empty string.  If the program
                            produces output in a ring buffer, it should
                            use this value to get the name of the ring buffer
                            it uses for output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>inring</literal></term>
                    <listitem>
                        <para>
                            This defaults to an empty string.  If the
                            program should be a consumer of data from a
                            ringbuffer it should use this value to get the
                            URI of the ring.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
   </refsect1>
</refentry>     

<!-- /manpage -->
=======
<!-- chapter utilities -->

<chapter id='chap.statemgr'>
    <title id='chap.statemgr.title'>The state manager</title>
    <para>
        The state manager is a program that manages and enforces the experiment
        state diagram.  It also provides a mechanism for external programs to:
        <itemizedlist>
            <listitem><para>
                Request state transitions
                </para></listitem>
            <listitem><para>
                Become aware of the current state
                </para></listitem>
            <listitem><para>
                Be notified of state transitions.
                </para></listitem>
        </itemizedlist>
    </para>
    <para>
        The state diagram that is enforced by the state manager is shown below:
    </para>
    <figure id='statemgr_statediagram'>
        <title id='statemgr_statediagram_title'>Experiment (State manager) State Diagram</title>
        <mediaobject>
           <imageobject>
                <imagedata fileref='statediagram.jpg' format='JPEG' />
            </imageobject>
        </mediaobject>
    </figure>
    <para>
        Here's a description of the states and the possible transitions out
        of each state.
    </para>
    <variablelist>
        <varlistentry>
            <term><literal>NotReady</literal></term>
            <listitem>
                <para>
                    This state means that the experiment has been defined
                    but that one or more pieces have not yet been started.
                    The <literal>BOOT</literal> transition implies an intent
                    to start all of the pieces that make up the experiment.
                    The <literal>BOOT</literal> transition places the experiment
                    in the <literal>Booting</literal> state.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><literal>Booting</literal></term>
            <listitem>
                <para>
                    This state implies the pieces that make up the experiment
                    are being started.
                    The Boot manager described in
                    <link linkend='chap.boot' endterm='chap.boot.title' />
                    responds to entering this state by
                    creating rings and starting programs defined by a list of
                    experiment created by the experiment configuration editor
                    described in
                    <link linkend='chap.expconfig' endterm='chap.expconfig.title' />.
                </para>
                <para>
                    The <literal>READY</literal> transition indicates a successful
                    start of all of the components.  the <literal>FAIL</literal>
                    transition indicates that at least one component could not
                    be created.  If the boot manager is used it will initiate
                    a <literal>FAIL</literal> transition if it detects an error
                    while creating the experiment components.
                    It will also initiate a <literal>READY</literal> transition
                    if all of the components started correctly.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><literal>Ready</literal></term>
            <listitem>
                <para>
                    Indicates that the experiment is ready to take data but
                    is not yet taking data.  If the boot manager is being used,
                    it monitors the programs it started and if any of them exit
                    (normally or abnormally), it intiates a <literal>FAIL</literal>
                    transition and shuts down all of the programs it is managing.
                </para>
                <para>
                    The <literal>BEGIN</literal> transition indicates a desire
                    to start taking data.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><literal>Active</literal></term>
            <listitem>
                <para>
                    Means that the experiment is acquiring data.  If any component
                    fails or if any component was not able to start taking data
                    due to an unrecoverable error, it can initiate a
                    <literal>FAIL</literal> transition taking the program back
                    to the <literal>NotReady</literal> state.
                </para>
                <para>
                    The <literal>END</literal> transition indicates a desire
                    to stop taking data and makes the transition to the
                    <literal>Ready</literal> state.
                </para>
            </listitem>
        </varlistentry>
        
    </variablelist>
    <para>
        The state diagram enforces this diagram.  For example, it will refuse
        to respond to a <literal>BOOT</literal> request while in the
        <literal>Ready</literal> state, returning an error condition if that
        request is made.
    </para>
    <para>
        To run the state manager, you must first define some environment variables.
        This is done sourcing the <filename>dasetup.bash</filename> script
            from the root of the installation directory for your DAQ distribution.
        </para>
        <para>
            If, for example, NSCLDAQ is installed in /usr/opt/daq/11.0:
        </para>
        <informalexample>
            <programlisting>
. /usr/opt/daq/11.0/daqsetup.bash
            </programlisting>
        </informalexample>
        <para>
            makes the necessary environment variable definitions.
        </para>
        <para>
            Once the <filename>daqsetup.bash</filename> script has been run,
            you can start up the experiment configuration tool via the command:
        </para>
        <informalexample>
            <programlisting>
$DAQBIN/statemanager
            </programlisting>
        </informalexample>
        <para>
            The state manager obtains and registers two ports named
            <literal>StatePublish</literal> and <literal>StateRequest</literal>
            from the NSCLDAQ port manager.
        </para>
    <section>
        <title>Application Programming Interfaces to the state manager</title>
        <para>
            By itself, the state manager does nothing.  Its value is in its
            interactions with other programs.
            <itemizedlist>
                <listitem><para>
                    The state manager provides a <firstterm>Transition request port</firstterm>.
                    Clients can connect to that port and request one or more
                    transitions.
                    </para></listitem>
                <listitem><para>
                    The state manager also provides a <firstterm>Transition subscription port</firstterm>.
                    Clients can use that port to monitor the current state as well
                    as state transitions.
                    </para>
                    <para>
                        The state manager periodically broadcasts the current
                        state to clients on the transition subscription port.
                        This allows a new client to become aware of the state
                        within a second or so of connecting.
                    </para>
                    <para>
                        Whenever the state manager successfully makes a state
                        transition a state message is sent to the
                        subscription port.
                    </para>
                </listitem>
            </itemizedlist>
            
            Application programming interfaces make it easy for programs
            written in Tcl/Tk, C++ or Python to interact with the state
            manager.  The remainder of this section will show some
            simple examples for each supported language.
            
        </para>
        <section>
            <title>Tcl/Tk state manager API</title>
            <para>
                Below is an annotated example of a Tcl state manager client.
            </para>
            <example>
                <title>Tcl client of the state manager</title>
                <programlisting>
##
# @file tcltest1.tcl
# @brief Test the state monitor tcl callbacks.
# @author Ron Fox &lt;fox@nscl.msu.edu&gt;

lappend auto_path [file join $env(DAROOT) TclLibs]  <co id='tclsmclient_pkg' />
package require statemanager

set reqURI [lindex $argv 0]                     <co id='tclsmclient_uris' />
set subURI [lindex $argv 1]

statemanager::statemonitor start $reqURI $subURI <co id='tclsmclient_start' />





statemanager::statemonitor register NotReady test
statemanager::statemonitor register Ready    test  <co id='tclsmclient_register' />
statemanager::statemonitor register Booting  test

proc test {from to} {                              <co id='tclsmclient_handler' />
    puts "Transition $from -> $to"            
    if {$to eq "Ready"} {
        statemanager::transition BEGIN             <co id='tclsmclient_transition' />
    }
}

vwait forever                                     <co id='tclsmclient_evloop' />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='tclsmclient_pkg'>
                    <para>
                        Under the assumption the <literal>daqstart.bash</literal>
                        script has been sourced, the environment variable
                        <literal>DAQROOT</literal> is the path to the top level
                        directory of the NSCLDAQ installation.  This line and the
                        next add the Tcl library directory tree to the <literal>auto_path</literal>
                        variable and then incorporate the state manager API into the
                        program.
                    </para>
                </callout>
                <callout arearefs='tclsmclient_uris'>
                    <para>
                        The state manager identifies connection endpoints using
                        <firstterm>Uniform Resource Identifiers</firstterm>.
                        The program assumes the URI for the state manager's
                        state transiton request port and state transition
                        subscription port are supplied on the command line.
                        These two lines extract those URI's from he command line
                        parameters.
                    </para>
                    <para>
                        The URI's for the state manager are of the form>
                        <literal>tcp://</literal><replaceable>hostname</replaceable><literal>:</literal><replaceable>portnum</replaceable>
                        where <replaceable>hostname</replaceable> is the name
                        of the host running the state manager and
                        <parameter>portnum</parameter> is the number of the
                        TCP/IP port on which the state manager is listening for
                        connection for that specific service.
                    </para>
                </callout>
                <callout arearefs='tclsmclient_start'>
                    <para>
                        Starts the state manager notifier. The notifier is a
                        a component of the state manager that pumps transition and
                        state notification received from the subscription port
                        into the Tcl event loop.
                    </para>
                    <para>
                        The parameters are the request and subscription URIs that
                        tell the state manager API how to connect with the
                        state manager server.
                    </para>
                </callout>
                <callout arearefs='tclsmclient_register'>
                    <para>
                        These lines subscribe to specific states.  In this
                        trivial program the test command/proc is invoked when
                        the indicated state is entered.
                    </para>
                    <para>
                        This can happen either because the program receives its
                        first state broadcast before it ever sees a transition,
                        or it sees a transition broadcast.
                    </para>
                </callout>
                <callout arearefs='tclsmclient_handler'>
                    <para>
                        This is the handler for state changes.  The
                        state manager API appends the prior state as well as
                        the new current state to the command.  These become
                        the <parameter>from</parameter> and <parameter>to</parameter>
                        parameters of the <command>proc</command>.  The first time
                        the state becomes known (either via a state broadcast or if
                        a transition is received prior to a state broadcast), the
                        prior state is unknown and the from parameter is set to the
                        empty string.
                    </para>
                </callout>
                <callout arearefs='tclsmclient_transition'>
                    <para>
                        This line shows how to request a transition from the state
                        manager.  In this case as soon as the state becomes ready,
                        we request the state transition to
                        <literal>Active</literal> via the
                        <literal>BEGIN</literal>
                        transition.
                    </para>
                    <para>
                        Note this is just a toy application and this code is
                        nonesensical as it means that whenever the
                        run stops it will start again.
                    </para>
                </callout>
                <callout arearefs='tclsmclient_evloop'>
                    <para>
                        <command>vwait</command> command enters the event loop
                        until the <varname>forever</varname> variable is modified
                        (it never is).  This allows the program to respond to
                        state transitions that are posted as events.  A Tcl/Tk
                        application automatically gets an event loop and does not
                        need this statement.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>C++ State manager API</title>
            <para>
                The C++ state manager api lives in the <filename>$DAQLIB/libStateMonitor.so</filename>
                shared library.  The header <filename>&lt;CStateMonitor.h&gt;</filename>.
                The <literal>DAQLIB</literal> environment variable is defined
                by the <filename>daqsetup.bash</filename> script in the top
                level directory of NSCLDAQ 11.0 or later.
            </para>
            <para>
                Let's look at an annotated C++ program that is a client to the
                state manager:
            </para>
            <example>
                <title>C++ client for the state manager.</title>
                <programlisting>
#include "CStateMonitor.h"                    <co id='csmclient_include' />
#include &lt;iostream&gt;

void
NotReady(CStateMonitor* pMonitor, std::string from, std::string to, void* arg) <co id='csmclient_handler' />
{
    const char* p =  reinterpret_cast&lt;const char*&gt;(arg);                 <co id='csmclient_clientdata' />
    
    std::cout &lt;&lt; "NotReady transition " &lt;&lt; from &lt;&lt; "-&gt;" &lt;&lt; to &lt;&lt; " (" &lt;&lt; p &lt;&lt; ")\n";
}

void
Ready(CStateMonitor* pMonitor, std::string from, std::string to, void* arg)
{
    const char* p =  reinterpret_cast&lt;const char*&gt;(arg);
    
    std::cout &lt;&lt; "Ready transition " &lt;&lt; from &lt;&lt; "-&gt;" &lt;&lt; to &lt;&lt; " (" &lt;&lt; p &lt;&lt; ")\n";
}

int main(int argc, char**argv)
{
    std::string reqURI   = argv[1];                                      <co id='csmclient_uris' />
    std::string stateURI = argv[2];
    
    CStateMonitor mon(reqURI, stateURI);                                 <co id='csmclient_construct' />

    mon.Register("NotReady", NotReady, const_cast&lt;char*&gt;("Some text")); <co id='csmclient_register' />
    mon.Register("Ready", Ready, const_cast&lt;char*&gt;("Different text"));
    
    mon.run();                                                         <co id='csmclient_eventloop' />
}
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='csmclient_include' >
                    <para>
                        This line includes the header that defines the classes
                        that make up the C++ API to the state manager.
                    </para>
                </callout>
                <callout arearefs='csmclient_handler'>
                    <para>
                        <function>NotReady</function> will be  a state handler.
                        State handlers are registered to be called when one or
                        more of a set of states has been entered.  State handlers
                        are passed a pointer to the state monitor, the state names
                        involved in the transition (<parameter>from</parameter> is the
                        empty string if the prior state is not known), and an
                        application specific parameters.
                    </para>
                </callout>
                <callout arearefs='csmclient_clientdata'>
                    <para>
                        As we will see, the client data used in this simple program
                        is a character string.  This line makes the
                        client data (<parameter>arg</parameter>), usable as a
                        <type>char*</type> again.
                    </para>
                </callout>
                <callout arearefs='csmclient_uris'>
                    <para>
                        The state manager's ports are specified as
                        <firstterm>Universal Resource Identifiers</firstterm>
                        (URIs).   Inthe as of this program, the URIs of the
                        state transition request port and the state publication port
                        are passeed in as command line parameters.
                        This naive code (no error checking) pulls in those URI's
                        from the command line.
                    </para>
                </callout>
                <callout arearefs='csmclient_construct' >
                    <para>
                        The <classname>CStateMonitor</classname> is a class that
                        encapsulates the API to the state manager.  This line
                        creates an instanc eof that class, providing it the
                        URI's it needs to connect to the state manager ports.
                    </para>
                    <para>
                        Note that while this program does not demonstrate that
                        fact, the class has a method <methodname>requestTransition</methodname>
                        tht can request state transition from the
                        state manager.
                    </para>
                </callout>
                <callout arearefs='csmclient_register' >
                    <para>
                        State monitoring works by registering states our
                        out application is interested.  When the interesting
                        state is entered, a callback is invoked.  The callback
                        is passed the state manager object, the  prior state, the
                        new state and an application specific parameter that is
                        not interpreted by the <classname>CStateMonitor</classname>
                        object.
                    </para>
                    <para>
                        These lines register intereste in the <literal>NotReady</literal>
                        and <literal>Ready</literal> states.
                    </para>
                </callout>
                <callout arearefs='csmclient_eventloop'>
                    <para>
                        Invoking the <methodname>run</methodname> method on a
                        <classname>CStateMonitor</classname> object enters its
                        event loop.  The monitor processes data from the
                        state manager and invokes callbacks for registered
                        states as they are entered.  This method won't exit,
                        however there are classes that do allow you to
                        interleave a state manager event loop with other
                        processing.  See the reference material for more information.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Python state manager API</title>
            <para>
                This section shows two sample Python programs that interface
                with the state manager.  The first program monitors state
                transitions.  The second program simply takes lines from stdin
                and pushes them as state transition requests to the statemanager,
                outputing the status of the request to stdout.
            </para>
            <para>
                Both of the examples assume that the environment variables
                defined by <filename>$DAQROOT/daqsetup.bash</filename> have
                been incorporated into you shell environment.   This is necessary
                as the <literal>PYTHONPATH</literal> variable is modified to
                allow NSCLDAQ specific packages to be imported.
            </para>
            <example>
                <title>Monitoring the state manager in Python</title>
                <programlisting>
from nscldaq.statemanager import StateMonitor    <co id='pyclient_import' />
import sys

## usage:
#  python StateMonitorTest1 statemanager-req-uri state-manager-pub-uri
#

requestUri = sys.argv[1]                        <co id ='pyclient_uris' />
pubUri     = sys.argv[2]


# We'll just use unbound methods for our callbacks:

def NotReadyHandler(monitor, fromState, toState, cbarg):  <co id='pyclient_handlers' />
    print('Not Ready state entered: %r -> %r  (%s)' %(fromState, toState, cbarg))


def ReadyHandler(monitor, fromState, toState, cbarg):
    print('Ready state entered: %r -> %r  (%s)' %(fromState, toState, cbarg))


mon = StateMonitor.StateMonitor(requestUri, pubUri)    <co id='pyclient_instantiate' />
mon.register('NotReady', NotReadyHandler, 'poof')      <co id='pyclient_register' />
mon.register('Ready', ReadyHandler, 'poof poof')

mon.run()                                              <co id='pyclient_run'/>
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='pyclient_import'>
                    <para>
                        This line imports the Statemonitor class from the
                        <literal>nscldaq.statemanager</literal> package.
                        The <literal>StateMonitor</literal> class encapsulates
                        the highest level API to the state manager server.
                        Lower level interfaces exist and may be necessary for
                        more complex examples.  See the reference material for
                        more information.
                    </para>
                    <para> All
                        nscldaq related packages for Python are sub packages
                        in the <literal>nscldaq</literal> package tree to ensure
                        their names don't collide with other packages you might
                        use within your scripts.
                    </para>
                </callout>
                <callout arearefs='pyclient_uris' >
                    <para>
                        Connection endpoints for the state manager are expressed
                        as <firstterm>Uniform Resource Identifiers</firstterm> (URIs).
                        These URIs are of the form
                        <literal>tcp://</literal><replaceable>hostname</replaceable><literal>:</literal><replaceable>port</replaceable>.
                        Where <replaceable>hostname</replaceable> is the
                        host in which the server is running and
                        <replaceable>port</replaceable> is the TCP/IP port on which
                        the monitor is  waiting for connections.
                    </para>
                    <para>
                        This program accepts those URI's on the command line
                        The first URI is the URI that corresponds to the state
                        transition request port, the second corresponds to the
                        state/transition publication port.
                    </para>
                    <para>
                        As we will see in the second example, if you know which
                        host the state manager is running under, it is possible
                        to ask the nscl port manager for the ports it use and,
                        from them,
                        construct the approprate URIs
                    </para>
                </callout>
                <callout arearefs='pyclient_handlers'>
                    <para>
                        This <command>def</command> and the next are state
                        handlers that will be registered with the
                        state manager. A state manager is a python method
                        that (in addition to <literal>self</literal> if it is
                        an object method), has the following parameters passed in:
                        <variablelist>
                            <varlistentry>
                                <term><parameter>monitor</parameter></term>
                                <listitem>
                                    <para>
                                        The state monitor API object.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><parameter>fromState</parameter></term>
                                <listitem>
                                    <para>
                                        The prior state.  This is
                                        <literal>None</literal> if the previous
                                        state is not known.  It is the string
                                        state name of the previous state otherwise.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><parameter>toState</parameter></term>
                                <listitem>
                                    <para>
                                        String containing the state that has
                                        just been entered.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><parameter>cbarg</parameter></term>
                                <listitem>
                                    <para>
                                        A parameter that is provided by the application
                                        when the state handler is registered and is
                                        not interpreted/modified in any way by the
                                        API.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </para>
                </callout>
                <callout arearefs='pyclient_instantiate' >
                    <para>
                        The <classname>StateMonitor</classname> class represents
                        the API that accesses the state manager server. This
                        line creates an instance of that class providing
                        it with the URI's that describe how to connect to both
                        the transition request and state/transition publication
                        ports.
                    </para>
                </callout>
                <callout arearefs='pyclient_register'>
                    <para>
                        The state monitoring part of the state manager API works
                        by registering callback handlers for states of interest.
                        When the system enters a state for which you have declared
                        interest, the callback associated with that state
                        is invoked.
                    </para>
                    <para>
                        This line of code and the next line register interest, and
                        callback handlers, for the <literal>NotReady</literal>
                        and <literal>Ready</literal> states.
                    </para>
                </callout>
                <callout arearefs='pyclient_run'>
                    <para>
                        Enters the event handling loop of the <classname>StateMonitor</classname>.
                        This loop processes state and transition publications from
                        the state manager server dispatching interesting ones
                        to registered callback handlers.
                    </para>
                </callout>
                            
            </calloutlist>
            <example>
                <title>Command line state changer</title>
                <programlisting>
from nscldaq.statemanager import StateMonitor       <co id='pytransition_imports' />
from nscldaq.statemanager import Utilities
import sys
import getpass

username        = getpass.getuser()                 <co id='pytransition_uriconstruction' />
requestPort     = Utilities.getPort('localhost', 'StateRequest', username)
transitionPort  = Utilities.getPort('localhost', 'StatePublish', username)

requestUri    = 'tcp://localhost:%d' % (requestPort)
transitionUri = 'tcp://localhost:%d' %(transitionPort)

mon = StateMonitor.StateMonitor(requestUri, transitionUri)  <co id='pytransition_instantiate' />

while 1:
    line = sys.stdin.readline()                   <co id='pytransition_getline' />
    if not line:
        break
    
    reply = mon.requestTransition(line[0:-1])     <co id='pytransition_request' />
    print("Reply: %s" % (reply))                  <co id='pytransition_reply' />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='pytransition_imports'>
                    <para>
                        Imports the packages required for the application.  The
                        first two lines are the ones that are interesting to us.
                        All NSCLDAQ python packages are provided inside the
                        toplevel <literal>nsclddaq</literal> package and
                        the state manager related packages are themselves
                        inside of <literal>nscldaq.statemanager</literal>
                    </para>
                    <para>
                        The <literal>StateMonitor</literal> package provides a high
                        level API to the state manager.  The <literal>Utiltities</literal>
                        package provides several utilities useful both to the state
                        manager and its clients.
                    </para>
                    <para>
                        The <literal>sys</literal> and <literal>getpass</literal>
                        packages are standard Python packages that are also used
                        by this application.
                    </para>
                </callout>
                <callout arearefs='pytransition_uriconstruction'>
                    <para>
                        This section of code constructs URIs that describe
                        the state transition request and state/transition publication
                        ports.  In this case, the state manager is assumed to
                        be running on the same host as the program.
                    </para>
                    <para>
                        The first three linse of this section of code use the
                        utility functions to get the ports the state manager
                        has requested from the port manager.  The
                        <literal>StateRequest</literal> service handles requests
                        for transitions while the <literal>StatePublish</literal>
                        service publishes states and transitions. The statemanager
                        is also assumed to be run by the same user as the one
                        running this program.   The <function>getPort</function>
                        function will throw a <classname>RuntimeException</classname>
                        if it is not able to locate the requested services.
                    </para>
                    <para>
                        The next two lines encode the port into URIs so that
                        they can be passed to the constructor for the
                        <classname>StateMonitor</classname> class.
                    </para>
                </callout>
                <callout arearefs='pytransition_instantiate'>
                    <para>
                        Creates an instance of the <classname>StateMonitor</classname>
                        class.  This object provides a method
                        <methodname>requestTransition</methodname> that will be
                        used to request state transitions.
                    </para>
                </callout>
                <callout arearefs='pytransition_getline'>
                    <para>
                        The main loop of the program gets lines from stdin.
                        <methodname>sys.stdin.readline()</methodname> returns an
                        empty string when the end of file is reached on <literal>stdin</literal>.
                        When that happens we exit.  Note that <methodname>realine</methodname>
                        includes the newline line terminator in the data it returns.
                    </para>
                </callout>
                <callout arearefs='pytransition_request'>
                    <para>
                        This line makes the transition request. The line is sliced
                        so that the newline is not passsed as part of the
                        transition request.
                    </para>
                </callout>
                <callout arearefs='pytransition_reply' >
                    <para>
                        This prints the reply to the state transition request
                        from the state manager.  On success, the return value is
                        <literal>OK</literal>.  On failure the return value is
                        <literal>FAIL </literal> followed by an error message.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </section>
</chapter>

<!-- /chapter -->

<!--  manpages -->

<!-- manpage 3python -->
<!-- python bindings -->

<refentry id="python3_statemanager_utilities">
  <refmeta>
     <refentrytitle id='python3_statemanager_utilities_title'>State manager utilities</refentrytitle>
     <manvolnum>3python</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>nscldaq.statemanager.Utilities.getPort</refname>
     <refname>nscldaq.statemanager.Utilities.connectRequestPort</refname>
     <refname>nscldaq.statemanager.Utilities.subscribe</refname>
     <refname>nscldaq.statemanager.Utilities.checkRequest</refname>
     <refname>nscldaq.statemanager.Utilities.ZmqFileEventLoop</refname>
     <refpurpose>State Manager utilities</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
from nscldaq.statemanager import Utilities
    </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
ipPort = Utilities.getPort(host, service, user)
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
zmqSocket = Utilities.connectRequestPort(
    zmqContext, host='localhost', service='StateRequest', user=None)
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
zmqSocket = Utilities.subscribe(
    zmqContext, wantTransitions, wantState, host='localhost', service='StatePublish', user=None)           
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
gotSomething = Utilities.checkRequest(zmqSocket, pollTimeout, maxPolls, callback, cbArg)
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
eventLoop = Utilities.zmqEventLoop()
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
eventLoop.register(ioItem, events, handler)
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
eventLoop.unregister(ioItem)
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
eventLoop.poll(timeout)
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
eventLoop.pollForever(timeout, idler=None)
        </command>
    </cmdsynopsis>
    
    
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The Utilities package provides several convenience functions and an event
        loop class for the state manager.  These can be considered mostly
        low level functions, and the event loop too is a pretty low level
        item.
     </para>
     <para>
        The state manager and its clients use the
        <ulink url='http://zeromq.org'>zeromq</ulink> communications software.
        This means that some parameters are actually zeromq objects.
        Where appropriate, this is pointed out.
     </para>
  </refsect1>
  <refsect1>
     <title>
        FUNCTIONS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <funcsynopsis>
                    <funcprototype><funcdef>ipPort =
                    <function>Utilities.getPort</function></funcdef>
                    <paramdef>
                        <parameter>host</parameter>
                        <parameter>service</parameter>
                        <parameter>user</parameter>
                    </paramdef>
                    </funcprototype>
                </funcsynopsis>
                    
            </term>
            <listitem>
                <para>
                    Looks up a service using the NSCL DAQ port manager.
                    <parameter>host</parameter> is the host on which the
                    service is believed to be advertised.
                    <parameter>service</parameter> is the name of the service
                    the server is advertising.  <parameter>user</parameter> is the
                    username qualifying the service.
                </para>
                <para>
                    In order to support multiple acquisition runs in a single
                    computer, services can be run by a specific user.  The
                    user that runs the service is part of the information
                    provided about services by the port manager query
                    subsystem.
                </para>
                <para>
                    The function returns the port on which the server is
                    listening for connections for that service.  If there is
                    no match or if the port manager on <parameter>host</parameter>
                    cannot be contacted, the function will raise a
                    <classname>RuntimeError</classname>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <funcsynopsis>
                    <funcprototype><funcdef>
                        <function>Utilities.connectRequestPort</function></funcdef>
                        <paramdef>
                            <parameter>zmqContext</parameter>
                            <parameter>host='localhost'</parameter>
                            <parameter>service='StateRequest'</parameter>
                            <parameter>user=None</parameter>
                        </paramdef>
                    </funcprototype>
                </funcsynopsis>
            </term>
            <listitem>
                <para>
                    Connects to the request port of the state manager.
                    <parameter>zmqContext</parameter> is the zeromq context
                    object that must have been created by the caller as part
                    of the initialization of zeromq.
                    <parameter>host</parameter>, which defaults to the localhost
                    indicates which system the state manager is running in.
                    <parameter>service</parameter> which defaults to
                    <literal>StateRequest</literal>, the service normally
                    used by the state manager, is the service name on which the
                    state manager is allowing state transition request
                    connections.
                    <parameter>user</parameter>, which defaults to <literal>None</literal>,
                    indicating the running user should be  used, is the username
                    that is running the state manager.
                </para>
                <para>
                    On successful completion a <classname>zmq::socket</classname>
                    object is returned.  Note that <classname>zmq::socket</classname>
                    is not interchangeable with the sockets produced by
                    the python <classname>socket</classname> constructor.
                </para>
            </listitem>
        </varlistentry>
        
     </variablelist>
  </refsect1>
  <refsect1>
    <title>
        <classname>zmqEventLoop</classname>
    </title>
    <para>
        <classname>zmqEventLoop</classname> (ZeroMQ Event loop) provides the ability to run
        an event loop based on a <classname>zmq.poller</classname> object.  The event
        loop is built to allow clients to register interest in either <classname>zmq.socket</classname>
        events or events on any Python object that has a <methodname>fileno</methodname> method.
        When events of interest occur, callbacks associated with those events are invoked.
        The event loop can be entered for some designated time period or it can be
        entered "forever" with a user callback determining if/when the loop exits.
    </para>
    <variablelist>
        <varlistentry>
            <term><methodname>zmqEventLoop</methodname>()</term>
            <listitem>
                <para>
                    Constructs and returns an instance of a <classname>zmqEventLoop</classname>.
                    No parameters are required or accepted.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><methodname>register</methodname>(
                <parameter>ioItem</parameter>,
                <parameter>events</parameter>,
                <parameter>handler</parameter>)
            </term>
            <listitem>
                <para>
                    Registers a callback.  <parameter>ioItem</parameter> is either a
                    <classname>zmq.socket</classname> or any Python object with a
                    <methodname>fileno</methodname> method that returns a file descriptor.
                    <parameter>events</parameter> is a set of flags bitwised OR'd together
                    to specify the events of interest.  The legal flags are
                    <literal>zmq.POLLIN</literal> or <literal>zmq.POLLOUT</literal>.
                    <parameter>handler</parameter> is a callable that will be invoked when
                    the <parameter>ioItem</parameter> has an event of interest.
                </para>
                <para>
                    <parameter>handler</parameter> is invoked with the following parameters
                    in order:  The event loop object that invoked the handler,  the
                    <parameter>ioItem</parameter> that has the desired event and
                    a <parameter>mask</parameter> of events that were fired by the
                    object.
                </para>
                <para>
                    Note that if an I/O item already has a callback register it is silently
                    replaced by the new one. 
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><methodname>unregister</methodname>(<parameter>ioItem</parameter>)</term>
            <listitem>
                <para>
                    Unregisters any callback registered for the <parameter>ioItem</parameter>.
                    If the <parameter>ioItem</parameter> is not registered, the underlying
                    <classname>zmq.Poller</classname> object will raise a
                    <literal>KeyError</literal> exception.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><methodname>poll</methodname>(<parameter>timeout</parameter>)</term>
            <listitem>
                <para>
                    Runs the event loop until the next events are declared or for
                    <parameter>timeout</parameter> microseconds, whichever is first.
                    Any event that occured will be dispatched prior to return. This
                    method provides for a main program loop that follows the model:
                </para>
                <informalexample>
                    <programlisting>
e = Utilities.zmqEventLoop()
...
while True:
   e.poll(maxLatencyInMicroseconds)
   doOtherStuff()
                    </programlisting>
                </informalexample>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><methodname>pollForever</methodname>(<parameter>timeout</parameter>, <parameter>idler=None</parameter>)</term>
            <listitem>
                <para>
                    Repeatedly invokes the <methodname>poll</methodname> method.
                    In this case, the <parameter>timeout</parameter> specifies the
                    maximum time the <methodname>poll</methodname> call can block
                     in milliseconds (not microseconds).
                </para>
                <para>
                     After each call to
                     <methodname>poll</methodname> the <parameter>idler</parameter>
                     callable, if supplied is called with the event loop object
                     as a parameter.   The <parameter>idler</parameter> method is assumed
                     to return a boolean <literal>True</literal> if the event loop
                     should make another pass or <literal>False</literal> fi
                     <methodname>pollForever</methodname> should return.
                     The <methodname>poll</methodname> method will always be called
                     at least once.
                </para>
            </listitem>
        </varlistentry>
        
    </variablelist>
  </refsect1>
</refentry>
      <refentry id="python3_statemonitor">
        <refmeta>
           <refentrytitle id="python3_statemonitor_title">StateMonitor</refentrytitle>
           <manvolnum>3python</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>StateMonitorBase</refname>
           <refname>StateMonitor</refname>
           <refpurpose>State transition dispatching</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
from nscldaq.statemanager import StateMonitor
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
smb = StateMonitor.StateMonitorBase(transitionRequestUri, statePublisherUri, initializer=None)
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
smb.requestTransition(requestString)
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
smb.initialState(state)
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
smb.transition(state)
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
smb.run()
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
sm = StateMonitor(transitionRequestUri, statePublisherUri, initializer=None)                    
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
sm.register(state, callable, argument)
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
sm.unregister(state)
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
sm.initialState(state)
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
sm.transition(state)
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
sm.run()
                </command>
            </cmdsynopsis>
            
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <filename>StateMonitor</filename> package provides a pair
            of classes that interact with the state manager in a way that
            makes state-aware progams easy to write.  The classes are
            ZeroMQ aware and provide sufficient hooks for you to interact
            with facilities other than the state manager.
           </para>
           <para>
            The <classname>StateMonitorBase</classname> class provides
            a base class on which all state monitoring programs can be
            implemented.  It provides combines with a internal
            <classname>zmqEventLoop</classname> object and
            <classname>zmq.Context</classname> object to intercept data on
            <classname>zmq.socket</classname> objects connected tothe state
            manager.  A callback is invoked for transition broadcasts as
            well as when the state of the system is initially learned.
           </para>
           <para>
            <classname>StateMonitor</classname> derives from
            <classname>StateMonitorBase</classname> allowing clients to
            register callbacks that are invoked when the system enters
            specific states.  When using these classes, if the flow of
            control the provide seems confining, remember that you can
            derive from these classes overiding methods such as
            <methodname>run</methodname> to get different event loop
            behavior and the low level handlers for state and transition
            handlers if needed.
           </para>
        </refsect1>
        <refsect1>
           <title>
              StateMonitorBase
           </title>
           <para>
            Provides a <classname>zmqEventLoop</classname> and connections to the
            state manager in a way that specific operations can be performed
            when state transitions occur and when the state of the system
            is initially discovered.
           </para>
           <para>
            Recall that the state manager is not only publishing state transitions.
            It also periodically publishes the current state.  The state is
            discovered when the current state publication is seen or if a state
            transition is seen prior to the receipt of a state publication.
           </para>
           <para>
            The <classname>StateMonitorBase</classname> class defines the following
            attributes that are considered public:
           </para>
           <variablelist>
            <varlistentry>
                <term><varname>zmqContext</varname></term>
                <listitem>
                    <para>
                        During initialization the object creates a
                        <classname>zmq.Context</classname> object which it uses
                        to generate the <classname>zmq.Socket</classname> objects
                        that talk to the state manager.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
           <para>
            The <classname>StateMonitorBase</classname> class has the following methods:
           </para>
           <variablelist>
            <varlistentry>
                <term><methodname>StateMonitor.StateMonitorBase</methodname>
                    (<parameter>transitionRequestUri</parameter>, <parameter>statePublisherUri</parameter>,
                    <parameter>initializer=None</parameter>)</term>
                <listitem>
                    <para>
                        Constructs a <classname>StateMonitorBase</classname> object.
                        The <parameter>transitionRequestUri</parameter> is
                        a URI that describes the endpoint on which the state manager
                        listens for state transition requests.  This is of the form
                        <literal>tcp://hostname:portnum</literal> the port manager
                        can be used to determine the port number if you know the
                        host.
                    </para>
                    <para>
                        The <parameter>statePublisherUri</parameter> parameter
                        similarly describes the endpoint on which the state manager
                        publishes both state information and state transitions.
                    </para>
                    <para>
                        Finally the <parameter>initializer</parameter> parameter
                        provides a callable that is invoked after initialization
                        of the object is complete. The <classname>StateMonitorBase</classname>
                        object is passed as a parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>requestTransition</methodname>(<parameter>requestString</parameter>)</term>
                <listitem>
                    <para>
                        Asks the state manager to perform the transition indicated
                        by <parameter>requestString</parameter>.  The return value
                        from this method is the response string from the state
                        manager.  If the state transition could be taken, the
                        string is simply <literal>OK</literal>.  If the state transtion
                        is could not be taken, the string is <literal>FAIL</literal>
                        followed by a human readable error message.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>initialState</methodname>(<parameter>state</parameter>)</term>
                <listitem>
                    <para>
                        This method is intended to be overriden in real applications that
                        make use of this class as a base class.  It is called when the
                        state of the state manager is initially learned.  This happens
                        either when a <literal>STATE</literal> message is received
                        from the state manager or when a <literal>TRANSITION</literal>
                        message is received prior to the first <literal>STATE</literal>
                        message.  In either case, there is no known prior state.
                    </para>
                    <para>
                        The <parameter>state</parameter> parameter is the current system
                        state.  The base class method should be called by any override. It
                        <orderedlist>
                            <listitem><para>Saves the prior state.</para></listitem>
                            <listitem><para>Unsubscribes from <literal>STATE</literal> messages
                            since the only way the state can now change is due to a
                            <literal>TRANSITION</literal> message.
                            </para>
                            </listitem>
                        </orderedlist>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>transition</methodname>(<parameter>state</parameter>)</term>
                <listitem>
                    <para>
                        Called when a state transition occurs.  <parameter>state</parameter>
                        is the new state.   This method is intended to be overridden by derived
                        classes.  The base class method:
                        <itemizedlist>
                            <listitem><para>If the prior state is not known invokes
                            <methodname>initialState</methodname></para></listitem>
                            <listitem><para>If the prior state is known, saves the current
                            state as the prior state for the next transition.
                            </para></listitem>
                        </itemizedlist>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>run()</methodname></term>
                <listitem>
                    <para>
                        Invokes the <varname>poller</varname>'s
                        <methodname>pollForever</methodname> method.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
           
        </refsect1>
        <refsect1>
            <title>StateMonitor</title>
            <para>
                This class is derived from <classname>StateManagerBase</classname>.
                It adds to that class the ability to register callbacks
                when specific states are entered.  The <classname>StateMonitor</classname>
                class has the following addtional methods:
            </para>
            <variablelist>
                <varlistentry>
                    <term><methodname>register</methodname>(
                        <parameter>state</parameter>, <parameter>callable</parameter>,
                        <parameter>argument</parameter>)</term>
                    <listitem>
                        <para>
                            Registers interest in entry into <parameter>state</parameter>.
                            When <parameter>state</parameter> is either
                            discovered to be the initial state,
                            or when there is a state transition into <parameter>state</parameter>
                        </para>
                        <para>
                            When either of those conditions is met, the <parameter>callable</parameter>
                            is invoked. It gets passed in order, the <classname>StateMonitor</classname> object,
                            the prior state (<literal>None</literal> if this is an initial state discovery),
                            the state being entered and the <parameter>argument</parameter> passed in at
                            registration time.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodname>unregister</methodname>(<parameter>state</parameter>)</term>
                    <listitem>
                        <para>
                            Unregisters any callback associated with <parameter>state</parameter>.
                            A <literal>KeyError</literal> is raised if you try to <methodname>unregister</methodname>
                            a <parameter>state</parameter> that has no callback registered.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>


        </refsect1>
      </refentry>




<!-- /manpage -->

<!-- manpage 3daq -->
<!-- C++ bindings -->

	 <refentry id="daq3_czmqeventloop">
       <refmeta>
          <refentrytitle id="daq3_czmqeventloop_title">CZMQEventLoop</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CZMQEventLoop</refname>
          <refpurpose>Event loop for fd's and zmq sockets</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
#include &lt;CStateMonitor.h&gt;
            <ooclass><classname>CZMQEventLoop</classname></ooclass>
           <constructorsynopsis>
          <methodname>CZMQEventLoop</methodname>
          <void />
          <exceptionname></exceptionname>
           </constructorsynopsis>
           <methodsynopsis>
          <type>void</type>
             <methodname>Register</methodname>
             <methodparam>
                <type>zmq::socket_t&amp;</type> <parameter> sock</parameter>
             </methodparam>
             <methodparam>
                <type>int</type> <parameter>mask</parameter>
             </methodparam>
             <methodparam>
                <type>Callback</type> <parameter>cb</parameter>
             </methodparam>
             <methodparam>
                <type>void* </type> <parameter>param = 0</parameter>
             </methodparam>
             <exceptionname></exceptionname>
             <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void</type>
               <methodname>Register</methodname>
               <methodparam>
                <type>int</type> <parameter>fd</parameter>
               </methodparam>
               <methodparam>
                <type>int</type> <parameter> mask</parameter>
               </methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void</type>
               <methodname>unregister</methodname>
               <methodparam>
                <type>zmq::socket_t&amp;</type> <parameter>sock</parameter>
               </methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void</type>
               <methodname>unregister</methodname>
               <methodparam>
                <type>int</type> <parameter>fd</parameter>
               </methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void</type>
               <methodname>poll</methodname>
               <methodparam>
                <type>int</type> <parameter>timeout</parameter>
               </methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void</type>
               <methodname>pollForever</methodname>
               <methodparam>
                <type>int</type> <parameter>timeout</parameter>
               </methodparam>
               <methodparam>
                <type>IdleCallback</type> <parameter>callback=0</parameter>
               </methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>  
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class provides an event loop that is capable of reacting
            to events on both
            <ulink url='http://zeromq.org'>ZeroMQ</ulink> sockets and
            file descriptors.  An event, in this context, is an object becoming
            readable or writable.  Events get callbacks associated with them,
            and those callbacks are invoked from the event loop whenever
            the associated object has an event of interest.
          </para>
          <para>
            The event loop can be interleaved with other work either by
            using the <methodname>poll</methodname> method, which waits for
            events until either one occurs or a timeout occurs, or by providing
            a callback to the <methodname>pollForever</methodname> method.
            Event interest is declared using the <methodname>Register</methodname>
            method and interest is removed via the <methodname>unregister</methodname>
            methods.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                   <type>void</type>
                      <methodname>Register</methodname>
                      <methodparam>
                         <type>zmq::socket_t&amp;</type> <parameter> sock</parameter>
                      </methodparam>
                      <methodparam>
                         <type>int</type> <parameter>mask</parameter>
                      </methodparam>
                      <methodparam>
                         <type>Callback</type> <parameter>cb</parameter>
                      </methodparam>
                      <methodparam>
                         <type>void* </type> <parameter>param = 0</parameter>
                      </methodparam>
                      <exceptionname></exceptionname>
                      <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Registers interest in one or more events on a
                        ZeroMQ socket; <parameter>sock</parameter>.
                        <parameter>mask</parameter> defines which events
                        are of interest and is a bitwise or of the masks:
                        <literal>ZMQ_POLLIN</literal> and <literal>ZMQ_POLLOUT</literal>.
                    </para>
                    <para>
                        When one of the events of interest occurs while the event
                        loop is running, the callback <parameter>cb</parameter> is
                        invoked.   See <literal>TYPES</literal> below for more
                        information about the <type>Callback</type> function...
                    </para>
                    <para>
                        The <parameter>cb</parameter> parameter, among others
                        is passed to the <parameter>cb</parameter> function
                        without any interpretation.
                    </para>
                    <para>
                        Note that a socket can only have a single callback
                        registered.  If you register a callback on a socket
                        that already has one defined, the new definition
                        replaces the previous definition.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname>Register</methodname>
                        <methodparam>
                         <type>int</type> <parameter>fd</parameter>
                        </methodparam>
                        <methodparam>
                         <type>int</type> <parameter> mask</parameter>
                        </methodparam>
                        <exceptionname></exceptionname>
                        <modifier></modifier>
                    </methodsynopsis>

                </term>
                <listitem>
                    <para>
                        This method is identical to the previous
                        <methodname>Register</methodname> method, however
                        the socket is replaced by a <parameter>fd</parameter>
                        which is a file descriptor for which we'd like to
                        receive events.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname>unregister</methodname>
                        <methodparam>
                         <type>zmq::socket_t&amp;</type> <parameter>sock</parameter>
                        </methodparam>
                        <exceptionname></exceptionname>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Unregisters interest in events from the
                        <parameter>sock</parameter> ZeroMQ Socket.
                        Once this is called, any callback establisedh on
                        events from this socket are no longer delivered.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname>unregister</methodname>
                        <methodparam>
                         <type>int</type> <parameter>fd</parameter>
                        </methodparam>
                        <exceptionname></exceptionname>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Unregisters events on the file descriptor
                        <parameter>fd</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                    <term>
                        <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname>poll</methodname>
                        <methodparam>
                         <type>int</type> <parameter>timeout</parameter>
                        </methodparam>
                        <exceptionname></exceptionname>
                        <modifier></modifier>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Blocks until either an event occurs or the
                            <parameter>timeout</parameter> number of microseconds
                            have passed.  If an event occurs for which a
                            callback has been established, that callback will
                            be invoked prior to returning.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                        <modifier></modifier>
                        <type>void</type>
                        <methodname>pollForever</methodname>
                        <methodparam>
                         <type>int</type> <parameter>timeout</parameter>
                        </methodparam>
                        <methodparam>
                         <type>IdleCallback</type> <parameter>callback=0</parameter>
                        </methodparam>
                        <exceptionname></exceptionname>
                        <modifier></modifier>
                    </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            Invokes <methodname>poll</methodname> witht he
                            <parameter>timeout</parameter> parameter supplied.
                            On return, the <parameter>callback</parameter> is
                            invoked, if non null.  If the <parameter>callback</parameter>
                            returns <literal>false</literal>, <methodname>pollForever</methodname>
                            returns, otherwise it loops to the <methodname>poll</methodname>
                            call.
                        </para>
                        <para>
                            If <parameter>callback</parameter> is null, the
                            <methodname>poll</methodname> loop does not exit
                            until the program exits.  It is this behavior
                            that inpsires the methodname.  For more information
                            about the <type>IdlCallback</type> type,
                            see TYPES below.
                        </para>
                    </listitem>
                </varlistentry>
                    
                    
          </variablelist>
       </refsect1>
        <refsect1>
           <title>TYPES</title>
           <refsect2>
            <title>Callback</title>
            <para>
                This type is a pointer to a function that is suitable
                for use as the <parameter>cb</parameter> parameter to
                the <methodname>Register</methodname> functions.
                It's form is as follows:
                <funcsynopsis>
                    <funcprototype>
                        <funcdef>typedef void <function>(*Callback)</function></funcdef>
                        <paramdef>
                            CZMQEventLoop* <parameter>pEventLoop</parameter>
                        </paramdef>
                        <paramdef>
                            zmq::pollitem_t* <parameter>object</parameter>
                        </paramdef>
                        <paramdef>
                            void* <parameter>param</parameter>
                        </paramdef>
                    </funcprototype>
                </funcsynopsis>
            </para>
            <para>
                The <parameter>pEventLoop</parameter> parameter is a pointer
                to the event loop that is invoking this callback.
                The <parameter>object</parameter> describes the object
                that cause the callback to be invoked.  See the ZeroMQ
                documentation for more information about its structure.
                <parameter>param</parameter> is the additional parameter
                passed in during the <methodname>Register</methodname> call
                that established this callback.
            </para>
           </refsect2>
           <refsect2>
            <title>IdleCallback</title>
            <para>
                This is a pointer to a function that is appropriate to use
                as a the <parameter>idler</parameter> callback parameter
                in a call to the <methodname>pollForevr</methodname> method.
            </para>
            <para>
                The form of this function is:
                <funcsynopsis>
                    <funcprototype>
                        <funcdef>typedef bool <function>(*IdleCallback)</function></funcdef>
                        <paramdef>
                            CZMQEventLoop* <parameter>pEventLoop</parameter>
                        </paramdef>
                    </funcprototype>
                </funcsynopsis>
            </para>
            <para>
                Where <parameter>pEventLoop</parameter> is a pointer to the
                event loop object that is running.
            </para>
           </refsect2>
        </refsect1>
     </refentry>     
<refentry id="daq3_cstatemonitorbase">
  <refmeta>
     <refentrytitle id="daq3_cstatemonitorbase_title">classname</refentrytitle>
     <manvolnum>3daq</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CStateMonitorBase</refname>
     <refpurpose>Base class for state monitor classess</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
        
#include &lt;CStateMonitor.h&gt;
    
       <ooclass><classname>CStateMonitorBase</classname></ooclass>
      <constructorsynopsis>
     <methodname>CStateMonitorBase</methodname>
     <methodparam>
        <type>std::string</type> <parameter>transitionRequestUri</parameter>
     </methodparam>
     <methodparam>
        <type>std::string</type> <parameter>statePublisherUri</parameter>
     </methodparam>
     <methodparam>
        <type>CStateMonitorBase::InitCallback</type> <parameter>cb</parameter>
     </methodparam>
     <exceptionname></exceptionname>
      </constructorsynopsis>
      <methodsynopsis>
     <type>std::string</type>
        <methodname>requestTransition</methodname>
        <methodparam>
            <type>std::string</type> <parameter>transitionName</parameter>
        </methodparam>
        <exceptionname></exceptionname>
        <modifier></modifier>
      </methodsynopsis>
      <methodsynopsis>
          <modifier></modifier>
          <type>void</type>
          <methodname>run</methodname>
          <void />
          <exceptionname></exceptionname>
          <modifier></modifier>
      </methodsynopsis>
      <methodsynopsis>
          <modifier></modifier>
          <type>CZMQEventLoop&amp;</type>
          <methodname>getEventLoop</methodname>
          <void />
          <exceptionname></exceptionname>
          <modifier></modifier>
      </methodsynopsis>
      <methodsynopsis>
          <modifier></modifier>
          <type>zmq::context_t*</type>
          <methodname>getContext</methodname>
          <void />
          <exceptionname></exceptionname>
          <modifier></modifier>
      </methodsynopsis>
      <methodsynopsis>
          <modifier></modifier>
          <type>std::string</type>
          <methodname>getState</methodname>
          <void />
          <exceptionname></exceptionname>
          <modifier></modifier>
      </methodsynopsis>
protected:
      <methodsynopsis>
          <modifier>virtual</modifier>
          <type>void</type>
          <methodname>initialState</methodname>
          <methodparam>
            <type>std::string</type> <parameter>state</parameter>
          </methodparam>
          <exceptionname></exceptionname>
          <modifier></modifier>
      </methodsynopsis>
      <methodsynopsis>
          <modifier>virtual</modifier>
          <type>void</type>
          <methodname>transition</methodname>
          <methodparam>
            <type>std::string</type> <parameter>newState</parameter>
          </methodparam>
          <exceptionname></exceptionname>
          <modifier></modifier>
      </methodsynopsis>  
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This class is intended to be used as a base class for programs
        that must monitor the state of the state manager program.  The
        methods <methodname>initialState</methodname> and
        <methodname>transition</methodname> are intended to be
        overidden by the actual application, as these methods are the
        ones that are called when state are entered. See also
        <classname>CStateMonitor</classname> which is a good concrete
        example of a derived class.
     </para>
     <para>
        This object contains a <classname>CZMQEventLoop</classname> which
        can also be obtained by the application software.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
               <methodname>CStateMonitorBase</methodname>
               <methodparam>
                  <type>std::string</type> <parameter>transitionRequestUri</parameter>
               </methodparam>
               <methodparam>
                  <type>std::string</type> <parameter>statePublisherUri</parameter>
               </methodparam>
               <methodparam>
                  <type>CStateMonitorBase::InitCallback</type> <parameter>cb</parameter>
               </methodparam>
               <exceptionname></exceptionname>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs the object.  The <parameter>transitionRequestUri</parameter>
                    is the URI that specifies the end point on which the state
                    manager is listening for transition requests.  This is normally
                    constructed by looking up the <literal>StateRequest</literal> service
                    in the system that is running the state manager to get the port
                    number.  The form of the URI is
                    <literal>tcp://</literal><replaceable>hostname</replaceable><literal>:</literal><replaceable>portnum</replaceable>
                </para>
                <para>
                    Similarly, <parameter>statePublisherUri</parameter> is the
                    URI of the endpoint on which the state manager periodically
                    publishes it state and publishes state transitions.  It
                    can usually be found by using the port manager to look
                    up the <literal>StatePublish</literal> service in the
                    host that is running the state manager.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
               <type>std::string</type>
                  <methodname>requestTransition</methodname>
                  <methodparam>
                      <type>std::string</type> <parameter>transitionName</parameter>
                  </methodparam>
                  <exceptionname></exceptionname>
                  <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Requests that the state transition perform the state
                    transition indicated by <parameter>transitionName</parameter>
                    the function retuns the reply from the state manager.
                    This is a string that is either <literal>OK</literal> if the
                    transition could be performed or <literal>FAIL</literal> followed
                    by human readable text that indicates why the state
                    transition could not be performed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void</type>
                    <methodname>run</methodname>
                    <void />
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Runs the event loop.  The event loop runs until the program
                    exits.  If you need more complex behavior you can invoke
                    <methodname>getEventLoop</methodname> to obtain the event
                    loop and use either its <methodname>poll</methodname> or
                    <methodname>pollForever</methodname> with a callback to
                    achieve that.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>CZMQEventLoop&amp;</type>
                    <methodname>getEventLoop</methodname>
                    <void />
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a reference to the event loop that will be used
                    to monitor the state manager.  This event loop
                    is the one that is used by the <methodname>run</methodname>
                    method above.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>zmq::context_t*</type>
                    <methodname>getContext</methodname>
                    <void />
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a pointer to the ZeroMQ context object that is
                    used by the <classname>CStateMonitor</classname> to
                    create <classname>zmq::socket_t</classname> objects.
                    If you will create your own sockets, it is best to use
                    this context rather than creating a new one.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string</type>
                    <methodname>getState</methodname>
                    <void />
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the current state of the state manager.
                    If that is not yet known, the function returns an empty string.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual</modifier>
                    <type>void</type>
                    <methodname>initialState</methodname>
                    <methodparam>
                      <type>std::string</type> <parameter>state</parameter>
                    </methodparam>
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This method is called when the event loop either gets a state
                    broadcast or when the state manager makes a state transition when
                    the state is not yet known.  Derived classes that override this
                    should invoke this base class method at some meaningful point
                    in their initial state processing.
                </para>
                <para>
                    In the base class implementation:
                    The current state is set to <parameter>state</parameter>, and
                    the subscription for state broacasts is removed.  From this
                    point on, only state transitions will activate us.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual</modifier>
                    <type>void</type>
                    <methodname>transition</methodname>
                    <methodparam>
                      <type>std::string</type> <parameter>newState</parameter>
                    </methodparam>
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    This method is called when the evetn loop gets a state transition
                    message from the state manager.  If you override this method in
                    a derived class you should invoke this method at some point
                    during your processing of state transitions.
                </para>
                <para>
                    If the prior state is not known, <methodname>initialState</methodname>
                    is invoked.  Otherwise, the new state (<parameter>newState</parameter>)
                    is memorized by the function, so that <methodname>getState</methodname>
                    will return it.
                </para>
            </listitem>
        </varlistentry>
        
                
                
        
     </variablelist>
  </refsect1>
   <refsect1>
      <title>TYPES</title>
      <refsect2>
        <title>InitCallback</title>
        <para>
            This is a pointer to a function that takes as a single parameter
            a pointer to the <classname>CStateMonitorBase</classname> that is
            being constructed.
        </para>
        <para>
            When called, any of the <classname>CStateMonitorBase</classname>
            methods can be safely called.  The intent is that this
            callback might need to obtain the event loop and register
            callbacks for other objects besides the sockets registered
            with the state and transition publications.
        </para>
        <para>
            The callback might also obtain the ZeroMQ context and use it
            to create additional ZeroMQ sockets.
        </para>
      </refsect2>
   </refsect1>
</refentry>
<refentry id="daq3_cstatemonitor">
  <refmeta>
     <refentrytitle id="daq3_cstatemonitor_title">CStateMonitor</refentrytitle>
     <manvolnum>3daq</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CStateMonitor</refname>
     <refpurpose>State monitor with callbacks.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CStateMonitor.h&gt;
       <ooclass><classname>CStateMonitor : public CStateManagerBase</classname></ooclass>
      <constructorsynopsis>
     <methodname>CStateMonitor(</methodname>
     <methodparam>
        <type>std::string</type> <parameter>transitionRequestUri</parameter>
     </methodparam>
     <methodparam>
        <type>std::string</type> <parameter>statePublisherUri</parameter>
     </methodparam>
     <methodparam>
        <type>CStaeMonitorBase::InitCallback</type> <parameter>cb = 0</parameter>
     </methodparam>
     <exceptionname></exceptionname>
      </constructorsynopsis>
      <methodsynopsis>
          <modifier>virtual</modifier>
          <type>void</type>
          <methodname>Register</methodname>
          <methodparam>
            <type>std::string</type> <parameter>state</parameter>
          </methodparam>
          <methodparam>
            <type>Callback</type> <parameter>cb</parameter>
          </methodparam>
          <methodparam>
            <type>void*</type> <parameter>cbarg</parameter>
          </methodparam>
          <exceptionname></exceptionname>
          <modifier></modifier>
      </methodsynopsis>  
      <methodsynopsis>
          <modifier>virtual</modifier>
          <type>void</type>
          <methodname>unregister</methodname>
          <methodparam>
            <type>std::string</type> <parameter>state</parameter>
          </methodparam>
          <exceptionname></exceptionname>
          <modifier></modifier>
      </methodsynopsis>  
     
     
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        Derived from <classname>CStateMonitorBase</classname> the
        <classname>CStateMonitor</classname> provides a fully functional
        state monitor class that allows its clients to regiser callbacks
        to be exeuted when states are entered.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
               <methodname>CStateMonitor(</methodname>
               <methodparam>
                  <type>std::string</type> <parameter>transitionRequestUri</parameter>
               </methodparam>
               <methodparam>
                  <type>std::string</type> <parameter>statePublisherUri</parameter>
               </methodparam>
               <methodparam>
                  <type>CStaeMonitorBase::InitCallback</type> <parameter>cb = 0</parameter>
               </methodparam>
               <exceptionname></exceptionname>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs the <classname>CStateMonitor</classname>
                    See <link linkend='daq3_cstatemonitorbase' endterm='daq3_cstatemonitorbase_title' />
                    for information about the constructor's parameters as they are the same as for
                    that classs.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual</modifier>
                    <type>void</type>
                    <methodname>Register</methodname>
                    <methodparam>
                      <type>std::string</type> <parameter>state</parameter>
                    </methodparam>
                    <methodparam>
                      <type>Callback</type> <parameter>cb</parameter>
                    </methodparam>
                    <methodparam>
                      <type>void*</type> <parameter>cbarg</parameter>
                    </methodparam>
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Registers interest in a <parameter>state</parameter>
                    the <parameter>cb</parameter> callback is invoked if the
                    <parameter>state</parameter> is either entered by transition
                    from a known state or if the state is the one the system
                    is discovered to be in at startup time.
                </para>
                <para>
                    See <literal>TYPES</literal> for information about the
                    <type>Callack</type> type.  When the <parameter>cb</parameter>
                    is called, one of the paramters it is passed is the
                    <parameter>cbarg</parameter> passed in at registration time.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual</modifier>
                    <type>void</type>
                    <methodname>unregister</methodname>
                    <methodparam>
                      <type>std::string</type> <parameter>state</parameter>
                    </methodparam>
                    <exceptionname></exceptionname>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    This unregisters any callback established for
                    <parameter>state</parameter>
                </para>
            </listitem>
        </varlistentry>
        
                
                
                
        
     </variablelist>
  </refsect1>
   <refsect1>
      <title> TYPES </title>
      <refsect2>
        <title>Callback</title>
        <para>
            This type is a function pointer to functinos that are
            suitable as callback functions.  The type has the following
            definition:
            <funcsynopsis>
                <funcprototype><funcdef> <function>typdef void (*Callback) </function></funcdef>
                <paramdef>
                    <parameter>
                        <type>CStateMonitor*</type> pMonitor
                    </parameter>
                   <parameter>
                    <type>std::string  </type> prior
                   </parameter>
                <parameter>
                    <type>std::string </type> current
                </parameter>
                </paramdef>
               </funcprototype>
            </funcsynopsis>
        </para>
        <para>
            <parameter>pMonitor</parameter> points to the <classname>CStateMonitor</classname>
            that called the callback.  <parameter>prior</parameter> is
            the prior state and is an empty string if it is not known.
            <parameter>current</parameter> is the state the system is
            now transitioned to.
        </para>
      </refsect2>
        
   </refsect1>
</refentry>     
<!-- /manpage -->

<!-- manpage 3tcl -->
<!-- Tcl bindings -->
      <refentry id="tcl3_statemanager">
        <refmeta>
           <refentrytitle id="tcl3_statemanager_title">statemanager</refentrytitle>
           <manvolnum>3tcl</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>statemanager</refname>
           <refpurpose>Tcl interface to state manager</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require statemanager
          </command>
          </cmdsynopsis>
        <cmdsynopsis>
            <command>
::statemanager::statemonitor start <replaceable>requestURI publishURI</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::statemanager::statemonitor register <replaceable>state scriptHead</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::statemanager::statemonitor unregister <replaceable>state</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::statemanager::statemonitor transition <replaceable>transition-name</replaceable>
            </command>
        </cmdsynopsis>
        
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>statemanager</literal> package provides an API
            for the State manager server to Tcl scripts.
            The API is provided as a command ensemble with the command
            head <command>::statemanager::statemonitor</command>.
           </para>
        </refsect1>
        <refsect1>
           <title>
              SUBCOMMANDS
           </title>
           <variablelist>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
::statemanager::statemonitor start <replaceable>requestURI publishURI</replaceable>
            </command>
        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Starts the state monitor thread.  In order to interface
                        with the Tcl event loop, the state monitor runs a thread
                        that accepts messages from the state manager and turns
                        them into events in the interpreter's thread.
                    </para>
                    <para>
                        <parameter>requestURI</parameter> is the
                        URI of the endpoint on which the state manager is
                        listening for state change requests while the
                        <parameter>publishURI</parameter> is the URI for the
                        endpointo n which the state manager publishes
                        state and state transitions.
                    </para>
                    <para>
                        The form of a URI is
                        <literal>tcp://</literal><replaceable>hostname</replaceable><literal>:</literal><replaceable>port</replaceable>
                        The port for each of the URI's can be determined using the port manager
                        API to look up the services <literal>StateRequest</literal> and
                        <literal>StatePublish</literal> respectively.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
::statemanager::statemonitor register <replaceable>state scriptHead</replaceable>
            </command>
        </cmdsynopsis>

                </term>
                <listitem>
                    <para>
                        Registers interest in a state mnager <parameter>state</parameter>.
                        When the <parameter>state</parameter> is entered, or
                        when the initial state is discovered to be <parameter>state</parameter>
                        <parameter>scriptHead</parameter> has the prior and current
                        state appended to it and is executed.  If the prior state
                        is not known, and empty string is passed for it instead.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
::statemanager::statemonitor unregister <replaceable>state</replaceable>
            </command>
        </cmdsynopsis>

                </term>
                <listitem>
                    <para>
                        Unregisters interest in <parameter>state</parameter>.
                        Any callback registered for that state will no longer
                        be invoked when that state is reached.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
::statemanager::statemonitor transition <replaceable>transition-name</replaceable>
            </command>
        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Requests the <parameter>transition-name</parameter>
                        state transition.  For legal transition names see
                        <link linkend='statemgr_statediagram' endterm='statemgr_statediagram_title' />.
                        The transition names are on the arcs between the bubbles
                        (which are the states).
                    </para>
                    <para>
                        This command returns the text of the state manager's
                        reply.  This can be <literal>OK</literal> or
                        <literal>FAIL</literal> followed by a human readable
                        error message.
                    </para> 
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>

<!-- /manpage -->

