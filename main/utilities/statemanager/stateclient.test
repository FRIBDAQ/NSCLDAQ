#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

#    This software is Copyright by the Board of Trustees of Michigan
#    State University (c) Copyright 2014.
#
#    You may use this software under the terms of the GNU public license
#    (GPL).  The terms of this license are described at:
#
#     http://www.gnu.org/licenses/gpl.txt
#
#    Authors:
#             Ron Fox
#             Jeromy Tompkins 
#	     NSCL
#	     Michigan State University
#	     East Lansing, MI 48824-1321



##
# @file tclbindings.test
# @brief tests of the Tcl bindings for the stateclient and state manager.
# @author Ron Fox <fox@nscl.msu.edu>
#

package require tcltest
package require stateclient
package require varmgr
package require portAllocator


#------------------------ Simple tests with no database needed ---------------

tcltest::test command-defined \
    {package defines ::nscldaq::stateclient} \
-body {
    info commands ::nscldaq::stateclient
} -result ::nscldaq::stateclient

tcltest::test command-needs-arg {Command without an arg is error} \
-body {
    catch {::nscldaq::stateclient}
} -result 1

tcltest::test delete-needs-arg {-delete flag needs arg} \
-body {
    catch {::nscldaq::stateclient -delete}
} -result 1

tcltest::test delete-needs-existing {-delete flag needs existing ensemble} \
-body {
    catch {::nscldaq::stateclient -delete testing}
} -result 1

#--------------------------------------------------------------------------

#  Infrastructure for tests that need a database setup.

set ::testFile ""
set ::bindir $::env(DAQBIN)
set ::serverPid ""

proc waitServer {} {
    portAllocator create lister
    while {1} {
        set ports [lister listPorts]
        foreach port $ports {
            if {[lindex $port 1] == "vardb-changes"} {
                lister destroy
                return
            }
            after 100
        }
    }
    
}

proc createRunDir h {
    varmgr::mkdir $h /RunState
    varmgr::statemachine $h RunStateMachine [dict create \
         0Initial NotReady NotReady [list 0Initial Readying] \
         Readying [list NotReady Ready] Ready [list Beginning NotReady] \
         Beginning [list Active NotReady] Active [list Pausing Ending NotReady] \
         Pausing [list Paused NotReady] Paused [list Ending Resuming NotReady] \
         Resuming [list Active NotReady] Ending [list Ready NotReady]           \
    ]
    
    varmgr::var create $h /RunState/State RunStateMachine
    varmgr::var create $h /RunState/SystemStatus string
    varmgr::var create $h /RunState/RunNumber integer
    varmgr::var create $h /RunState/Title     string
    varmgr::var create $h /RunState/Recording bool false
    varmgr::var create $h /RunState/Timeout   integer  60
    varmgr::var create $h /RunState/ReadoutParentDir string
    
}


proc createProgram {h name} {
    set dir /RunState/$name
    varmgr::mkdir $h $dir
    varmgr::var create $h $dir/State RunStateMachine
    varmgr::var create $h $dir/enable bool   true
    varmgr::var create $h $dir/standalone bool false
    varmgr::var create $h $dir/path  string "/some/test/path"
    varmgr::var create $h $dir/host string "somehost.nscl.msu.edu"
    varmgr::var create $h $dir/outring string "output"
    varmgr::var create $h $dir/inring string "tcp://localhost/ring"
    
}

proc setup {} {
    set dbPath [tcltest::makeFile "" testdb.db]
    file delete -force $dbPath ;    # just using it to get a file in tempdir.
    
    varmgr::create $dbPath
    set h [varmgr::open file://$dbPath]
    
    createRunDir $h
    createProgram $h test
    
    varmgr::close $h
    set ::testFile $dbPath
    
    # start the server
    #
    
    set pid [exec -- $::bindir/vardbServer --database $dbPath &]
    set ::serverPid $pid
    
    waitServer
}


proc cleanup {} {
    # Kill the server
    
    
    exec kill -9 $::serverPid
    
    # Destroy the database
    
    tcltest::removeFile $::testFile
    
    # Reset global vars:
    
    set ::testFile ""
    set ::serverPid ""
    
}

#------------------------------------------------------
# Create makes an ensemble that can be deleted:

tcltest::test create-ok-del {Create/delete an ensemble} \
-setup {
    setup
} \
-cleanup {
    cleanup
} \
-body {
    set crstat [catch \
        {::nscldaq::stateclient me tcp://localhost tcp://localhost test} msg]
    set delstat [catch {::nscldaq::stateclient -delete me} msg]
    
    list $crstat $delstat
} -result [list 0 0]

tcltest::test create-makes-ensemble {Create makes a command ensemble} \
-setup {
    setup
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
} \
-body {
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    info command me
} -result me

tcltest::test ensemble-needs-subcommand {Created command needs a subcommand} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
} \
-body {
    catch {me}
} -result 1

#  Get state

tcltest::test getstate-initial {Get state gets the initial value} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
} \
-body {
    me getstate
} -result "0Initial"

if 0 {
tcltest::test getstate-changed {Get state when it's been changed} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/State" "NotReady"
    varmgr::var set $h "/RunState/State" "Readying"
    
    varmgr::close $h
    
    after 350 incr waiter;    # Wait on message pump.
    vwait waiter
    
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me getstate
} -result "Readying"
}


tcltest::test getstate-standalone {If state is standalone - get program state} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/test/standalone"  true
    varmgr::var set $h "/RunState/test/State" "NotReady"
    varmgr::var set $h "/RunState/test/State" "Readying"
    
    varmgr::close $h
    
    after 350 incr waiter;    # Wait on message pump.
    vwait waiter
    
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me getstate
} -result "Readying"

# Set State tests - always sets program state:

tcltest::test setstate-needs-new {Set state needs a new state parameter} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    catch {me setstate}
} -result 1

tcltest::test setstate-sets {Set state sets a new legal state} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me setstate NotReady;                   # valid from 0Initial
    set h [varmgr::open tcp://localhost]
    set state [varmgr::var get $h "/RunState/test/State"]
    varmgr::close $h
    set state
} -result "NotReady"


tcltest::test set-state-notlegal {Setting an illegal state is an error} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    catch {me setstate Ready}
} -result 1

# Bad subcommand -- Had problems already with mis-spelled subcommands so no more:

tcltest::test bad-subcommand {Illegal subcommand is an error} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    catch {me no-such-sub}
} -result 1

# isenabled - check if the program is enbabled.

tcltest::test isenabled-yes {Program is enabled} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me isenabled
} -result 1

tcltest::test isenabled-no {Program is disabled} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/test/enable" false
    varmgr::close $h
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
   
} \
-body {
    me isenabled
} -result 0

# isstandaone - check if the program is in standalone mode.

tcltest::test isstandalone-no {Program is not standalone} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me isstandalone
} -result 0

tcltest::test isstandalone-yes {Program is standalone} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/test/standalone" true
    varmgr::close $h
    
    after 300;       # Wait for message pump to change this.
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me isstandalone
} -result 1

#  Title -returns title string.

tcltest::test title-initial {Initially empty} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me title
} -result ""

tcltest::test title-set {Modified} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/Title" "This is a title"
    varmgr::close $h
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me title
} -result "This is a title"

# runnumber:

tcltest::test runnumber-initial {Initial run number 0} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me runNumber
} -result 0

tcltest::test runnumber-set {set run number value tracked} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/RunNumber" 1234
    varmgr::close $h
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me runNumber
} -result 1234

#  recording flag:

tcltest::test recording-initial {Get the recording flag} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me recording
} -result 0

tcltest::test recording-set {set run number value tracked} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/Recording" true
    varmgr::close $h
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me recording
} -result 1

# outring:

tcltest::test outring-initial {Output ring value} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me outring
} -result output

tcltest::test outring-modified {Outring modified value} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/test/outring" foxring
    varmgr::close $h
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
    
   
} \
-body {
    me outring
} -result foxring

# inring

tcltest::test inring-initial {Initial value of inring} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
   
} \
-body {
    me inring
} -result tcp://localhost/ring

tcltest::test outring-set {Modified value of outring tracks} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/test/inring" tcp://some.other.host/ring
    varmgr::close $h
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
   
} \
-body {
    me inring
} -result tcp://some.other.host/ring

#  Callback:

set state  unknown
proc handleStateChanges newstate {
    set ::state $newstate
}

tcltest::test onstate-change {State Change callbacks work} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
   
} \
-body {
    me onStateChange handleStateChanges
    set h [varmgr::open tcp://localhost]
    varmgr::var set $h "/RunState/State" NotReady
    varmgr::close $h
    
    after 2000 {set state {Callout timedout}}
    vwait state
    
    set state
} -result NotReady


tcltest::test delegation {Should be able to delegate commands to base class} \
-setup {
    setup
    ::nscldaq::stateclient me tcp://localhost tcp://localhost test
} \
-cleanup {
    ::nscldaq::stateclient -delete me
    cleanup
   
} \
-body {
    me listPrograms
} -result test
#------------------------------------------------------------------
#
# Magic to exit with errors if there are test failures:

proc tcltest::cleanupTestsHook {} {
    variable numTests
    set ::exitCode $numTests(Failed)
}


tcltest::cleanupTests

exit $::exitCode
