package require tcltest
package require snit
# We'll provide mocks for bits of the packages below (if needed).

package provide Tk $tcl_patchLevel
package provide StateManagerControl 1.0

package require ReadoutCalloutsHarness

##
# frame object

namespace eval ::ttk {}

##
# ttk::frame.
snit::type ttk::frame {
    constructor args {

    }
}


##
#  Mock for grid.
#
set gridlist [list]
proc grid  args {
    lappend ::gridlist $args
}
proc getGridlist {} {return $::gridlist}
proc clearGridlist {} {set ::gridlist [list]}

##
# Mock for top level.
snit::type toplevel {
    option -menu ""
    option -children [list]
    
    constructor args {
        $self configurelist $args
    }
    destructor {
        if {$options(-menu) ne ""} {
            $options(-menu) destroy
        }
    }
}

proc winfo {children toplevel} {
    return [$toplevel cget -children]
}

##
# mock for menus:

snit::type menu {
    option -tearoff 1
    
    variable contents [list]

    method add args {
        lappend contents $args
    }
    method getContents {} {return $contents}
}

##
# Tests for addUserFrame:

tcltest::test addFirst {Add first user frame} \
-setup {
    clearGridlist
} \
-cleanup {
   ::ReadoutGUIPanel::.f1 destroy 
} \
-body {
    set f1 [ReadoutGUIPanel::addUserFrame f1]
    
    list $f1 $gridlist
} -result [list ::ReadoutGUIPanel::.f1 [list [list ::ReadoutGUIPanel::.f1 -sticky nsew]]]

tcltest::test addTwo {add Two frames} \
-setup {
    clearGridlist
} \
-cleanup {
    ::ReadoutGUIPanel::.f1 destroy
    ::ReadoutGUIPanel::.f2 destroy
} \
-body {
    ReadoutGUIPanel::addUserFrame f1
    ReadoutGUIPanel::addUserFrame f2
    
    set gridlist
} -result [list [list  ::ReadoutGUIPanel::.f1 -sticky nsew] [list ::ReadoutGUIPanel::.f2 -sticky nsew]]

##
# tests for addUserMenu:

tcltest::test addUserMenu-create {Add user menu forcing a creation} \
-setup {
    toplevel .
    
} \
-cleanup {
    . destroy
} \
-body {
    ReadoutGUIPanel::addUserMenu test {a test menu}
    
    set menubar [. cget -menu]
    list $menubar  [$menubar getContents]
} -result [list ::ReadoutGUIPanel::.m_0  [list [list cascade -menu ::ReadoutGUIPanel::.m_0.test -label "a test menu"]]]

tcltest::test addUserMenu-exists {Add user menu when toplevel has one} \
-setup {
    menu .junk
    toplevel . -menu .junk
} \
-cleanup {
    . destroy
} \
-body {
    set menu [ReadoutGUIPanel::addUserMenu test {a test menu}]
    set menubar [. cget -menu];   # Should still be .junk
    set contents [$menubar getContents]

    list $menubar $menu $contents
    
} -result [list .junk ::ReadoutGUIPanel::.junk.test [list [list cascade -menu ::ReadoutGUIPanel::.junk.test -label "a test menu"]]]


tcltest::test addUserMenu-dup {Add user menu when we need to hunt for a free widget.} \
-setup {
    toplevel . -children [list .m_0 .m_1]
} \
-cleanup {
    . destroy
} \
-body {
 ReadoutGUIPanel::addUserMenu test {a test menu} 
    set menubar [. cget -menu]
    list $menubar  [$menubar getContents]
} -result [list ::ReadoutGUIPanel::.m_2  [list [list cascade -menu ::ReadoutGUIPanel::.m_2.test -label "a test menu"]]]

#------------------------------------------------------------------
#
# Magic to exit with errors if there are test failures:

proc ::tcltest::cleanupTestsHook {} {
    variable numTests
    set ::exitCode $numTests(Failed)
}

tcltest::cleanupTests

exit $::exitCode

