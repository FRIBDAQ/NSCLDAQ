<!-- chapter libraries -->

<chapter>
   <title>DAQ Manager APIs</title>
   <para>
    The DAQ Manager has extensive APIs for database, server REST access.
    Also provided are a set of user interface libraries that provide canned views
    which can either be coupled with standard model/controller APIs to build
    user interfaces, or coupled with application specific model/controller
    code to produce custom written GUIs.
   </para>
   <para>
    At present these APIs only supply Tcl bindings.  As time goes on, it is
    likely that additional bindings will be written and documented here
    and in the reference pages.
   </para>
   <para>
    The organization of this chapter is as follows:
   </para>
   <itemizedlist>
    <listitem>
       <para>
           <link linkend='sec.manager.dbapi' endterm='sec.manager.dbapi.title' />
           documents the components of the DAQ manager configuration database API.
           This API not only supports database manipulation but includes
           code used by the manager.  
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.manager.clientapi' endterm='sec.manager.clientapi.title' />
          documents the components of the manager REST client API.  This API
          allows you to create custom code to interact witht he manager.
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.manager.guiapi' endterm='sec.manager.guiapi.title' /> 
       </para>
    </listitem>
   </itemizedlist>
   <para>
      Each of these sections will list and describe the packages provided
      in each category and provide copious references to man pages that
      provide detailed descriptions of their public interfaces.
   </para>
   <section id='sec.manager.dbapi'>
      <title id='sec.manager.dbapi.title'>Manager Configuration Database API</title>
      <para>
        This section will provide documenation for Tcl packages that provide direct
        access to the experiment configuration database used by the manager.
        In actual fact, these packages also contain the manager server, minus
        its REST interface packages.
      </para>
      <para>
        The  Tcl packages described in this section are available in the
        NSCLDAQ Tcl library tree. This is defined by the $DAQTCLLIBS environment
        variable when you source in <filename>daqsetup.bash</filename> from
        NSCLDAQ 12.0 and later.  You can add this directory to your path
        by either adding it to the TCLLIBPATH environment variable when running
        tclsh or explicitly including it in <varname>auto_path</varname>
        prior to sourcing your packages.  The next pair of examples illustrate
        both options.
      </para>
      <example>
        <title>Setting the TCLLIBPATH environment variable for tclsh</title>
        <programlisting>
# On the Tcl command line:

TCLLIBPATH="$TCLLIBPATH $DAQTCLLIBS" tclsh

# Or via a persistent environment variable:

TCLLIBPATH="$TCLLIBPATH $DAQTCLLIBS"
export TCLLIBPATH
tclsh
        </programlisting>
      </example>
      <para>
        Note that the method shown appends the
        <literal>DAQTCLLIBS</literal> environment variable
        value to any existing directorys in the
        <literal>TCLLIBPATH</literal>.  This environment
        variable is a space separated list of directories (valid Tcl list)  that
        are top levels of directories searched for packages.
      </para>
      <example>
        <title>Adding DAQTCLLIBS to auto_path</title>
        <programlisting>
lappend ::auto_path $::env(DAQTCLLIBS)
        </programlisting>
      </example>
      <para>
        This code snippet takes advantage of the fact that environment
        variables in Tcl are stored in a global array named <varname>env</varname>
        whose indices are variable names and values the values.  Using ::
        in front of these variable names forces them to be evaluated in the
        global scope allowing this code snippet to work even in the body of a
        <command>proc</command>.
      </para>
      <para>
        The database API packages are described in subsections listed below:
      </para>
      <itemizedlist>
        <listitem>
           <para>
              The <link linkend='sec.manager.containers' endterm='sec.manager.containers.title' />
              section describes a package that allows the manipulation of
              container definitions as well as the ability to start a
              persistent container
              as defined by the database in an arbitrary node that can access
              the container image and user's home directory tree.
           </para>
        </listitem>
        <listitem>
           <para>
               The <link linkend='sec.manager.programs' endterm='sec.manager.programs.title' />
               section describes a package that suports the definition of programs
               in the database and can manipulate them as well.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.sequence' endterm='sec.manager.sequence.title' />
              section describes a package that supports manipulation of the
              state machine and sequences attached to state transitions.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.kvstore' endterm='sec.manager.kvstore.title' />
              section describes a package that can manipulate the key value store.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.auth' endterm='sec.manager.auth.title' />
              section describes support for an authorization database.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.eventloggers'
              endterm='sec.manager.eventloggers.title' />
              section describes a package that supports the definition of
              event loggers.
           </para>
        </listitem>
      </itemizedlist>
      <para>
        Note that configuration databases are SQLite3 database files.
        Thus a pre-requisite for all of these packages is the
        <literal>sqlite3</literal> package.  More details will be provided
        in the sections below.
      </para>
      <section id='sec.manager.containers'>
         <title id='sec.manager.containers.title'>
            The <literal>containers</literal> package.
         </title>
         <para>
            The <literal>containers</literal> package is provided
            to manipulate the definitions of containers and to start
            and stop persistent containers defined in a configuration database.
            A common parameter to many of the exported procs is an sqlite3 database
            command.  The example below shows what you need to
            do to create
            this command.
         </para>
         <example id='ex.sqlite3cmd'>
            <title id='ex.sqlite3cmd.title'>Creating an SQLite3 database command</title>
            <programlisting>
package require sqlite3
...

sqlite3 db mydbfile.db
            </programlisting>            
         </example>
         <para>
            This code snippet pulls in the <literal>sqlite3</literal> Tcl
            package and later uses the <command>sqlite3</command> command
            to associate the command <command>db</command> with the
            database file <filename>mydbfile.db</filename>. The
            <command>sqlite3</command> command, by default will create
            a new database file, however since the database must have
            a specific schema before it can be used by this package you
            should not rely on this capability but use
            <link  linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
            to create configuration databases instead.
         </para>
         <para>
            The remainder of this section will briefly describe the capability
            of the package along with examples.  Reference material on the
            package can be found at:
            <link linkend='tcl3.containers' endterm='tcl3.containers.title' />.
         </para>
         <para>
            Containers are represented to have the following attributes:
         </para>
         <variablelist>
            <varlistentry>
               <term>name</term>
               <listitem>
                   <para>
                    Each container definition has a unqique name. This
                    name is used to identify the container definition
                    throughout the API>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>image</term>
               <listitem>
                   <para>
                    Each container has an image fie.  This is a singularity
                    image that, when activated produces a containerized
                    environment within which programs can run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>initialization script</term>
               <listitem>
                   <para>
                    Each container definition can have an initialization
                    script.  This is a shell script that is run prior
                    to running any program in the container.  One common
                    use for this script is to source an appropriate
                    <filename>daqsetup.bash</filename> into the shell that
                    runs programs in the container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>mount points</term>
               <listitem>
                   <para>
                    Each conatainer definition has a possibly empty list of
                    mount points.  A mount point is a host file or directory
                    and where it should appear inthe containerized environment.
                    The term for these in singularity's documentation are
                    <firstterm>bindpoints</firstterm>.
                   </para>
                   <para>
                    The singularity configuration provides a set of default
                    mount points that meet most needs, however some mount points
                    depend on the container.  For example a containerized
                    environment for Debian 10 will probably need a directory tree
                    of the NSCL software compiled for that software while
                    one for Debian 8 will need a different directory tree.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
         <para>
            Containers can be created, removed, listed, tested for, activated,
            and deactivated.  A program can be run in an activated container.
         </para>
         <para>
            Here's an example of a typical container creation we might have
            at the FRIB.  We want a container that will run the image
            <filename>/user/opt/buster.img</filename> and, for each program
            run in it will have the environment variables set up for
            NSCLDAQ-12.0.   This will require an  initialization script (to
            set up those variables) and the following code:
         </para>
         <example>
            <title>Creating a container definition for buster</title>
            <programlisting>
#---------------- Contents of ~/daq12.0.sh   --------------- 
#!/bin/bash
                                      <co id='ex.mgr.mkcont.init' />
. /usr/opt/daq/12.0/daqsetup.bash
#------------------------------------------------------------
#------------------------ contents of mkcontainr.tcl -----------

lappend auto_path $env(DAQTCLLIBS)  <co id='ex.mgr.mkcont.auto_path' />

package require sqlite3             <co id='ex.mgr.mkcont.requires' />
package require containers

sqlite3 db myconfig.db              <co id='ex.mgr.mkcont.opendb' />

   <co id='ex.mgr.mkcont.add' />
container::add db buster /usr/opt/buster.img ~/daq12.0.sh \
    [list [list /usr/opt/opt-buster /usr/opt]]
    
db close                         <co id='ex.mgr.mkcont.closedb' />
            </programlisting>
         </example>
         <para>
            Let's pick this apart.
         </para>
         <calloutlist>
            <callout arearefs='ex.mgr.mkcont.init' >
                <para>
                    The contents of this initialization file will be pulled
                    into the datbase and run prior to each program run in
                    an activated container.
                </para>
                <para>
                    Note, as we shall see later, the path used for
                    <filename>daqsetup.bash</filename>, is therefore where this
                    file will appear in the activated  container.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.auto_path' >
                <para>
                    As we've seen, this is one way to pull the libraries in
                    NSCLDAQ into the Tcl library package search path.  This
                    line assumes that prior to running this program
                    <filename>daqsetup.bash</filename> for NSCLDAQ 12.0 or
                    later has been sourced.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.requires' >
                <para>
                    Pulls in the packages we need. We need the
                    <literal>sqlite3</literal> package because we're going to have
                    to create a command connected to our configuration database.
                    We need the <literal>containers</literal> package because
                    that's the package we'll be exercising.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.opendb' >
                <para>
                    Creates a new command <command>db</command> which is connected
                    to the SQLite3 database file <filename>myconfig.db</filename>.
                    This file should have been made with
                    <link linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.add' >
                <para>
                    This command adds the container definition to the database
                    connected to <command>db</command>.  The remaining parameters
                    are the name, image, initialization script and bindings.
                </para>
                <para>
                    The binding we create will make the host directory tree
                    <filename>/usr/opt/opt-buster</filename> visible in the
                    activated containers as <filename>/usr/opt</filename>.
                </para>
                <para>
                    This matches our FRIB convention of storing built NSCLDAQ
                    software for a specific container type in
                    <filename>/usr/opt/opt-containertype</filename> which, for
                    proper use should appear at
                    <filename>/usr/opt</filename>.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.closedb' >
                <para>
                    Closes the SQLite3 connection to <filename>myconfig.cb</filename>.
                    This also undefined the command <command>db</command>
                </para>
            </callout>
         </calloutlist>
         <para>
            Defining a container does nothing more than that.  To use the containerized
            environment it defines, you must activate the container and subsequently
            run programs in that container.  You can then shutdown a container
            by deactivating it.  The example below makes a ringbuffer in the
            system <literal>spdaq99</literal> named <literal>fox</literal>.
            We override the default ring buffer data size and create a 16Mbyte
            ringbuffers.
         </para>
         <example>
            <title>Using <literal>containers</literal> To Make a RingBuffer.</title>
            <programlisting>
lappend auto_path $env(DAQTCLLIBS)  

package require sqlite3             
package require containers

sqlite3 db myconfig.db

set containerFd [container::activate db buster spdaq99]  <co id='ex.usecont.activate' />

set programFd   [container::run buster spdaq99 \        <co id='ex.usecont.run' />
     {$DAQBIN/ringbuffer create fox --datasize=16m}]
puts [gets $programFd]                                  <co id='ex.usecont.relay'/>
close $programFd

container::deactivate spdaq99 buseter               <co id='ex.usecont.deactivate' />
close $containerfd                                  <co id='ex.usecont.closecfd' />

            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.usecont.activate' >
                <para>
                    This command creates a persistent instance of the container
                    named <literal>buster</literal> on the host
                    <literal>spdaq99</literal>.  Before running a program
                    in a container it must be activated in the host(s) in which
                    we want to use it.
                </para>
                <para>
                    The variable <varname>programFd</varname> is a file descriptor
                    that receives output and error from the SSH command used
                    to activate the container.  
                </para>
            </callout>
            <callout arearefs='ex.usecont.run' >
                <para>
                    Runs the the NSCLDAQ program <command>ringbuffer</command>
                    to create a ringbuffer with the data size set to
                    <literal>16m</literal>, or 16 Megabytes.  A few things
                    to note: First we quoted the command in {}'s so that Tcl
                    would not interpret <literal>$DAQBIN</literal> as an attempt
                    to substitute for the <emphasis>Tcl</emphasis> variable
                    <varname>DAQBIN</varname>. Second because in our container
                    definition, we've arranged for <filename>daqsetup.bash</filename>
                    to be run the environment variable <varname>DAQBIN</varname>
                    is defined.  Finally, because the container package writes a
                    script to run the program, the string <literal>$DAQBIN</literal>
                    will get properly substituted.
                </para>
            </callout>
            <callout arearefs='ex.usecont.relay' >
                <para>
                    The <command>ringbuffer</command> command is transitory,
                    therefore we can capture its output simply in this way.
                    For a more long-lived program we might need to use fileevents
                    and the event loop to capture the output/error messages over
                    time.
                </para>
                <para>
                    Having captured and output the ringbuffer output/error
                    messages, we close the file descriptor.
                </para>
            </callout>
            <callout arearefs='ex.usecont.deactivate' >
                <para>
                    Done with the container, we deactivate it.
                </para>
            </callout>
            <callout arearefs='ex.usecont.closecfd' >
                <para>
                    In this simple example, we don't care about any output/error
                    messages from the container activation.  In fact, monitoring
                    the output from container activations is a bit complex,
                    and beyond the scope of this documentation.  The source
                    code for the <literal>programs</literal> package includes
                    code that does that.
                </para>
            </callout>
         </calloutlist>
         <para>
            Note that the package's ideas about which containers are active
            depend on internal data rather than any system information.  Therefore
            If you activate a container in one program and then run
            a program in it in another, you may fail.
         </para>
         <para>
            Note also that activating a container and running programs in it,
            depends on being able to run the <command>ssh</command> command.
            It is therefore important that your
            <filename>~/.ssh/authorized_keys</filename> file has a public key
            for your ssh identity.  See the results of google searches for
            <literal>SSH without password</literal> for information about how
            to set this up.
         </para>
      </section>
      <section id='sec.manager.programs'>
         <title id='sec.manager.programs.title'>
            The <literal>programs</literal> package
         </title>
         <para>
         </para>
      </section>
      <section id='sec.manager.sequence'>
         <title id='sec.manager.sequence.title'>
            The <command>sequence</command> package
         </title>
         <para>
         </para>
      </section>
      <section id='sec.manager.kvstore'>
         <title id='sec.manager.kvstore.title'>
            The <literal>kvstore</literal> package
         </title>
         <para>
         </para>
      </section>
      <section id='sec.manager.auth'>
         <title id='sec.manager.auth.title'>
            The <literal>auth</literal> package.
         </title>
         <para>
         </para>
      </section>
      <section id='sec.manager.eventloggers'>
         <title id='sec.manager.eventloggers.title'>
            The <literal>eventloggers</literal> package
         </title>
         <para>
         </para>
      </section>
   </section>
   <section id='sec.manager.clientapi'>
      <title id='sec.manager.clientapi.title'>Manager REST client API.</title>
      <para>
      </para>
   </section>
   <section id='sec.manager.guiapi'>
      <title id='sec.manager.guiapi.title'>Manager User Interface API</title>
      <para>
      </para>
   </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3tcl -->


<refentry id='tcl3.containers'>
   <refmeta>
      <refentrytitle id='tcl3.containers.title'>containers</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>containers</refname>
      <refpurpose>DAQ Manager Containers Database Package.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
package require containers

container::exists db name
container::add    db name image initfile mountpoints
container::remove db name
set fd [container::activate db name host]
set fd [container::run name host command]
container::deactivate host name
set dictlist [container::listDefinitions db ?name?]
        </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This package provides an API for the database schema that
            defines containers to the manager.  It is used by the manager
            code itself.  The API is roughly divided into database manipulations
            and procs that allow containers to be activated and applications
            run in those containers.
          </para>
          <para>
            The API makes use of singularity's ability to create persistent
            containers.  A persistent container is a container image process
            that also provides a new Linux namespace.  These containers have
            a script that can be run with parameters passed from the command
            line.  This provides the possibility of running programs within
            those persistent containers.
          </para>
          <para>
            Container definitions avhe the following attributes:
          </para>
          <variablelist>
            <varlistentry>
               <term>name</term>
               <listitem>
                   <para>
                    Each container definition has a unqique name. This
                    name is used to identify the container definition
                    throughout the API>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>image</term>
               <listitem>
                   <para>
                    Each container has an image fie.  This is a singularity
                    image that, when activated produces a containerized
                    environment within which programs can run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>initialization script</term>
               <listitem>
                   <para>
                    Each container definition can have an initialization
                    script.  This is a shell script that is run prior
                    to running any program in the container.  One common
                    use for this script is to source an appropriate
                    <filename>daqsetup.bash</filename> into the shell that
                    runs programs in the container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>mount points</term>
               <listitem>
                   <para>
                    Each conatainer definition has a possibly empty list of
                    mount points.  A mount point is a host file or directory
                    and where it should appear inthe containerized environment.
                    The term for these in singularity's documentation are
                    <firstterm>bindpoints</firstterm>.
                   </para>
                   <para>
                    The singularity configuration provides a set of default
                    mount points that meet most needs, however some mount points
                    depend on the container.  For example a containerized
                    environment for Debian 10 will probably need a directory tree
                    of the NSCL software compiled for that software while
                    one for Debian 8 will need a different directory tree.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
    </refsect1>
    <refsect1>
        <title>EXPORTED ENTRY POINTS</title>
        <para>
            For all entry points with a <parameter>db</parameter> parameter,
            this parameter should be an SQLite3 command that is connected to the
            configuration database you wish to manipulate.
        </para>
        <variablelist>
            <varlistentry>
               <term>
                <command>container::exists <replaceable>db name</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Returns a boolean value that is true if the container
                    <parameter>name</parameter> has been defined in the
                    configuration database whose SQLite3 database command
                    is <replaceable>db</replaceable>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::add <replaceable>db name image initfile mountpoints</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Adds a new container definition. The name of the new container
                    will be <parameter>name</parameter>, the container image is
                    given by the filename path in <parameter>image</parameter>.
                    The path must be valid in the host system(s) in which the
                    container will be activated.
                   </para>
                   <para>
                    If the <parameter>initfile</parameter> parameter is a non-empty
                    string it is the path to the initialization script to be
                    run prior to each program run in an activation of this container.
                    The path must be valid in the <emphasis>host</emphasis>
                    filesystem.  The <emphasis>contents</emphasis> of this
                    file at the time the container is added is sucked into the
                    database.  If you modify this file and want the modifications
                    to be reflected you must recreate the container definition.
                   </para>
                   <para>
                    The <parameter>mountpoints</parameter> parameter is a
                    list of desired mount points.  Each mount point is
                    a one or two element sublist.  If one element, the element
                    is a filesystem point in the native filesystem that's mounted
                    to the same position in the container (e.g. equivalent to
                    <literal>--bind point</literal>
                   ).  If a two element list, the first element is the
                    native file system point to bind and the second is where to bind
                    it in the container (e.g.
                    <literal>--bind point:where</literal>).
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::remove <replaceable>db name</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Removes the definition of the container <parameter>name</parameter>
                    from the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>
                    container::activate <replaceable>db name host</replaceable>
                </command>
               </term>
               <listitem>
                   <para>
                    Activates the container <parameter>name</parameter> in
                    the system with the DNS name <parameter>host</parameter>.
                    This proc, if successful, returns a Tcl file descriptor.
                   </para>
                   <para>
                    The container is activated using <command>ssh</command> the
                    user's public key must, therefore be in the
                    <filename>~/.ssh/authorized_keys</filename> file.  The
                    file descriptor returned is the output/error end of the
                    pipeline used to run ssh and therefore can capture the
                    messages and errors this ssh command output.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::run <replaceable>name host command</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Runs the <parameter>command</parameter> in the container
                    instance of <parameter>name</parameter> that must already
                    have been activated in a system with the DNS name
                    <parameter>host</parameter>.  
                   </para>
                   <para>
                    On success, a file descriptor connected to the output/error
                    of the program.  This allows you to capture messages and
                    
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::deactivate <replaceable>host name</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Deactivates the container <parameter>name</parameter> in the
                    system <parameter>host</parameter>.  The container must already
                    have been activated.  Deactivating a container will also kill
                    any programs that are running in that container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::listDefinitions <replaceable>db ?name?</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Returns a list of dicts that describe the containers that
                    have been defined.  If the optional <parameter>name</parameter>
                    parameter is provided, the list will be filtered to only
                    include that container <emphasis>but is still a list</emphasis>.
                    If no containers are defined or <parameter>name</parameter>
                    is provided but there is no container named
                    <parameter>name</parameter>, the result is an empty list.
                   </para>
                   <para>
                    Each elementof the list is a dict which describes one container
                    definition.  THe dict contains the following key/values:
                   </para>
                   <variablelist>
                    <varlistentry>
                       <term><literal>id</literal></term>
                       <listitem>
                           <para>
                            This is the primary key of the root record
                            for the container description in the database.
                            For the most part it does not help your code to
                            know this value but it is provided for internal use.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>name</literal></term>
                       <listitem>
                           <para>
                            Name of the container described by this dict.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>image</literal></term>
                       <listitem>
                           <para>
                            The file path (in the host filesystem) of
                            the container image that will be run when this
                            container is activated in a host.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>init</literal></term>
                       <listitem>
                           <para>
                            The <emphasis>contents</emphasis> of the
                            initialization script.   If no initialization
                            script was provided, this key will not be
                            present.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>bindings</literal></term>
                       <listitem>
                           <para>
                            A list of one or two element sublists describing
                            the mountpoints.  The first element (element 0)
                            of each list is a host file or directory.  If there
                            is no second element, this file or directory will
                            appear in the same place in the container as it does
                             in the host filesystem.  If there is a second element,
                             it describes where the file or directory will
                             appear in the container filesystem.
                           </para>
                           <para>
                            This second form is needed to provide for e.g.
                            mapping <filename>/usr/opt/opt-buster</filename>
                            in the host filesystem to <filename>/usr/opt</filename>
                            in the container, as is usually done at the FRIB.
                           </para>
                        </listitem>
                    </varlistentry>
                   </variablelist>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>
            FILES
        </title>
        <para>
            Container activation and their associated initialization
            scripts require that the package write shell scripts. These
            are stored in a hidden directory <filename>~/.daqmanager</filename>.
            The path to this directory is stored in the variable
            <varname>::container::tempdir</varname>. 
        </para>
        <para>
            Two sorts of scripts are stored there:
        </para>
        <variablelist>
            <varlistentry>
               <term><filename>container_init_nn</filename></term>
               <listitem>
                   <para>
                    Where nn is an integer is the script needed by
                    singluarity to run programs inside the activated,
                    persistent container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><filename>container_user_nn</filename></term>
               <listitem>
                   <para>
                    Where again nn is an integer is an initialization
                    script provided for the user run prior to running any
                    program within the activated container.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Note these scripts are a property of the container not of
            an activation of the container in a host.  That is all
            activations of a container will share the same scripts.
        </para>
    </refsect1>
</refentry>
<!-- /manpage -->