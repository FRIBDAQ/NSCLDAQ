<!-- chapter libraries -->

<chapter>
   <title>DAQ Manager APIs</title>
   <para>
    The DAQ Manager has extensive APIs for database, server REST access.
    Also provided are a set of user interface libraries that provide canned views
    which can either be coupled with standard model/controller APIs to build
    user interfaces, or coupled with application specific model/controller
    code to produce custom written GUIs.
   </para>
   <para>
    At present these APIs only supply Tcl bindings.  As time goes on, it is
    likely that additional bindings will be written and documented here
    and in the reference pages.
   </para>
   <para>
    The organization of this chapter is as follows:
   </para>
   <itemizedlist>
    <listitem>
       <para>
           <link linkend='sec.manager.dbapi' endterm='sec.manager.dbapi.title' />
           documents the components of the DAQ manager configuration database API.
           This API not only supports database manipulation but includes
           code used by the manager.  
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.manager.clientapi' endterm='sec.manager.clientapi.title' />
          documents the components of the manager REST client API.  This API
          allows you to create custom code to interact witht he manager.
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.manager.guiapi' endterm='sec.manager.guiapi.title' /> 
       </para>
    </listitem>
   </itemizedlist>
   <para>
      Each of these sections will list and describe the packages provided
      in each category and provide copious references to man pages that
      provide detailed descriptions of their public interfaces.
   </para>
   <section id='sec.manager.dbapi'>
      <title id='sec.manager.dbapi.title'>Manager Configuration Database API</title>
      <para>
        This section will provide documenation for Tcl packages that provide direct
        access to the experiment configuration database used by the manager.
        In actual fact, these packages also contain the manager server, minus
        its REST interface packages.
      </para>
      <para>
        The  Tcl packages described in this section are available in the
        NSCLDAQ Tcl library tree. This is defined by the $DAQTCLLIBS environment
        variable when you source in <filename>daqsetup.bash</filename> from
        NSCLDAQ 12.0 and later.  You can add this directory to your path
        by either adding it to the TCLLIBPATH environment variable when running
        tclsh or explicitly including it in <varname>auto_path</varname>
        prior to sourcing your packages.  The next pair of examples illustrate
        both options.
      </para>
      <example>
        <title>Setting the TCLLIBPATH environment variable for tclsh</title>
        <programlisting>
# On the Tcl command line:

TCLLIBPATH="$TCLLIBPATH $DAQTCLLIBS" tclsh

# Or via a persistent environment variable:

TCLLIBPATH="$TCLLIBPATH $DAQTCLLIBS"
export TCLLIBPATH
tclsh
        </programlisting>
      </example>
      <para>
        Note that the method shown appends the
        <literal>DAQTCLLIBS</literal> environment variable
        value to any existing directorys in the
        <literal>TCLLIBPATH</literal>.  This environment
        variable is a space separated list of directories (valid Tcl list)  that
        are top levels of directories searched for packages.
      </para>
      <example>
        <title>Adding DAQTCLLIBS to auto_path</title>
        <programlisting>
lappend ::auto_path $::env(DAQTCLLIBS)
        </programlisting>
      </example>
      <para>
        This code snippet takes advantage of the fact that environment
        variables in Tcl are stored in a global array named <varname>env</varname>
        whose indices are variable names and values the values.  Using ::
        in front of these variable names forces them to be evaluated in the
        global scope allowing this code snippet to work even in the body of a
        <command>proc</command>.
      </para>
      <para>
        The database API packages are described in subsections listed below:
      </para>
      <itemizedlist>
        <listitem>
           <para>
              The <link linkend='sec.manager.containers' endterm='sec.manager.containers.title' />
              section describes a package that allows the manipulation of
              container definitions as well as the ability to start a
              persistent container
              as defined by the database in an arbitrary node that can access
              the container image and user's home directory tree.
           </para>
        </listitem>
        <listitem>
           <para>
               The <link linkend='sec.manager.programs' endterm='sec.manager.programs.title' />
               section describes a package that suports the definition of programs
               in the database and can manipulate them as well.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.sequence' endterm='sec.manager.sequence.title' />
              section describes a package that supports manipulation of the
              state machine and sequences attached to state transitions.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.kvstore' endterm='sec.manager.kvstore.title' />
              section describes a package that can manipulate the key value store.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.auth' endterm='sec.manager.auth.title' />
              section describes support for an authorization database.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.eventloggers'
              endterm='sec.manager.eventloggers.title' />
              section describes a package that supports the definition of
              event loggers.
           </para>
        </listitem>
      </itemizedlist>
      <para>
        Note that configuration databases are SQLite3 database files.
        Thus a pre-requisite for all of these packages is the
        <literal>sqlite3</literal> package.  More details will be provided
        in the sections below.
      </para>
      <section id='sec.manager.containers'>
         <title id='sec.manager.containers.title'>
            The <literal>containers</literal> package.
         </title>
         <para>
            The <literal>containers</literal> package is provided
            to manipulate the definitions of containers and to start
            and stop persistent containers defined in a configuration database.
            A common parameter to many of the exported procs is an sqlite3 database
            command.  The example below shows what you need to
            do to create
            this command.
         </para>
         <example id='ex.sqlite3cmd'>
            <title id='ex.sqlite3cmd.title'>Creating an SQLite3 database command</title>
            <programlisting>
package require sqlite3
...

sqlite3 db mydbfile.db
            </programlisting>            
         </example>
         <para>
            This code snippet pulls in the <literal>sqlite3</literal> Tcl
            package and later uses the <command>sqlite3</command> command
            to associate the command <command>db</command> with the
            database file <filename>mydbfile.db</filename>. The
            <command>sqlite3</command> command, by default will create
            a new database file, however since the database must have
            a specific schema before it can be used by this package you
            should not rely on this capability but use
            <link  linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
            to create configuration databases instead.
         </para>
         <para>
            The remainder of this section will briefly describe the capability
            of the package along with examples.  Reference material on the
            package can be found at:
            <link linkend='tcl3.containers' endterm='tcl3.containers.title' />.
         </para>
         <para>
            Containers are represented to have the following attributes:
         </para>
         <variablelist>
            <varlistentry>
               <term>name</term>
               <listitem>
                   <para>
                    Each container definition has a unqique name. This
                    name is used to identify the container definition
                    throughout the API>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>image</term>
               <listitem>
                   <para>
                    Each container has an image fie.  This is a singularity
                    image that, when activated produces a containerized
                    environment within which programs can run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>initialization script</term>
               <listitem>
                   <para>
                    Each container definition can have an initialization
                    script.  This is a shell script that is run prior
                    to running any program in the container.  One common
                    use for this script is to source an appropriate
                    <filename>daqsetup.bash</filename> into the shell that
                    runs programs in the container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>mount points</term>
               <listitem>
                   <para>
                    Each conatainer definition has a possibly empty list of
                    mount points.  A mount point is a host file or directory
                    and where it should appear inthe containerized environment.
                    The term for these in singularity's documentation are
                    <firstterm>bindpoints</firstterm>.
                   </para>
                   <para>
                    The singularity configuration provides a set of default
                    mount points that meet most needs, however some mount points
                    depend on the container.  For example a containerized
                    environment for Debian 10 will probably need a directory tree
                    of the NSCL software compiled for that software while
                    one for Debian 8 will need a different directory tree.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
         <para>
            Containers can be created, removed, listed, tested for, activated,
            and deactivated.  A program can be run in an activated container.
         </para>
         <para>
            Here's an example of a typical container creation we might have
            at the FRIB.  We want a container that will run the image
            <filename>/user/opt/buster.img</filename> and, for each program
            run in it will have the environment variables set up for
            NSCLDAQ-12.0.   This will require an  initialization script (to
            set up those variables) and the following code:
         </para>
         <example>
            <title>Creating a container definition for buster</title>
            <programlisting>
#---------------- Contents of ~/daq12.0.sh   --------------- 
#!/bin/bash
                                      <co id='ex.mgr.mkcont.init' />
. /usr/opt/daq/12.0/daqsetup.bash
#------------------------------------------------------------
#------------------------ contents of mkcontainr.tcl -----------

lappend auto_path $env(DAQTCLLIBS)  <co id='ex.mgr.mkcont.auto_path' />

package require sqlite3             <co id='ex.mgr.mkcont.requires' />
package require containers

sqlite3 db myconfig.db              <co id='ex.mgr.mkcont.opendb' />

   <co id='ex.mgr.mkcont.add' />
container::add db buster /usr/opt/buster.img ~/daq12.0.sh \
    [list [list /usr/opt/opt-buster /usr/opt]]
    
db close                         <co id='ex.mgr.mkcont.closedb' />
            </programlisting>
         </example>
         <para>
            Let's pick this apart.
         </para>
         <calloutlist>
            <callout arearefs='ex.mgr.mkcont.init' >
                <para>
                    The contents of this initialization file will be pulled
                    into the datbase and run prior to each program run in
                    an activated container.
                </para>
                <para>
                    Note, as we shall see later, the path used for
                    <filename>daqsetup.bash</filename>, is therefore where this
                    file will appear in the activated  container.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.auto_path' >
                <para>
                    As we've seen, this is one way to pull the libraries in
                    NSCLDAQ into the Tcl library package search path.  This
                    line assumes that prior to running this program
                    <filename>daqsetup.bash</filename> for NSCLDAQ 12.0 or
                    later has been sourced.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.requires' >
                <para>
                    Pulls in the packages we need. We need the
                    <literal>sqlite3</literal> package because we're going to have
                    to create a command connected to our configuration database.
                    We need the <literal>containers</literal> package because
                    that's the package we'll be exercising.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.opendb' >
                <para>
                    Creates a new command <command>db</command> which is connected
                    to the SQLite3 database file <filename>myconfig.db</filename>.
                    This file should have been made with
                    <link linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.add' >
                <para>
                    This command adds the container definition to the database
                    connected to <command>db</command>.  The remaining parameters
                    are the name, image, initialization script and bindings.
                </para>
                <para>
                    The binding we create will make the host directory tree
                    <filename>/usr/opt/opt-buster</filename> visible in the
                    activated containers as <filename>/usr/opt</filename>.
                </para>
                <para>
                    This matches our FRIB convention of storing built NSCLDAQ
                    software for a specific container type in
                    <filename>/usr/opt/opt-containertype</filename> which, for
                    proper use should appear at
                    <filename>/usr/opt</filename>.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.closedb' >
                <para>
                    Closes the SQLite3 connection to <filename>myconfig.cb</filename>.
                    This also undefined the command <command>db</command>
                </para>
            </callout>
         </calloutlist>
         <para>
            Defining a container does nothing more than that.  To use the containerized
            environment it defines, you must activate the container and subsequently
            run programs in that container.  You can then shutdown a container
            by deactivating it.  The example below makes a ringbuffer in the
            system <literal>spdaq99</literal> named <literal>fox</literal>.
            We override the default ring buffer data size and create a 16Mbyte
            ringbuffers.
         </para>
         <example>
            <title>Using <literal>containers</literal> To Make a RingBuffer.</title>
            <programlisting>
lappend auto_path $env(DAQTCLLIBS)  

package require sqlite3             
package require containers

sqlite3 db myconfig.db

set containerFd [container::activate db buster spdaq99]  <co id='ex.usecont.activate' />

set programFd   [container::run buster spdaq99 \        <co id='ex.usecont.run' />
     {$DAQBIN/ringbuffer create fox --datasize=16m}]
puts [gets $programFd]                                  <co id='ex.usecont.relay'/>
close $programFd

container::deactivate spdaq99 buseter               <co id='ex.usecont.deactivate' />
close $containerfd                                  <co id='ex.usecont.closecfd' />

            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.usecont.activate' >
                <para>
                    This command creates a persistent instance of the container
                    named <literal>buster</literal> on the host
                    <literal>spdaq99</literal>.  Before running a program
                    in a container it must be activated in the host(s) in which
                    we want to use it.
                </para>
                <para>
                    The variable <varname>programFd</varname> is a file descriptor
                    that receives output and error from the SSH command used
                    to activate the container.  
                </para>
            </callout>
            <callout arearefs='ex.usecont.run' >
                <para>
                    Runs the the NSCLDAQ program <command>ringbuffer</command>
                    to create a ringbuffer with the data size set to
                    <literal>16m</literal>, or 16 Megabytes.  A few things
                    to note: First we quoted the command in {}'s so that Tcl
                    would not interpret <literal>$DAQBIN</literal> as an attempt
                    to substitute for the <emphasis>Tcl</emphasis> variable
                    <varname>DAQBIN</varname>. Second because in our container
                    definition, we've arranged for <filename>daqsetup.bash</filename>
                    to be run the environment variable <varname>DAQBIN</varname>
                    is defined.  Finally, because the container package writes a
                    script to run the program, the string <literal>$DAQBIN</literal>
                    will get properly substituted.
                </para>
            </callout>
            <callout arearefs='ex.usecont.relay' >
                <para>
                    The <command>ringbuffer</command> command is transitory,
                    therefore we can capture its output simply in this way.
                    For a more long-lived program we might need to use fileevents
                    and the event loop to capture the output/error messages over
                    time.
                </para>
                <para>
                    Having captured and output the ringbuffer output/error
                    messages, we close the file descriptor.
                </para>
            </callout>
            <callout arearefs='ex.usecont.deactivate' >
                <para>
                    Done with the container, we deactivate it.
                </para>
            </callout>
            <callout arearefs='ex.usecont.closecfd' >
                <para>
                    In this simple example, we don't care about any output/error
                    messages from the container activation.  In fact, monitoring
                    the output from container activations is a bit complex,
                    and beyond the scope of this documentation.  The source
                    code for the <literal>programs</literal> package includes
                    code that does that.
                </para>
            </callout>
         </calloutlist>
         <para>
            Note that the package's ideas about which containers are active
            depend on internal data rather than any system information.  Therefore
            If you activate a container in one program and then run
            a program in it in another, you may fail.
         </para>
         <para>
            Note also that activating a container and running programs in it,
            depends on being able to run the <command>ssh</command> command.
            It is therefore important that your
            <filename>~/.ssh/authorized_keys</filename> file has a public key
            for your ssh identity.  See the results of google searches for
            <literal>SSH without password</literal> for information about how
            to set this up.
         </para>
      </section>
      <section id='sec.manager.programs'>
         <title id='sec.manager.programs.title'>
            The <literal>programs</literal> package
         </title>
         <para>
            The <literal>programs</literal> package provides support for
            making and manipulating program definitions, for running and killing
            programs in hosts (either in or without containers), and for
            capturing program output.  The package, if needed, activates containers
            using the <literal>containers</literal> package we just described
            to run programs within a containerized environment.
         </para>
         <para>
            Reference material on the <literal>programs</literal>
            package can be found at:
            <link linkend='tcl3.programs' endterm='tcl3.programs.title' />
         </para>
         <para>
            A program is defined by the following mandatory data:
         </para>
         <variablelist>
            <varlistentry>
               <term>id</term>
               <listitem>
                   <para>
                     An integer that is unique across all programs.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>name</literal></term>
               <listitem>
                   <para>
                     This name is used to identify the program primarily to
                     people.  The <literal>name</literal> must be unique
                     among all programs.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>path</literal></term>
               <listitem>
                   <para>
                     The filesystem path to an executable entity. Executable
                     entities can be binary program sor they can be scripts.
                   </para>
                   <para>
                     If the program runs containerized the executable entity
                     must be locatable within the containerized environment.
                     This means that if the path to the script is incomplete,
                     the <literal>PATH</literal> variable in the container
                     must be able to locate the program.  Alternatively,
                     if the path to the program is complete, but the image of the
                     filesystem within the container is different that in the host,
                     the path within the container must be used.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>type</literal></term>
               <listitem>
                   <para>
                     The type of the program.  Programs can be
                     <literal>Transitory</literal>, which means it is expected
                     they will exit.  There are also two types of persistent
                     programs (programs that are not expected to exit):
                     <literal>Critical</literal> programs are required for
                     the data acquisition system to function properly.  If a
                     <literal>Critical</literal> program exits, the DAQ
                     manager forces the DAQ system to shutdown.
                     <literal>Persistent</literal> programs are not expected to
                     exit but, if they do, data taking can continue.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>host</literal></term>
               <listitem>
                   <para>
                     The DNS name of the host in which the program will be run.
                     You should specify exactly the name of the host in which to
                     run the program and not use <literal>localhost</literal>.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            Several optional bits of data can be associated with a program and
            define the environment in which the program runs.  Not all of these
            items are used at this implementation of the system.
         </para>
         <variablelist>
            <varlistentry>
               <term><literal>container</literal></term>
               <listitem>
                   <para>
                     The name of a container in which the program will
                     run.  This container must be defined in the
                     <literal>containers</literal> package.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>initscript</literal></term>
               <listitem>
                   <para>
                     An initialization script run prior to running the program.
                     This is not yet used.  The contents of this script are
                     pulled into the database.  Thus changes to the
                     initialization script (once it's implemented) will
                     not bee seen until the program is re-defined.
                   </para>
                   <para>
                     By not used, I mean that the GUI systems to edit program
                     definitions don't provide a mechanism for providing this
                     script.  At program activation time, any initialization
                     script provided is used.
                   </para>
                   <para>
                     Since the contents of the script are sucked into the
                     database, it's important to provide the path to the
                     script at the time the program is defined.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>service</literal></term>
               <listitem>
                   <para>
                     Not currently used.  If the program provides a REST service,
                     its name should be provided here.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>environment</literal></term>
               <listitem>
                   <para>
                     A list of environment name, value pairs which will be
                     put into the program's environment before it is started.
                   </para>
                   <para>
                     For example, when a Tcl script is the program, you
                     may need to supply a <literal>TCLLIBPATH=$DAQTCLLIBS</literal>
                     environment definition
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>directory</literal></term>
               <listitem>
                   <para>
                     The working directory in which the program will be started.
                     If not provided, you should make no assumptions about
                     the working directory the program will be run in.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            These bits of optional data are used to construct the
            command used to run the program.
         </para>
         <variablelist>
            <varlistentry>
               <term><literal>options</literal></term>
               <listitem>
                   <para>
                     These are the program options and optionally values
                     needed by those options.  For example, for a Readout,
                     an option might
                     be <option>--ring</option> with a value like
                     <option>fox</option>.  It is legal for options not to have
                     a value (for example <option>--oneshot</option>).
                   </para>
                   <para>
                     Options are considered to be unordered.
                  </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>parameters</literal></term>
               <listitem>
                   <para>
                     Parameters are placed on the command line following
                     all options.  They are considered to be a list of ordered
                     values.  An example of program parameters might be
                     the name of the host in which the manager is running.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            Note that since many of these items are used to construct a
            script to run the command environment substitutions are supported
            e.g. if daqsetup has been run in the context in which the program
            was run <literal>$DAQBIN</literal> can be used to specify the
            path to an NSCLDAQ program.
         </para>
         <para>
            Let's look at some of the operations you can perform on
            programs.  We're going to assume that there's a container defined
            named <literal>buster</literal> whose initialization script
            runs <literal>daqsetup.bash</literal>.
         </para>
         <formalpara>
            <title>Adding a Program</title>
            <para>
               To add a program running <literal>VMUSBReadout</literal>in
               <literal>spdaq99</literal>, for example we might do the following:
            </para>
         </formalpara>
         <example>
            <title>Adding a New Program Definition</title>
            <programlisting>
lappend auto_path $env(DAQTCLLIBS)    <co id='ex.addpgm.autopath' />
package require sqlite3               <co id='ex.addpgm.requires' />
package require programs

sqlite3 db myconfig.db                <co id='ex.addpgm.open' />

program::add db readcrate1 \$DAQBIN/VMUSBReadout Critical spdaq99 \
     [dict create                                                  \
        container buster                                           \
        options [list {--daqconfig ~/spdaq99/daqconfig.tcl}        \ <co id='ex.addpgm.add' />
           {--ctlconfig /dev/null} {--ring=crate1} {--sourceid 99} \
           {--initscript ~/spdaq99/startrest.tcl}                   \
        ]                                                          \
        environment {TCLLIBPATH $DAQTCLLIBS}                       \
        service     ReadoutREST                                    \
     ]

db close


            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.addpgm.autopath' >
                <para>
                  Adds the NSCLDAQ Tcl library path to the
                  <varname>auto_path</varname> so that the
                  <literal>programs</literal> package can be found.
                </para>
            </callout>
            <callout arearefs='ex.addpgm.requires' >
                <para>
                  Pulls in the packages this simple example needs.
                  The <literal>sqlite3</literal> package is needed to
                  create a connection to the configuration database.
                  The <literal>programs</literal> package is needed
                  to add a program definition.
                </para>
            </callout>
            <callout arearefs='ex.addpgm.open' >
                <para>
                  Almost all of the programs package procs require
                  an sqlite3 database connection parameter to tell them
                  which database to operate on.  This line opens a
                  database creating the command ensemble
                  <command>db</command>.  
                </para>
                <para>
                  Note that while this command
                  will create a database if does not exist, the resulting
                  database will not have any table definitions.
                  To create an experiment configuration database
                  file, you should instead use the NSCLDAQ
                  <link linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
                  command.
                </para>
            </callout>
            <callout arearefs='ex.addpgm.add' >
                <para>
                  There's a lot going on in this command so let's take it a
                  bit at a time.  The <command>program::add</command> command
                  creates a new program definition.  The first parameter it takes
                  is an SQLite3 datbase connection.  This connection must
                  connect to a database that was created with
                  <link linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
                </para>
                <para>
                  The next two parameters are the name and program path
                  respectively.  The name must be unique over all
                  programs or else an error will be thrown.  The
                  program path must be valid within the environment
                  in which the program will be run.  Note the use of the
                  backslash character to prevent variable substitution in
                  specifying that the <command>VMUSBReadout</command>
                  command lives in the NSCDAQ binaries directory.
                </para>
                <para>
                  The program type is <literal>Critical</literal> since
                  it is a readout and likely the experiment cannot run
                  without it.
                </para>
                <para>
                  The program will run in the host <literal>spdaq99</literal>
                </para>
                <para>
                  The optional data are specified as a dict.  The
                  key of the dict specifies the data provided and the
                  value the data itself.  The <literal>container</literal>
                  key specifies the program will be started containerized
                  and will run in the <literal>buster</literal> container.
                </para>
                <para>
                  The <literal>options</literal> key specifies a list of
                  option/value pairs passed to the program when it is run.
                  Each option is a one or two element sublist containing,
                  inorder, the
                  option name and value.  If an option does not require a name,
                  it must be specified with a single element sublist.
                  The option/value pairs in this example should be familiar
                  to users of <command>VMUSBReadout</command>, with the
                  possible exception of <option>--initscript</option> which
                  supplies a TCL script sourced by the program's Tcl interpreter
                  to start the REST server component.
                </para>
                <para>
                  The <literal>environment</literal> key provides environment
                  variables.  In this case we ensure that the DAQ Tcl libraries
                  are in the library search path.  This will be needed by
                  <filename>~/spdaq99/startrest.tcl</filename>.
                </para>
                <para>
                  While not yet used, we set the servicename used by the
                  REST interface so that when this is used by the system,
                  we don't need any changes.
                </para>
            </callout>
         </calloutlist>
         <para>
            The contents of the <filename>~/spdaq99/startrest.tcl</filename>
            script are simple:
         </para>
         <example>
            <title>Initialization Script to start Readout REST servers</title>
            <programlisting>
package require ReadoutREST
close stdin
            </programlisting>
         </example>
         <formalpara>
            <title>Listing Program Definitions</title>
            <para>
               There are two entries for getting program definitions
               <command>getdef</command> returns a dict that describes
               a program definition when given a database handle and the
               name of a program.  <command>listDefinitions</command>
               returns a list of those dicts, one for each program definition.
            </para>
         </formalpara>
         <para>
            The example below lists the name of each program, where it
            runs and the image it runs.  See
            <link linkend='tcl3.programs' endterm='tcl3.programs.title' />
            for a full description of the dict used to describe program definitions.
         </para>
         <example>
            <title>Listing Program Definitions</title>
            <programlisting>
lappend auto_path $env(DAQTCLLIBS)
package require sqlite3
pacakge require programs

sqlite3 db myconfig.db

set inf [program::listDefinitions db]
foreach p $inf {
   set name [dict get $p name]
   set host [dict get $p host]
   set path [dict get $p path]
   puts "$name runs $path in $host"
}
            </programlisting>
         </example>
         <para>
            This example should be relatively self explanatory
            <command>listDefinitions</command> only requires a database
            command ensemble connected to a properly formatted database.
         </para>
         <formalpara>
            <title>Running a Program</title>
            <para>
               Once a program has been defined it can be run.   When you
               run a program, if it has a container specified, the package
               will first activate the container.  Regardless it will
               write a script to run the program.  The program itself,
               is run over an ssh pipe and the file descriptor for that
               pipe's output and stderr  is returned to the caller.
            </para>
         </formalpara>
         <para>
            <command>program::run</command> establishes an output
            handler for the pipe.  Optionally the caller can supply
            an output handler as well.  Regardless, it's important,
            for those output handlers, that at some point an event loop
            is entered to allow those file handlers to be dispatched.
         </para>
         <para>
            In the example below, we run two programs:  <literal>readcrate1</literal>
            and <literal>unimportant</literal>.  We'll catch and output the
            output/error of readcrate1 and let the default handler take care
            of unimportant.
         </para>
         <para>
            When readcrate1 exits (detected by an eof on the pipe), we'll
            exit as well. 
         </para>
         <example>
            <title>Starting Programs in the <literal>programs</literal> Package</title>
            <programlisting>
lappend auto_path $env(DAQTCLLIBS)
package require sqlite3
package require programs

sqlite3 db myconfig.db

set done 0
proc ReadCrate1OutputHandler {name fd} {                <co id='program.run.handler' />
   if {![eof $fd]} {
      puts "$name: [gets $fd]"
   } else {
      incr ::done
   }
}

program::run db readcrate1 ReadCrateOutputHandler      <co id='program.run.run' />
set fd [program::run db unimportant]

vwait done                                             <co id='program.run.evloop' />

if {[program::isActive unimportant]} {
   program::kill db unimportant                       <co id='program.run.kill' />
   catch [close $fd]
}

db close
            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='program.run.handler' >
                <para>
                  This will be the output handler for the <literal>readcrate1</literal>
                  program.   This will be called with two parameters.  The
                  first is the name of the program, the second is the file descriptor
                  connected to the pipe.
               </para>
                <para>
                  If the file descriptor has not been closed by the program,
                  a line is read and output preceded by the name of the program.
                  If an end file is detected, we increment the <varname>done</varname>
                  variable.  More about this later.
                </para>
                <para>
                  Note that we don't close the file descriptor.  The program
                  API wraps our output handler in its own output handler.
                  That output handler wrapper will take care of closing the
                  file descriptor.
                </para>
            </callout>
            <callout arearefs='program.run.run' >
                <para>
                  These two lines run the two programs.  <literal>readcrate1</literal>
                  is given an output handler while <literal>unimportant</literal>
                  just gets the output handler wrapper (which throws away
                  any output).  We capture the file descriptor of
                  <literal>unimportant</literal> because, as we'll see later
                  we may need to close it.
                </para>
            </callout>
            <callout arearefs='program.run.evloop' >
                <para>
                  Enters the event loop until the <varname>done</varname>
                  global variable is modified.  As we've seen, this will
                  be modified when <literal>readcrate1</literal> exits
                  (or at least closes its output and error pipe).
                  Entering the event loop allows Tcl to dispatch the output
                  handlers attached to file descriptors
                  (see the Tcl documentation of <command>fileevent</command>).
                </para>
            </callout>
            <callout arearefs='program.run.kill' >
                <para>
                  The <command>isActive</command> command determines if a
                  program is still active.  If <literal>unimportant</literal>
                  is still running we ask the package to kill it and
                  then close the file descriptor open on its pipe.
                </para>
                <para>
                  It's a good idea to wrap <command>close</command> file
                  file descriptors open on pipelines  in a
                  <command>catch</command>.  This is because anything that
                  looks like a failure of the process connected to the pipe
                  will result in an error from the <command>close</command>
                  command.  This includes not only a non zero exit status
                  but any output on the program's stderr as well.
                </para>
            </callout>
         </calloutlist>
         <para>
            A note about <literal>program::kill</literal>.  This operates
            by locating the program image in the remote system and using
            ssh to issue a <command>kill</command> command.  Sadly, there are
            cases where this is unsufficient and I don't know how to help that.
            Specifically, if the image is a script that runs a program,
            even though the script gets killed, the program my continue to run.
         </para>
      </section>
      <section id='sec.manager.sequence'>
         <title id='sec.manager.sequence.title'>
            The <command>sequence</command> package
         </title>
         <para>
            The <literal>sequence</literal> package provides support for
            two concepts within the manager:
         </para>
         <orderedlist>
            <listitem>
               <para>
                  The manager implements a state machine.  While there is
                  a default state machine loaded into the manager it is
                  possible to define any state machine as long as its initial
                  state is called <literal>SHUTDOWN</literal> and
                  any state can transition to <literal>SHUTDOWN</literal>
               </para>
            </listitem>
            <listitem>
               <para>
                  The manager associates sequences to transitions into
                  a specific state.  A sequence is a list of programs
                  (see previous section) that are run to properly transition
                  to that state.
               </para>
            </listitem>
         </orderedlist>
         <para>
            The remainder of this section will describe:
         </para>
         <itemizedlist>
            <listitem>
               <para>
                  What a state machine is, and the default state machine
                  that's implemented when a configuration database is
                  created.
               </para>
            </listitem>
            <listitem>
               <para>
                  Parts of the <literal>sequence</literal> package that
                  can be used to create other state machines than the
                  default state machine.  Note that in most cases it is not
                  necessary to create a custom state machine.
               </para>
            </listitem>
            <listitem>
               <para>
                  Sequences and the API section of the sequence
                  package that manage sequences.
               </para>
            </listitem>
            <listitem>
               <para>
                  Transitions and the parts of the API that manage them.
               </para>
            </listitem>
            <listitem>
               <para>
                  Miscellaneous parts of the AP:I that don't neatly fit into
                  any of these categories.
               </para>
            </listitem>
         </itemizedlist>
      </section>
      <section id='sec.manager.kvstore'>
         <title id='sec.manager.kvstore.title'>
            The <literal>kvstore</literal> package
         </title>
         <para>
         </para>
      </section>
      <section id='sec.manager.auth'>
         <title id='sec.manager.auth.title'>
            The <literal>auth</literal> package.
         </title>
         <para>
         </para>
      </section>
      <section id='sec.manager.eventloggers'>
         <title id='sec.manager.eventloggers.title'>
            The <literal>eventloggers</literal> package
         </title>
         <para>
         </para>
      </section>
   </section>
   <section id='sec.manager.clientapi'>
      <title id='sec.manager.clientapi.title'>Manager REST client API.</title>
      <para>
      </para>
   </section>
   <section id='sec.manager.guiapi'>
      <title id='sec.manager.guiapi.title'>Manager User Interface API</title>
      <para>
      </para>
   </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3tcl -->


<refentry id='tcl3.containers'>
   <refmeta>
      <refentrytitle id='tcl3.containers.title'>containers</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>containers</refname>
      <refpurpose>DAQ Manager Containers Database Package.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
package require containers

container::exists db name
container::add    db name image initfile mountpoints
container::remove db name
set fd [container::activate db name host]
set fd [container::run name host command]
container::deactivate host name
set dictlist [container::listDefinitions db ?name?]
        </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This package provides an API for the database schema that
            defines containers to the manager.  It is used by the manager
            code itself.  The API is roughly divided into database manipulations
            and procs that allow containers to be activated and applications
            run in those containers.
          </para>
          <para>
            The API makes use of singularity's ability to create persistent
            containers.  A persistent container is a container image process
            that also provides a new Linux namespace.  These containers have
            a script that can be run with parameters passed from the command
            line.  This provides the possibility of running programs within
            those persistent containers.
          </para>
          <para>
            Container definitions avhe the following attributes:
          </para>
          <variablelist>
            <varlistentry>
               <term>name</term>
               <listitem>
                   <para>
                    Each container definition has a unqique name. This
                    name is used to identify the container definition
                    throughout the API>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>image</term>
               <listitem>
                   <para>
                    Each container has an image fie.  This is a singularity
                    image that, when activated produces a containerized
                    environment within which programs can run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>initialization script</term>
               <listitem>
                   <para>
                    Each container definition can have an initialization
                    script.  This is a shell script that is run prior
                    to running any program in the container.  One common
                    use for this script is to source an appropriate
                    <filename>daqsetup.bash</filename> into the shell that
                    runs programs in the container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>mount points</term>
               <listitem>
                   <para>
                    Each conatainer definition has a possibly empty list of
                    mount points.  A mount point is a host file or directory
                    and where it should appear inthe containerized environment.
                    The term for these in singularity's documentation are
                    <firstterm>bindpoints</firstterm>.
                   </para>
                   <para>
                    The singularity configuration provides a set of default
                    mount points that meet most needs, however some mount points
                    depend on the container.  For example a containerized
                    environment for Debian 10 will probably need a directory tree
                    of the NSCL software compiled for that software while
                    one for Debian 8 will need a different directory tree.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
    </refsect1>
    <refsect1>
        <title>EXPORTED ENTRY POINTS</title>
        <para>
            For all entry points with a <parameter>db</parameter> parameter,
            this parameter should be an SQLite3 command that is connected to the
            configuration database you wish to manipulate.
        </para>
        <variablelist>
            <varlistentry>
               <term>
                <command>container::exists <replaceable>db name</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Returns a boolean value that is true if the container
                    <parameter>name</parameter> has been defined in the
                    configuration database whose SQLite3 database command
                    is <replaceable>db</replaceable>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::add <replaceable>db name image initfile mountpoints</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Adds a new container definition. The name of the new container
                    will be <parameter>name</parameter>, the container image is
                    given by the filename path in <parameter>image</parameter>.
                    The path must be valid in the host system(s) in which the
                    container will be activated.
                   </para>
                   <para>
                    If the <parameter>initfile</parameter> parameter is a non-empty
                    string it is the path to the initialization script to be
                    run prior to each program run in an activation of this container.
                    The path must be valid in the <emphasis>host</emphasis>
                    filesystem.  The <emphasis>contents</emphasis> of this
                    file at the time the container is added is sucked into the
                    database.  If you modify this file and want the modifications
                    to be reflected you must recreate the container definition.
                   </para>
                   <para>
                    The <parameter>mountpoints</parameter> parameter is a
                    list of desired mount points.  Each mount point is
                    a one or two element sublist.  If one element, the element
                    is a filesystem point in the native filesystem that's mounted
                    to the same position in the container (e.g. equivalent to
                    <literal>--bind point</literal>
                   ).  If a two element list, the first element is the
                    native file system point to bind and the second is where to bind
                    it in the container (e.g.
                    <literal>--bind point:where</literal>).
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::remove <replaceable>db name</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Removes the definition of the container <parameter>name</parameter>
                    from the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>
                    container::activate <replaceable>db name host</replaceable>
                </command>
               </term>
               <listitem>
                   <para>
                    Activates the container <parameter>name</parameter> in
                    the system with the DNS name <parameter>host</parameter>.
                    This proc, if successful, returns a Tcl file descriptor.
                   </para>
                   <para>
                    The container is activated using <command>ssh</command> the
                    user's public key must, therefore be in the
                    <filename>~/.ssh/authorized_keys</filename> file.  The
                    file descriptor returned is the output/error end of the
                    pipeline used to run ssh and therefore can capture the
                    messages and errors this ssh command output.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::run <replaceable>name host command</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Runs the <parameter>command</parameter> in the container
                    instance of <parameter>name</parameter> that must already
                    have been activated in a system with the DNS name
                    <parameter>host</parameter>.  
                   </para>
                   <para>
                    On success, a file descriptor connected to the output/error
                    of the program.  This allows you to capture messages and
                    
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::deactivate <replaceable>host name</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Deactivates the container <parameter>name</parameter> in the
                    system <parameter>host</parameter>.  The container must already
                    have been activated.  Deactivating a container will also kill
                    any programs that are running in that container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::listDefinitions <replaceable>db ?name?</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Returns a list of dicts that describe the containers that
                    have been defined.  If the optional <parameter>name</parameter>
                    parameter is provided, the list will be filtered to only
                    include that container <emphasis>but is still a list</emphasis>.
                    If no containers are defined or <parameter>name</parameter>
                    is provided but there is no container named
                    <parameter>name</parameter>, the result is an empty list.
                   </para>
                   <para>
                    Each elementof the list is a dict which describes one container
                    definition.  THe dict contains the following key/values:
                   </para>
                   <variablelist>
                    <varlistentry>
                       <term><literal>id</literal></term>
                       <listitem>
                           <para>
                            This is the primary key of the root record
                            for the container description in the database.
                            For the most part it does not help your code to
                            know this value but it is provided for internal use.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>name</literal></term>
                       <listitem>
                           <para>
                            Name of the container described by this dict.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>image</literal></term>
                       <listitem>
                           <para>
                            The file path (in the host filesystem) of
                            the container image that will be run when this
                            container is activated in a host.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>init</literal></term>
                       <listitem>
                           <para>
                            The <emphasis>contents</emphasis> of the
                            initialization script.   If no initialization
                            script was provided, this key will not be
                            present.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>bindings</literal></term>
                       <listitem>
                           <para>
                            A list of one or two element sublists describing
                            the mountpoints.  The first element (element 0)
                            of each list is a host file or directory.  If there
                            is no second element, this file or directory will
                            appear in the same place in the container as it does
                             in the host filesystem.  If there is a second element,
                             it describes where the file or directory will
                             appear in the container filesystem.
                           </para>
                           <para>
                            This second form is needed to provide for e.g.
                            mapping <filename>/usr/opt/opt-buster</filename>
                            in the host filesystem to <filename>/usr/opt</filename>
                            in the container, as is usually done at the FRIB.
                           </para>
                        </listitem>
                    </varlistentry>
                   </variablelist>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>
            FILES
        </title>
        <para>
            Container activation and their associated initialization
            scripts require that the package write shell scripts. These
            are stored in a hidden directory <filename>~/.daqmanager</filename>.
            The path to this directory is stored in the variable
            <varname>::container::tempdir</varname>. 
        </para>
        <para>
            Two sorts of scripts are stored there:
        </para>
        <variablelist>
            <varlistentry>
               <term><filename>container_init_nn</filename></term>
               <listitem>
                   <para>
                    Where nn is an integer is the script needed by
                    singluarity to run programs inside the activated,
                    persistent container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><filename>container_user_nn</filename></term>
               <listitem>
                   <para>
                    Where again nn is an integer is an initialization
                    script provided for the user run prior to running any
                    program within the activated container.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Note these scripts are a property of the container not of
            an activation of the container in a host.  That is all container
            activations use the same script filename although the current
            implementation writes the script each time it's needed to allow
            for changes in a container's definition between activations.
        </para>
    </refsect1>
</refentry>

<refentry id='tcl3.programs'>
   <refmeta>
      <refentrytitle id='tcl3.programs.title'>programs</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>programs</refname>
      <refpurpose>API For the DAQ Manager Program Database</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require programs

program::exists db name
program::add    db name path type host options
program::remove db name
set def [program::getdef db name]
set defs [program::listDefinitions db]
if {[program::isActive name]} {...}
set namesAndHosts [::program::activeContainers]
set names [::program::activePrograms]
set fd [::program::run db name ?outputHandler?]
::program::kill db name


      </programlisting>
    </refsynopsisdiv>
    <refsect1>
      <title>DESCRIPTION</title>
         <para>
           This package provides access to the program definition part of
           the experiment database.  It also provides procs that allow
           programs to be run and stopped.  See
           <literal>EXPORTED ENTRY POINTS</literal> below for details.
         </para>
         <para>
           A program is defined by the following mandatory data:
        </para>
        <variablelist>
           <varlistentry>
              <term>id</term>
              <listitem>
                  <para>
                    An integer that is unique across all programs.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>name</literal></term>
              <listitem>
                  <para>
                    This name is used to identify the program primarily to
                    people.  The <literal>name</literal> must be unique
                    among all programs.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>path</literal></term>
              <listitem>
                  <para>
                    The filesystem path to an executable entity. Executable
                    entities can be binary program sor they can be scripts.
                  </para>
                  <para>
                    If the program runs containerized the executable entity
                    must be locatable within the containerized environment.
                    This means that if the path to the script is incomplete,
                    the <literal>PATH</literal> variable in the container
                    must be able to locate the program.  Alternatively,
                    if the path to the program is complete, but the image of the
                    filesystem within the container is different that in the host,
                    the path within the container must be used.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>type</literal></term>
              <listitem>
                  <para>
                    The type of the program.  Programs can be
                    <literal>Transitory</literal>, which means it is expected
                    they will exit.  There are also two types of persistent
                    programs (programs that are not expected to exit):
                    <literal>Critical</literal> programs are required for
                    the data acquisition system to function properly.  If a
                    <literal>Critical</literal> program exits, the DAQ
                    manager forces the DAQ system to shutdown.
                    <literal>Persistent</literal> programs are not expected to
                    exit but, if they do, data taking can continue.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>host</literal></term>
              <listitem>
                  <para>
                    The DNS name of the host in which the program will be run.
                    You should specify exactly the name of the host in which to
                    run the program and not use <literal>localhost</literal>.
                  </para>
               </listitem>
           </varlistentry>
        </variablelist>
        <para>
           Several optional bits of data can be associated with a program and
           define the environment in which the program runs.  Not all of these
           items are used at this implementation of the system.
        </para>
        <variablelist>
           <varlistentry>
              <term><literal>container</literal></term>
              <listitem>
                  <para>
                    The name of a container in which the program will
                    run.  This container must be defined in the
                    <literal>containers</literal> package.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>initscript</literal></term>
              <listitem>
                  <para>
                    An initialization script run prior to running the program.
                    This is not yet used.  The contents of this script are
                    pulled into the database.  Thus changes to the
                    initialization script (once it's implemented) will
                    not bee seen until the program is re-defined.
                  </para>
                  <para>
                    By not used, I mean that the GUI systems to edit program
                    definitions don't provide a mechanism for providing this
                    script.  At program activation time, any initialization
                    script provided is used.
                  </para>
                  <para>
                    Since the contents of the script are sucked into the
                    database, it's important to provide the path to the
                    script at the time the program is defined.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>service</literal></term>
              <listitem>
                  <para>
                    Not currently used.  If the program provides a REST service,
                    its name should be provided here.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>environment</literal></term>
              <listitem>
                  <para>
                    A list of environment name, value pairs which will be
                    put into the program's environment before it is started.
                  </para>
                  <para>
                    For example, when a Tcl script is the program, you
                    may need to supply a <literal>TCLLIBPATH=$DAQTCLLIBS</literal>
                    environment definition
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>directory</literal></term>
              <listitem>
                  <para>
                    The working directory in which the program will be started.
                    If not provided, you should make no assumptions about
                    the working directory the program will be run in.
                  </para>
               </listitem>
           </varlistentry>
        </variablelist>
        <para>
           These bits of optional data are used to construct the
           command used to run the program.
        </para>
        <variablelist>
           <varlistentry>
              <term><literal>options</literal></term>
              <listitem>
                  <para>
                    These are the program options and optionally values
                    needed by those options.  For example, for a Readout,
                    an option might
                    be <option>--ring</option> with a value like
                    <option>fox</option>.  It is legal for options not to have
                    a value (for example <option>--oneshot</option>).
                  </para>
                  <para>
                    Options are considered to be unordered.
                 </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>parameters</literal></term>
              <listitem>
                  <para>
                    Parameters are placed on the command line following
                    all options.  They are considered to be a list of ordered
                    values.  An example of program parameters might be
                    the name of the host in which the manager is running.
                  </para>
               </listitem>
           </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
      <title>EXPORTED ENTRY POINTS</title>
      <para>
         All of the exported entries are in the
         <literal>::program</literal> namespace.  If you are browsing the
         source code of the package. Note that any proc name beginning with
         a <literal>_</literal> is internal and not gauranteed to be stable
         over time.  
      </para>
      <variablelist>
         <varlistentry>
            <term><command>program::exists</command> <replaceable>db name</replaceable></term>
            <listitem>
                <para>
                  Determines if the named program; <parameter>name</parameter>
                  has been defined in the database whose SQLite3 connection
                  is <parameter>db</parameter>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>program::add</command> <replaceable>db name path type host ?options?</replaceable>
            </term>
            <listitem>
                <para>
                  Adds a new program definition in the SQLite3 experiment
                  configuration database pointed to by <parameter>db</parameter>
               </para>
                <para>
                  <parameter>name</parameter> is the name that will be given
                  to the new program.  The name must be unique across all
                  program definitions in the database.  If a program with
                  that name already exists, an error will be thrown.
                </para>
                <para>
                  <parameter>path</parameter> is the path to the thing
                  (executable program or script) that will be run when
                  <parameter>name</parameter> is run.  Note that if the
                  program is containerized, this path must be correct within
                  the container rather than the host system.
                </para>
                <para>
                  <parameter>type</parameter> is the program type.  This is
                  one of <literal>Transitory</literal>, <literal>Critical</literal>
                  or <literal>Persistent</literal>.  Transitory programs
                  are expected to exit, normally relatively quickly.  Critical programs
                  are required for the DAQ system to run.  If a critical
                  program exits, the manager shuts down the DAQ system.
                  Persistent programs are also intended to not exit, however
                  the DAQ system can continue to run without them. 
                </para>
                <para>
                  <parameter>host</parameter> is the DNS name of the system
                  in which the program will be run.
                </para>
                <para>
                  The <parameter>options</parameter> optional parameter is
                  provided to supply additional  information describing
                  the environment and manner in which the program
                  will be run.  It consists of a dict that whose keys
                  are parameter names and values for those parameters.
                </para>
                <para>
                  None of the keys are mandatory.  The keys are:
                </para>
                <variablelist>
                  <varlistentry>
                     <term><literal>container</literal></term>
                     <listitem>
                         <para>
                           If supplied, this must be the name of a container
                           that is already defined via the
                           <link linkend='tcl3.containers' endterm='tcl3.containers.title' />
                           package.    If supplied, the program, when run,
                           will be run in the container environment specified
                           by that container definition.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>initscript</literal></term>
                     <listitem>
                         <para>
                           Initialization script.  This should be the path to
                           a valid shell script in the context in which the
                           <command>program::add</command> command is run.
                           The contents of this file, at the time
                           <command>program::add</command> is called will
                           be stored in the database and, when the program
                           is run, will be run prior to executing the program.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>service</literal></term>
                     <listitem>
                         <para>
                           This is not yet used.  If your program publishes
                           a service with the NSCLDAQ port manager, the
                           name of this service should be placed here.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>options</literal></term>
                     <listitem>
                         <para>
                           The value of this key is a list of program command
                           line options.  If an option is a two element list,
                           the first is considered to be the option name and
                           the second a value associated with the option.
                       </para>
                       <para>
                           name value pairs become command line options
                           of the form <literal>name=value</literal>.
                       </para>
                       <para>
                        The order in which options are specified is not
                        considered to be important, however, they are written
                        on the command line in the same order as provided here.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>parameters</literal></term>
                     <listitem>
                         <para>
                           The value of this is a list of values that will
                           be provided as program command line parameters in the
                           order in which they are given here.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term>environment</term>
                     <listitem>
                         <para>
                           The value of this is a list of name value pairs
                           that will become environment variables available
                           to the program.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>directory</literal></term>
                     <listitem>
                         <para>
                           Sets a current working directory for the program.
                           Note if the program is containerized, this must
                           be expressed in terms of the containerized file
                           system.  If this is not specified, no assumptions
                           should be made about the working directory
                           in which the program is run.
                       </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
                <para>
                  Note that when the program is run, a script is generated to run
                  the program.  As such, any shell substitutions can be
                  specified for any of the values used to start a program.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>program::remove</command> <replaceable>db name</replaceable></term>
            <listitem>
                <para>
                  Removes the program named <parameter>name</parameter> from
                  the database whose connection command is <parameter>db</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>><command>program::getdef</command> <replaceable>db name</replaceable></term>
            <listitem>
                <para>
                  Returns a dict that describes the program
                  <parameter>name</parameter> in the database
                  <parameter>db</parameter>.  The dict will have the
                  following keys and values:
               </para>
               <variablelist>
                  <varlistentry>
                     <term><literal>id</literal></term>
                     <listitem>
                         <para>
                           A unique integer that identifies the program.
                           In database terminology, this is the primary key of
                           the root record of the program definition.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>name</literal></term>
                     <listitem>
                         <para>
                           Name of the program
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>path</literal></term>
                     <listitem>
                         <para>
                           Path to the program or script that will be run.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>type</literal></term>
                     <listitem>
                         <para>
                           Type of the program  in text form. This will
                           be one of <literal>Transitory</literal>,
                           <literal>Persistent</literal> or
                           <literal>Critical</literal>.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>type_id</literal></term>
                     <listitem>
                         <para>
                           Integer value that's related to the
                           <literal>type</literal>.   In fact the
                           legal types are in a database table, and this value
                           is the primary key for the type described in
                           <literal>type</literal>.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>host</literal></term>
                     <listitem>
                         <para>
                           The DNS name of the host in which the program
                           will be run.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>directory</literal></term>
                     <listitem>
                         <para>
                            Present only if a working directory was specified for the
                            program.  The value will be the value of that
                            directory.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>container_name, container_id</literal></term>
                     <listitem>
                         <para>
                           If present, the program is to be run containerized.
                           The <literal>container_name</literal> value
                           is the name of the container in which to run
                           the program. The <literal>container_id</literal>
                           value is the primary key of the container's root
                           record.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>initscript</literal></term>
                     <listitem>
                         <para>
                           If an initialization script was specified, this
                           will be the contents of that script file at the
                           time the program was defined with
                           <command>program::add</command>
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>service</literal></term>
                     <listitem>
                         <para>
                           If present a service name was provided and
                           the value is the name provided.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>options</literal></term>
                     <listitem>
                         <para>
                           List of two element lists where the first
                           element of each sublist is a program option name
                           and the second element its value.  If the option
                           has no value, the second element is an empty string.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>parameters</literal></term>
                     <listitem>
                         <para>
                           List of parameters that will be added to the
                           program command line.  These are considered
                           to be ordered.  That is they are added to the
                           command line after the options and in the same
                           order as this list.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>environment</literal></term>
                     <listitem>
                         <para>
                           A list of two item sublists that define additions
                           to the environment variables that will be added
                           to the environment prior to running the program.
                           The first element of each sublist is the name of
                           an environment variable and the second is the
                           value of that variable.
                       </para>
                    </listitem>
                  </varlistentry>
               </variablelist>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<!-- /manpage -->