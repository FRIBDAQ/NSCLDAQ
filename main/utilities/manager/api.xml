<!-- chapter libraries -->

<chapter>
   <title>DAQ Manager APIs</title>
   <para>
    The DAQ Manager has extensive APIs for database, server REST access.
    Also provided are a set of user interface libraries that provide canned views
    which can either be coupled with standard model/controller APIs to build
    user interfaces, or coupled with application specific model/controller
    code to produce custom written GUIs.
   </para>
   <para>
    At present these APIs only supply Tcl bindings.  As time goes on, it is
    likely that additional bindings will be written and documented here
    and in the reference pages.
   </para>
   <para>
    The organization of this chapter is as follows:
   </para>
   <itemizedlist>
    <listitem>
       <para>
           <link linkend='sec.manager.dbapi' endterm='sec.manager.dbapi.title' />
           documents the components of the DAQ manager configuration database API.
           This API not only supports database manipulation but includes
           code used by the manager.  
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.manager.clientapi' endterm='sec.manager.clientapi.title' />
          documents the components of the manager REST client API.  This API
          allows you to create custom code to interact witht he manager.
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.manager.guiapi' endterm='sec.manager.guiapi.title' /> 
       </para>
    </listitem>
   </itemizedlist>
   <para>
      Each of these sections will list and describe the packages provided
      in each category and provide copious references to man pages that
      provide detailed descriptions of their public interfaces.
   </para>
   <section id='sec.manager.dbapi'>
      <title id='sec.manager.dbapi.title'>Manager Configuration Database API</title>
      <para>
        This section will provide documenation for Tcl packages that provide direct
        access to the experiment configuration database used by the manager.
        In actual fact, these packages also contain the manager server, minus
        its REST interface packages.
      </para>
      <para>
        The  Tcl packages described in this section are available in the
        NSCLDAQ Tcl library tree. This is defined by the $DAQTCLLIBS environment
        variable when you source in <filename>daqsetup.bash</filename> from
        NSCLDAQ 12.0 and later.  You can add this directory to your path
        by either adding it to the TCLLIBPATH environment variable when running
        tclsh or explicitly including it in <varname>auto_path</varname>
        prior to sourcing your packages.  The next pair of examples illustrate
        both options.
      </para>
      <example>
        <title>Setting the TCLLIBPATH environment variable for tclsh</title>
        <programlisting>
# On the Tcl command line:

TCLLIBPATH="$TCLLIBPATH $DAQTCLLIBS" tclsh

# Or via a persistent environment variable:

TCLLIBPATH="$TCLLIBPATH $DAQTCLLIBS"
export TCLLIBPATH
tclsh
        </programlisting>
      </example>
      <para>
        Note that the method shown appends the
        <literal>DAQTCLLIBS</literal> environment variable
        value to any existing directorys in the
        <literal>TCLLIBPATH</literal>.  This environment
        variable is a space separated list of directories (valid Tcl list)  that
        are top levels of directories searched for packages.
      </para>
      <example>
        <title>Adding DAQTCLLIBS to auto_path</title>
        <programlisting>
lappend ::auto_path $::env(DAQTCLLIBS)
        </programlisting>
      </example>
      <para>
        This code snippet takes advantage of the fact that environment
        variables in Tcl are stored in a global array named <varname>env</varname>
        whose indices are variable names and values the values.  Using ::
        in front of these variable names forces them to be evaluated in the
        global scope allowing this code snippet to work even in the body of a
        <command>proc</command>.
      </para>
      <para>
        The database API packages are described in subsections listed below:
      </para>
      <itemizedlist>
        <listitem>
           <para>
              The <link linkend='sec.manager.containers' endterm='sec.manager.containers.title' />
              section describes a package that allows the manipulation of
              container definitions as well as the ability to start a
              persistent container
              as defined by the database in an arbitrary node that can access
              the container image and user's home directory tree.
           </para>
        </listitem>
        <listitem>
           <para>
               The <link linkend='sec.manager.programs' endterm='sec.manager.programs.title' />
               section describes a package that suports the definition of programs
               in the database and can manipulate them as well.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.sequence' endterm='sec.manager.sequence.title' />
              section describes a package that supports manipulation of the
              state machine and sequences attached to state transitions.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.kvstore' endterm='sec.manager.kvstore.title' />
              section describes a package that can manipulate the key value store.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.auth' endterm='sec.manager.auth.title' />
              section describes support for an authorization database.
           </para>
        </listitem>
        <listitem>
           <para>
              The <link linkend='sec.manager.eventloggers'
              endterm='sec.manager.eventloggers.title' />
              section describes a package that supports the definition of
              event loggers.
           </para>
        </listitem>
      </itemizedlist>
      <para>
        Note that configuration databases are SQLite3 database files.
        Thus a pre-requisite for all of these packages is the
        <literal>sqlite3</literal> package.  More details will be provided
        in the sections below.
      </para>
      <section id='sec.manager.containers'>
         <title id='sec.manager.containers.title'>
            The <literal>containers</literal> package.
         </title>
         <para>
            The <literal>containers</literal> package is provided
            to manipulate the definitions of containers and to start
            and stop persistent containers defined in a configuration database.
            A common parameter to many of the exported procs is an sqlite3 database
            command.  The example below shows what you need to
            do to create
            this command.
         </para>
         <example id='ex.sqlite3cmd'>
            <title id='ex.sqlite3cmd.title'>Creating an SQLite3 database command</title>
            <programlisting>
package require sqlite3
...

sqlite3 db mydbfile.db
            </programlisting>            
         </example>
         <para>
            This code snippet pulls in the <literal>sqlite3</literal> Tcl
            package and later uses the <command>sqlite3</command> command
            to associate the command <command>db</command> with the
            database file <filename>mydbfile.db</filename>. The
            <command>sqlite3</command> command, by default will create
            a new database file, however since the database must have
            a specific schema before it can be used by this package you
            should not rely on this capability but use
            <link  linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
            to create configuration databases instead.
         </para>
         <para>
            The remainder of this section will briefly describe the capability
            of the package along with examples.  Reference material on the
            package can be found at:
            <link linkend='tcl3.containers' endterm='tcl3.containers.title' />.
         </para>
         <para>
            Containers are represented to have the following attributes:
         </para>
         <variablelist>
            <varlistentry>
               <term>name</term>
               <listitem>
                   <para>
                    Each container definition has a unqique name. This
                    name is used to identify the container definition
                    throughout the API>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>image</term>
               <listitem>
                   <para>
                    Each container has an image fie.  This is a singularity
                    image that, when activated produces a containerized
                    environment within which programs can run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>initialization script</term>
               <listitem>
                   <para>
                    Each container definition can have an initialization
                    script.  This is a shell script that is run prior
                    to running any program in the container.  One common
                    use for this script is to source an appropriate
                    <filename>daqsetup.bash</filename> into the shell that
                    runs programs in the container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>mount points</term>
               <listitem>
                   <para>
                    Each conatainer definition has a possibly empty list of
                    mount points.  A mount point is a host file or directory
                    and where it should appear inthe containerized environment.
                    The term for these in singularity's documentation are
                    <firstterm>bindpoints</firstterm>.
                   </para>
                   <para>
                    The singularity configuration provides a set of default
                    mount points that meet most needs, however some mount points
                    depend on the container.  For example a containerized
                    environment for Debian 10 will probably need a directory tree
                    of the NSCL software compiled for that software while
                    one for Debian 8 will need a different directory tree.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
         <para>
            Containers can be created, removed, listed, tested for, activated,
            and deactivated.  A program can be run in an activated container.
         </para>
         <para>
            Here's an example of a typical container creation we might have
            at the FRIB.  We want a container that will run the image
            <filename>/user/opt/buster.img</filename> and, for each program
            run in it will have the environment variables set up for
            NSCLDAQ-12.0.   This will require an  initialization script (to
            set up those variables) and the following code:
         </para>
         <example>
            <title>Creating a container definition for buster</title>
            <programlisting>
#---------------- Contents of ~/daq12.0.sh   --------------- 
#!/bin/bash
                                      <co id='ex.mgr.mkcont.init' />
. /usr/opt/daq/12.0/daqsetup.bash
#------------------------------------------------------------
#------------------------ contents of mkcontainr.tcl -----------

lappend auto_path $env(DAQTCLLIBS)  <co id='ex.mgr.mkcont.auto_path' />

package require sqlite3             <co id='ex.mgr.mkcont.requires' />
package require containers

sqlite3 db myconfig.db              <co id='ex.mgr.mkcont.opendb' />

   <co id='ex.mgr.mkcont.add' />
container::add db buster /usr/opt/buster.img ~/daq12.0.sh \
    [list [list /usr/opt/opt-buster /usr/opt]]
    
db close                         <co id='ex.mgr.mkcont.closedb' />
            </programlisting>
         </example>
         <para>
            Let's pick this apart.
         </para>
         <calloutlist>
            <callout arearefs='ex.mgr.mkcont.init' >
                <para>
                    The contents of this initialization file will be pulled
                    into the datbase and run prior to each program run in
                    an activated container.
                </para>
                <para>
                    Note, as we shall see later, the path used for
                    <filename>daqsetup.bash</filename>, is therefore where this
                    file will appear in the activated  container.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.auto_path' >
                <para>
                    As we've seen, this is one way to pull the libraries in
                    NSCLDAQ into the Tcl library package search path.  This
                    line assumes that prior to running this program
                    <filename>daqsetup.bash</filename> for NSCLDAQ 12.0 or
                    later has been sourced.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.requires' >
                <para>
                    Pulls in the packages we need. We need the
                    <literal>sqlite3</literal> package because we're going to have
                    to create a command connected to our configuration database.
                    We need the <literal>containers</literal> package because
                    that's the package we'll be exercising.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.opendb' >
                <para>
                    Creates a new command <command>db</command> which is connected
                    to the SQLite3 database file <filename>myconfig.db</filename>.
                    This file should have been made with
                    <link linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.add' >
                <para>
                    This command adds the container definition to the database
                    connected to <command>db</command>.  The remaining parameters
                    are the name, image, initialization script and bindings.
                </para>
                <para>
                    The binding we create will make the host directory tree
                    <filename>/usr/opt/opt-buster</filename> visible in the
                    activated containers as <filename>/usr/opt</filename>.
                </para>
                <para>
                    This matches our FRIB convention of storing built NSCLDAQ
                    software for a specific container type in
                    <filename>/usr/opt/opt-containertype</filename> which, for
                    proper use should appear at
                    <filename>/usr/opt</filename>.
                </para>
            </callout>
            <callout arearefs='ex.mgr.mkcont.closedb' >
                <para>
                    Closes the SQLite3 connection to <filename>myconfig.cb</filename>.
                    This also undefined the command <command>db</command>
                </para>
            </callout>
         </calloutlist>
         <para>
            Defining a container does nothing more than that.  To use the containerized
            environment it defines, you must activate the container and subsequently
            run programs in that container.  You can then shutdown a container
            by deactivating it.  The example below makes a ringbuffer in the
            system <literal>spdaq99</literal> named <literal>fox</literal>.
            We override the default ring buffer data size and create a 16Mbyte
            ringbuffers.
         </para>
         <example>
            <title>Using <literal>containers</literal> To Make a RingBuffer.</title>
            <programlisting>
lappend auto_path $env(DAQTCLLIBS)  

package require sqlite3             
package require containers

sqlite3 db myconfig.db

set containerFd [container::activate db buster spdaq99]  <co id='ex.usecont.activate' />

set programFd   [container::run buster spdaq99 \        <co id='ex.usecont.run' />
     {$DAQBIN/ringbuffer create fox --datasize=16m}]
puts [gets $programFd]                                  <co id='ex.usecont.relay'/>
close $programFd

container::deactivate spdaq99 buseter               <co id='ex.usecont.deactivate' />
close $containerfd                                  <co id='ex.usecont.closecfd' />

            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.usecont.activate' >
                <para>
                    This command creates a persistent instance of the container
                    named <literal>buster</literal> on the host
                    <literal>spdaq99</literal>.  Before running a program
                    in a container it must be activated in the host(s) in which
                    we want to use it.
                </para>
                <para>
                    The variable <varname>programFd</varname> is a file descriptor
                    that receives output and error from the SSH command used
                    to activate the container.  
                </para>
            </callout>
            <callout arearefs='ex.usecont.run' >
                <para>
                    Runs the the NSCLDAQ program <command>ringbuffer</command>
                    to create a ringbuffer with the data size set to
                    <literal>16m</literal>, or 16 Megabytes.  A few things
                    to note: First we quoted the command in {}'s so that Tcl
                    would not interpret <literal>$DAQBIN</literal> as an attempt
                    to substitute for the <emphasis>Tcl</emphasis> variable
                    <varname>DAQBIN</varname>. Second because in our container
                    definition, we've arranged for <filename>daqsetup.bash</filename>
                    to be run the environment variable <varname>DAQBIN</varname>
                    is defined.  Finally, because the container package writes a
                    script to run the program, the string <literal>$DAQBIN</literal>
                    will get properly substituted.
                </para>
            </callout>
            <callout arearefs='ex.usecont.relay' >
                <para>
                    The <command>ringbuffer</command> command is transitory,
                    therefore we can capture its output simply in this way.
                    For a more long-lived program we might need to use fileevents
                    and the event loop to capture the output/error messages over
                    time.
                </para>
                <para>
                    Having captured and output the ringbuffer output/error
                    messages, we close the file descriptor.
                </para>
            </callout>
            <callout arearefs='ex.usecont.deactivate' >
                <para>
                    Done with the container, we deactivate it.
                </para>
            </callout>
            <callout arearefs='ex.usecont.closecfd' >
                <para>
                    In this simple example, we don't care about any output/error
                    messages from the container activation.  In fact, monitoring
                    the output from container activations is a bit complex,
                    and beyond the scope of this documentation.  The source
                    code for the <literal>programs</literal> package includes
                    code that does that.
                </para>
            </callout>
         </calloutlist>
         <para>
            Note that the package's ideas about which containers are active
            depend on internal data rather than any system information.  Therefore
            If you activate a container in one program and then run
            a program in it in another, you may fail.
         </para>
         <para>
            Note also that activating a container and running programs in it,
            depends on being able to run the <command>ssh</command> command.
            It is therefore important that your
            <filename>~/.ssh/authorized_keys</filename> file has a public key
            for your ssh identity.  See the results of google searches for
            <literal>SSH without password</literal> for information about how
            to set this up.
         </para>
      </section>
      <section id='sec.manager.programs'>
         <title id='sec.manager.programs.title'>
            The <literal>programs</literal> package
         </title>
         <para>
            The <literal>programs</literal> package provides support for
            making and manipulating program definitions, for running and killing
            programs in hosts (either in or without containers), and for
            capturing program output.  The package, if needed, activates containers
            using the <literal>containers</literal> package we just described
            to run programs within a containerized environment.
         </para>
         <para>
            Reference material on the <literal>programs</literal>
            package can be found at:
            <link linkend='tcl3.programs' endterm='tcl3.programs.title' />
         </para>
         <para>
            A program is defined by the following mandatory data:
         </para>
         <variablelist>
            <varlistentry>
               <term>id</term>
               <listitem>
                   <para>
                     An integer that is unique across all programs.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>name</literal></term>
               <listitem>
                   <para>
                     This name is used to identify the program primarily to
                     people.  The <literal>name</literal> must be unique
                     among all programs.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>path</literal></term>
               <listitem>
                   <para>
                     The filesystem path to an executable entity. Executable
                     entities can be binary program sor they can be scripts.
                   </para>
                   <para>
                     If the program runs containerized the executable entity
                     must be locatable within the containerized environment.
                     This means that if the path to the script is incomplete,
                     the <literal>PATH</literal> variable in the container
                     must be able to locate the program.  Alternatively,
                     if the path to the program is complete, but the image of the
                     filesystem within the container is different that in the host,
                     the path within the container must be used.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>type</literal></term>
               <listitem>
                   <para>
                     The type of the program.  Programs can be
                     <literal>Transitory</literal>, which means it is expected
                     they will exit.  There are also two types of persistent
                     programs (programs that are not expected to exit):
                     <literal>Critical</literal> programs are required for
                     the data acquisition system to function properly.  If a
                     <literal>Critical</literal> program exits, the DAQ
                     manager forces the DAQ system to shutdown.
                     <literal>Persistent</literal> programs are not expected to
                     exit but, if they do, data taking can continue.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>host</literal></term>
               <listitem>
                   <para>
                     The DNS name of the host in which the program will be run.
                     You should specify exactly the name of the host in which to
                     run the program and not use <literal>localhost</literal>.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            Several optional bits of data can be associated with a program and
            define the environment in which the program runs.  Not all of these
            items are used at this implementation of the system.
         </para>
         <variablelist>
            <varlistentry>
               <term><literal>container</literal></term>
               <listitem>
                   <para>
                     The name of a container in which the program will
                     run.  This container must be defined in the
                     <literal>containers</literal> package.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>initscript</literal></term>
               <listitem>
                   <para>
                     An initialization script run prior to running the program.
                     This is not yet used.  The contents of this script are
                     pulled into the database.  Thus changes to the
                     initialization script (once it's implemented) will
                     not bee seen until the program is re-defined.
                   </para>
                   <para>
                     By not used, I mean that the GUI systems to edit program
                     definitions don't provide a mechanism for providing this
                     script.  At program activation time, any initialization
                     script provided is used.
                   </para>
                   <para>
                     Since the contents of the script are sucked into the
                     database, it's important to provide the path to the
                     script at the time the program is defined.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>service</literal></term>
               <listitem>
                   <para>
                     Not currently used.  If the program provides a REST service,
                     its name should be provided here.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>environment</literal></term>
               <listitem>
                   <para>
                     A list of environment name, value pairs which will be
                     put into the program's environment before it is started.
                   </para>
                   <para>
                     For example, when a Tcl script is the program, you
                     may need to supply a <literal>TCLLIBPATH=$DAQTCLLIBS</literal>
                     environment definition
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>directory</literal></term>
               <listitem>
                   <para>
                     The working directory in which the program will be started.
                     If not provided, you should make no assumptions about
                     the working directory the program will be run in.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            These bits of optional data are used to construct the
            command used to run the program.
         </para>
         <variablelist>
            <varlistentry>
               <term><literal>options</literal></term>
               <listitem>
                   <para>
                     These are the program options and optionally values
                     needed by those options.  For example, for a Readout,
                     an option might
                     be <option>--ring</option> with a value like
                     <option>fox</option>.  It is legal for options not to have
                     a value (for example <option>--oneshot</option>).
                   </para>
                   <para>
                     Options are considered to be unordered.
                  </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>parameters</literal></term>
               <listitem>
                   <para>
                     Parameters are placed on the command line following
                     all options.  They are considered to be a list of ordered
                     values.  An example of program parameters might be
                     the name of the host in which the manager is running.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            Note that since many of these items are used to construct a
            script to run the command environment substitutions are supported
            e.g. if daqsetup has been run in the context in which the program
            was run <literal>$DAQBIN</literal> can be used to specify the
            path to an NSCLDAQ program.
         </para>
         <para>
            Let's look at some of the operations you can perform on
            programs.  We're going to assume that there's a container defined
            named <literal>buster</literal> whose initialization script
            runs <literal>daqsetup.bash</literal>.
         </para>
         <formalpara>
            <title>Adding a Program</title>
            <para>
               To add a program running <literal>VMUSBReadout</literal>in
               <literal>spdaq99</literal>, for example we might do the following:
            </para>
         </formalpara>
         <example>
            <title>Adding a New Program Definition</title>
            <programlisting>
lappend auto_path $env(DAQTCLLIBS)    <co id='ex.addpgm.autopath' />
package require sqlite3               <co id='ex.addpgm.requires' />
package require programs

sqlite3 db myconfig.db                <co id='ex.addpgm.open' />

program::add db readcrate1 \$DAQBIN/VMUSBReadout Critical spdaq99 \
     [dict create                                                  \
        container buster                                           \
        options [list {--daqconfig ~/spdaq99/daqconfig.tcl}        \ <co id='ex.addpgm.add' />
           {--ctlconfig /dev/null} {--ring=crate1} {--sourceid 99} \
           {--initscript ~/spdaq99/startrest.tcl}                   \
        ]                                                          \
        environment {TCLLIBPATH $DAQTCLLIBS}                       \
        service     ReadoutREST                                    \
     ]

db close


            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.addpgm.autopath' >
                <para>
                  Adds the NSCLDAQ Tcl library path to the
                  <varname>auto_path</varname> so that the
                  <literal>programs</literal> package can be found.
                </para>
            </callout>
            <callout arearefs='ex.addpgm.requires' >
                <para>
                  Pulls in the packages this simple example needs.
                  The <literal>sqlite3</literal> package is needed to
                  create a connection to the configuration database.
                  The <literal>programs</literal> package is needed
                  to add a program definition.
                </para>
            </callout>
            <callout arearefs='ex.addpgm.open' >
                <para>
                  Almost all of the programs package procs require
                  an sqlite3 database connection parameter to tell them
                  which database to operate on.  This line opens a
                  database creating the command ensemble
                  <command>db</command>.  
                </para>
                <para>
                  Note that while this command
                  will create a database if does not exist, the resulting
                  database will not have any table definitions.
                  To create an experiment configuration database
                  file, you should instead use the NSCLDAQ
                  <link linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
                  command.
                </para>
            </callout>
            <callout arearefs='ex.addpgm.add' >
                <para>
                  There's a lot going on in this command so let's take it a
                  bit at a time.  The <command>program::add</command> command
                  creates a new program definition.  The first parameter it takes
                  is an SQLite3 datbase connection.  This connection must
                  connect to a database that was created with
                  <link linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
                </para>
                <para>
                  The next two parameters are the name and program path
                  respectively.  The name must be unique over all
                  programs or else an error will be thrown.  The
                  program path must be valid within the environment
                  in which the program will be run.  Note the use of the
                  backslash character to prevent variable substitution in
                  specifying that the <command>VMUSBReadout</command>
                  command lives in the NSCDAQ binaries directory.
                </para>
                <para>
                  The program type is <literal>Critical</literal> since
                  it is a readout and likely the experiment cannot run
                  without it.
                </para>
                <para>
                  The program will run in the host <literal>spdaq99</literal>
                </para>
                <para>
                  The optional data are specified as a dict.  The
                  key of the dict specifies the data provided and the
                  value the data itself.  The <literal>container</literal>
                  key specifies the program will be started containerized
                  and will run in the <literal>buster</literal> container.
                </para>
                <para>
                  The <literal>options</literal> key specifies a list of
                  option/value pairs passed to the program when it is run.
                  Each option is a one or two element sublist containing,
                  inorder, the
                  option name and value.  If an option does not require a name,
                  it must be specified with a single element sublist.
                  The option/value pairs in this example should be familiar
                  to users of <command>VMUSBReadout</command>, with the
                  possible exception of <option>--initscript</option> which
                  supplies a TCL script sourced by the program's Tcl interpreter
                  to start the REST server component.
                </para>
                <para>
                  The <literal>environment</literal> key provides environment
                  variables.  In this case we ensure that the DAQ Tcl libraries
                  are in the library search path.  This will be needed by
                  <filename>~/spdaq99/startrest.tcl</filename>.
                </para>
                <para>
                  While not yet used, we set the servicename used by the
                  REST interface so that when this is used by the system,
                  we don't need any changes.
                </para>
            </callout>
         </calloutlist>
         <para>
            The contents of the <filename>~/spdaq99/startrest.tcl</filename>
            script are simple:
         </para>
         <example>
            <title>Initialization Script to start Readout REST servers</title>
            <programlisting>
package require ReadoutREST
close stdin
            </programlisting>
         </example>
         <formalpara>
            <title>Listing Program Definitions</title>
            <para>
               There are two entries for getting program definitions
               <command>getdef</command> returns a dict that describes
               a program definition when given a database handle and the
               name of a program.  <command>listDefinitions</command>
               returns a list of those dicts, one for each program definition.
            </para>
         </formalpara>
         <para>
            The example below lists the name of each program, where it
            runs and the image it runs.  See
            <link linkend='tcl3.programs' endterm='tcl3.programs.title' />
            for a full description of the dict used to describe program definitions.
         </para>
         <example>
            <title>Listing Program Definitions</title>
            <programlisting>
lappend auto_path $env(DAQTCLLIBS)
package require sqlite3
pacakge require programs

sqlite3 db myconfig.db

set inf [program::listDefinitions db]
foreach p $inf {
   set name [dict get $p name]
   set host [dict get $p host]
   set path [dict get $p path]
   puts "$name runs $path in $host"
}
            </programlisting>
         </example>
         <para>
            This example should be relatively self explanatory
            <command>listDefinitions</command> only requires a database
            command ensemble connected to a properly formatted database.
         </para>
         <formalpara>
            <title>Running a Program</title>
            <para>
               Once a program has been defined it can be run.   When you
               run a program, if it has a container specified, the package
               will first activate the container.  Regardless it will
               write a script to run the program.  The program itself,
               is run over an ssh pipe and the file descriptor for that
               pipe's output and stderr  is returned to the caller.
            </para>
         </formalpara>
         <para>
            <command>program::run</command> establishes an output
            handler for the pipe.  Optionally the caller can supply
            an output handler as well.  Regardless, it's important,
            for those output handlers, that at some point an event loop
            is entered to allow those file handlers to be dispatched.
         </para>
         <para>
            In the example below, we run two programs:  <literal>readcrate1</literal>
            and <literal>unimportant</literal>.  We'll catch and output the
            output/error of readcrate1 and let the default handler take care
            of unimportant.
         </para>
         <para>
            When readcrate1 exits (detected by an eof on the pipe), we'll
            exit as well. 
         </para>
         <example>
            <title>Starting Programs in the <literal>programs</literal> Package</title>
            <programlisting>
lappend auto_path $env(DAQTCLLIBS)
package require sqlite3
package require programs

sqlite3 db myconfig.db

set done 0
proc ReadCrate1OutputHandler {name fd} {                <co id='program.run.handler' />
   if {![eof $fd]} {
      puts "$name: [gets $fd]"
   } else {
      incr ::done
   }
}

program::run db readcrate1 ReadCrateOutputHandler      <co id='program.run.run' />
set fd [program::run db unimportant]

vwait done                                             <co id='program.run.evloop' />

if {[program::isActive unimportant]} {
   program::kill db unimportant                       <co id='program.run.kill' />
   catch [close $fd]
}

db close
            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='program.run.handler' >
                <para>
                  This will be the output handler for the <literal>readcrate1</literal>
                  program.   This will be called with two parameters.  The
                  first is the name of the program, the second is the file descriptor
                  connected to the pipe.
               </para>
                <para>
                  If the file descriptor has not been closed by the program,
                  a line is read and output preceded by the name of the program.
                  If an end file is detected, we increment the <varname>done</varname>
                  variable.  More about this later.
                </para>
                <para>
                  Note that we don't close the file descriptor.  The program
                  API wraps our output handler in its own output handler.
                  That output handler wrapper will take care of closing the
                  file descriptor.
                </para>
            </callout>
            <callout arearefs='program.run.run' >
                <para>
                  These two lines run the two programs.  <literal>readcrate1</literal>
                  is given an output handler while <literal>unimportant</literal>
                  just gets the output handler wrapper (which throws away
                  any output).  We capture the file descriptor of
                  <literal>unimportant</literal> because, as we'll see later
                  we may need to close it.
                </para>
            </callout>
            <callout arearefs='program.run.evloop' >
                <para>
                  Enters the event loop until the <varname>done</varname>
                  global variable is modified.  As we've seen, this will
                  be modified when <literal>readcrate1</literal> exits
                  (or at least closes its output and error pipe).
                  Entering the event loop allows Tcl to dispatch the output
                  handlers attached to file descriptors
                  (see the Tcl documentation of <command>fileevent</command>).
                </para>
            </callout>
            <callout arearefs='program.run.kill' >
                <para>
                  The <command>isActive</command> command determines if a
                  program is still active.  If <literal>unimportant</literal>
                  is still running we ask the package to kill it and
                  then close the file descriptor open on its pipe.
                </para>
                <para>
                  It's a good idea to wrap <command>close</command> file
                  file descriptors open on pipelines  in a
                  <command>catch</command>.  This is because anything that
                  looks like a failure of the process connected to the pipe
                  will result in an error from the <command>close</command>
                  command.  This includes not only a non zero exit status
                  but any output on the program's stderr as well.
                </para>
            </callout>
         </calloutlist>
         <para>
            A note about <literal>program::kill</literal>.  This operates
            by locating the program image in the remote system and using
            ssh to issue a <command>kill</command> command.  Sadly, there are
            cases where this is unsufficient and I don't know how to help that.
            Specifically, if the image is a script that runs a program,
            even though the script gets killed, the program my continue to run.
         </para>
      </section>
      <section id='sec.manager.sequence'>
         <title id='sec.manager.sequence.title'>
            The <command>sequence</command> package
         </title>
         <para>
            The <literal>sequence</literal> package provides support for
            two concepts within the manager:
         </para>
         <orderedlist>
            <listitem>
               <para>
                  The manager implements a state machine.  While there is
                  a default state machine loaded into the manager it is
                  possible to define any state machine as long as its initial
                  state is called <literal>SHUTDOWN</literal> and
                  any state can transition to <literal>SHUTDOWN</literal>
               </para>
            </listitem>
            <listitem>
               <para>
                  The manager associates sequences to transitions into
                  a specific state.  A sequence is a list of programs
                  (see previous section) that are run to properly transition
                  to that state.
               </para>
            </listitem>
         </orderedlist>
         <para>
            Reference information on the sequence package is at
            <link linkend='tcl3.sequence' endterm='tcl3.sequence.title' />
         </para>
         <para>
            The remainder of this section will describe:
         </para>
         <itemizedlist>
            <listitem>
               <para>
                  What a state machine is, and the default state machine
                  that's implemented when a configuration database is
                  created.  This is described in
                  <link linkend='sec.sequence.statemachine' endterm='sec.sequence.statemachine.title' />
               </para>
            </listitem>
            <listitem>
               <para>
                  Parts of the <literal>sequence</literal> package that
                  can be used to create other state machines than the
                  default state machine.  Note that in most cases it is not
                  necessary to create a custom state machine.
                  This is described in
                  <link linkend='sec.sequence.stateapi' endterm='sec.sequence.stateapi.title' />
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='sec.sequence.seqapi' endterm='sec.sequence.seqapi.title' />
                  sequences and the API section of the sequence
                  package that manage sequences.
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='sec.sequence.transition'
                        endterm='sec.sequence.transition.title' />
                  describes transitions and the parts of the API that manage them.
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='sec.sequence.misc'
                        endterm='sec.sequence.misc.title' />
                  describes miscellaneous parts of the API that don't neatly fit into
                  any of these categories.
               </para>
            </listitem>
         </itemizedlist>
         <section id='sec.sequence.statemachine'>
            <title id='sec.sequence.statemachine.title'>
            State Machines, and the Default State Machine
            </title>
            <para>
               This section describes, in a general way, what a state machine
               is and the default state machine that is loaded into the
               database by
               <link linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />.
            </para>
            <para>
               A state machine is a system that can live in any of a set of named
               <firstterm>states</firstterm>.  State machines define, as well,
               the legal transitions to successor states given the system is in
               a specific state.
            </para>
            <para>
               State machines have at most two special states.  The
               <firstterm>initial state</firstterm> defines the state
               the system is in when it is initially instantiated.
               A system may also have a
               <firstterm>final state</firstterm>.  The final state is one
               that has no legal successors.  If a state machine
               enters the final state it has completed execution.
            </para>
            <para>
               The table below describes the default state machine
               as the set of state names and their legal successor states.
               The initial state is also described.
            </para>
            <table>
               <title>Default Manager State Machine</title>
               <tgroup cols='2' align='left' rowsep='1' >
                  <colspec colname='state' />
                  <colspec colname='successors' />
                  <thead>
                     <row>
                        <entry align='center'>State</entry>
                        <entry align='center'>Successors</entry>
                     </row>
                  </thead>
                  <tbody>
                     <row>
                        <entry>SHUTDOWN (initial)</entry>
                        <entry>BOOT, SHUTDOWN</entry>
                     </row>
                     <row>
                        <entry>BOOT</entry>
                        <entry>SHUTDOWN, HWINIT, BEGIN</entry>
                     </row>
                     <row>
                        <entry>HWINIT</entry>
                        <entry>SHUTDOWN, BEGIN</entry>
                     </row>
                     <row>
                        <entry>BEGIN</entry>
                        <entry>SHUTDOWN, END</entry>
                     </row>
                     <row>
                        <entry>END</entry>
                        <entry>SHUTDOWN, HWINIT, BEGIN</entry>
                     </row>
                  </tbody>
               </tgroup>
            </table>
            <para>
               This state machine has no final state.
            </para>
         </section>
         <section id='sec.sequence.stateapi'>
            <title id='sec.sequence.stateapi.title'>
               The State machine API
            </title>
            <para>
               The state machine API allows you to configure an arbitrary
               state machine.  The requirement that the manager has
               for statemachines is simply that there's an initial state
               named <literal>SHUTDOWN</literal> and that this state is directly
               reachable from any other state.  Note that various other GUI's
               such as <link linkend='daq1.rdo_RunControl' endterm='daq1.rdo_RunControl.title' />
               have additional requirements.
            </para>
            <para>
               The three procs that support modifying the state machine are
               <command>newState</command> which creates a new state.
               <command>newTransition</command> which defines a new transition
               and <command>rmvState</command> which removes a state and
               all transitions to/from it as well as all sequences it triggers.
               See <link linkend='sec.sequence.seqapi' endterm='sec.sequence.seqapi.title' />
               for more on sequences and triggers.
            </para>
            <para>
               In the example below we extend the state machine to support
               a <literal>PAUSED</literal> state.  The paused state can be
               reached from  the existing <literal>BEGIN</literal> state and
               can reach <literal>BEGIN</literal>, <literal>END</literal>
               and, of course <literal>SHUTDOWN</literal>.
            </para>
            <example>
               <title>Adding a PAUSED State</title>
               <programlisting>
lappend auto_path $env(DAQTCLLIBS)
package require sqlite3
package require sequence                       <co id='ex.seq.boilerplate' />

sqlite3 db myconfig.db

sequence::newState db PAUSED                 <co id='ex.seq.addstate' />
sequence::newTransition db BEGIN PAUSED
sequence::newTransition db PAUSED END        <co id='ex.seq.addtransitions' />
sequence::newTransition db PAUSED BEGIN
sequence::newTransition db PAUSED SHUTDOWN

db close

               </programlisting>
            </example>
            <calloutlist>
               <callout arearefs='ex.seq.boilerplate' >
                   <para>
                     By now this should be familiar.  Extend the library
                     search path and require the packages we need before
                     opening the database.
                </para>
               </callout>
               <callout arearefs='ex.seq.addstate' >
                   <para>
                     Adds a new state named <parameter>PAUSED</parameter>
                     to the state machine.  At this point there are no
                     states that can transition into <literal>PAUSED</literal>
                     and <literal>PAUSED</literal> cannot transition to any
                     successor state.
                </para>
               </callout>
               <callout arearefs='ex.seq.addtransitions' >
                   <para>
                     This chunk of code adds the transitions required to make
                     <literal>PAUSED</literal> functional.  Each call, in
                     addition to the database command, requires a
                     <firstterm>predecessor</firstterm> state and a
                     <firstterm>successor state</firstterm>.  These two states
                     define a transition.  In the first call, for example;
                     we are saying that <literal>PAUSED</literal> can be reached
                     from <literal>BEGIN</literal>.
                </para>
               </callout>
            </calloutlist>
            <para>
               Using the <command>rmvState</command> operation it's possible
               to make a completely new state machine by removing all states in
               the existing state machine and starting from scrach.
            </para>
         </section>
         <section id='sec.sequence.seqapi'>
            <title id='sec.sequence.seqapi.title'>
               The Sequence API
            </title>
            <para>
               States and transitions by themselves do nothing.  The power
               of this package is the ability to add sequences of actions to
               transitions into a state.  In this version (NSCLDAQ 12.0), the
               actions that can be added are simply running programs that have
               been defined using e.g. the <literal>programs</literal>
               API.
            </para>
            <para>
               A sequence is a series of ordered steps.  Each step runs a program
               with an optional pre and post delay.  Sequences are
               <firstterm>triggered</firstterm> by the entry into a specific
               state.  Any number of sequences can be defined and a transition
               into a state can trigger as many sequences as desired.
            </para>
            <para>
               Each sequence step runs a program that was defined using
               the <literal>programs</literal> API.  Recall that there are
               three types of programs; Transitory, Persistent and Critical.
               Transitory programs are expected to exit quickly while Persistent
               and Critical programs are expected to endure indefinitely.
            </para>
            <para>
               Therefore, when a Transitory program runs, the step stalls
               until that program exits.   Persistent and Critical
               programs, however, are simply started.  If a Critical program
               exit is detected, the tate machine initiates a transition to the
               SHUTDOWN state.
            </para>
            <para>
               Supose we want to start the readout1 and readout2 the event builder
               (eventbuilder) and data sources for readout1 and readout2 (feed1 and
               feed2)
               on a transition to BOOT.  These programs have already
               been defined in the database.  The following  code snippet
               performs this task:
            </para>
            <example>
               <title>Defining A Boot Sequence</title>
               <programlisting>
lappend auto_path $env(DAQTCLLIBS)
package require sequence
package require sqlite3

sqlite3 db myconfig.db

sequence::add db InitiateDataFlow BOOT  <co id='ex.seq.makeseq' />

::sequence::addStep db InitiateDataFlow readout1
::sequence::addStep db InitiateDataFlow readout2    <co id='ex.seq.addsteps' />
::sequence::addStep db InitiateDataFlow eventbuilder 0 2 <co id='ex.seq.delay' />
::sequence::addStep db InitiateDataFlow feeder1
::sequence::addStep db InitiateDataFlow feeder2

db close
               </programlisting>
            </example>
            <calloutlist>
               <callout arearefs='ex.seq.makeseq' >
                <para>
                  This creates a new sequence named
                  <literal>InitiateDataFlow</literal> and
                  triggers it on transitions to the <literal>BOOT</literal>
                  state.  Note that at present, the database and software only
                  support a sequence being triggered on a single state.
                  That is a sequence cannot be created to trigger both by
                  transitions to <literal>BOOT</literal> and
                  <literal>HWINIT</literal>.
                </para>
               </callout>
               <callout arearefs='ex.seq.addsteps' >
               <para>
                  This block of code adds the five steps we need to the
                  sequence.  <literal>addStep</literal> adds a new step to the
                  end of a sequence.  Other API elements provide the ability
                  to edit sequences. 
                </para>
               </callout>
               <callout arearefs='ex.seq.delay' >
                   <para>
                     We add a post delay of 2 seconds to the step that runs
                     the <literal>eventbuilder</literal> program  as it may
                     need time to start up and become ready to accept connections
                     from its feeder programs.
                </para>
               </callout>
            </calloutlist>
         </section>
         <section id='sec.sequence.transition'>
            <title id='sec.sequence.transition.title'>
               The Transition API
            </title>
            <para>
               Transitions are the act of placing the system in a new state that
               can be legally reached from the current state.
               Doing so requires that all sequences triggered on the new
               state run successfully.
            </para>
            <para>
               There are several API members that allow you to determine the
               current state, the legal transtions from that state, to
               test if a transition is legal and, most importantly, to
               initiate a transition.
            </para>
            <para>
               Transitions require scheduling and this requires the event
               loop.  Thus normally, you initiate a transition and enter
               the event loop at least until the transition completes.
            </para>
            <para>
               Note that if a sequence triggered by the transition runs
               either Persistent or Critical programs, capturing output
               from those programs is also done via the event loop.
               Thus users of this package that drive the state machine through
               transitions must be sure to enter the event loop in
               a manner that makes the system responsive to events.
            </para>
            <para>
               The example below tests to see if we are in SHUTDOWN state
               and, if so, initiates a transition to BOOT the system.
            </para>
            <example>
               <title>Booting the System.</title>
               <programlisting>
lappend auto_path $env(DAQTCLLIBS)
package require sqlite3
package require sequence

sqlite3 db myconfig.db

set status ""

proc completion {db manager completionStatus} {   <co id='ex.seq.trans.completion' />
   set ::status $completionStatus
}

if {[::sequence::currentState db] eq "SHUTDOWN"} {  <co id='ex.seq.trans.check' />
    ::sequence::transition db BOOT completion       <co id='ex.seq.trans.boot' />
    vwait status                                    <co id='ex.seq.trans.vwait' />
    puts "Transition to BOOT completed in $status
} else {
    puts "Not in SHUTDOWN state."
}
db close

               </programlisting>
            </example>
            <calloutlist>
               <callout arearefs='ex.seq.trans.completion' >
               <para>
                  The sequence package allows you to synchronize with the
                  completion of transitions via endscripts.  These is
                  code invoked when a transition finishes, no matter how
                  it completes.  endscripts are invoked with three
                  additional command parameters:  The database command,
                  The name of the command that represents a transition manager
                  that's shephearding the system through the transition and
                  the status of the completion (which is one of
                  <literal>OK</literal>, <literal>ABORTED</literal>
                  or <literal>FAILED</literal>).
                </para>
               <para>
                  See the reference page for more information about the
                  Transition manager and its public methods.
               </para>
               </callout>
               <callout arearefs='ex.seq.trans.check' >
                   <para>
                     Gets the system's current state. Note that the state
                     is maintained in the database so it's possible for an
                     application to exit and for the state to be maintained.
                     Note that the manager, in practice forces a
                     <literal>SHUTDOWN</literal>, if necessary before
                     exiting.
                </para>
               </callout>
               <callout arearefs='ex.seq.trans.boot' >
                   <para>
                     Initiates the shutdown. Note that <literal>completion</literal>
                     is specified as the end script for this transition.
                </para>
               </callout>
               <callout arearefs='ex.seq.trans.vwait' >
                   <para>
                     The <command>vwait</command> command enters the event
                     loop until the <literal>completion</literal> proc is
                     invoked after the transition completed.  That proc sets
                     the <varname>status</varname> global variable with the status
                     of the transition which ends the vwait and makes the
                     completion status available.
                </para>
               </callout>
            </calloutlist>
         </section>
         <section id='sec.sequence.misc'>
            <title id='sec.sequence.misc.title'>
               Miscellaneous API Entries.
            </title>
            <para>
               Several miscellaneous API interfaces allow you to gain information
               about the system.   It is possible, for example, for
               applications to:
            </para>
            <itemizedlist>
               <listitem>
                  <para>
                     Get information about the currently active state
                     transition.
                  </para>
               </listitem>
               <listitem>
                  <para>
                     Capture the output of specific sequence steps. 
                  </para>
               </listitem>
               <listitem>
                  <para>
                     Send text to the output server so that it is
                     relayed to all output clients.
                  </para>
               </listitem>
            </itemizedlist>
            <para>
               Note, again, that transitions and output handling
               are triggered by the event loop and thaty therefore
               the program in which these are used must enter the event
               loop  in a timely manner.  
            </para>
            <para>
               The fragment below will determine which, if any transitionis
               currently in progress, and attach an output monitor to
               each step of the sequences that are triggered by that
               transition.  This makes use of the services of
               a TransitionManager object that is documented fully in the
               reference material.
            </para>
            <example>
               <title>Using Miscellaneous Sequence Facilities</title>
               <programlisting>
...
package require sequence
package require snit       <co id='ex.seq.misc.snit' />
...

set manager [::sequence::getCurrentTransition]   <co id='ex.seq.misc.getmgr' />
if {$manager ne ""} {
   set db [$manager cget -database]
   set t  [$manager cget -type]
   set allSequences [::sequence::listSequences $db]   <co id='ex.seq.misc.lseq' />
   foreach seq $allSequences {
      set name [dict get $seq transition_name]
       if {[dict get $seq transition_name] eq $t} {
         set steps [::sequence::listSteps $db $name]  <co id='ex.seq.misc.lstep' />
         foreach step $steps {
            set aMonitor [MyMonitor %AUTO% \     <co id='ex.seq.misc.monitor' />
              -database $db -sequence $seq -step $stepno \
            ]                          
            set stepno [dict get $step step]
            ::sequence::addMonitor $db $name $stepno $aMonitor <co id='ex.seq.misc.addmon' />
         }
       }
   }
   
}
                           <co id='ex.seq.misc.omonitor' />
snit::type MyMonitor {
   option -step
   option -database
   option -sequence
   constructor args { $self configurelist $args}
   
   method onOutput  {db program fd} {  <co id='ex.seq.misc.onout' />
      set line [gets $fd]
      set name [dict get $program name]
      ::sequence::relayOutput "Step $options(-step); $name: $line" <co id='seq.misc.orelay' />
   }
   method onExit {program fd} {     <co id='ex.seq.misc.onexit' />
      ::sequence::relayOutput "[dict get $program name] exited!!"
      ::sequence::addMonitor $options(-database) $options(-sequence) \
         $options(-step) ""
      after 0 [mymethod destroy]
   }
}
                  
... # More code that eventually enters the event loop.
               </programlisting>
            </example>
            <para>
               It's important to emphasize that this code is a program
               fragment not an complete program.   The elipses show where
               additional code would be needed.
            </para>
            <calloutlist>
               <callout arearefs='ex.seq.misc.snit' >
                   <para>
                     In this example we're going to add an
                     <firstterm>output monitor</firstterm> to steps in t
                     sequences.  Output monitors are command ensembles (a base
                     command with subcommand following).  Snit is a package
                     that supports object oriented program. Snit types
                     are like classes and an instance of a snit type
                     is represented by a command ensemble.
                   </para>
                   <para>
                     We're going to use snit types to define our output
                     monitors.  There are other options like namespace ensembles,
                     TclOO and Incremental Tcl (in fact SNIT is a
                     recursive acronym that stands for
                     SNIT Is Not Incremental Tcl).
                   </para>
                   <para>
                     The key point, as we'll see is that in order to
                     make an output monitor, you need to have
                     a command ensemble that accepts the two subcommand
                     <command>onOutput</command> and
                     <command>onExit</command>.
                   </para>
               </callout>
               <callout arearefs='ex.seq.misc.getmgr' >
                   <para>
                     <command>::sequence::getCurrentTransition</command>
                     returns a command ensemble that implements what
                     is called a transition manager for the transition
                     that's currently running.  If no transition
                     is actively running, the return value is an
                     empty string.
                   </para>
               </callout>
               <callout arearefs='ex.seq.misc.lseq' >
                   <para>
                     <command>::sequence::listSequences</command>
                     takes the database connection command and returns
                     a list of dicts that describe the sequences
                     that have been defined.  For the sake of this
                     example, we only care that the <literal>transition_name</literal>
                     key in that dict provides the name of the state
                     whose attempted entry triggers the sequence,
                     and that <literal>name</literal> provides the name
                     of the sequence.
                   </para>
               </callout>
               <callout arearefs='ex.seq.misc.lstep' >
                   <para>
                     For every sequence that's triggered by the current
                     transition manager, we list that sequence's steps
                     using <command>::sequence::listSteps</command>
                   </para>
               </callout>
               <callout arearefs='ex.seq.misc.monitor' >
                   <para>
                     For each setp we create a monitor instance.  That is
                     a new command ensemble that will monitor output
                     from the program in that step.  The construction of
                     the snit type (see below) returns the name of the
                     command ensemble.  Instantiating a new snit::type
                     with the <literal>%AUTO%</literal> keyword gets snit
                     to create a new command base name that is unique
                   </para>
               </callout>
               <callout arearefs='ex.seq.misc.addmon' >
                   <para>
                     This associates the monitor with the step.  Note that the
                     return value from <command>::sequence::addMonitor</command>
                     is any prior monitor.  
                   </para>
               </callout>
               <callout arearefs='ex.seq.misc.omonitor' >
                   <para>
                     This section of code defines a new snit type.  Snit types
                     are like classes in that the define a template for
                     producing new command ensembles that are encapsulated
                     with data.  
                   </para>
                   <para>
                     Since snit is also used as a megawidget framework.
                     in addition to encapsulating
                     <command>variable</command>s, a snit type can
                     define options.  Options are like the options in a
                     Tk widget.  They can be supplied at construction time or
                     built in methods <command>configure</command>
                     and <command>cget</command> set or query options.
                     Options appear to method code like an array named
                     <varname>options</varname> indexed by the option name.
                   </para>
                   <para>
                     Finally a snit type <command>method</command> defines a
                     subcommand of the instance command ensembles.
                     </para>
               </callout>
               <callout arearefs='ex.seq.misc.onout' >
                   <para>
                     When output is available from the program, the sequence API
                     invokes the output monitor's <command>onOutput</command>
                     subcommand.  It passes the database command, the program
                     definition dict and the file descriptor open on the output
                     of the program run in the step being monitored.
                   </para>
               </callout>
               <callout arearefs='seq.misc.orelay' >
                   <para>
                     The <command>::sequence::relayOutput</command> command
                     sends its argument to all processes connected to its output
                     relay server.
                   </para>
               </callout>
               <callout arearefs='ex.seq.misc.onexit' >
                   <para>
                     The <command>onExit</command> subcommand of the output monitor
                     command ensemble is invoked if an end file condition is
                     detected on the file descriptor connected to the step
                     program's output.  The framework passes the program definition
                     dict and the file descriptor which, while still open, can no longer be read.
                     The caller will close that file descriptor
                   </para>
                   <para>
                     This sample implementation simply informs clients of the
                     output relay server, removes itself as a monitor (by passing
                     an empty command to <command>::sequence::addMonitor</command>).
                     Finally it schedules itself for destruction.  This is done
                     from the event loop to prevent potential awkward problems with
                     the object being destroyed while one of its method is still
                     being executed.  While I have successfully done
                     <command>$self destroy</command> in similar situations, it's always
                     left me fealing uneasy.
                   </para>
               </callout>
            </calloutlist>
         </section>
      </section>
      <section id='sec.manager.kvstore'>
         <title id='sec.manager.kvstore.title'>
            The <literal>kvstore</literal> package
         </title>
         <para>
            A key value store can be thought of as an array whose
            keys are strings.  The manager key value store is string valued.
            Associated with each key is a string value.  A
            <literal>kvstore</literal> package provides the abiliy
            directly access the key value store in the
            configuration SQLite3 database file.
         </para>
         <para>
            Using the API, you can create a new key/value pair.  Your
            application can read existing keys and modify their values.
            Finally, you can also remove an existing key/value pair
            from the store.
         </para>
         <para>
            The key value store can be used by you  as you wish.  However,
            note that the readout control packages create and use
            a pair of keys: <literal>run</literal> and
            <literal>title</literal> to hold the run number and title
            of the next run.  As the manager evolves it is possible that
            additional facilities will create and use other standard
            key/value pairs.
         </para>
         <para>
            See
            <link linkend='tcl3.kvstore' endterm='tcl3.kvstore.title' />
            for reference information on the key value store API.
         </para>
         <para>
            The example below shows a few of the features of the
            <literal>kvstore</literal> package.  It assumes that
            the DAQ environment for a version 12.0 or higher NSCLDAQ
            has been setup or, alternatively that the <literal>TCLLIBPATH</literal>
            environment variable includes the <filename>TclLibs</filename>
            subdirectory of such a version.
         </para>
         <example>
            <title>Using the <literal>kvstore</literal> package</title>
            <programlisting>
if {[array names env DAQTCLLIBS] ne ""} {
   lappend auto_path $env(DAQTCLLIBS)
}
package require kvstore        <co id='ex.kvstore.require' />
package require sqlite3

sqlite3 db myconfig.db

kvstore::create db mykey myvalue  <co id='ex.kvstore.create' />

kvstore::modify db mykey {A new value} <co id='ex.kvstore.modify' />

puts "Contents of kvstore:"
dict for {key value} [::kvstore::listAll db] {  <co id='ex.kvstore.listall' />'
   puts "$key => $value"
}

db close

            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.kvstore.require' >
                <para>
                  This and the next line import the packages needed
                  for
                  this simple example.  <literal>kvstore</literal>
                  contains the code needed to access the key value
                  store and the <literal>sqlite3</literal> package
                  provides access to the Tcl bindings to the
                  SQLite3 database system needed to access
                  a database file.
                </para>
            </callout>
            <callout arearefs='ex.kvstore.create' >
                <para>
                  Creates a new key named <literal>mykey</literal>
                  with an initial value <literal>myvalue</literal>.
                  Not here and in futuure calls to the
                  <literal>kvstore</literal> commands, that the
                  first parameter is always the database command
                  used to manipulate the desired database file.
                </para>
            </callout>
            <callout arearefs='ex.kvstore.modify' >
                <para>
                  <command>kvstore::modify</command> changes the value
                  of an existing key.  In this line we change
                  the value of the key we just created to
                  <literal>A new value</literal>.  Note that the values
                  of keys can be arbitrary strings.  In this case,
                  we use Tcl's quoting system to create a value that
                  has embedded white space.
                </para>
            </callout>
            <callout arearefs='ex.kvstore.listall' >
                <para>
                  The <command>kvstore::listAll</command> command
                  returns a dict version of the key value store contents.
                  Keys in the dict are keys in the kvstore, values are
                  the values of those keys.  This means that the
                  <command>dict for</command> command will output the
                  contents of the key value store.
                </para>
            </callout>
         </calloutlist>
      </section>
      <section id='sec.manager.auth'>
         <title id='sec.manager.auth.title'>
            The <literal>auth</literal> package.
         </title>
         <para>
            While it is not yet used as of NSCLDAQ-12.0, the manager supports
            an authorization database.  In the future, this will be used
            to limit the things individual users can request of the manager.
            Understanding this part of the API and database requires understanding
            the following basic terms:
         </para>
         <variablelist>
            <varlistentry>
               <term><literal>users</literal></term>
               <listitem>
                   <para>
                     Users represent holders of computer accounts.  Users
                     band together to collaborate on experiments.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>roles</literal></term>
               <listitem>
                   <para>
                     A role is represents a bundle of capabilities.
                     Usually role names are designed to represent the things
                     that individual users on an experiment might do.
                     For example <literal>manager</literal> might be the
                     people that can configure the system and start/stop the
                     DAQ manager.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>grant/revoke</literal></term>
               <listitem>
                   <para>
                     Roles can be granted and revoked to users.  When
                     a role has been granted, the user  gains the
                     bundle of capabilities represented by the role.
                     For example, if a user is granted the role of
                     <literal>ShiftOperator</literal>, they might gain
                     the ability to start/stop runs.
                </para>
             </listitem>
            </varlistentry>
         </variablelist>
         <para>
            Full reference material for the authorization package
            (<literal>auth)</literal>) is provided in
            <link linkend='tcl3.auth' endterm='tcl3.auth.title' />.
         </para>
         <para>
            The example below adds a new user to the experiment, creates a few
            roles and grants a few of those roles to the new user.
         </para>
         <example>
            <title>Program Using the <literal>auth</literal> Package</title>
            <programlisting>
if {[array  names env DAQTCLLIBS] ne ""} {
   lappend auto_path $env(DAQTCLLIBS)
}
package require auth      <co id='ex.auth.require' />
package require sqlite3

sqlite3 db myconfig.db

auth::adduser  db fox    <co id='ex.auth.adduser' />

auth::addrole db manager
auth::addrole db analyzer <co id='ex.auth.addroles' />
auth::addrole db operator

auth::grant fox operator  <co id='ex.auth.grantrole' />

puts "People and the roles they have:"

dict for {person roles} [auth::listAll db] {     <co id='ex.auth.listall' />
   puts "$person has been granted [join $roles ", "]
}

db close

            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.auth.require' >
                <para>
                  The <literal>auth</literal> package must be pulled into the
                  program to use this API.  Note that all commands in that package
                  are in the namespace <literal>::auth</literal>.  
                </para>
            </callout>
            <callout arearefs='ex.auth.adduser' >
                <para>
                  <command>auth::adduser</command> makes a new user known to the
                  configuration.  The name of the user should be the same as
                  their account username.
                </para>
            </callout>
            <callout arearefs='ex.auth.addroles' >
                <para>
                  This set of lines uses <command>auth::addrole</command> to
                  add three roles, <literal>manager</literal>, <literal>analyzer</literal>
                  and <literal>operator</literal> to the authorization database.
                </para>
            </callout>
            <callout arearefs='ex.auth.grantrole' >
                <para>
                  The <command>auth::grant</command> command grants a role
                  to a user.  In this case, the <literal>operator</literal>
                  role is granted to the user <literal>fox</literal> we
                  created earlier in the program.  Once a role has been granted
                  to a user, all of the capabilities associated with that role
                  are available to that user.
                </para>
            </callout>
         </calloutlist>
      </section>
      <section id='sec.manager.eventloggers'>
         <title id='sec.manager.eventloggers.title'>
            The <literal>eventloggers</literal> Package.
         </title>
         <para>
            The <literal>eventloggers</literal> package  provides
            the
            ability to define and control event loggers.  Event logger
            definitions in the manager configuration database subsume
            all of the capabilities of the NSCLDAQ-11
            <command>ReadoutShell</command>'s
            multilogger and primary event logger.  
            
         </para>
         <para>
            An arbitrary number
            of event loggers of <emphasis>both</emphasis> types
            can be defined, enabled, disabled, and marked as critical.
            If a critical logger fails, a <literal>SHUTDOWN</literal>
            state transition is forced.  In this sense, this package
            is dependent on the <literal>sequence</literal> package.
         </para>
         <para>
            As you build the set of event loggers you will use, be careful to
            consider the bandwidth required to run them.  
         </para>
         <para>
            Event loggers have the following attributes:
         </para>
         <variablelist>
            <varlistentry>
               <term><literal>id</literal></term>
               <listitem>
                   <para>
                     A unique integer, or <literal>id</literal> is
                     assigned to each logger as it is created.  This
                     id can be used to refer to that logger in the future.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>root</literal></term>
               <listitem>
                   <para>
                     Top level directory of the NSCLDAQ installation that
                     contains the event logger that will be run.
                     This determines the version of NSCLDAQ from which
                     the event logger comes.
                   </para>
                   <para>
                     If the event logger is containerized (see
                     <literal>options</literal> below), this  path
                     must be the correct path inside the running container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>source</literal></term>
               <listitem>
                   <para>
                     The URL which defines the ring buffer from
                     the logger logs data.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>host</literal></term>
               <listitem>
                   <para>
                     The host in which the event logger must run.
                     It is assumed, that <literal>root</literal> is
                     valid in that host and that the host is running
                     the NSCLDAQ services.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>destination</literal>
               </term>
               <listitem>
                   <para>
                     The top level directory in which the loggers
                     stores data.  See <literal>TYPES OF LOGGERS</literal>
                     below for more information about this.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>partial</literal></term>
               <listitem>
                   <para>
                     Boolean value. If <literal>true</literal>, this
                     logger is a partial logger.  See
                     <literal>TYPES OF LOGGERS</literal> below.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>critical</literal></term>
               <listitem>
                   <para>
                     Boolean.  If <literal>true</literal>, the logger
                     is a critical component of the running DAQ system.
                     If this logger fails, the manager will therefore
                     force
                     a <literal>SHUTDOWN</literal> transition.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>enabled</literal></term>
               <listitem>
                   <para>
                     Boolean that, if true, indicates the logger is
                     enabled.   If not enabled, a logger won't run
                     to take data during a data taking run.
                     If enabled it will.
                   </para>
                   <para>
                     Note that it is legal for critical loggers to be
                     disabled.  
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>container</literal></term>
               <listitem>
                   <para>
                     THe name of the container the event logger will run
                     in.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            Destination directories, and data source URI's must be unique.
         </para>
         <formalpara>
            <title>TYPES OF LOGGERS</title>
            <para>
               The event logging subsystem recognizes two types of loggers,
               <firstterm>partial</firstterm> and <firstterm>complete</firstterm>.
               Partial loggers, like loggers in the NSCLDAQ
               <literal>multilogger</literal> package just log event files
               into a directory in a 'soup of files'.  Event files are
               preceded with the date/time at which the logger started to
               ensure they are unique.  For partial loggers, the
               <literal>destiniation</literal> is simply the
               directory in which these files are stored.
            </para>
         </formalpara>
         <para>
            Full loggers, on the other hand, behave like the primary
            event logger in the NSCLDAQ <command>ReadoutShell</command>.
            The <literal>destination</literal> directory is the top level
            directory of the directory tree managed by the logger and its
            wrapper. The structure of this tree is shown below.
            The intent is to provide an experiment view and a per run
            view.  The experiment view provides access to all event files
            while the per run view also provides access to
            associated run metadata stored in the
            <filename>experiment/current</filename> subdirectory
            when the run ended.
         </para>
         <figure>
            <title>Full logger directory tree</title>
            <literallayout>
(destiniation) +
               +----> experiment+
               |                +---> current
               |                +---> run1
               |                +---> run2
               ...             ...
               +----> complete
        
            </literallayout>
         </figure>
         <para>
            The example below illustrates some of the simple capabilities
            of the <literal>eventloggers</literal> package.  Full
            reference documentation can be found at
            <link linkend='tcl3.eventloggers' endterm='tcl3.eventloggers.title' />
         </para>
         <example>
            <title>Sample Eventloggers Program</title>
            <programlisting>
if {[array names env DAQTCLLIBS]} {
   lappend auto_path $env(DAQTCLLIBS)
}

package require eventloggers
package require sqlite3     <co id='ex.evlog.require' />

sqlite3 db myconfig.db

set dest [file normalize ~/stagearea/evlog1] <co id='ex.evlog.dest' />
file mkdir $dest

set id [::eventlog::add db /usr/opt/daq/12.0-000 \ <co id='ex.evlog.add' />
  tcp://spdaq99/fox $dest                        \
  [dict create host evloghost critical 1 enabled 1 container buster] \
]

set killdest [file normalize ~/stagearea/evlog2]

                    <co id='ex.evlog.searchdest' />

foreach logger [eventlog::listLoggers db] {     <co id='ex.evlog.list' />
    if {[file normalize[dict get $logger destination]] eq $killdest} {
      eventlog::rm db [dict get $logger id]     <co id='ex.evlog.rm' />
    }
}


db close
            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.evlog.require' >
                <para>
                  Requires the packages needed to make this program
                  work.  The <literal>eventloggers</literal>
                  package has the code to manage event logging.
                  Note that all public entries are in the
                  <literal>::eventlog</literal> namespace.
                </para>
            </callout>
            <callout arearefs='ex.evlog.dest' >
                <para>
                  These two lines of code determine the full file system
                  path of the event area we want to populate
                  (<command>file normalize</command>).
                  Note that event loggers don't create their destination
                  directory, so we use <command>file mkdir</command>
                  to create it here as well.
                </para>
            </callout>
            <callout arearefs='ex.evlog.add' >
                <para>
                  <command>eventlog::add</command> adds a new event logger
                  and returns the id assigned to it.  The
                  first four parameters are, in order, the database
                  command, the NSCLDAQ installation root from which the
                  logger comes, the URI of the data source, and where
                  the event logger will put its data.
                </para>
                <para>
                  The final parameter is a dict whose keys define
                  overrides for optional configuration values.
                  We illustrate some of the more common options here:
                </para>
                <variablelist>
                  <varlistentry>
                     <term><literal>host</literal></term>
                     <listitem>
                         <para>
                           The system which will run the event logger.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>critical</literal></term>
                     <listitem>
                         <para>
                           Flag that indicates whether or not the
                           logger is critical, we've marked it critical
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>enabled</literal></term>
                     <listitem>
                         <para>
                           Flag that indicates whether or not the
                           logger is enabled.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>container</literal></term>
                     <listitem>
                         <para>
                           Name of a container that was established
                           via the <literal>containers</literal>
                           package.  Note that when supplying this any filesystem
                           paths provided (in this case the destination
                           and root), must be valid within the running
                           container.
                       </para>
                     </listitem>
                  </varlistentry>
                </variablelist>
                
            </callout>
            <callout arearefs='ex.evlog.searchdest' >
                <para>
                  The next section of code will search the existing
                  loggers for one that has a specific destination
                  (the value of <varname>killdest</varname>), and
                  destroy it using
                  <command>eventlog::rm</command>
                </para>
            </callout>
            <callout arearefs='ex.evlog.list' >
                <para>
                  The <command>eventlog::listLoggers</command>
                  command returns a list of dicts.  Each dict
                  describes a logger.  The keys we need are
                  <literal>destination</literal> whose value is the
                  logging destination passed when the logger was
                  defined and <literal>id</literal> which is the id
                  that was assigned to the logger.
                </para>
                <para>
                  This loop loops over the loggers searching for one
                  who's normalized destination path is the same as
                  the path in <varname>killdest</varname>.
                  When comparing file system paths, it is important
                  to compare normalized paths as several path designations
                  can point to the same place.
                </para>
            </callout>
            <callout arearefs='ex.evlog.rm' >
                <para>
                  <command>eventlog::rm</command> is used to remove
                  the matching event logger.  Note that while we continue
                  to iterate over logger definitions, theoretically we
                  could <command>break</command> from the loop after
                  finding a match because the API prevents you from
                  specifying two loggers with the same destination.
                </para>
            </callout>
         </calloutlist>
      </section>
   </section>
   <section id='sec.manager.clientapi'>
      <title id='sec.manager.clientapi.title'>Manager REST client API.</title>
      <para>
         While the APIs described in the previous section are required to
         to define the configuration of an experiment;  software that
         interacts with the running program manager will do so via
         one or more of the REST interfaces and APIs provided for them.
      </para>
      <para>
         REST, or REpresentational State Transfer interfaces are
         a mechanism to use normal web (http and https) protocols
         to map URLs and query/form data to operations in a server.
         The NSCLDAQ manager program provides several URL families (or
         domains) and we also provide Tcl packages to allow your
         applications to interact with those domains.
      </para>
      <para>
         When the manager starts up, it uses the NSCLDAQ port manager
         to advertise its REST service port.  By default this port is given
         the service name <literal>DAQManager</literal>.   REST interfaces, in
         general, do not make use of persistent connections.  In order to be
         robust with respect to manager restarts, the rest client code
         looks up the service port for each request.
      </para>
      <para>
         In  the remainder of this section we will:
      </para>
      <itemizedlist>
         <listitem>
            <para>
               Describe and show examples of the REST client for  handling state
               transitions.
            </para>
         </listitem>
         <listitem>
            <para>
               Describe and show examples of the REST client for checking
               the status of programs run by the manager.
            </para>
         </listitem>
         <listitem>
            <para>
               Describe and show examples of the REST client for accessing
               the key value store.
            </para>
         </listitem>
         <listitem>
            <para>
               Describe and show examples of the REST client for
               managing event logging.
            </para>
         </listitem>
      </itemizedlist>
      <section>
         <title>REST Client for State Transitions</title>
         <para>
            This client package, <literal>stateclient</literal> provides
            a REST client to the State domain of the DAQ manager.  In order
            to use it, you must know the host in which the DAQ manager is
            running and the user that ran the manager (the NSCLDAQ port
            manager advertises services as servicename-username pairs).
         </para>
         <para>
            The REST client is exported in an object oriented manner.
            Applications create an inteface object and then invoke its methods
            to perform various actions.  Reference material is available:
            <link linkend='tcl3.stateclient' endterm='tcl3.stateclient.title' />
         </para>
         <para>
            The sample application below gets the current state of the system,
            produces a list of the valid next states and then attempts a
            transition into the first of the valid next states.  Please don't
            try this yourself, in general the state transition we're going to
            trigger makes little to no sense.
         </para>
         <para>
            The application accepts the host and username as command parameters.
         </para>
         <example>
            <title>Sample State Transition REST Client</title>
            <programlisting>
if {[array names env DAQTCLLIBS] ne ""} {
    lappend auto_path $env(DAQTCLLIBS)
}
package require stateclient     <co id='ex.staterest.require' />

proc usage {msg} {              <co id='ex.staterest.usage' />
    puts stderr "Usage: "
    puts stderr "   $::argv0 host user"
    puts stderr "Where:"
    puts stderr "   host is the host in which the manager is running and"
    puts stderr "   user is the user that started the manager."
    exit -1
}


if {[llength $argv] != 2} {
   usage
}

set host [lindex $argv 0]     <co id='ex.staterest.parameters' />
set user [lindex $argv 1]

StateClient client -host $host -user $user  <co id='ex.staterest.construct' />
puts "Current state: [client currentState"]  <co id='ex.staterest.current' />

set nextStates [client nextStates]          <co id='ex.staterest.next' />
puts "Allowed next states are [join $nextStates {, }]"
client transition [lindex $nextStates 0]    <co id='ex.staterest.transition' />

client destroy                              <co id='ex.staterest.destroy' />
exit 0


            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.staterest.require' >
                <para>
                  In order to use the REST state transition client, it is
                  necessary to pull the <literal>stateclient</literal>
                  package into your script.
                </para>
            </callout>
            <callout arearefs='ex.staterest.usage' >
                <para>
                  This proc outputs the program usage.  It'll be called if
                  the user does not provide the correct command parameters.
                </para>
            </callout>
            <callout arearefs='ex.staterest.parameters' >
                <para>
                  These two lines of code extract the host and the username
                  from the command line parameters.
                </para>
            </callout>
            <callout arearefs='ex.staterest.construct' >
                <para>
                  Constructs the client object.  The typical form of object
                  construction in Tcl object systems  is
                  <literal>classname objectname ?options...?</literal>.
                  Where <literal>classname</literal> is the name of the class
                  whose instance we're constructing.  <literal>objectname</literal>
                  is the name to give to the object.  In Tcl objects are represented
                  as command ensembles with the object name as the base command
                  name.  
                </para>
                <para>
                  Options can also be provided to construction and these, in this case,
                  provide the host and username.  The result of this construction
                  is a command ensemble named <command>client</command> whose
                  subcommands are object method invocations.  Note that,
                  as with Tk object construction, construction also returns
                  the name of the object.  In some object systems like e.g.
                  <literal>snit</literal>, the special object name
                  <literal>%AUTO%</literal> makes the object system assign a
                  unique object name to the constructed object.
                </para>
            </callout>
            <callout arearefs='ex.staterest.current' >
                <para>
                  The <methodname>currentState</methodname> method of a
                  <classname>StateClient</classname> object returns the name
                  of the current state in which the state machine is now in.
                </para>
            </callout>
            <callout arearefs='ex.staterest.next' >
                <para>
                  The <methodname>nextStates</methodname> method of
                  <classname>StateClient</classname> objects returns a list of
                  valid next state names.  That is a list of valid transitions
                  out of the current state.  Note that the code that follows
                  assumes that the state we are in is not terminal, that is there is
                  at east one valid next state.
                </para>
            </callout>
            <callout arearefs='ex.staterest.transition' >
                <para>
                  Requests the manager to make a state transition to the
                  first of the legal next states (we're assuming there is at
                  least one legal next state).  The REST request completes only
                  after the state transition has completed.
                </para>
            </callout>
            <callout arearefs='ex.staterest.destroy' >
                <para>
                  The <classname>StateClient</classname> object has a
                  pre-defined method <methodname>destroy</methodname> which
                  destroys the object.  We call this before exiting the program.
                </para>
            </callout>
         </calloutlist>
         
      </section>
      <section>
         <title>REST Client for Program Status</title>
         <para>
            The <literal>programstatusclient</literal> package provides an
            object oriented interface to the REST server domain that
            exports information about container and program status.  It
            exports a single class: <classname>ProgramClient</classname>.
            Instances of that object support the <methodname>status</methodname>
            method in addition to the pre-defined <methodname>destroy</methodname>,
            <methodname>configure</methodname> and <methodname>cget</methodname>
            methods
         </para>
         <para>
            Reference information is available:
            <link linkend='tcl3.pgmstatus' endterm='tcl3.pgmstatus.title' />.
         </para>
         <para>
            The example below creates a client, requests the status and displays
            a list of which containers are activated and in which systems they
            have been activated. 
         </para>
         <example>
            <title>Using The <literal>programstatusclient</literal> Package</title>
            <programlisting>
if {[array names env DAQTCLLIBS] ne ""} {
    lappend auto_path $env(DAQTCLLIBS)
}

package require programstatusclient    <co id='ex.pgmstat.require' />

proc usage {} {
    puts stderr "Usage:"
    puts stderr "  $::argv0  host user"
    puts stderr "Where:"
    puts stderr "   host is the host on which the manager is running and"
    puts stderr "   user is the name of the user running the manager"
    exit -1
}

if {[llength $argv] != 2} {
   usage
}

set host [lindex $argv 0]
set user [lindex $argv 1]
ProgramClient client -host $host -user $user  <co id='ex.pgmstat.construct' />

set info [client status]                     <co id='ex.pgmstat.status' />
set containers [dict get $info containers]
puts "Active Containers:"
foreach container $containers {
    set name [dict get $container name]
    set image [dict get $container image]
    set activations [dict get $container activations]
    if {[llength $activations] > 0} {
      puts "$name ($image) is active in [join $activations {, }]"
    }
}

client destroy                              <co id='ex.pgmstat.destroy' />
exit 0
            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.pgmstat.require' >
                <para>
                  To use the package it must be pulled into the script via
                  the <command>package require</command> command shown.
                </para>
            </callout>
            <callout arearefs='ex.pgmstat.construct' >
                <para>
                  This constructs a <classname>ProgramClient</classname> object
                  that will be used to communicate with the REST server.
                  The <option>-host</option> and <option>-user</option>
                  options describe how to perform service discovery.
                </para>
                <para>
                  The user and host can be provided at construction time as
                  shown here or any time prior to the first REST request
                  using the <methodname>configure</methodname> method.
                </para>
                <para>
                  The object name will be <literal>client</literal>.  This
                  will be a new base command for a command ensemble who's members
                  are the methods supported by the object.
                </para>
            </callout>
            <callout arearefs='ex.pgmstat.status' >
                <para>
                  The <methodname>status</methodname> method/subcommand provides
                  the status of all containers and programs.  The return value
                  is a dict with two keys: <literal>containers</literal> that
                  provides information about container activations and
                  <literal>programs</literal> which provides information about
                  the programs that have been defined and their status.
                </para>
                <para>
                  In this sample, we just output information about the containers.
                  The value of the <literal>containers</literal> key is a list
                  of dicts.  Each of the dicts describes a container.
                  For this application we only need to know that
                  <literal>name</literal> is the container name, <literal>image</literal>
                  is the path to the container image file in the host filesystem
                  and <literal>activations</literal> is a list of the hosts on
                  which the container is activated (this will be an empty list if
                  the container is not active).
                </para>
                <para>
                  Subsequent code iterates over the containers outputting,
                  for each container with at least one activation, information
                  about the container and where it's active.
                </para>
            </callout>
            <callout arearefs='ex.pgmstat.destroy' >
                <para>
                  This line destroys the client object.
                </para>
            </callout>
         </calloutlist>
      </section>
      <section>
         <title>REST Client for Key Value Store</title>
         <para>
            The <literal>kvclient</literal> package provides an object
            oriented API to the key value store.  Using this package,
            you can set and get values of keys as well as list keys and
            dump the complete contents of the store.
         </para>
         <para>
            Full documentation on this package is available at
            <link linkend='tcl3.kvclient' endterm='tcl3.kvclient.title' />.
            In the example below we set the <literal>title</literal> key
            and dump the entire KV store.  The <literal>title</literal> key is
            used by the Readout support software to set the run titles in the various
            Readouts used by the experiment.
         </para>
         <example>
            <title>Using the <literal>kvclient</literal> Package.</title>
            <programlisting>
if {[array names env DAQTCLLIBS] ne ""} {
   lappend auto_path $env(DAQTCLLIBS)
}
package require kvclient     <co id='ex.kvclient.require' />

proc usage {} {
   puts stderr "Usage"
   puts stderr "   $::argv0 host user new title words"
   puts stderr "Where:"
   puts stderr "   host and user specify the host running the manager and
   puts stderr "   user that started it.  The remaining parameters are
   puts stderr "   the new title to set.  They will be combined separated by spaces"
   exit -1
}

if {[llength $argv] < 3} {
    usage
}

set host [lindex $argv  0]
set user [lindex $argv 1]
set title [lrange $argv 2 end]           <co id='ex.kvclient.mktitle' />

KvClient client -host $host -user $user   <co id='ex.kvclient.construct' />
client setValue title $title              <co id='ex.kvclient.settitle' />

puts "Dump of kv store:"

dict for {name value} [client list] {               <co id='ex.kvclient.list' />
   
   puts "$name :     $value"
}
client destroy                          <co id='ex.kvclient.destroy' />

            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.kvclient.require' >
                <para>
                  In order to make calls to the Key Value REST client API,
                  the <literal>kvclient</literal> package must be pulled into the
                  program.
                </para>
            </callout>
            <callout arearefs='ex.kvclient.mktitle' >
                <para>
                  This little bit of Tcl makes a variable named <varname>title</varname>
                  from the words on the command line that follow the host and user
                  (words 2 through the end).
                </para>
            </callout>
            <callout arearefs='ex.kvclient.construct' >
                <para>
                  Constructs a Key Value store REST client object specifying
                  the <option>-host</option> and <option>-user</option> options
                  from the values on the command line.  Note that constructing
                  the object does not network operations.  Network operations, like
                  service discovery and connecting to the server are only
                  done when a REST request is made.
                </para>
            </callout>
            <callout arearefs='ex.kvclient.settitle' >
                <para>
                  The <methodname>setValue</methodname> method accepts two parameters,
                  the name of an existing key value store key and the new value
                  to give to it.  This sets the key <literal>title</literal>
                  to the title words the user passed in on the command line.
                </para>
            </callout>
            <callout arearefs='ex.kvclient.list' >
                <para>
                  The <methodname>list</methodname> method dumps the entire
                  key value store, returning it as a dict whos keys are key value
                  store keys and whose values are the values of the corresponding
                  key value store key.
                </para>
            </callout>
            <callout arearefs='ex.kvclient.destroy' >
                <para>
                  The <methodname>destroy</methodname> method destroys the client
                  when we are done using it. Note that given the nature of
                  interactions with REST servers, <classname>KvClient</classname>
                  instance objects are quite light weight.
                </para>
            </callout>
         </calloutlist>
      </section>
      <section>
         <title>REST Clients for Event Log Management</title>
         <para>
            The <literal>loggerrestclient</literal> package provides an
            object oriented interface to the REST domain (<literal>/Loggers</literal>)
            in the manager server that manages event loggers.
            Reference material for this package is available
            <link linkend='tcl3.loggerrestclient' endterm='tcl3.loggerrestclient.title' />
         </para>
         <para>
            The following example program enables all loggers, sets the recording
            state on and starts the loggers.
         </para>
         <example>
            <title>Using the <literal>loggerrestclient</literal> Package</title>
            <programlisting>
if {[array  names env DAQTCLLIBS] ne ""} {
   lappend auto_path $env(DAQTCLLIBS)
}
package require loggerrestclient      <co id='ex.lgclient.require' />

proc usage {} {
   puts stderr "Usage:"
   puts stderr "  $::argv0 host user"
   puts stderr "Where:"
   puts stderr "   host is the host on which the manager server is running."
   puts stderr "   user is the user who started the server.
   exit -1
}

if {[length $argv] != 2} {
   usage
}

set host [lindex $argv 0]
set user [lindex $argv 1]


LoggerRestClient client -host $host  -user $user  <co id='ex.lgclient.construct' />

foreach logger [client listLoggers] {             <co id='ex.lgclient.list' />
    client enableLogger [dict get $logger destination]  <co id='ex.lgclient.enable' />
}
client record 1                         <co id='ex.lgclient.record' />
client start                            <co id='ex.lgclient.start' />

client destroy                          <co id='ex.lgclient.destroy' />



            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs='ex.lgclient.require' >
                <para>
                  Using the logger rest client API means applications must
                  <command>package require loggerrestclient</command> as this
                  package contains the implementation of that package.
                </para>
            </callout>
            <callout arearefs='ex.lgclient.construct' >
                <para>
                  Constructs an instance of a client to a manager server that
                  will interact with the logger REST  server domain.k
                </para>
            </callout>
            <callout arearefs='ex.lgclient.list' >
                <para>
                  The <methodname>listLoggers</methodname> method of a logger
                  REST client instance returns a list of dicts. Each dict includes,
                  among other keys, a <literal>destination</literal> key
                  which contains the logger destination.  The logger
                  destination is required, by the API to be unique and is used
                   in the REST API, rather than the invisible id, to identify
                   loggers.
                </para>
            </callout>
            <callout arearefs='ex.lgclient.enable' >
                <para>
                  The <methodname>enableLogger</methodname> method enables
                  the logger designated by its destination.   If that logger
                  is already enabled this call silently has no effect.
                </para>
            </callout>
            <callout arearefs='ex.lgclient.record' >
                <para>
                  The <methodname>record</methodname> method sets the state of
                  the global recording flag.
                </para>
            </callout>
            <callout arearefs='ex.lgclient.start' >
                <para>
                  Starts all loggers that should start.   Since we've previously
                  enabled all loggers and ensured the global recording flag is
                  true, this will start all defined loggers.
                </para>
            </callout>
            <callout arearefs='ex.lgclient.destroy' >
                <para>
                  Destroys the logger REST API Object
                </para>
            </callout>
         </calloutlist>
      </section>
   </section>
   <section id='sec.manager.guiapi'>
      <title id='sec.manager.guiapi.title'>Manager User Interface API</title>
      <para>
         This section descsribes support for building user interfaces that interact
         with the Manager.  While these are intended to interact through the REST
         interface, in fact the architecture is, in many cases quite a bit more
         general. 
      </para>
      <para>
         Before digging into the user interface support classes in subsections to
         this section, it's important to say something about the Model View
         Controller (MVC) architecture on which most of these GUI classes are based.
      </para>
      <para>
         MVC provides a generlized patter for building software that requires user
         interaction. In MVC, applications consist of three interacting objects:
      </para>
      <variablelist>
         <varlistentry>
            <term><firstterm>View</firstterm></term>
            <listitem>
                <para>
                  A view object provides presentation and interaction controls.
                  It specifies what the user sees, given data, and how the user
                  can attempt to interact with that data.
               </para>
                <para>
                  For the purposes of the following discussion, our view objects
                  are represented by snit megawidgets.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><firstterm>Model</firstterm></term>
            <listitem>
                <para>
                  Model objects provide access to the data.   This access can be
                  read-only or read-write depending on the application.
               </para>
                <para>
                  For the purposes of the following discussion, our model objects
                  are represented by REST, interface objects or database APIs.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><firstterm>Controller</firstterm></term>
            <listitem>
                <para>
                  Controller objects mediate between the view and the
                  application's model.  It is controllers that get data from the
                  models and load them into the view for presentation.
                  Controllers also respond to events detected by the view and,
                  interact with the model either to get more or different data
                  to present or to request the model to modify data it managers.
               </para>
                <para>
                  In the following discussion, the controllers are implemented
                  as <command>snit::type</command> instances.
                </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <section>
         <title>Eventlog database configuration MVC</title>
         <formalpara>
            <title>Model</title>
            <para>
               The <literal>evlogeditmodel</literal> provides a model,
               in the form of the <command>snit::type</command>
               <classname>evlogEditModel</classname> that supports obtaining and
               modifiying the event log configuration.
            </para>
         </formalpara>
         <para>
            The model is instantiated with the <option>-database</option> option
            set to be a data base configuration file.  This is the underlying database
            the model abstracts through the following methods:
         </para>
         <variablelist>
            <varlistentry>
               <term><methodname>listContainers</methodname></term>
               <listitem>
                   <para>
                     Returns a list of the names of all the containers
                     defined in the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>listEventLogs</methodname></term>
               <listitem>
                   <para>
                     Returns a list of the dicts defining the current set of
                     event loggers.  This is a thin wrapper around
                     <command>::eventlog::listLoggers</command>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <methodname>updateEventLogs</methodname> <parameter>newLoggerDefs</parameter>
               </term>
               <listitem>
                   <para>
                     Removes existing event log definitions and replaces
                     them with those in the <parameter>newLoggerDefs</parameter>
                     list of dicts.  The dicst in <parameter>newLoggerDefs</parameter>
                     have the same form as those returned from
                     <methodname>listEventLogs</methodname>.  Note, however that the
                     <literal>id</literal> key, if provided is ignored and
                     the underlying API will assign its own ids.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <formalpara>
            <title>View</title>
            <para>
               The package <literal>evlogEditViews</literal> provides several
               view like <command>snit::widgetadaptors</command> (using
               <command>ttk::frame</command> as hulls).  These views are:
            </para>
         </formalpara>
         <variablelist>
            <varlistentry>
               <term><classname>evlogEditLogger</classname></term>
               <listitem>
                   <para>
                     Which provides a view of a single logger and the capability
                     to modify its definition.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>evlogListView</classname></term>
               <listitem>
                   <para>
                     Provides an overview presentation of a  list of event loggers
                     with the ability to choose from the list.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>evlogEditorView</classname></term>
               <listitem>
                   <para>
                     Provides a fully featured editor view class that allows
                     users to select from an logger in a
                     <classname>evlogListView</classname> and then use
                     <classname>evlogEditLogger</classname> to modify its
                     definition.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            <classname>evlogEditLogger</classname>
            can be loaded with the definition of a single event log and
            provides the ability to edit it. It has the following options and
            methods:
         </para>
         <variablelist>
            <varlistentry>
               <term><option>-containers</option></term>
               <listitem>
                   <para>
                     The list of container names that p;opulate the drop down
                     from which a container can be selected.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-savelabel</option></term>
               <listitem>
                   <para>
                     The label of the button that saves the definition. This
                     can be customized to allow it to read e.g.
                     <literal>Create</literal> when creating a new editor or
                     <literal>Update</literal> or <literal>Save</literal>
                     when editing an existing one.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-command</option></term>
               <listitem>
                   <para>
                     Script to be executed when the button is clicked. Note
                     that this is normally the hook the controller uses to
                     respond to saved event loggers.   
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>load</methodname> <parameter>logger</parameter></term>
               <listitem>
                   <para>
                     Loads the <parameter>logger</parameter> eventlog definition
                     dict into the view. <parameter>logger</parameter> is
                     a dict with the same key/value pair definitions an
                     element of the list returned from
                     <command>eventlog::listLoggers</command>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>get</methodname></term>
               <listitem>
                   <para>
                     Returns the contents of the editor as a logger definition
                     dict with the keys:
                     <literal>daqroot, ring, host, partial, destination
                     critical, enabled</literal> and <literal>container</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>selectContainer</methodname> <parameter>name</parameter></term>
               <listitem>
                   <para>
                     Sets the container selection dropdown to <parameter>name</parameter>.
                     This is normaly done after a <methodname>load</methodname>
                     call, after the <option>-containers</option> option has
                     been configured to set the default container name to be the
                     container the loaded event logger is using.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            The <classname>evlogListView</classname> view provides a table of
            event log editor definitions.  It allows the client to set up a context
            menu activated via a right click and handlers for that menu.
            Instances of <classname>evlogListView</classname> have the following
            options and methods:
         </para>
         <variablelist>
            <varlistentry>
               <term><option>-data</option></term>
               <listitem>
                   <para>
                     The value of this option is the data that comes from
                     <command>::eventlog::listLoggers</command>, or some
                     identically formatted list of dicts.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-contextmenu</option></term>
               <listitem>
                   <para>
                     A list of text strings.  These text strings will be the
                     entries in the context menu activated by right clicking over
                     a definition line in the table.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-command</option></term>
               <listitem>
                   <para>
                     Command invoked when a context menu entry is seleted.
                     The script is passed the text of the menu entry and the
                     definition of the item the menu was selected on.
                   </para>
                   <para>
                     This provides the hook for controllers or other clients
                     to actually process context menu selections.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>highlight</methodname> <parameter>def</parameter></term>
               <listitem>
                   <para>
                     Given a logger definition dict,
                     <parameter>def</parameter>, highlight that entry in the
                     table in reverse video.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>unhighlight</methodname> <parameter>def</parameter></term>
               <listitem>
                   <para>
                     Given a logger definition dict
                     <parameter>def</parameter>, remove any highlight from that
                     entry that might have been added by
                     <methodname>highlight</methodname>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>unhighlightall</methodname></term>
               <listitem>
                   <para>
                     Removes the highlighting from all entries that are currently
                     highlighted as a result of applying
                     <methodname>highlight</methodname> to them.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            The <classname>evlogEditorView</classname> provides an integrated editor
            view.  It builds on the <classname>evlogListView</classname>,
            providing context menu definitions that support editing via the
            <classname>evlogEditLogger</classname> view.
            <classname>evlogEditorView</classname> does not export any public methods
            but does export the following  configuration options:
         </para>
         <variablelist>
            <varlistentry>
               <term><option>-data</option></term>
               <listitem>
                   <para>
                     Suplies/fetches the list of logger definitions in the form
                     <command>eventlog::listLoggers</command> produces.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-containers</option></term>
               <listitem>
                   <para>
                     List of containers to provide to the
                     <classname>evlogEditLogger</classname> instance created
                     to edit a logger.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-savecommand</option></term>
               <listitem>
                   <para>
                     Script that will be called when the <guibutton>Save</guibutton>
                     button is clicked.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-cancelcommand</option></term>
               <listitem>
                   <para>
                     Command executed when the <guibutton>Cancel</guibutton>
                     button is clicked.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <formalpara>
            <title>Controller</title>
            <para>
               Mediates between a <classname>evlogEditorView</classname> or
               compatible (via duck typing) view object and a
               <classname>evlogEditModel</classname> or compatible mode object.
               The controller supports only two options:
               <option>-model</option> configures the model object and
               <option>-view</option> configures the view object.
            </para>
         </formalpara>
      </section>
      <section>
         <title>Output Monitor MVC.</title>
         <para>
            This subsystem uses the pre-existing <classname>OutputWindow</classname>
            view object which will not be documented here, other than to say that
            it provides a scrolling window into which read-only text can be
            placed.   The result of this MVC triad is to provide a user interface
            into which output from programs relayed by the manager to clients
            can be presented to users.
         </para>
         <formalpara>
            <title>ManagerOutputModel (Model).</title>
            <para>
               Instances of this class provide the data from the manager.
               Specifically, what's provided are lines of text that have been
               output by programs under the control oft the manager.
               Some features of this modela re:
            </para>
         </formalpara>
         <itemizedlist>
            <listitem>
               <para>
                  Since data are provided in an event driven mannner, the
                  class provides for a callback script to receive notification
                  of the arrival of new output.
               </para>
            </listitem>
            <listitem>
               <para>
                  The class manages connection failures by retrying connections
                  when they are lost.
               </para>
            </listitem>
            <listitem>
               <para>
                  The class provides for a callback script  to be invoked when
                  the connection retry limits are reached (possibly indicating
                  that the manager has permenently exited).
               </para>
            </listitem>
            <listitem>
               <para>
                  The class provides for a callback script to be notified when
                  connection status has changed.  This allows for the client
                  application to indicate to the user the current connection
                  status.
               </para>
            </listitem>
            
         </itemizedlist>
         <para>
            Note that to immplement these features requirs that the client
            application be event loop driven.
         </para>
         <para>
            The <classname>ManagerOutputModel</classname> provides several
            configuration options:
         </para>
         <variablelist>
            <varlistentry>
               <term><option>-host</option></term>
               <listitem>
                   <para>
                     The value of this option is the host the manager is running in.
                     This option can only be set at construction time.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-service</option></term>
               <listitem>
                   <para>
                     This option is the service the manager is advertising
                     for the output relay service.  This defaults to
                     <literal>DAQManager-outputMonitor</literal> which
                     is the default name of this service.
                   </para>
                   <para>
                     This option can only be specified at constrution time.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-user</option></term>
               <listitem>
                   <para>
                     The user that started the DAQ manager this object will
                     connect to. This defaults to the current user which may
                     not be correct.  This option can only be specified at
                     construction time.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-output</option></term>
               <listitem>
                   <para>
                     The script to be invoked when program output has been
                     relayed to the model. This script will receive the
                     object instance command and output received in that order
                     as parameters.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-connected</option></term>
               <listitem>
                   <para>
                     Script to be invoked when a connection has been made to the
                     manager's output relay service.   This script will receive
                     the object instance command as a parameter.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-disconnected</option></term>
               <listitem>
                   <para>
                     Script to be invoked when the connection to the server has
                     been lost.  This script will receive the object instance
                     command as a parameter.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-connectionretries</option></term>
               <listitem>
                   <para>
                     The number of times the object will try to reconnect if
                     the connection is lost or cannot be made.  This
                     defaults to <literal>100</literal>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-cnnnectioninterval</option></term>
               <listitem>
                   <para>
                     Number of seconds between connection retries.  This
                     defaults to <literal>1</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-connectionabandoned</option></term>
               <listitem>
                   <para>
                     Script that's invoked if the connection retry count
                     was exceeded.  The object instance command is passed
                     as a parameter.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            Only one public method is provided <methodname>connect</methodname>
            which starts attempting connections.  If the object is already
            connected it is disconnected.  If the object is attempting to connect
            but not yet succeeded, this resets the connection retry count.
         </para>
         <para>
            Note that <methodname>connect</methodname> is invoked by the
            constructor and therefore is typically not needed unless
            the <option>-connectionabandoned</option> script is invoked and the
            application wants to start another cycle of connection requests./
         </para>
         <formalpara>
            <title>ManagerOutputController (controller)</title>
            <para>
               Instances of this class bind togehter a
               <classname>ManagerOutputModel</classname> with a
               <classname>OutputWindow</classname> or compatible object(s).
               Instances of the class latch onto the model's
               <option>-output</option> option script and relay data received
               to the <classname>OutputWindow</classname>.
            </para>
         </formalpara>
         <para>
            Two options configure instances:
         </para>
         <variablelist>
            <varlistentry>
               <term><option>-model</option></term>
               <listitem>
                   <para>
                     The value of this option is the model object instance
                     command.  If there is previously an object configured as
                     the model, the <option>-output</option> option of that
                     model is configured to be an empty script.
                   </para>
                   <para>
                     Supplying a <option>-model</option> object
                     configures that object's <option>-output</option>
                     option to be handled by this controller.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-view</option></term>
               <listitem>
                   <para>
                     The value of this object is the view object instance
                     command to which output will be sent via it's
                     <methodname>log</methodname> method.  When output
                     is received and a view is configured,
                     it is logged using the <literal>output</literal>
                     log level.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </section>
   </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3tcl -->


<refentry id='tcl3.containers'>
   <refmeta>
      <refentrytitle id='tcl3.containers.title'>containers</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>containers</refname>
      <refpurpose>DAQ Manager Containers Database Package.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
package require containers

container::exists db name
container::add    db name image initfile mountpoints
container::replace db oldname newname image initfile mountpoints
container::remove db name
set fd [container::activate db name host]
set fd [container::run name host command]
container::deactivate host name
set dictlist [container::listDefinitions db ?name?]
        </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This package provides an API for the database schema that
            defines containers to the manager.  It is used by the manager
            code itself.  The API is roughly divided into database manipulations
            and procs that allow containers to be activated and applications
            run in those containers.
          </para>
          <para>
            The API makes use of singularity's ability to create persistent
            containers.  A persistent container is a container image process
            that also provides a new Linux namespace.  These containers have
            a script that can be run with parameters passed from the command
            line.  This provides the possibility of running programs within
            those persistent containers.
          </para>
          <para>
            Container definitions have the following attributes:
          </para>
          <variablelist>
            <varlistentry>
               <term>name</term>
               <listitem>
                   <para>
                    Each container definition has a unqique name. This
                    name is used to identify the container definition
                    throughout the API.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>image</term>
               <listitem>
                   <para>
                    Each container has an image fie.  This is a singularity
                    image that, when activated produces a containerized
                    environment within which programs can run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>initialization script</term>
               <listitem>
                   <para>
                    Each container definition can have an initialization
                    script.  This is a shell script that is run prior
                    to running any program in the container.  One common
                    use for this script is to source an appropriate
                    <filename>daqsetup.bash</filename> into the shell that
                    runs programs in the container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>mount points</term>
               <listitem>
                   <para>
                    Each conatainer definition has a possibly empty list of
                    mount points.  A mount point is a host file or directory
                    and where it should appear inthe containerized environment.
                    The term for these in singularity's documentation are
                    <firstterm>bindpoints</firstterm>.
                   </para>
                   <para>
                    The singularity configuration provides a set of default
                    mount points that meet most needs, however some mount points
                    depend on the container.  For example a containerized
                    environment for Debian 10 will probably need a directory tree
                    of the NSCL software compiled for that software while
                    one for Debian 8 will need a different directory tree.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
    </refsect1>
    <refsect1>
        <title>EXPORTED ENTRY POINTS</title>
        <para>
            For all entry points with a <parameter>db</parameter> parameter,
            this parameter should be an SQLite3 command that is connected to the
            configuration database you wish to manipulate.
        </para>
        <variablelist>
            <varlistentry>
               <term>
                <command>container::exists <replaceable>db name</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Returns a boolean value that is true if the container
                    <parameter>name</parameter> has been defined in the
                    configuration database whose SQLite3 database command
                    is <replaceable>db</replaceable>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::add <replaceable>db name image initfile mountpoints</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Adds a new container definition. The name of the new container
                    will be <parameter>name</parameter>, the container image is
                    given by the filename path in <parameter>image</parameter>.
                    The path must be valid in the host system(s) in which the
                    container will be activated.
                   </para>
                   <para>
                    If the <parameter>initfile</parameter> parameter is a non-empty
                    string it is the path to the initialization script to be
                    run prior to each program run in an activation of this container.
                    The path must be valid in the <emphasis>host</emphasis>
                    filesystem.  The <emphasis>contents</emphasis> of this
                    file at the time the container is added is sucked into the
                    database.  If you modify this file and want the modifications
                    to be reflected you must recreate the container definition.
                   </para>
                   <para>
                    The <parameter>mountpoints</parameter> parameter is a
                    list of desired mount points.  Each mount point is
                    a one or two element sublist.  If one element, the element
                    is a filesystem point in the native filesystem that's mounted
                    to the same position in the container (e.g. equivalent to
                    <literal>--bind point</literal>
                   ).  If a two element list, the first element is the
                    native file system point to bind and the second is where to bind
                    it in the container (e.g.
                    <literal>--bind point:where</literal>).
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><command>container::replace <replaceable>db oldname newname image initfile mountpoints</replaceable></command></term>
               <listitem>
                   <para>
                    Replaces the container named <parameter>oldname</parameter>
                    with a container named <parameter>newname</parameter> and
                    the definition described by the subsequent parameters
                    that have the same meaning as for
                    <command>container::add</command> above.
                   </para>
                   <para>
                    The resulting container is referenced everywhere in the database
                    that the old container was referenced.  This is accomplished because
                    the new container definition retains the primary key of the
                    root record of the container <parameter>oldname</parameter>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::remove <replaceable>db name</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Removes the definition of the container <parameter>name</parameter>
                    from the database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>
                    container::activate <replaceable>db name host</replaceable>
                </command>
               </term>
               <listitem>
                   <para>
                    Activates the container <parameter>name</parameter> in
                    the system with the DNS name <parameter>host</parameter>.
                    This proc, if successful, returns a Tcl file descriptor.
                   </para>
                   <para>
                    The container is activated using <command>ssh</command> the
                    user's public key must, therefore be in the
                    <filename>~/.ssh/authorized_keys</filename> file.  The
                    file descriptor returned is the output/error end of the
                    pipeline used to run ssh and therefore can capture the
                    messages and errors this ssh command output.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::run <replaceable>name host command</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Runs the <parameter>command</parameter> in the container
                    instance of <parameter>name</parameter> that must already
                    have been activated in a system with the DNS name
                    <parameter>host</parameter>.  
                   </para>
                   <para>
                    On success, a file descriptor connected to the output/error
                    of the program.  This allows you to capture messages and
                    
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::deactivate <replaceable>host name</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Deactivates the container <parameter>name</parameter> in the
                    system <parameter>host</parameter>.  The container must already
                    have been activated.  Deactivating a container will also kill
                    any programs that are running in that container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                <command>container::listDefinitions <replaceable>db ?name?</replaceable></command>
               </term>
               <listitem>
                   <para>
                    Returns a list of dicts that describe the containers that
                    have been defined.  If the optional <parameter>name</parameter>
                    parameter is provided, the list will be filtered to only
                    include that container <emphasis>but is still a list</emphasis>.
                    If no containers are defined or <parameter>name</parameter>
                    is provided but there is no container named
                    <parameter>name</parameter>, the result is an empty list.
                   </para>
                   <para>
                    Each elementof the list is a dict which describes one container
                    definition.  THe dict contains the following key/values:
                   </para>
                   <variablelist>
                    <varlistentry>
                       <term><literal>id</literal></term>
                       <listitem>
                           <para>
                            This is the primary key of the root record
                            for the container description in the database.
                            For the most part it does not help your code to
                            know this value but it is provided for internal use.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>name</literal></term>
                       <listitem>
                           <para>
                            Name of the container described by this dict.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>image</literal></term>
                       <listitem>
                           <para>
                            The file path (in the host filesystem) of
                            the container image that will be run when this
                            container is activated in a host.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>init</literal></term>
                       <listitem>
                           <para>
                            The <emphasis>contents</emphasis> of the
                            initialization script.   If no initialization
                            script was provided, this key will not be
                            present.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>bindings</literal></term>
                       <listitem>
                           <para>
                            A list of one or two element sublists describing
                            the mountpoints.  The first element (element 0)
                            of each list is a host file or directory.  If there
                            is no second element, this file or directory will
                            appear in the same place in the container as it does
                             in the host filesystem.  If there is a second element,
                             it describes where the file or directory will
                             appear in the container filesystem.
                           </para>
                           <para>
                            This second form is needed to provide for e.g.
                            mapping <filename>/usr/opt/opt-buster</filename>
                            in the host filesystem to <filename>/usr/opt</filename>
                            in the container, as is usually done at the FRIB.
                           </para>
                        </listitem>
                    </varlistentry>
                   </variablelist>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>
            FILES
        </title>
        <para>
            Container activation and their associated initialization
            scripts require that the package write shell scripts. These
            are stored in a hidden directory <filename>~/.daqmanager</filename>.
            The path to this directory is stored in the variable
            <varname>::container::tempdir</varname>. 
        </para>
        <para>
            Two sorts of scripts are stored there:
        </para>
        <variablelist>
            <varlistentry>
               <term><filename>container_init_nn</filename></term>
               <listitem>
                   <para>
                    Where nn is an integer is the script needed by
                    singluarity to run programs inside the activated,
                    persistent container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><filename>container_user_nn</filename></term>
               <listitem>
                   <para>
                    Where again nn is an integer is an initialization
                    script provided for the user run prior to running any
                    program within the activated container.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Note these scripts are a property of the container not of
            an activation of the container in a host.  That is all container
            activations use the same script filename although the current
            implementation writes the script each time it's needed to allow
            for changes in a container's definition between activations.
        </para>
    </refsect1>
</refentry>

<refentry id='tcl3.programs'>
   <refmeta>
      <refentrytitle id='tcl3.programs.title'>programs</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>programs</refname>
      <refpurpose>API For the DAQ Manager Program Database</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require programs

program::exists db name
program::add    db name path type host options
program::replace db oldname newname path type host options
program::remove db name
set def [program::getdef db name]
set defs [program::listDefinitions db]
if {[program::isActive name]} {...}
set namesAndHosts [::program::activeContainers]
set names [::program::activePrograms]
set fd [::program::run db name ?outputHandler?]
::program::kill db name


      </programlisting>
    </refsynopsisdiv>
    <refsect1>
      <title>DESCRIPTION</title>
         <para>
           This package provides access to the program definition part of
           the experiment database.  It also provides procs that allow
           programs to be run and stopped.  See
           <literal>EXPORTED ENTRY POINTS</literal> below for details.
         </para>
         <para>
           A program is defined by the following mandatory data:
        </para>
        <variablelist>
           <varlistentry>
              <term>id</term>
              <listitem>
                  <para>
                    An integer that is unique across all programs.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>name</literal></term>
              <listitem>
                  <para>
                    This name is used to identify the program primarily to
                    people.  The <literal>name</literal> must be unique
                    among all programs.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>path</literal></term>
              <listitem>
                  <para>
                    The filesystem path to an executable entity. Executable
                    entities can be binary program sor they can be scripts.
                  </para>
                  <para>
                    If the program runs containerized the executable entity
                    must be locatable within the containerized environment.
                    This means that if the path to the script is incomplete,
                    the <literal>PATH</literal> variable in the container
                    must be able to locate the program.  Alternatively,
                    if the path to the program is complete, but the image of the
                    filesystem within the container is different that in the host,
                    the path within the container must be used.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>type</literal></term>
              <listitem>
                  <para>
                    The type of the program.  Programs can be
                    <literal>Transitory</literal>, which means it is expected
                    they will exit.  There are also two types of persistent
                    programs (programs that are not expected to exit):
                    <literal>Critical</literal> programs are required for
                    the data acquisition system to function properly.  If a
                    <literal>Critical</literal> program exits, the DAQ
                    manager forces the DAQ system to shutdown.
                    <literal>Persistent</literal> programs are not expected to
                    exit but, if they do, data taking can continue.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>host</literal></term>
              <listitem>
                  <para>
                    The DNS name of the host in which the program will be run.
                    You should specify exactly the name of the host in which to
                    run the program and not use <literal>localhost</literal>.
                  </para>
               </listitem>
           </varlistentry>
        </variablelist>
        <para>
           Several optional bits of data can be associated with a program and
           define the environment in which the program runs.  Not all of these
           items are used at this implementation of the system.
        </para>
        <variablelist>
           <varlistentry>
              <term><literal>container</literal></term>
              <listitem>
                  <para>
                    The name of a container in which the program will
                    run.  This container must be defined in the
                    <literal>containers</literal> package.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>initscript</literal></term>
              <listitem>
                  <para>
                    An initialization script run prior to running the program.
                    This is not yet used.  The contents of this script are
                    pulled into the database.  Thus changes to the
                    initialization script (once it's implemented) will
                    not bee seen until the program is re-defined.
                  </para>
                  <para>
                    By not used, I mean that the GUI systems to edit program
                    definitions don't provide a mechanism for providing this
                    script.  At program activation time, any initialization
                    script provided is used.
                  </para>
                  <para>
                    Since the contents of the script are sucked into the
                    database, it's important to provide the path to the
                    script at the time the program is defined.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>service</literal></term>
              <listitem>
                  <para>
                    Not currently used.  If the program provides a REST service,
                    its name should be provided here.
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>environment</literal></term>
              <listitem>
                  <para>
                    A list of environment name, value pairs which will be
                    put into the program's environment before it is started.
                  </para>
                  <para>
                    For example, when a Tcl script is the program, you
                    may need to supply a <literal>TCLLIBPATH=$DAQTCLLIBS</literal>
                    environment definition
                  </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>directory</literal></term>
              <listitem>
                  <para>
                    The working directory in which the program will be started.
                    If not provided, you should make no assumptions about
                    the working directory the program will be run in.
                  </para>
               </listitem>
           </varlistentry>
        </variablelist>
        <para>
           These bits of optional data are used to construct the
           command used to run the program.
        </para>
        <variablelist>
           <varlistentry>
              <term><literal>options</literal></term>
              <listitem>
                  <para>
                    These are the program options and optionally values
                    needed by those options.  For example, for a Readout,
                    an option might
                    be <option>--ring</option> with a value like
                    <option>fox</option>.  It is legal for options not to have
                    a value (for example <option>--oneshot</option>).
                  </para>
                  <para>
                    Options are considered to be unordered.
                 </para>
               </listitem>
           </varlistentry>
           <varlistentry>
              <term><literal>parameters</literal></term>
              <listitem>
                  <para>
                    Parameters are placed on the command line following
                    all options.  They are considered to be a list of ordered
                    values.  An example of program parameters might be
                    the name of the host in which the manager is running.
                  </para>
               </listitem>
           </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
      <title>EXPORTED ENTRY POINTS</title>
      <para>
         All of the exported entries are in the
         <literal>::program</literal> namespace.  If you are browsing the
         source code of the package. Note that any proc name beginning with
         a <literal>_</literal> is internal and not gauranteed to be stable
         over time.  
      </para>
      <variablelist>
         <varlistentry>
            <term><command>program::exists</command> <replaceable>db name</replaceable></term>
            <listitem>
                <para>
                  Determines if the named program; <parameter>name</parameter>
                  has been defined in the database whose SQLite3 connection
                  is <parameter>db</parameter>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>program::add</command> <replaceable>db name path type host ?options?</replaceable>
            </term>
            <listitem>
                <para>
                  Adds a new program definition in the SQLite3 experiment
                  configuration database pointed to by <parameter>db</parameter>
               </para>
                <para>
                  <parameter>name</parameter> is the name that will be given
                  to the new program.  The name must be unique across all
                  program definitions in the database.  If a program with
                  that name already exists, an error will be thrown.
                </para>
                <para>
                  <parameter>path</parameter> is the path to the thing
                  (executable program or script) that will be run when
                  <parameter>name</parameter> is run.  Note that if the
                  program is containerized, this path must be correct within
                  the container rather than the host system.
                </para>
                <para>
                  <parameter>type</parameter> is the program type.  This is
                  one of <literal>Transitory</literal>, <literal>Critical</literal>
                  or <literal>Persistent</literal>.  Transitory programs
                  are expected to exit, normally relatively quickly.  Critical programs
                  are required for the DAQ system to run.  If a critical
                  program exits, the manager shuts down the DAQ system.
                  Persistent programs are also intended to not exit, however
                  the DAQ system can continue to run without them. 
                </para>
                <para>
                  <parameter>host</parameter> is the DNS name of the system
                  in which the program will be run.
                </para>
                <para>
                  The <parameter>options</parameter> optional parameter is
                  provided to supply additional  information describing
                  the environment and manner in which the program
                  will be run.  It consists of a dict that whose keys
                  are parameter names and values for those parameters.
                </para>
                <para>
                  None of the keys are mandatory.  The keys are:
                </para>
                <variablelist>
                  <varlistentry>
                     <term><literal>container</literal></term>
                     <listitem>
                         <para>
                           If supplied, this must be the name of a container
                           that is already defined via the
                           <link linkend='tcl3.containers' endterm='tcl3.containers.title' />
                           package.    If supplied, the program, when run,
                           will be run in the container environment specified
                           by that container definition.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>initscript</literal></term>
                     <listitem>
                         <para>
                           Initialization script.  This should be the path to
                           a valid shell script in the context in which the
                           <command>program::add</command> command is run.
                           The contents of this file, at the time
                           <command>program::add</command> is called will
                           be stored in the database and, when the program
                           is run, will be run prior to executing the program.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>service</literal></term>
                     <listitem>
                         <para>
                           This is not yet used.  If your program publishes
                           a service with the NSCLDAQ port manager, the
                           name of this service should be placed here.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>options</literal></term>
                     <listitem>
                         <para>
                           The value of this key is a list of program command
                           line options.  If an option is a two element list,
                           the first is considered to be the option name and
                           the second a value associated with the option.
                       </para>
                       <para>
                           name value pairs become command line options
                           of the form <literal>name=value</literal>.
                       </para>
                       <para>
                        The order in which options are specified is not
                        considered to be important, however, they are written
                        on the command line in the same order as provided here.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>parameters</literal></term>
                     <listitem>
                         <para>
                           The value of this is a list of values that will
                           be provided as program command line parameters in the
                           order in which they are given here.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term>environment</term>
                     <listitem>
                         <para>
                           The value of this is a list of name value pairs
                           that will become environment variables available
                           to the program.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>directory</literal></term>
                     <listitem>
                         <para>
                           Sets a current working directory for the program.
                           Note if the program is containerized, this must
                           be expressed in terms of the containerized file
                           system.  If this is not specified, no assumptions
                           should be made about the working directory
                           in which the program is run.
                       </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
                <para>
                  Note that when the program is run, a script is generated to run
                  the program.  As such, any shell substitutions can be
                  specified for any of the values used to start a program.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>program::replace <replaceable>db oldname newname path type host ?options?</replaceable> </command></term>
            <listitem>
                <para>
                    Replaces the program named <parameter>oldname</parameter>
                    with the program named <parameter>newname</parameter>
                    that is defined by the remaining parameters.  These
                    parameters have the same meaning as in
                    <command>program::add</command> above.
               </para>
                <para>
                    The new program definition retains the primary key of the
                    root record of the old program.  This means that all references
                    to the program are retained throughout the database.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>program::remove</command> <replaceable>db name</replaceable></term>
            <listitem>
                <para>
                  Removes the program named <parameter>name</parameter> from
                  the database whose connection command is <parameter>db</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>><command>program::getdef</command> <replaceable>db name</replaceable></term>
            <listitem>
                <para>
                  Returns a dict that describes the program
                  <parameter>name</parameter> in the database
                  <parameter>db</parameter>.  The dict will have the
                  following keys and values:
               </para>
               <variablelist>
                  <varlistentry>
                     <term><literal>id</literal></term>
                     <listitem>
                         <para>
                           A unique integer that identifies the program.
                           In database terminology, this is the primary key of
                           the root record of the program definition.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>name</literal></term>
                     <listitem>
                         <para>
                           Name of the program
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>path</literal></term>
                     <listitem>
                         <para>
                           Path to the program or script that will be run.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>type</literal></term>
                     <listitem>
                         <para>
                           Type of the program  in text form. This will
                           be one of <literal>Transitory</literal>,
                           <literal>Persistent</literal> or
                           <literal>Critical</literal>.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>type_id</literal></term>
                     <listitem>
                         <para>
                           Integer value that's related to the
                           <literal>type</literal>.   In fact the
                           legal types are in a database table, and this value
                           is the primary key for the type described in
                           <literal>type</literal>.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>host</literal></term>
                     <listitem>
                         <para>
                           The DNS name of the host in which the program
                           will be run.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>directory</literal></term>
                     <listitem>
                         <para>
                            Present only if a working directory was specified for the
                            program.  The value will be the value of that
                            directory.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>container_name, container_id</literal></term>
                     <listitem>
                         <para>
                           If present, the program is to be run containerized.
                           The <literal>container_name</literal> value
                           is the name of the container in which to run
                           the program. The <literal>container_id</literal>
                           value is the primary key of the container's root
                           record.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>initscript</literal></term>
                     <listitem>
                         <para>
                           If an initialization script was specified, this
                           will be the contents of that script file at the
                           time the program was defined with
                           <command>program::add</command>
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>service</literal></term>
                     <listitem>
                         <para>
                           If present a service name was provided and
                           the value is the name provided.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>options</literal></term>
                     <listitem>
                         <para>
                           List of two element lists where the first
                           element of each sublist is a program option name
                           and the second element its value.  If the option
                           has no value, the second element is an empty string.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>parameters</literal></term>
                     <listitem>
                         <para>
                           List of parameters that will be added to the
                           program command line.  These are considered
                           to be ordered.  That is they are added to the
                           command line after the options and in the same
                           order as this list.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>environment</literal></term>
                     <listitem>
                         <para>
                           A list of two item sublists that define additions
                           to the environment variables that will be added
                           to the environment prior to running the program.
                           The first element of each sublist is the name of
                           an environment variable and the second is the
                           value of that variable.
                       </para>
                    </listitem>
                  </varlistentry>
               </variablelist>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>

<refentry id='tcl3.sequence'>
   <refmeta>
      <refentrytitle id='tcl3.sequence.title'>sequence</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>sequence</refname>
      <refpurpose>States, Sequence, Transitions API</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require sequence

sequence::newState db state-name
sequence::newTransition db from to
sequence::add db sequence-name trigger
set stepno [sequence::addStep db seqname program predelay postdelay]
sequence::rmvstep db name stepno
set stepno [sequence::insertStep db seqname program priorstepno predelay postdelay]
set stepno [sequence::prependStep db seqname program predelay postdelay]
sequence::rmvState db state-name
sequence::rmvSequence db name
sequence::reachable db state-name
sequence::listReachableStates db state-name
sequence::listLegalFromStates db state-name
sequence::listStates db
sequence::listLegalNextStates db
sequence::isLegalTransition db next
sequence::currentState db
sequence::listSequences db
sequence::listSteps db sequence-name
sequence::addMonitor db sequence stepno monitor-base-command
sequence::runSequence db name ?endproc?
sequence::transition db transition ?endscript?
sequence::getCurrentTransition
sequence::relayOutput text


      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This package provides several facilities:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                   The capability to define or modify a state machine.
               </para>
            </listitem>
            <listitem>
               <para>
                  The ability to describe sequences of programs that will be run
                  as a result of state transitions in the state machine.  The programs
                  come in two major flavors; transient and persistent.  Sequence
                  steps that run a transient program stall until that program exits.
                  Sequence stesps that run persistent programs start the program
                  and continue on.  Persistent programs can, furthermore be
                  declared to be critical.  If a critical program exists, a
                  transition to the special, <literal>SHUTDOWN</literal>
                  stage is forced.
               </para>
            </listitem>
            <listitem>
               <para>
                  The ability to introspect the state machine and sequences. 
               </para>
            </listitem>
            <listitem>
               <para>
                  The ability to perform state transitions. State transitions,
                  as well as many other package features depend on an event loop.
                  Since this package is normally run from within the mananager
                  which, itself is a customized TclHTTPD sever, that server
                  normally provides the event loop.
               </para>
            </listitem>
            <listitem>
               <para>
                  A server that supports the ability to relay output to programs
                  that are connected to it via a TCP/IP socket stream.
               </para>
            </listitem>
          </itemizedlist>
    </refsect1>
    <refsect1>
      <title>EXPORTED ENTRY POINTS</title>
      <para>
         In the entry points below the formal arguments named
         <parameter>db</parameter> are always an sqlite3 database connection
         command that designates the database that will be operated on.
      </para>   
      <variablelist>
         <varlistentry>
            <term>
               <command>sequence::newState <replaceable>db state-name</replaceable></command>
            </term>
            <listitem>
                <para>
                  Defines a new state in the state machine.  The new
                  state definition is stored in the configuration database
                  connecected to the sqlite3 command
                  <parameter>db</parameter>.  The new state will be named by the
                  <parameter>new-state</parameter> parameter.  The new state
                  name must be unique.
                </para>
                <para>
                  Note that unless transitions into this state are defined,
                  the state remains an orphan in the state diagram, in the sense
                  that it cannot be reached via state transition operations.
                  See <command>::sequence::newTransition</command> below.
                </para>
             </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::newTransition <replaceable>db from to</replaceable></command>
            </term>
            <listitem>
                <para>
                  Defines a new state transition in the database
                  connected to <parameter>db</parameter>.  The transtion
                  is defined between the named states <parameter>from</parameter>
                  as a precursor and <parameter>to</parameter> as a successor.
                </para>
                <para>
                  Both the <parameter>from</parameter> and
                  <parameter>to</parameter> states must already be defined.
                </para>
             </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::add <replaceable>db sequence-name trigger</replaceable></command>
            </term>
            <listitem>
                <para>
                  Defines a new sequence in the database connected to
                  <parameter>db</parameter>.  The sequence will be named
                  <parameter>sequence-name</parameter> which must not
                  yet be the name of a sequence.  The
                  steps in the sequence will be triggered by a transition
                  into the state named by the <parameter>trigger</parameter>.
                </para>
                <para>
                  Initially the sequence is empty and will do nothing if
                  triggered.  <command>sequence::addStep</command>
                  and other sequence step editing commands are used to
                  define the steps in a sequence and their order.
                </para>
             </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::addStep <replaceable>db seqname program ?predelay? ?postdelay?</replaceable></command>
            </term>
            <listitem>
                <para>
                  Adds a new step to the end of the sequence
                  <parameter>seqname</parameter>.  The step will run
                  the program  named <parameter>progname</parameter>. The optional
                  <parameter>predelay</parameter> and <parameter>postdelay</parameter>
                  parameters are a delay in seconds before and after executing
                  the step.  These default to <literal>0</literal> if not
                  specified.
               </para>
                <para>
                  The return value of this command is the step number that was
                  assigned to the step.  Step numbers are real numbers and are used
                  to ensure steps are executed in the correct order.
                  Real values are used to allow steps to be inserted between
                  existing steps without needing to renumber the entire
                  sequence.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::rmvstep <replaceable>db name stepno</replaceable></command>
            </term>
            <listitem>
                <para>
                  Removes the step numbered <parameter>stepno</parameter>
                  from the sequence named by <parameter>name</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::insertStep <replaceable>db seqname program priorstepno ?predelay? ?postdelay?</replaceable></command>
            </term>
            <listitem>
                <para>
                  Inserts a new sequence step after the existing step with a step
                  numbered <parameter>priorstepno</parameter>.  The remaining
                  parameters are the same as the parameters for
                  <command>::sequence::insertStep</command>.
               </para>
                <para>
                  Naturally if <parameter>priorstepno</parameter> designates
                  the last step in <parameter>seqname</parameter>, this
                  command acts identically to <command>::sequence::addStep</command>.
                </para>
                <para>
                  The command returns the number of the new step.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::prependStep <replaceable>db seqname program ?predelay? >postdelay?</replaceable></command>
            </term>
            <listitem>
                <para>
                  Adds a new first step to the beginning of <parameter>seqname</parameter>
                  All the remaining parameters are the same as
                  <command>::sequence::addStep</command>.  The command returns
                  the number of the new step.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::rmvState <replaceable>db state-name</replaceable></command>
            </term>
            <listitem>
                <para>
                  Removes the state <parameter>state-name</parameter> from
                  the state machine definition.  This can have far reaching consequences
                  so use with care:
               </para>
                <itemizedlist>
                  <listitem>
                     <para>
                        All sequences triggered by entry to this state are removed
                        along with all steps in those sequences.
                     </para>
                  </listitem>
                  <listitem>
                     <para>
                        Depending on the actual graph of the state machine,
                        this may leave the system with unreachable states.
                     </para>
                  </listitem>
                  <listitem>
                     <para>
                        Depending on the current state of the system, this
                        may leave the system in a state with no valid
                        successor states.
                     </para>
                  </listitem>
                </itemizedlist>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::rmvSequence <replaceable>db name</replaceable></command>
            </term>
            <listitem>
                <para>
                  Removes the definition of the sequence <parameter>name</parameter>.
                  Note that all steps in the sequence are also removed from
                  the database.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::reachable db state-name</command>
            </term>
            <listitem>
                <para>
                  Returns the number of valid precursor states to
                  the state <parameter>state-name</parameter>.  A precursor
                  state is a state that has a transition to
                  <parameter>state-name</parameter> defined.  If the
                  returned value is <literal>0</literal>,
                  <parameter>state-name</parameter> is orphaned in the sense
                  that there it cannot be reached from any other state in the
                  state machine via a legal transition.
              </para>
           </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::listReachableStates <replaceable>db state-name</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns a list of the states that can be reached by transition
                  from the state <parameter>state-name</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::listLegalFromStates <replaceable>db state-name</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns a list of state names that can transition to
                  <parameter>state-name</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>sequence::listStates <replaceable>db</replaceable></command></term>
            <listitem>
                <para>
                  Lists all the states defined in the system. Using this
                  and <command>sequence::listReachableStates</command>
                  as well as <command>sequence::listLegalFromStates</command>
                  it is possible to programmtically reconstruct the full state
                  diagram.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::listLegalNextStates <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns a list of states that can be transitioned to from
                  the current state.  Note that the system's current state
                  is stored in the database.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::isLegalTransition <replaceable>db next</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns a boolean that is true valued if <parameter>next</parameter>
                  is a legal next state for the current state.  This is a
                  shortcut for
                  <literal>expr $next in [::sequence::listLegalNextStates]</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::currentState <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns the name of the current state.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::listSequences <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns a list of dicts that describe the currently defined
                  set of sequences.  The key/values in this dict are:
               </para>
                <variablelist>
                  <varlistentry>
                     <term><literal>id</literal></term>
                     <listitem>
                         <para>
                           Integer primary key of the sequence.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>name</literal></term>
                     <listitem>
                         <para>
                           Name of the sequence.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>transtion_name</literal></term>
                     <listitem>
                         <para>
                           Name of the state whose that triggers the
                           execution of the sequence.  An attempted legal
                           transition to this named state will trigger sequence
                           execution.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>transition_id</literal></term>
                     <listitem>
                       <para>
                        The primary key of the transition named in
                        <literal>transition_name</literal>.
                       </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::listSteps <replaceable>db sequence-name</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns a list of dicts that describe the steps in the sequence
                  named by <parameter>sequence-name</parameter>.
                  Each of these dicts has the following key/value pairs:
               </para>
                <variablelist>
                  <varlistentry>
                     <term><literal>step</literal></term>
                     <listitem>
                         <para>
                           Real number that is the step number of that step.
                           Steps are executed from lowest step number to highest
                           step number.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>program_name</literal></term>
                     <listitem>
                         <para>
                           Name of the program to run when the step is executed.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>program_id</literal></term>
                     <listitem>
                         <para>
                           Primary key of the program to run when the step
                           is executed.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>predelay</literal></term>
                     <listitem>
                         <para>
                           Number of seconds to delay prior to running the program
                           (integer).
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>postdelay</literal></term>
                     <listitem>
                         <para>
                           Number of seconds to delay after running the program
                           (integer).
                       </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::addMonitor <replaceable>db sequence stepno monitor-base-command</replaceable></command>
            </term>
            <listitem>
                <para>
                  Attaches an <firstterm>output monitor</firstterm> to a
                  step in a sequence.  The name of the sequence is
                  <parameter>sequence</parameter>.  The monitor is attached to
                  step <parameter>stepno</parameter>.
                  <parameter>monitor-base-command</parameter> is the base command
                  of a command ensemble described in
                  <literal>OUTPUT MONITOR OBJECTS</literal> that is the
                  output monitor for the program in that step.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::runSequence db name ?endproc?</command>
            </term>
            <listitem>
                <para>
                  Runs the named sequence <parameter>name</parameter>.
                  If <parameter>endproc</parameter> is specified, it is called
                  when the sequence has completed.  Note that running sequences
                  require the event loop.
               </para>
                <para>
                  The <parameter>endproc</parameter> command, if specified, is called
                  with the SequenceRunner object, the completion status and
                  a reason for the completion.
                  SequenceRunner objects are described in
                  <literal>SEQUENCE RUNNER OBJECTS</literal> below.
                  The status can be either <literal>OK</literal> or
                  <literal>ABORTED</literal> with meanings that should be clear.
                  The reason is a user readable reason for the completion.
                  This is an empty string for 
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::transition <replaceable>db transition ?endscript?</replaceable></command>
            </term>
            <listitem>
                <para>
                  Runs a transition to the state specified by
                  <parameter>transition</parameter>.  For the transition to
                  succeed, all steps in all sequences must complete
                  successfully.  If <parameter>endscript</parameter> is specified,
                  it is invoked at the end of the attempted transition.
                  Note that as with <command>sequence::runSequence</command>,
                  the event loop is needed to execute the transition.
               </para>
                <para>
                  If specified, the end script is invoked with the
                  database command, the Transition Manager (see
                  <literal>TRANSITION MANAGER OBJECTS</literal> below),
                  and completion status. The completion status is one of
                  <literal>OK</literal> successful completion,
                  <literal>ABORTED</literal> the sequence executaion was aborted
                  (the system is not in a well defined state).
                  <literal>SHUTDOWN</literal>, sequence execution failed and
                  the system forced a transition to the
                  <literal>SHUTDOWN</literal> initial state.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>sequence::getCurrentTransition</command></term>
            <listitem>
                <para>
                  Returns the base command of the transition manager that
                  is
                  performing the current transition.  If no transition
                  is in progress, an empty string is returned.
                  See <literal>TRANSITION MANAGER OBJECTS</literal> for
                  information about transition managers.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>sequence::relayOutput <replaceable>text</replaceable></command>
            </term>
            <listitem>
                <para>
                  Relays the <parameter>text</parameter> to all clients of the
                  output relay server.  See
                  <literal>OUTPUT RELAY SERVER</literal> below for more information.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>TRANSITION MANAGER OBJECTS</title>
      <para>
         When the sequence package performs a transition, it instantiates
         a transition manager object.  This object, runs all of the sequences
         triggered by the transition and invokes any script associated with
         the end of the transition.  The Tcl/Tk event loop is required to
         both to perform sequences and the transition as a whole.
      </para>
      <para>
         The transition manager object instances are are instances of a
         snit::type named <classname>sequence::TransitionManager</classname>.
         This section describes the options and methods of that object.
      </para>
      <refsect2>
         <title>OPTIONS</title>
         <para></para>
         <variablelist>
            <varlistentry>
               <term><option>-database</option></term>
               <listitem>
                   <para>
                     This readonly (must be set at construction time) option
                     must be set with the database connection command.  The
                     connection command must be valid for the duration of the
                     transition.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-type</option></term>
               <listitem>
                   <para>
                     This readonly option must be set with the desired
                     final state of the system.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-endscript</option></term>
               <listitem>
                   <para>
                     This option can be modified any time before the
                     transition ends.  If, when the transition ends, it is
                     non empty, it is assumed to contain a script that is
                     evaluated at the global level with  the database command,
                     the transition manager instance command, and the
                     transition
                     completion status. The completion status is one of
                     <literal>OK</literal> successful completion,
                     <literal>ABORTED</literal> the sequence executaion was aborted
                     (the system is not in a well defined state).
                     <literal>SHUTDOWN</literal>, sequence execution failed and
                     the system forced a transition to the
                     <literal>SHUTDOWN</literal> initial state.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
      <refsect2>
         <title>METHODS</title>
         <para>
            
         </para>
         <variablelist>
            <varlistentry>
               <term><methodname>start</methodname></term>
               <listitem>
                   <para>
                     Starts the transition managed by the instance.  If the
                     transition is already in progress, this method
                     reports an error.
                   </para>
                   <para>
                     If there are no sequences triggered by this transition,
                     the transition completes immediately.  Otherwise,
                     the sequences are executed from the event loop.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>abort</methodname></term>
               <listitem>
                   <para>
                     Aborts the transition.  The state remains unchanged,
                     however it's not, in general, possible to reverse sequence
                     steps already performed.   The current sequence is
                     aborted.  The transition end is signalled with the status
                     <literal>ABORTED</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>isActive</methodname></term>
               <listitem>
                   <para>
                     Returns a boolean that is true valued if the transition
                     is active and false valued if not.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><methodname>currentSequence</methodname></term>
               <listitem>
                   <para>
                     Returns the name of the currently active sequence in the
                     transition.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
    </refsect1>
    <refsect1>
      <title>SEQUENCE RUNNER OBJECTS</title>
      <para>
         Sequence runner objects are used to manage the execution of the
         steps in a sequence.   They are instances of the snit::type
         <classname>sequence::SequenceRunner</classname>.  Sequence execution
         requires the event loop.
      </para>
      <refsect2>
         <title>OPTIONS</title>
         <para>
            
         </para>
         <variablelist>
            <varlistentry>
               <term><option>-database</option></term>
               <listitem>
                   <para>
                     The SQLite3 database connection command
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-name</option></term>
               <listitem>
                   <para>
                     Name of the sequence.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-steps</option></term>
               <listitem>
                   <para>
                     List of step definition dicts.  These
                     are the output of
                     <command>sequence::listSteps</command>
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-endcommand</option></term>
               <listitem>
                   <para>
                     If not an empty string, this is a script
                     that will be invoked when the sequence
                     finishes running.  The script will receive
                     three actual parameters.
                     The command that represents the
                     <classname>sequence::SequenceRunner</classname>
                     instance, the completion status which will be
                     one of <literal>NORMAL</literal> or
                     <literal>ABORT</literal> and a text string that,
                     if the completion reason was
                     <literal>ABORT</literal> describes why the sequence
                     was aborted.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect2>
      <refsect2>
         <title>METHODS</title>
         <para></para>
      </refsect2>
    </refsect1>
    <refsect1>
      <title>OUTPUT MONITOR OBJECTS</title>
      <para>
         The following public methods are exported by
         <classname>sequence::SequenceRunner</classname> objects.
         They are intended for use by the
         <classname>sequence::TransitionManager</classname> as
         it executes sequences associated with its transition, however
         they can be used for test purposes as well.
      </para>
      <variablelist>
         <varlistentry>
            <term><methodname>start</methodname></term>
            <listitem>
                <para>
                  Starts sequence execution.  Sequence execution relies
                  on the event loop to dispatch its execution of
                  each step.  
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>abort</methodname> ?reason?</term>
            <listitem>
                <para>
                  Aborts sequence execution. The sequence will
                  complete immediately.  Any
                  <option>-endcommand</option> will be executed with
                  the reason <literal>ABORT</literal> and the
                  reason text string given by the optional
                  <parameter>reason</parameter> parameter which,
                  if not provided defaults to
                  <literal>Programmatically aborted</literal>
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>OUTPUT RELAY SERVER</title>
      <para>
         WHen the sequence package is loaded it starts a server
         on an advertised service name.  The name of the
         service is the value of the environment variable
         <literal>SERVICE_NAME</literal> with
         <literal>-outputMonitor</literal> appended.   Note that
         when the manager is run, the environment variable
         <literal>SERVICE_NAME</literal> is set to the name of the
         service the manager advertises for REST interactions.
      </para>
      <para>
         For test purposes, if the
         <literal>SERVICE_NAME</literal> environment variable is
         not defined the service name <literal>dummy-outputMonitor</literal>
         is used instead.
      </para>
      <para>
         The server started in this manner accepts connections from
         clients and sends them the text that's passed to the command
         <command>sequence::relayOutput</command>.  All clients
         receive this text.  
      </para>
      <para>
         By default, output from programs that are run in sequences
         are sent to the <command>::sequence::relayOutput</command>
         command.  In practice, this means that this service
         provides combined output from all programs both persistent and
         transitory.
      </para>
    </refsect1>
</refentry>
<refentry id='tcl3.kvstore'>
   <refmeta>
      <refentrytitle id='tcl3.kvstore.title'>kvstore</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>kvstore</refname>
      <refpurpose>Access the manager configuration's key value store</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require kvstore

kvstore::create db key value
kvstore::modify db key new-value
kvstore::remove db key
set value [kvstore::get    db key]
set keys [kvstore::listKeys db]
set kvdict [dvstore::listAll db]

      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The key value store API, <literal>kvstore</literal>,
            provides access to the key value store table in a
            manager configuration database.  
          </para>
          <para>
          A key value store can be thought of as an array whose
            keys are strings.  The manager key value store is string valued.
            Associated with each key is a string value.  A
            <literal>kvstore</literal> package provides the abiliy
            directly access the key value store in the
            configuration SQLite3 database file.
         </para>
         <para>
            Using the API, you can create a new key/value pair.  Your
            application can read existing keys and modify their values.
            Finally, you can also remove an existing key/value pair
            from the store.
         </para>

    </refsect1>
    <refsect1>
         <title>PUBLIC COMMANDS</title>
         <para>
            In the list of public entries that follow,
            The <parameter>db</parameter> parameter is an
            SQLite3 database connection command that's associated
            with the manager configuration database that contains
            the kvstore you wish to use.
         </para>
         <variablelist>
            <varlistentry>
               <term>
                  <command>kvstore::create <replaceable>db key value</replaceable></command>
               </term>
               <listitem>
                <para>
                  Creates a new entry in the key value store with
                  key named <parameter>key</parameter> and an initial
                  value <parameter>value</parameter>
                </para>
                <para>
                  If there is already a key named <parameter>key</parameter>
                  in the database, an error is signalled.
                </para>
             </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <command>kvstore::modify <replaceable>db key new-value</replaceable></command>
               </term>
               <listitem>
                <para>
                  Modifies the value of the existing <parameter>key</parameter>
                  setting it to <parameter>new-value</parameter>.
                  If <parameter>key</parameter> does not yet exist,
                  an error will be signalled.
                </para>
             </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <command>kvstore::remove <replaceable>db key</replaceable></command>
               </term>
               <listitem>
                <para>
                  Removes the existing <parameter>key</parameter>
                  from the key value store.  If <parameter>key</parameter>
                  was not yet defined, an error is signalled.
                </para>
             </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <command>kvstore::get <replaceable>db key</replaceable></command>
               </term>
               <listitem>
                <para>
                  Returns the value 
                  associated with the <parameter>key</parameter>.
                  If the <parameter>key</parameter> is not defined,
                  an error is signalled.
                </para>
             </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <command>kvstore::listKeys <replaceable>db</replaceable></command>
               </term>
               <listitem>
                   <para>
                     Lists the keys defined in the key value store.
                     It is not an error to invoke this when no keys
                     are defined.  If that is the case an empty list
                     is returned.
                </para>
             </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <command>dvstore::listAll <replaceable>db</replaceable></command>
               </term>
               <listitem>
                <para>
                  Returns a dict whose keys are all of the defined
                  keys in the key value store and whose values are the
                  values of those keys.
                </para>
             </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
</refentry>

<refentry id='tcl3.eventloggers'>
   <refmeta>
      <refentrytitle id='tcl3.eventloggers.title'>eventloggers</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>eventloggers</refname>
      <refpurpose>Define Event Logging for the NSCLDAQ Manager.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require eventloggers

set id [eventlog::add db root source dest ?options?]
set loggerInfo [eventlog::listLoggers db]
eventlog::rm db id
eventlog::enable db id
eventlog::disable db id
eventlog::enableAll db
eventlog::disableAll db
eventlog::enableRecording db
eventlog::disableRecording db
set state [eventlog::isRecording db]
eventlog::start db


      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This package provides the database manipulations to set up
            and query event logger definitions.
          </para>
          <para>
            An arbitrary number
            of event loggers of <emphasis>both</emphasis> types
            can be defined, enabled, disabled, and marked as critical.
            If a critical logger fails, a <literal>SHUTDOWN</literal>
            state transition is forced.  In this sense, this package
            is dependent on the <literal>sequence</literal> package.
         </para>
         <para>
            As you build the set of event loggers you will use, be careful to
            consider the bandwidth required to run them.  
         </para>
         <para>
            Event loggers have the following attributes:
         </para>
         <variablelist>
            <varlistentry>
               <term><literal>id</literal></term>
               <listitem>
                   <para>
                     A unique integer, or <literal>id</literal> is
                     assigned to each logger as it is created.  This
                     id can be used to refer to that logger in the future.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>root</literal></term>
               <listitem>
                   <para>
                     Top level directory of the NSCLDAQ installation that
                     contains the event logger that will be run.
                     This determines the version of NSCLDAQ from which
                     the event logger comes.
                   </para>
                   <para>
                     If the event logger is containerized (see
                     <literal>options</literal> below), this  path
                     must be the correct path inside the running container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>source</literal></term>
               <listitem>
                   <para>
                     The URL which defines the ring buffer from
                     the logger logs data.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>host</literal></term>
               <listitem>
                   <para>
                     The host in which the event logger must run.
                     It is assumed, that <literal>root</literal> is
                     valid in that host and that the host is running
                     the NSCLDAQ services.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>
                  <literal>destination</literal>
               </term>
               <listitem>
                   <para>
                     The top level directory in which the loggers
                     stores data.  See <literal>TYPES OF LOGGERS</literal>
                     below for more information about this.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>partial</literal></term>
               <listitem>
                   <para>
                     Boolean value. If <literal>true</literal>, this
                     logger is a partial logger.  See
                     <literal>TYPES OF LOGGERS</literal> below.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>critical</literal></term>
               <listitem>
                   <para>
                     Boolean.  If <literal>true</literal>, the logger
                     is a critical component of the running DAQ system.
                     If this logger fails, the manager will therefore
                     force
                     a <literal>SHUTDOWN</literal> transition.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>enabled</literal></term>
               <listitem>
                   <para>
                     Boolean that, if true, indicates the logger is
                     enabled.   If not enabled, a logger won't run
                     to take data during a data taking run.
                     If enabled it will.
                   </para>
                   <para>
                     Note that it is legal for critical loggers to be
                     disabled.  
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>container</literal></term>
               <listitem>
                   <para>
                     THe name of the container the event logger will run
                     in.
                   </para>
                </listitem>
            </varlistentry>
         </variablelist>
         <para>
            Destination directories, and data source URI's must be unique.
         </para>
         <formalpara>
            <title>TYPES OF LOGGERS</title>
            <para>
               The event logging subsystem recognizes two types of loggers,
               <firstterm>partial</firstterm> and <firstterm>complete</firstterm>.
               Partial loggers, like loggers in the NSCLDAQ
               <literal>multilogger</literal> package just log event files
               into a directory in a 'soup of files'.  Event files are
               preceded with the date/time at which the logger started to
               ensure they are unique.  For partial loggers, the
               <literal>destiniation</literal> is simply the
               directory in which these files are stored.
            </para>
         </formalpara>
         <para>
            Full loggers, on the other hand, behave like the primary
            event logger in the NSCLDAQ <command>ReadoutShell</command>.
            The <literal>destination</literal> directory is the top level
            directory of the directory tree managed by the logger and its
            wrapper. The structure of this tree is shown below.
            The intent is to provide an experiment view and a per run
            view.  The experiment view provides access to all event files
            while the per run view also provides access to
            associated run metadata stored in the
            <filename>experiment/current</filename> subdirectory
            when the run ended.
         </para>
         <figure>
            <title>Full logger directory tree</title>
            <literallayout>
(destiniation) +
               +----> experiment+
               |                +---> current
               |                +---> run1
               |                +---> run2
               ...             ...
               +----> complete
        
            </literallayout>
         </figure>
         <para>
            In addition to the logger definitions, the configuration
            database includes a global enable flag which, if not boolean
            true ensures no logging is done.
            An entry also exists to start the appropriate loggers.  This is normally
            done on a transition to <literal>BEGIN</literal>.  If you
            implement <literal>PAUSE</literal>  state machine semantics it is,
            therefore, very important to resume to a <literal>RESUME</literal>
            state and not the <literal>BEGIN</literal> state.
         </para>
    </refsect1>
    <refsect1>
      <title>PUBLIC ENTRY POINTS</title>
      <para>
         In all of the entry points described below, the
         <parameter>db</parameter> parameter represents an
         SQLite3 database connection command created using the
         <command>sqlite3</command> command.
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <command>eventlog::add <replaceable>db root source dest ?options?</replaceable></command>
            </term>
            <listitem>
                <para>
                  Adds a new event logger definition to the database.
                  <parameter>root</parameter> is the NSCLDAQ installation
                  root directory who's event logger will be used.
                  <parameter>source</parameter> is the URI of the ringbuffer
                  from which the event data will be logged.
                  <parameter>dest</parameter> is the destination
                  directory that describes where data from
                  <parameter>source</parameter> will be logged.
               </para>
               <para>
                  The optional <parameter>options</parameter> parameter,
                  if supplied is a dict of options that overrides default
                  values.  The keys in the dict we care about are:
               </para>
               <variablelist>
                  <varlistentry>
                     <term><literal>host</literal> (defaults to localhost)</term>
                     <listitem>
                         <para>
                           The host in which the event logger will be run.
                           Note that <literal>localhost</literal>
                           will be the host in which the manager is run,
                           not the host in which the definition was made.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>partial</literal> (defaults to 0)</term>
                     <listitem>
                         <para>
                           If non zero, the logger is a partial loggers.
                           See <literal>DESCRIPTION</literal> for information
                           on what a partial logger is and, by contrast,
                           what a complete logger is.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>critical</literal> (defaults to 1)</term>
                     <listitem>
                         <para>
                           If non zero, if the logger fails or exits prior
                           to the run attempting to transition out of
                           <literal>BEGIN</literal>, the system will
                           enforce a <literal>SHUTDOWN</literal>
                           transition.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>enabled</literal> (defaults to 1)</term>
                     <listitem>
                         <para>
                           If nonzero the event logger will log the
                           next run if global logging is enabled.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>container</literal> (defaults to empty)</term>
                     <listitem>
                         <para>
                           If a non-empty string, this specifies the name
                           of a container defined in the
                           <literal>containers</literal> package.
                           The event logger, when run, will run in the container
                           specified by this name.
                       </para>
                    </listitem>
                  </varlistentry>
               </variablelist>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>eventlog::listLoggers <replaceable>db</replaceable></command></term>
            <listitem>
                <para>
                  Returns a list of dicts.  Each dict describes one of the
                  loggers that has been defined via
                  <command>eventlog::add</command>.  Each dict
                  contains the following key/value pairs:
               </para>
                <variablelist>
                  <varlistentry>
                     <term><literal>id</literal></term>
                     <listitem>
                         <para>
                           The integer id of the event logger. This is
                           a unique id that can be used to refer to the
                           logger.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>daqroot</literal></term>
                     <listitem>
                         <para>
                           Path to the root of the NSCLDAQ installation
                           whose event logger will be run.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>ring</literal></term>
                     <listitem>
                         <para>
                           URI of the ringbuffer from which the event
                           logger will accept data.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>host</literal></term>
                     <listitem>
                         <para>
                           DNS name of the host in which the event logger
                           will run.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>partial</literal></term>
                     <listitem>
                         <para>
                           If non zero, this is a partial logger.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>destination</literal></term>
                     <listitem>
                         <para>
                           The directory in which the data will be
                           stored.  See <literal>DESCRIPTION</literal>
                           and the types of event loggers for the
                           full meaning of this.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>critical</literal></term>
                     <listitem>
                         <para>
                           If non-zero, the event logger is considered
                           critical and failure during a run will
                           force a transition to <literal>SHUTDOWN</literal>.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>enabled</literal></term>
                     <listitem>
                         <para>
                           If true the event logger is enabled and
                           the
                           <command>eventlog::start</command> will
                           not start this logger.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>container</literal></term>
                     <listitem>
                         <para>
                           Name of the container in which the
                           logger will run if it is containerized.
                           This will be an empty string if there is
                           no container.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>container_id</literal></term>
                     <listitem>
                         <para>
                           Id of the container that will run the
                           logger.  This will be an empty string if
                           no container was specified.
                       </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>eventlog::rm <replaceable>db id</replaceable></command>
            </term>
            <listitem>
                <para>
                  Removes the event log definition associated with
                  the id <parameter>id</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>eventlog::enable <replaceable> db id</replaceable></command></term>
            <listitem>
                <para>
                  Enables the event logger identified by
                  <parameter>id</parameter>.  
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>eventlog::disable <replaceable>db id</replaceable></command>
            </term>
            <listitem>
                <para>
                  Disables the event logger identified by
                  <parameter>id</parameter>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>eventlog::enableAll <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Enables all event loggers.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>eventlog::disableAll <replaceable>db</replaceable></command></term>
            <listitem>
                <para>
                  Disables all event loggers.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>eventlog::enableRecording <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Turns on the global recording flag.   If this is off,
                  no event loggers, regardless of their enabled state
                  will record any data.
               </para>
            </listitem>
         </varlistentry>         
         <varlistentry>
            <term>
               <command>eventlog::disableRecording <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Turns off the global recording flag.  If this is off,
                  no event recording is done.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>eventlog::isRecording <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns the state of the global recording flag.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>eventlog::start <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Starts all elligible event recorders.  Event recorders
                  that were started are expected to record a single run
                  and then exit.  The following pseudo code describes
                  how
                  the decision to start an event logger is made:
               </para>
               <informalexample>
                  <programlisting>
if global recording flag enabled
THEN
    foreach event logger: logger
    DO
        if logger is enabled
        THEN
            start logger
        ENDIF
    END DO
ENDIF
                  </programlisting>
               </informalexample>
               <para>
                  From the psuedo code above you can see that a logger
                  is started only if the global recording flag is enabled
                  <emphasis>and</emphasis> the logger itself is enabled.
               </para>
            </listitem>
         </varlistentry>

      </variablelist>
    </refsect1>
</refentry>

<refentry id='tcl3.auth'>
   <refmeta>
      <refentrytitle id='tcl3.auth.title'>auth</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>auth</refname>
      <refpurpose>Manager Authorization System</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require auth

auth::adduser db username
auth::addrole db rolename
auth::rmrole db rolename
auth::grant db user role
auth::revoke db user role
set usernames [auth::users db]
set roles [auth::listRoles db]
set info [auth::listAll db]


      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>Description</title>
          <para>
            Implements the database for a role based authorization system.
            In role based authorization systems, there are users and there
            are roles.  Users can be <firstterm>granted</firstterm> one
            or more roles and roles the currently have been granted can be
            <firstterm>revoked</firstterm>.
            The authorized capabilities of the user are then determined by the
            roles they've been granted.
          </para>
          <para>
            Note the difference between authorization, and authentication.
            Authentication is the process of "proving" who you are.  For example,
            when you provide a user name and a password to login, you are
            authenticating.  Authorization is the process of determining,
            the access appropriate to an authenticated user.  For example, the
            unix file modes determine, for a specific authenticated user
            the operations that user can perform on that file.
          </para>
         <para>
            This package explicitly addresses <firstterm>authorization</firstterm>
            and explictly does <emphasis>not</emphasis> address
            <firstterm>authentication</firstterm>.
         </para>
    </refsect1>
    <refsect1>
      <title>PUBLIC ENTRIES</title>
      <para>
         In the command documentation that follows, all commands require an
         SQLite3 database access command.  The parameter <parameter>db</parameter>
         is that access command and will not be mentioned further.
      </para>
      <variablelist>
         <varlistentry>
            <term>
               <command>auth::adduser <replaceable>db username</replaceable></command>
            </term>
            <listitem>
                <para>
                  Adds a new user, <parameter>username</parameter> to the
                  set of users that can be authorized with roles.
                  <parameter>username</parameter> must not have been added
                  in the past or an error will be thrown.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>auth::addrole <replaceable>db rolename</replaceable></command>
            </term>
            <listitem>
                <para>
                  Adds a new role,
                  <parameter>rolename</parameter>that can be granted to users.
                  <parameter>rolename</parameter> must not be the name of an
                  existing role or else an error will be thrown.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>auth::rmrole <replaceable>db rolename</replaceable></command>
            </term>
            <listitem>
                <para>
                  Removes the role <parameter>rolename</parameter> from
                  the list of roles that can be granted to users.
                  A scorched earth policy is adopted in the sense that prior
                  to removing the role it is revoked from any users it has
                  been granted to.
               </para>
                <para>
                  An error is throw if <parameter>rolename</parameter> is
                  not an existing role.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>auth::grant <replaceable>db user role</replaceable></command>
            </term>
            <listitem>
                <para>
                  Grants the <parameter>user</parameter> the role named by
                  <parameter>role</parameter>.  Both
                  <parameter>user</parameter> and <parameter>role</parameter>
                  must have been previously defined as a user and a role
                  respectively or else an error will be thrown.
               </para>
               <para>
                  Once the user has been granted this <parameter>role</parameter>,
                  the user has all of the capabilities implied by that role.
               </para>
            </listitem>
         </varlistentry>      
         <varlistentry>
            <term>
               <command>auth::revoke <replaceable>db user role</replaceable></command>
            </term>
            <listitem>
                <para>
                  Revokes the role named <parameter>role</parameter> from
                  the user named <parameter>user</parameter>.   Any capabilities
                  implied by the <parameter>role</parameter> that are not also
                  implied by another role the user was granted are no longer
                  allowed to that user.
               </para>
                <para>
                  By the previous paragraph we mean that the set of capabilities
                  carried by roles may not be orthogonal.  
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>auth::users <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns a list of the user names that have been added to the
                  system.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>auth::listRoles <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Returns a list of all of the role names that have been
                  added to the system.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term></term>
            <listitem>
                <para>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <command>auth::listAll <replaceable>db</replaceable></command>
            </term>
            <listitem>
                <para>
                  Lists all of the information in the authorization database.
                  The result is a dict.  The dict keys are usernames and the
                  values for each key are a list of roles that have been
                  granted to that user.  Users with no roles granted will
                  appear as keys in to the dict and those keys
                  will have empty lists as
                  values.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    
</refentry>

<refentry id='tcl3.stateclient'>
   <refmeta>
      <refentrytitle id='tcl3.stateclient.title'>stateclient</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>stateclient</refname>
      <refpurpose>REST client of manager state machine</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require stateclient

set obj [StateClient objname ?options...?]
$obj configure optname value ...
set state [$obj currentState]
set successors [$obj nextStates]
set actual [$obj transition desired]
$obj kill

$obj destroy

      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The <literal>stateclient</literal> package provides a
            <command>snit::type</command> class that serves as a client to the
            DAQ manager's state machine REST server domain.  The client hides
            package presents a simple to use interface that completely hides
            the process of service location, request formation and reply
            decoding.
          </para>
    </refsect1>
    <refsect1>
      <title>OPTIONS</title>
      <para>
         The following options can be provided either at construction time
         or later on via the <methodname>configure</methodname> method.
         Each rest request performs service discovery and connects to the
         server.  Therefore it is possible to dynamically switch the target
         of a client object by reconfiguring the connection information.
      </para>
      <para>
         Note that the service name discovered defaults to
         <literal>DAQManager</literal>.  It can be modified by setting
         the <varname>::clientutils::SERVICE</varname>  variable to the
         desired service name.
      </para>
      <variablelist>
         <varlistentry>
            <term><option>-host</option> DNS-name</term>
            <listitem>
                <para>
                  The DNS host name or IP address of the system on which
                  the manager is running
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-user</option> username</term>
            <listitem>
                <para>
                  The username of the user that started the server.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      
    </refsect1>
    <refsect1>
      <title>METHODS</title>
      <para>
         Constructed  <classname>StateClient </classname> objects have the following
         methods:
      </para>
      <variablelist>
         <varlistentry>
            <term><methodname>configure</methodname> option value...</term>
            <listitem>
                <para>
                  Modifies the value of one or more options.  The parameters
                  to this method are a sequence of option names followed by
                  new values for that option.  See <literal>OPTIONS</literal>
                  above for a list of the legal options.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>currentState</methodname></term>
            <listitem>
                <para>
                  Returns the textual name of the current state.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>nextStates</methodname></term>
            <listitem>
                <para>
                  Returns a list of textual state names that can be
                  reached by transitioning from the current state.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>transition</methodname> <parameter>newstate</parameter></term>
            <listitem>
                <para>
                  Attempts a tranisition to the <parameter>newstate</parameter>.
                  The method call blocks until the server has completed its
                  transition.  At that time the state of the system is returned.
                  Note that it is possible the state transition will fail
                  and that may result in a return value other than
                  <parameter>newstate</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>kill</methodname></term>
            <listitem>
                <para>
                  Request that the server exit. Note that the server will
                  first attempt to transition into the <literal>SHUTDOWN</literal>
                  state.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>


<refentry id='tcl3.pgmstatus'>
   <refmeta>
      <refentrytitle id='tcl3.pgmstatus.title'>programstatusclient</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>programstatusclient</refname>
      <refpurpose>REST Client for Manager /Programs Domain.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require programstatusclient

ProgramClient name ?option value...?

set info [name status]
      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Provides a REST client for the <literal>/Programs</literal>
            domain of the manager REST server.  This client allows applications
            to learn about the status of both containers and programs
            that are activated/run under the control of the DAQ manager.
          </para>
    </refsect1>
    <refsect1>
      <title>OPTIONS</title>
      <para>
         Options are used to guide service discovery.  The manager advertises
         a service with its host's NSCLDAQ Port manager.   Services are qualified
         by the username.  Therefore, to discover the service port used by the
         manager, it's necesary to know the service name, the host the manager
         is running in and the user that started the manager.
      </para>
      <para>
         The service name defaults to <literal>DAQManager</literal> and is
         stored in <varname>clientutils::DAQManager</varname>.  Each REST request
         does service discovery, connects to the server, makes the request and
         disconnects from the server.  As such, the service name, the user
         and host are dynamic.  The host and user are <classname>ProgramClient</classname>
         options that can be provided at construction time and/or set using an
         instance's <methodname>configure</methodname> method:
      </para>
      <variablelist>
         <varlistentry>
            <term><option>-host</option></term>
            <listitem>
                <para>
                  Host in which the server is running.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-user</option></term>
            <listitem>
                <para>
                  Username of the account that started the server.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>METHODS</title>
      <para>
         Instances of <classname>ProgramClient</classname> have only one method:
         <methodname>status</methodname>.  This method takes no parameters and
         returns a dict.  The dict has two keys <literal>containers</literal>
         and <literal>programs</literal>.  
      </para>
      <formalpara>
         <title>The <literal>containers</literal> Key.</title>
         <para>
            This key contains a list of dicts.  Each dict describes a container
            configured into the server.  The container dicts have the following
            key/value pairs.
         </para>
      </formalpara>
      <variablelist>
         <varlistentry>
            <term><literal>name</literal></term>
            <listitem>
                <para>
                  Contains the name given to the container.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>image</literal></term>
            <listitem>
                <para>
                  The container image file.  This path is, of course, in the host
                  system.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>bindings</literal></term>
            <listitem>
                <para>
                  A list of file system bindings between the host filesystem and
                  the containerized filesystem.  Each binding is a string given
                  in the form expected by the
                  <command>singularity</command> command's
                  <option>--bind</option> option.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>activations</literal></term>
            <listitem>
                <para>
                  List of hosts in which the container is currently active.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <formalpara>
         <title>The <literal>programs</literal> Key</title>
         <para>
            The <literal>programs</literal> key contains a list of dicts
            that describe programs configured into the server, and their status.
            Each dict describes one such program and has the following
            key/value pairs:
         </para>
      </formalpara>
      <variablelist>
         <varlistentry>
            <term><literal>name</literal></term>
            <listitem>
                <para>
                  Name of the program.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>path</literal></term>
            <listitem>
                <para>
                  Path to the program image or script file.  If the program
                  is run containerized, this is expressed in the filesystem
                  as seen within the container.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>type</literal></term>
            <listitem>
                <para>
                  Textual program type.  This will be one of
                  <literal>Transitory</literal>, <literal>Persistent</literal>
                  or <literal>Critical</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>host</literal></term>
            <listitem>
                <para>
                  Host in which the program will be run.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>container</literal></term>
            <listitem>
                <para>
                  If not an empty string, the name of the container the program
                  will be run in.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>active</literal></term>
            <listitem>
                <para>
                  Boolean that, if true, indicates the program is currently
                  active.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>

<refentry id='tcl3.kvclient'>
   <refmeta>
      <refentrytitle id='tcl3.kvclient.title'>kvclient</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>kvclient</refname>
      <refpurpose>Client To Manager's REST Key Value Store Service</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require kvclient

KvClient client-name ?option value...?
client configure option value ?...?
set value [client getValue keyname]
client setValue keyname value
set keys [client listNames]
set kvdump [client list]
      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>
               DESCRIPTION
             </title>
          <para>
            REST client for the key value store domain (<literal>/KVStore</literal>)
            of the DAQ manager server.  This package provides an object oriented
            client package.  The package does service discovery and reconnects for
            every REST request rather than maintaining a connection with e.g.
            persistent sockets.
          </para>
          <para>
            Because the package does per-request service discovery and connection,
            it is generally tolerant of the sorts of port reassignment that can happen
            as a result of server exit and restart.  Similarly server restarts
            are transparent to the package because no persistent connection is
            maintained.
          </para>
    </refsect1>
    <refsect1>
      <title>OPTIONS</title>
      <para>
         The client is configured using options, much the same way Tk widgets
         are configured.  Options, in addition to the <varname>clientutils::SERVICE</varname>
         variable configure service discovery.  <varname>clientutils::SERVICE</varname>
         contains the service the manager advertises and defaults to
         <literal>DAQManager</literal>, which is the default service advertised.
      </para>
      <para>
         The host in which the server runs as well as the user that started the
         server are configuration options:
      </para>
      <variablelist>
         <varlistentry>
            <term><option>-host</option></term>
            <listitem>
                <para>
                  Host in which the server is running.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-user</option></term>
            <listitem>
                <para>
                  User name of the user that started the server.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>METHODS</title>
      <para>
         Constructed objects support the following methods:
      </para>
      <variablelist>
         <varlistentry>
            <term><methodname>configure </methodname><parameter>option value ?...?</parameter></term>
            <listitem>
                <para>
                  Built in method that configures the object's options. Since
                  service discover and connections are made/broken with each
                  request, this provide support for e.g. service migration.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>getValue</methodname> <parameter> keyname</parameter></term>
            <listitem>
                <para>
                  Returns the value of the key <parameter>keyname</parameter>.
                  <parameter>keyname</parameter> must be a defined key in the
                  Key Value store or an error will be signalled.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>setValue</methodname><parameter> keyname value</parameter></term>
            <listitem>
                <para>
                  This method modifies the value of the key <parameter>keyname</parameter>.
                  setting it to <parameter>value</parameter>.  <parameter>keyname</parameter>
                  must already exist in the key value store or an error will be returned.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>listNames</methodname></term>
            <listitem>
                <para>
                  Returns a list of the keynames that are defined in the
                  key value store.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>list</term>
            <listitem>
                <para>
                  Returns a dict whose keys are the keys of the key value store and
                  whose values are their values.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>

    </refsect1>
</refentry>
<refentry id='tcl3.loggerrestclient'>
   <refmeta>
      <refentrytitle id='tcl3.loggerrestclient.title'>loggerrestclient</refentrytitle>
      <manvolnum>3tcl</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>loggerrestclient</refname>
      <refpurpose>Client to Manager's Event Log REST Interface</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
package require loggerrestclient

LoggerRestClient name -host hostname -user username
name configure option value ?...?

name enableLogger logger-dest
name disableLogger logger-dest
set loggerInfo [name listLoggers]
name record recording-state
name isRecording
name start
name destroy
      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Provides an object oriented interface to the part of the manager's
            REST server that controls event logging.  Each method of a
            <classname>LoggerRestClient</classname> instance makes a REST request of
            the server.  The request logic includes service discovery based
            on the current values of the <option>-host</option>, <option>-user</option>
            options and <varname>clientutils::SERVICE</varname> variables.
          </para>
    </refsect1>
    <refsect1>
      <title>OPTIONS</title>
      <para>
         Options control service lookup and how the server is connected during
         each method call.   As such the host, user and even the service can be
         varied from request to requrest.  Furthermore, the object is robust in
         the presence of server restarts that may change the actual server port.
      </para>
      <para>
         The options described below must be properly defined prior to any
         method call that makes a REST request.
      </para>
      <variablelist>
         <varlistentry>
            <term><option>-host</option></term>
            <listitem>
                <para>
                  Host in which the server is running.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-user</option></term>
            <listitem>
                <para>
                  Username of the user that started th server.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>
         METHODS
      </title>
      <para>
         With the exception of the built in methods (e.g.
         <methodname>configure</methodname>, <methodname>cget</methodname>,
         <methodname>destroy</methodname>), each method call described
         below performs exactly one REST request.  
      </para>
      <para>
         The REST request includes service discovery which provides, from the
         Port Manager the port on which the server is listening for connection.
         This service discovery is performed for <emphasis>every</emphasis>
         REST request.
      </para>
      <variablelist>
         <varlistentry>
            <term><methodname>enableLogger</methodname> <parameter>dest</parameter></term>
            <listitem>
                <para>
                  Enables the logger whose log destination is
                  <parameter>dest</parameter>.  In the
                  <classname>LoggerRestClient</classname> API, loggers are
                  specified by their log destinations.  These are required by the
                  database APIs to be unique.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>disableLogger</methodname> <parameter>dest</parameter></term>
            <listitem>
                <para>
                  Disables the logger whose log destination is
                  <parameter>dest</parameter>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>listLoggers</methodname></term>
            <listitem>
                <para>
                  Returns a list of dicts that describe the loggers known
                  to the server database.  Each list item is a dict that describes
                  a single logger and has the following key/value pairs:
               </para>
                <variablelist>
                  <varlistentry>
                     <term><literal>id</literal></term>
                     <listitem>
                         <para>
                           Unique integer number that is the logger's primary
                           database key.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>daqroot</literal></term>
                     <listitem>
                         <para>
                           The root directory where the NSCLDAQ installation
                           lives.  Note that if the event logger runs containerized,
                           this path is expressed in terms of the filesystem
                           seen within the container.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>ring</literal></term>
                     <listitem>
                         <para>
                           The URI of the ring buffer from which the logger
                           will log data.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>host</literal></term>
                     <listitem>
                         <para>
                           The host on which the event logger will run.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>partial</literal></term>
                     <listitem>
                         <para>
                           Boolean that is true if this is a partial event logger.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>destination</literal></term>
                     <listitem>
                         <para>
                           The directory (or top level directory if full event
                           logging is done) in which the event logging will be
                           done.  If the event logger runs containerized,
                           this destination will be a path in the containerized
                           environment.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>critical</literal></term>
                     <listitem>
                         <para>
                           Boolean that is true if the logger is critical to the
                           functioning of the experiment.  If this is true
                           and the logger exits prematurely for any reason,
                           the manager forces a <literal>SHUTDOWN</literal>
                           transition.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>enabled</literal></term>
                     <listitem>
                         <para>
                           Boolean that is true if the event logger is enabled
                           to record data.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>container</literal></term>
                     <listitem>
                         <para>
                           If the event logger should run containerized, this is
                           the name of the container in which it will run.  If
                           the event log runs in the native environment,
                           this will be an empty string.
                       </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>record</methodname> <parameter>state</parameter></term>
            <listitem>
                <para>
                  Set the
                  global recording state to <parameter>state</parameter>.  This
                  should be a boolean that is true to enable global recording
                  or false to disable it.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>isRecording</methodname></term>
            <listitem>
                <para>
                  Returns a boolean value.  The value will be true if event recording
                  is enabled or false if not.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><methodname>start</methodname></term>
            <listitem>
                <para>
                  Starts the appropriate set of loggers.  For a logger to start,
                  it must be enabled and the global recording flag must also
                  be true.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<!-- /manpage -->

<!-- manpage 5daq -->

<refentry>
   <refmeta>
      <refentrytitle>Manager REST</refentrytitle>
      <manvolnum>5daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>Manager REST</refname>
      <refpurpose>DAQ Manager REST Specification</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>

/State/status
/State/allowed
/State/transition
/State/shutdown

/Programs/status

/KVStore/value
/KVStore/listnames
/KVStore/list
/KVSTore/set

/Loggers/enable
/Loggers/disable
/Loggers/list
/Loggers/record
/Loggers/isrecording
/Loggers/start
/Loggers/stop
/Loggers/status


      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
               The DAQ Experiment manager daemon provides a REST interface that
               allows external programs to control and query it.  This manpage
               describes the requests that can be made and the form of the response
               you can expect.  Note that Tcl client bindings already exist and
               are documented elsewhere.  This page documents the URLs, the parameters
               they require and the returned data.
          </para>
          <para>
            REST interfaces use standard HTTPD protocols to provide an in interface
            by which a client can make a server do something other than simply
            return some HTML to be rendered in a browser.  In REST interfaces,
            the requests are encoded a URLs with parameters provided either as
            query parameters or as POST parameters.
          </para>
          <para>
            In the case of the program manager, returned data are JSON encoded
            objects.  All of these objects have at least the atributes
            <literal>status</literal> which should be <literal>OK</literal>
            on success or <literal>ERROR</literal> on failure, and
            <literal>message</literal> which, in the case <literal>status</literal>
            is <literal>ERROR</literal>, provides a textual message string that
            describes why the action failed.
          </para>
          <para>
            REST requests are expressed as URLs.  The server provides several
            categories of REST requests or, as the server technology it uses calls
            them <firstterm>Domains</firstterm>.  These domains are:
          </para>
          <variablelist>
            <varlistentry>
               <term><literal>State</literal></term>
               <listitem>
                   <para>
                     Provides control and query of the state machine.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Programs</literal></term>
               <listitem>
                   <para>
                     provides status of programs run by the server.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>KVStore</literal></term>
               <listitem>
                   <para>
                     Provides access to the key value store maintained by the
                     server's configuration database.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Loggers</literal></term>
               <listitem>
                   <para>
                     Provides status and control over event loggers managed
                     by the server.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            Specific requests within a domain are encoded within the URL.
            For example; To obtain the current state of the state machine,
            you would perform the GET method on a URL of the form:
            <literal>http://serverhost:serverport/State/status</literal>.
            In this URL, <literal>serverhost</literal> is the host in which the
            server is running and <literal>serverport</literal> is the
            port the server is listening on for HTTP connections. This can be
            discovered by interacting with the port manager of <literal>serverhost</literal>
            to translate the service name given the user that started
            the manager.
          </para>
          <para>
            The remaining sections document each domain and the requests it
            supports.  Note that unless otherwise indictated, a request can
            be made via the GET method.  Parameters are either query parameters
            appended to the URL, in the case of GET request or POST form parameters
            in the case of POST requests.
          </para>
    </refsect1>
    <refsect1>
      <title>The /State Domain</title>
      <para>
         This domain provides access to the experiment manager's state machine.
         Note that in all requests a JSON encoded object is returned
         (mimetype application/json). We document the attributes in addition to
         <literal>status</literal> and <literal>message</literal> in the case
         <literal>status</literal> is <literal>OK</literal>.
         The following requests are supported:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>/status</literal></term>
            <listitem>
                <para>
                  Returns a JSON object with the attribute
                  <literal>state</literal>.  The value of this attribute is the
                  textual state name of the current state.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/allowed</literal></term>
            <listitem>
                <para>
                  Returns a JSON object with the attribute
                  <literal>states</literal>. The value of this attributes is
                  an array of strings that are the state names of states the
                  system can be made to transition to.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>transition</literal> (POST)</term>
            <listitem>
                <para>
                  This request must be issued with a POST method. The required
                  parameters are:
                  <parameter>user</parameter> the username of the user issuing
                  the request and <parameter>state</parameter> the requested
                  name of the state to transition to.
                  In the future <parameter>user</parameter> will be used in
                  conjunction with the authorization database to ensure the
                  user is authorized to request this transition.
               </para>
                <para>
                  Authentication is 'honesty is the best policy' which is not
                  secure at all but ok in the context of a collaborative experiment.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/shutdown</literal> (POST)</term>
            <listitem>
                <para>
                  This request must be issued with a POST method.  The
                  required parameter is <literal>user</literal>, the user
                  name of the person issuing the request.  
               </para>
                <para>
                  The server first performsa transtion to
                  <literal>SHUTDOWN</literal>.  Once this transition is complete,
                  the return data, which has no additional attributes is
                  sent to the server and, the program exit is scheduled.
                </para>
                <para>
                  There is some delay between the request and the actual
                  shutdown.  This is done to ensure the requester has been
                  sent the reply data before the server is actually shutdown.
                </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title> The /Programs Domain</title>
      <para>
         The requests in this domain provide information about the programs
         and containers under the control of the manager.  Note that there
         is only one request: <literal>/status</literal>.  This request
         requires no parameters and a GET method may be used to initiate it.
         In addition to the <literal>status</literal> and <literal>message</literal>
         attributes, if <literal>status</literal> is <literal>OK</literal>, the
         reply contains two additional attributes: <literal>containers</literal>
         and <literal>programs</literal>.
      </para>
      <para>
         The <literal>containers</literal> attribute is an array of objects.
         Each object describes a container managed by the server.  The
         <literal>program</literal> attribute is an array of objects.  Each of those
         objects describes a program managed by the server.
      </para>
      <para>
         The attributes of each element of the <literal>containers</literal>
         attribute are:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>name</literal></term>
            <listitem>
                <para>
                  The name of the container.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>image</literal></term>
            <listitem>
                <para>
                  The container image path.  This file will be specified by
                  a path in the host system.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>bindings</literal></term>
            <listitem>
                <para>
                  An array  of host/container filesystem bindings.  Each element
                  is expressed in a form suitable for use with the
                  <command>singularity</command> <option>--bind</option> option.
                  That is either <literal>hostpath</literal> or
                  <literal>hostpath:containerpath</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>activations</literal></term>
            <listitem>
                <para>
                  An array of hostnames in which the container is currently
                  active.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         The elements of the <literal>programs</literal> array are objects
         that have the following attributes:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>name</literal></term>
            <listitem>
                <para>
                  The name of the program.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>path</literal></term>
            <listitem>
                <para>
                  The path to the program file.  The meaning of this path
                  depends on the environment in which the program is run.
                  If the program is containerized, this path is specified
                  within the running container's filesystem.  If not containerized,
                  this path is expressed in terms of the host system's
                  filesystem.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>type</literal></term>
            <listitem>
                <para>
                  The textual program type.  This is one of
                  <literal>Transitory</literal>, <literal>Critical</literal>
                  or <literal>Persistent</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>container</literal></term>
            <listitem>
                <para>
                  The container the program runs in.  If the program does not
                  run containerized, this is an empty string.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>active</literal></term>
            <listitem>
                <para>
                  A boolean value that is true if the program is running or
                  false otherwise.  For the purposes of REST interfaces
                  <literal>1</literal> is true and <literal>0</literal>
                  is fales.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>The /KVStore domain</title>
      <para>
         The requests in this domain provide access to the key value
         store through the server.  Accessing this information via the
         server, rather than via direct database transactions, inherently serializes
         all operations which, otherwise might, due to parallelism, result in
         unpredictable results.  Even so, care must be taken.
      </para>
      <para>
         The supported requests in this domain are:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>/value</literal></term>
            <listitem>
                <para>
                  Requires the parameter <literal>name</literal> which must
                  be the name of an existing Key Value store key.  On
                  <literal>status</literal> of <literal>OK</literal>,
                  the returned object includes the attributes
                  <literal>name</literal>, which is, once more the
                  name of the key being queried and
                  <literal>value</literal> its current value.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/listnames</literal></term>
            <listitem>
                <para>
                  On <literal>status</literal> of <literal>OK</literal>,
                  the reply JSON object contains the attribute
                  <literal>names</literal> which is an array of strings.
                  Each string is a valid key in the key values store and all keys
                  are present in the array.  The user should not assume this array
                  is in any particular order.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/list</literal></term>
            <listitem>
                <para>
                  On <literal>status</literal> of <literal>OK</literal>,
                  the reply JSON includes the attribute <literal>variables</literal>.
                  The value of this attribute is an array of objects.  Each
                  object in the array contains the attributes <literal>name</literal>
                  which is a key in the key value store and
                  <literal>value</literal> which is the value associated with that
                  key.
               </para>
                <para>
                  All key value pairs will be represented in the array.  You should
                  not assume the array is in any particular order.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/set</literal> (POST)</term>
            <listitem>
                <para>
                  This request requires a POST method.
                  Changes the value of a key in the key values store.  Required
                  parameters are:
               </para>
                <variablelist>
                  <varlistentry>
                     <term><literal>user</literal></term>
                     <listitem>
                         <para>
                           Username of the requester (will eventually be used
                           to check authorization)
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>name</literal></term>
                     <listitem>
                         <para>
                           Name of the key to modify.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>value</literal></term>
                     <listitem>
                         <para>
                           New value to give to the value of that key.
                       </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
                <para>
                  Note that <literal>name</literal> must be an existing key.
                  This request cannot be used to create a new key.
                  On <literal>status</literal> of <literal>OK</literal>, the
                  returned JSON object will have the additional attributes:
                  <literal>name</literal>, the original key name.
                  <literal>value</literal> the new value.
                </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>The /Loggers domain</title>
      <para>
         Requests in this domain control and get information about the
         event loggers that are managed by the server.  In the request documentation
         below, the returned object attributes are only present if the
         <literal>status</literal> attribute has the value <literal>OK</literal>.
         Note as well that all requests documented as needing to use the
         <literal>POST</literal> method have a required parameter
         <parameter>user</parameter> which is the name of the user that is
         making the request.
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>/enable</literal> (POST)</term>
            <listitem>
               <para>
                  Enables a specific logger.
               </para>
                <para>
                  This request must use the POST method.  In addition it must
                  supply the <literal>logger</literal> parameter which
                  specifies the destination of the logger to enable.
                  The returned object does not have any additional attributes.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/disable</literal> (POST)</term>
            <listitem>
               <para>
                  Disables a specific logger.
               </para>
                <para>
                  This request must use the POST method.  In addition in must supply the
                  <literal>logger</literal> parameter which specifies the
                  destination of the logger to be disabled.
                  The returned object has no additional attributes.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/list</literal></term>
            <listitem>
                <para>
                  Returns an object that has the addition attributes
                  <literal>loggers</literal>.  The value of this attribute
                  is an array of JSON encoded objects.  Each object in the
                  array describes a logger.  These object have the following
                  attributes:
               </para>
                <variablelist>
                  <varlistentry>
                     <term><literal>id</literal> (integer)</term>
                     <listitem>
                         <para>
                           Primary key of the logger in the database.
                           For most REST clients this is not useful.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>daqroot</literal> (string)</term>
                     <listitem>
                         <para>
                           The root of the NSCLDAQ installation tree from which
                           the logger will be run.  This indirectly specifies
                           the event logging program that will be used.
                       </para>
                         <para>
                           If the logger is run containerized, this path
                           will be specified in the filesystem as seen within
                           the running container.
                         </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>ring</literal> (string)</term>
                     <listitem>
                         <para>
                           URI of the ringbuffer that will be logged.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>host</literal> (string)</term>
                     <listitem>
                         <para>
                           Host in which the event logger will be run.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>partial</literal> (integer)</term>
                     <listitem>
                         <para>
                           Non zero if this logger is a partial (multilogger style)
                           logger.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>destination</literal> (string)</term>
                     <listitem>
                         <para>
                           Filesystem path to where the data will be logged.
                           If the logger runs containerized, this is expressed
                           in the filesystem as seen by the container.
                       </para>
                         <para>
                           If this logger is partial, this is the path to the
                           directory in which the data are logged.  If not,
                           this path is  the top level of the directory tree of the
                           logger directory structure.
                         </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>critical</literal> (integer)</term>
                     <listitem>
                         <para>
                           If nonzero, premature exits of this logger
                           will result in a forced <literal>SHUTDOWN</literal>
                           transition.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>enabled</literal> (integer)</term>
                     <listitem>
                         <para>
                           If non zero the logger is enabled.
                       </para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>container</literal> (string)</term>
                     <listitem>
                         <para>
                           Name of the container if the logger should be
                           run containerized.  If this is an empty string,
                           the logger is run in the host system.
                       </para>
                    </listitem>
                  </varlistentry>
                </variablelist>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/record</literal> (POST)</term>
            <listitem>
                <para>
                  Sets the state of the global recording flag.  This request
                  must be done as  POST method and requires
                  a POST parameter <parameter>state</parameter> which is
                  an integer.  A value of 1 enables recording, zero values
                  disable it.  All other values are illegal and result in an
                  error object.  
               </para>
                <para>
                  On success, no additional attributes are defined in the returned
                  object.
                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/isrecording</literal></term>
            <listitem>
                <para>
                  Returns an object with the additional attribute
                  <literal>state</literal> which is <literal>1</literal>
                  if the global recording flag is set and <literal>0</literal>
                  if not.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/start</literal> (POST)</term>
            <listitem>
                <para>
                  POST method required.  This request begins the event loggers
                  that are entitled to start for this run.  A logger starts
                  if the global recording flag is set
                  <emphasis>and</emphasis> that logger is enabled.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/stop</literal></term>
            <listitem>
                <para>
                  Not yet implemented.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>/status</literal></term>
            <listitem>
                <para>
                  Not yet implemented.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<refentry>
   <refmeta>
      <refentrytitle>DAQ manager database schema</refentrytitle>
      <manvolnum>5daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>DAQ Manager schema</refname>
      <refpurpose>Document database tables for manager.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      
         <programlisting>
CREATE TABLE container  (
            id         INTEGER PRIMARY KEY,
            container  TEXT,
            image_path TEXT,
            init_script TEXT
        );
CREATE TABLE bindpoint (
            id            INTEGER PRIMARY KEY,
            container_id  INTEGER,    -- FK to container
            path          TEXT,
            mountpoint    TEXT DEFAULT NULL
        );
CREATE TABLE program_type (
            id                INTEGER PRIMARY KEY,
            type              TEXT
        );
CREATE TABLE program (
            id           INTEGER PRIMARY KEY,
            name         TEXT,      -- Name used to refer to the program.
            path         TEXT,
            type_id      INTEGER, -- FK to program_type
            host         TEXT,
            directory    TEXT,
            container_id INTEGER, -- FK to container
            initscript   TEXT,
            service      TEXT
        );
CREATE TABLE program_option (
                id          INTEGER PRIMARY KEY,
                program_id  INTEGER,  -- FK to program
                option      TEXT,
                value       TEXT
            );
CREATE TABLE program_parameter (
            id             INTEGER PRIMARY KEY,
            program_id     INTEGER,   -- FK to program.
            parameter      TEXT
        );
CREATE TABLE program_environment (
                id         INTEGER PRIMARY KEY,
                program_id INTEGER,
                name       TEXT,
                value      TEXT
            );
CREATE TABLE sequence (
            id                INTEGER PRIMARY KEY,
            name              TEXT,
            transition_id     INTEGER -- FK to transition triggering seq.
        );
CREATE TABLE step (
            id                       INTEGER PRIMARY KEY,
            sequence_id              INTEGER, -- fk to sequence
            step                     REAL,
            program_id               INTEGER, -- fk to program table.
            predelay                 INTEGER DEFAULT 0,
            postdelay                INTEGER DEFAULT 0
        );
CREATE TABLE transition_name (
            id        INTEGER PRIMARY KEY,
            name      TEXT
        );
CREATE TABLE legal_transition (
            id              INTEGER, PRIMARY KEY,
            from_id         INTEGER,   -- FK in to transition_name
            to_id           INTEGER    -- Also FK into transition_name
        );
CREATE TABLE last_transition (
            state           INTEGER     -- FK to transition_name
        );

CREATE TABLE logger (
            id                 INTEGER PRIMARY KEY,
            daqroot            TEXT,
            ring               TEXT,
            host               TEXT,
            partial            INTEGER DEFAULT 0,
            destination        TEXT,
            critical           INTEGER DEFAULT 1,
            enabled            INTEGER DEFAULT 1,
            container_id       INTEGER DEFAULT NULL -- FK to container tbl.
        );
CREATE TABLE recording (
            state     INTEGER
        );
CREATE TABLE kvstore (
            id        INTEGER PRIMARY KEY,
            keyname   TEXT,
            value     TEXT
        );
CREATE TABLE users (
            id        INTEGER PRIMARY KEY,
            username  TEXT
        );
CREATE TABLE roles (
            id       INTEGER PRIMARY KEY,
            role     TEXT
        );
CREATE TABLE user_roles (
            user_id    INTEGER,
            role_id    INTEGER
        );
            
         </programlisting>
      
    </refsynopsisdiv>
    <refsect1>
             <title>INTRODUCTION</title>
          <para>
            The program manager maintains a DAQ instance configuration in an
            SQLite3 database.  In addition some state is also maintained in that
            database.   The purpose of this section is to describe the
            tables and their relationships in this schema.
          </para>
          <para>
            For the most part, the database tables make up subsystems of
            roughly orthogonal table sets.  Each of these table sets will
            be given section in the man page.  
          </para>
          <para>
            All tables have an integer primary key field named <literal>id</literal>.
            This will not be further described in the interest brevity.  When
            a field is said to be a foreign key into another table, its value is
            the value of the <literal>id</literal> field of a row in that other
            table.  This is a normal way to make relationships between tables
            in SQL databases.
          </para>
    </refsect1>
    <refsect1>
      <title>Users and Roles</title>
      <para>
         While at the time this is being written, the intended functionalit behind
         these tables is not implemented, the eventual purpose is to allow for
         a capability based system that constrains what each user can do.
         The tables are probably pretty close to the final shape but there is
         no code to implement the protections.
      </para>
      <para>
         The concept of this table set is that users of the system must be defined.
         Roles indicate the sorts of things a person is allowed to do within the
         system and a user can be granted any set of roles which, in turn, describe
         what that user can do within the system.
      </para>
      <para>
         The <literal>users</literal> table defines the set of users known to the
         system  the <literal>username</literal> field is the login name of
         a system user.
      </para>
      <para>
         Similarly, the <literal>roles</literal> table contains the set of
         roles defined by the system.  The <literal>role</literal> field is the
         name of a role that can be <firstterm>granted</firstterm> to a set of
         users.
      </para>
      <para>
         Finally, the <literal>user_roles</literal> table is a
         <firstterm>join table</firstterm>.  It does not have or need a primary
         key field.  It has two fields:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>user_id</literal></term>
            <listitem>
                <para>
                  A foreign key into the <literal>users</literal> table which
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>role_id</literal></term>
            <listitem>
                <para>
                  A foreign key into the <literal>roles</literal> table.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         Thus each entry in the <literal>user_roles</literal> table defines
         a role that has been granted to a specific user.
      </para>
    </refsect1>
    <refsect1>
      <title>Containers</title>
      <para>
         The database supports the definition of containers and bindpoints.
         In addition an <firstterm>init script</firstterm> can be defined
         that is run prior to running a program within the container.  Containers
         can be activated on specific nodes in the network.  Once activated a
         container persists and any number of programs can run within it.
      </para>
      <para>
         The <literal>container</literal> table defines the containers and gives
         names to each one.
         <literal>container</literal>  field is the name of the container.
            <literal>image_path</literal> is the path in the <emphasis>host system</emphasis>
            to the container image.
            <literal>init_script</literal> is a script that is run prior to running
            any program in the container.  The field contains the script itself not
            the path to a file containing that script.  If, however, the script
            depends on other scripts, the must be referred to in a way that they
            can be located within the container (e.g. located in a directory bound
            into the running container).
      </para>
      <para>
         Since each running container can have any number of bind points,
         a separate table is needed to contain their definitions. The
         <literal>bindpoint</literal> table is this table.  It contains
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>container_id</literal></term>
            <listitem>
                <para>
                  A foreign key back into the <literal>container</literal>
                  table that indicates which container this bind point
                  belongs to.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>path</literal></term>
            <listitem>
                <para>
                  The host system path to be bound into the container.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>mountpoint</literal></term>
            <listitem>
                <para>
                  If not null, this is the location in the container's file system
                  where <literal>path</literal> will be bound.  If this field is
                  null, the <literal>path</literal> is bound into the same
                  filesystem location in the container.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>Programs</title>
      <para>
         Programs are executables or shell scripts that are run by the manager.
         Programs are run on a specific host and can either run in the native system
         or inside a container that has been defined in the database.
      </para>
      <para>
         Programs have a type, which determines what happens when it exits, options
         (name value pairs e.g. <option>--ring</option> myring), parameters which are
         an ordered set of values.  In addition programs can have a set of
         name value pairs that are loaded into the environment prior to program
         startup.  Note that programs started in containers will first have the
         containers initialization script executed on their behalf.
      </para>
      <para>
         The <literal>program_type</literal> table in the program table set
         provides names for the types of programs the system recognizes.
         This table is pre-loaded when the schema is created. A program's program
         type determines the actions taken by the system when the program exits.
      </para>
      <para>
         Possible values are:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>Transitory</literal></term>
            <listitem>
                <para>
                  The program is expected to run, do something and then exit.
                  No action is taken when it exits.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>Persistent</literal></term>
            <listitem>
                <para>
                  The program is intended to run and continue to run but is
                  not critical to the functioning of the system.  For example
                  a SpecTcl instance could be run under the program manager.
                  SpecTcl is not intended to exit but data continues to flow
                  and external SpecTcl instances can be attached to the system
                  to monitor the data.
               </para>
               <para>
                  If a persistent program exits, a note is sent to all output monitors
                  but no other action is taken.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>Critical</literal></term>
            <listitem>
                <para>
                  The continued operation of the program is critical to the
                  system.  If a critical program exits, the manager makes a
                  transition to <literal>SHUTDOWN</literal> stopping the system.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         The <literal>program</literal> table is the <firstterm>root table</firstterm>
         of program definitions.  It has the following fields:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>name</literal></term>
            <listitem>
                <para>
                  A name assigned to the program that can be used to reference
                  the program when using the tools provided to configure the
                  system.  This is <emphasis>not</emphasis> the program path.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>path</literal></term>
            <listitem>
                <para>
                  Path to the executable or script that will run when the program
                  is activated.  Note that if the program should be run in a container,
                  this must be the path to the program as seen within the container.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>type_id</literal></term>
            <listitem>
                <para>
                  A foreign key into the <literal>program_type</literal> table
                  that indicates the type of program this is.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>host</literal></term>
            <listitem>
                <para>
                  The IP address or DNS name of the host in which the program will
                  be run.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>directory</literal></term>
            <listitem>
                <para>
                  The working directory that will be set for the program when it
                  runs.  Again, if the program is containerized, this must be
                  the path to the directory as seen within the container.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>container_id</literal></term> 
            <listitem>
                <para>
                  If not null, the
                  program will be run containerized and this is a foreign key into the
                  <literal>container</literal> table that selects the container within
                  which the program will run.  If null, the program runs in the native
                  system.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>initscript</literal></term>
            <listitem>
                <para>
                  If not empty, this is a script that is run prior to program
                  activation.  As with <literal>container</literal>, this contains
                  the contents of a script not a path.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>service</literal></term>
            <listitem>
                <para>
                  Not yet used by code.  The intent is that this field can encapsulate
                  a service advertised in the host's port manager on which requests
                  can be made to the program.  
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         The <literal>program_option</literal> table captures a list of option/value
         pairs that will be passed to the program's command line.  The fields are
         <literal>program_id</literal> a foreign key into the <literal>program</literal>
         table indicating the program this belongs to, <literal>option</literal>
         the option and <literal>value</literal> the option's value.
         For example if <literal>option</literal> is <literal>--ring</literal>
         and value is <literal>fox</literal>, <literal>--ring=fox</literal>
         is passed to the program.
      </para>
      <para>
         Similarly, <literal>program_parameter</literal> is an ordered list
         of parameters that is passed to the program on startup.
         <literal>program_id</literal> is the foreign key back to
         <literal>program</literal> indicating the program this will be passed to and
         <literal>parameter</literal> is the value that will be passed.
         Parameters are given in the command line in order of their primary keys..
      </para>
      <para>
         Finally, <literal>program_environment</literal>, is  a list of environment
         variables and their values that will be set prior to running the
         program.  <literal>program_id</literal> is, again, a foreign key
         into the <literal>program</literal> that determines which program each
         record belongs to. <literal>name</literal> is the environment variable name
         and <literal>value</literal> its value. 
      </para>
      <para>
         An implementation note of some interest:  Since the manager writes a
         shell script and runs it to execute the program, all shell substitutions
         will work in the option, parameter and environment tables.
      </para>
    </refsect1>
    <refsect1>
      <title>States and transitions</title>
      <para>
         At its heart the manager is just a state machine.  States are defined
         in the database as are valid transitions from each state.  Each state
         transition can trigger sequences of program executions.  While the set
         of states is initially defined when the schema is created, the states
         and valid transitions can be redefined using the configuration tools.
         That is not recommended.   
      </para>
      <para>
         This section describes states, transitions and sequences.
      </para>
      <para>
         Since actions occur on transitions not within the states themselves,
         the stae names are actually captured in the <literal>transition_name</literal>
         table.  Other than its primary key, it consists of a single text field;
         <literal>name</literal> that is the textual state of the
         state-name/transition into the state.  Initially, this is stocked with 
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>SHUTDOWN</literal></term>
            <listitem>
                <para>
                  The system is shutdown.  This is a special state in the
                  sense that transitioning into  that state involves stoppping
                  execution of all programs.  In addition failure of critical
                  programs will cause an automatic transition to the <literal>SHUTDOWN</literal>
                  state.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>BOOT</literal></term>
            <listitem>
                <para>
                  The system is ready for use.  Often, for a DAQ system to be usable,
                  a set of base programs (e.g. readout engines, event builders and their
                  feeders) must be running.  Sequences attached to the transition
                  to this state normally initiate that set of base programs.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>HWINIT</literal></term>
            <listitem>
                <para>
                  Hardware is initialized.  This is normally done once after
                  boot to ensure that the hardware has been  made ready to
                  start/stop runs.  Any time consuming, one-time initialization is
                  normally done here.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>BEGIN</literal></term>
            <listitem>
                <para>
                  The system is taking data, a run has begun.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>END</literal></term>
            <listitem>
                <para>
                  The system has finished taking data and is now ready to start
                  the next run.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         Legal transitions between states are defined in the <literal>legal_transition</literal>.
         In addition to its primary key, it contains
         a pair of foreign keys into the <literal>transition_name</literal> table:
         <literal>from_id</literal> and <literal>to_id</literal> which define
         a legal transition's initial and final states respectively.
      </para>
      <para>
         The <literal>last_transition</literal> table captures the last
         state of the system.  It is primarily used on system start up to know if
         the manager has to transition to <literal>SHUTDOWN</literal>.  It's a
         table with a single entry  and a single field <literal>state</literal>
         which is a foreign key into <literal>legal_transition</literal> indicating
         the current manager state.
      </para>
      <para>
         The power of the manager system comes from being able to trigger
         actions as a result of attempts to transition to another state of
         the system.   These actions are called sequences and consist of
         attempts to run a set of programs.  How programs are run depends on their
         types.  If a program is transitory it is run and must complete before
         the next step in a sequence is initiated.  If a program is either
         Critical or Persistent it is started and then next step of the
         sequence can be run.
      </para>
      <para>
         From the previous paragraph, you have hopefully built a model that
         a sequence has a transition trigger and an ordered series of steps
         that run programs.  This model is captured in the
         following tables:
      </para>
      <para>
         The <literal>sequence</literal> table contains one entry per sequence.
         The entry contains a <literal>name</literal>, which provides a name to
         the sequencde and <literal>transition_id</literal> which is a foreign key
         into the <literal>transition_name</literal> table indicating which
         transition will trigger execution of the sequence.
      </para>
      <para>
         Each sequence has a series of steps.  These are defined in the
         <literal>step</literal> table which defines both the actions of each
         step in the sequence as well as the ordering of the steps. The ordering
         is captured in a way that allows steps to be inserted at any point in the
         sequence when configuring the system.  The <literal>step</literal>
         table contains the following fields:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>sequence_id</literal></term>
            <listitem>
                <para>
                  Foreign key  into the <literal>sequence</literal> table
                  that indicates the sequence to which this step belongs.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>step</literal></term>
            <listitem>
                <para>
                  A real value that indicates the step ordering.  To determine step
                  ordering for a sequence, the system retreives all steps that
                  belong to that sequence and orders them by this field.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>program_id</literal></term>
            <listitem>
                <para>
                  Foreign key into the <literal>program</literal>
                  table that describes the program to be run in this step.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>predelay</literal></term>
            <listitem>
                <para>
                  Number of seconds to delay prior to running this step.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>postdelay</literal></term>
            <listitem>
                <para>
                  Number of seconds to delay after starting the program described
                  by this step.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         Note that several sequences can be given the same trigger.  This is useful
         when buiding systems that consist of quasi-independent detector systems.
         While there's no specification that defines the order in which sequences
         are run, in practice their primary key determines that order.
      </para>
      <para>
         One way to ensure that sequences are run in the order you want is to add
         intermediate states to the system, and use external software to step
         the system from desired initial state to desired final state along that
         set of intermediate states.
      </para>
      
    </refsect1>
    <refsect1>
      <title>Event Logging</title>
      <para>
         Event logging could have been captured as steps in sequences, however
         the actions, and order in which they are taken are so critical, they
         are separated out from that subsystem.  In NSCLDAQ prior to the manager,
         there were two types of loggers, the primary logger managed a directory
         tree that maintained run metadata and used symbolic links to provide
         both and experiment and a run view of the event files.  Multiloggers just
         put event files in a soup in a directory.
      </para>
      <para>
         In NSCLDAQ prior to the manager you could have a single primary logger and
         as many multiloggers as you wanted.  The manager allows any number of
         any type of logger.  Loggers that look like multilogger are called
         <firstterm>partial</firstterm> loggers.  Loggers can also be critical or not.
         Failure of a critical logger results in a transition to <literal>SHUTDOWN</literal>.
      </para>
      <para>
         Two tables describe and manage logger fucntionality <literal>recording</literal>
         simply contains a single record with a single boolean field <literal>state</literal>
         which is non-zero if logging should be done and zero if not.
      </para>
      <para>
         The <literal>logger</literal> table defines the loggers themselves.  It
         contains the following fields:
      </para>
      <variablelist>
         <varlistentry>
            <term>daqroot</term>
            <listitem>
                <para>
                  The directory tree that contains the event loggers. This should
                  be the top leve of an NSCLDAQ installation either in a container
                  (if the logger is run containerized), or the native system if not.
                  The actual program run will be <filename>eventlog</filename> from
                  the <filename>bin</filename> subdirectory of that tree.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>ring</term>
            <listitem>
                <para>
                  This is the URL of the NSCLDAQ ring buffer from which event
                  data will be logged.  This should be of the form:
                  <literal>tcp://</literal><replaceable>host/ringname</replaceable>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>host</literal></term>
            <listitem>
                <para>
                  Host in which the event logger should be run.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>partial</literal></term>
            <listitem>
                <para>
                  Non zero if the loggers is partial (multilogger style). If
                  zero, the logger is a full logger and will maintain a directory
                  tree in the same manner the primary logger of the
                  ReadoutShell does.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>critical</literal></term>
            <listitem>
                <para>
                  If nonzero, the logger is critial to the experiment function and the
                  system should be <literal>SHUTDOWN</literal> if it fails/exits
                  unexpectedly.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>enabled</literal></term>
            <listitem>
                <para>
                  If nozero, the logger will record data when the
                  <literal>recoring.state</literal> field is nonzero.
                  This allows loggers to be turned off once system debugging
                  is complete.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>container_id</literal></term>
            <listitem>
                <para>
                  If non-null, the logger will be run containerized and this
                  specifies the foreign key into the
                  <literal>container</literal> table that specifies the
                  container definition to use when containerizing the
                  logger software.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>Key value store</title>
      <para>
         The key value store is used to hold miscellaneous data.  For example,
         the Readout program control programs use this to store the run title
         and run number.  The is simply a table that contains the fields:
         <literal>keyname</literal> the name of an item.
         <literal>value</literal> the value of that item.  User software can
         also use this table to store arbitrary data.
      </para>
      <para>
         $DAQBIN/mg_mkconfig adds two entries to this table when it is created:
      </para>
      <variablelist>
         <varlistentry>
            <term>Key: <literal>title</literal> Value: <literal>Set a new title</literal></term>
            <listitem>
                <para>
                  The title Readout programs will use for their next run.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>Key: <literal>run</literal> Value: <literal>0</literal></term>
            <listitem>
                <para>
                  The run number readout programs will use for their next run.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
</refentry>
<refentry>
   <refmeta>
      <refentrytitle>Container Description File</refentrytitle>
      <manvolnum>5daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>Container Description File</refname>
      <refpurpose>Describe containes to Manager configuration container wizard</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <programlisting>
[CONFIG]
native_tree=/location/of/opts/in/native/system
container_tree=/location/of/opts/in/containerized/systems

[container-name]
path=/path/to/container
usropt=usr-opt-for-that-container
bindings=native,native:container...
....

      </programlisting>
    </refsynopsisdiv>
    <refsect1>
             <title>INTRODUCTION</title>
          <para>
            Configuring the manager for an experiment is a complex process
            and the initial set of configuration tools is quite simplistic.
            The container wizard allows users to define containers that can be
            used to run programs and event loggers using a configuration
            file to define the set of containers and how to specify them
            and their bindings for <filename>/usr/opt</filename> as well
            as other bindings that might be required to make that container
            work correctly (e.g. bindings needed to make the module system
            work within the container.
          </para>
          <para>
            The wizard can use the information in this configuration file
            to present options for the version of NSCLDAQ to setup within
            the container as well as provide the option to make other
            filesystem bindings.
          </para>
          <para>
            See the <literal>ContainerWizard (1daq)</literal> man page for
            more information about what the container wizard does, and where it
            looks for its configuration file.
          </para>
    </refsect1>
    <refsect1>
      <title>Configuration file format</title>
      <para>
         The configuration file format used is .ini (or .toml if you prefer).
         In that format the file has sections which are introduced by
         [sectionname] and each section has a number of key=value pairs.
      </para>
      <para>
         A mandatory [CONFIG] section describes where the /usr/opt directories
         live in both native and containerized file systems.  This information
         is used by the wizard to enumerate the versions of NSCLDAQ that are installed
         to present them as options to the user.  The keys in this section
         are mandatory and are:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>native_tree</literal></term>
            <listitem>
                <para>
                  Where the /usr/opt directories live in the native file system.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>container_tree</literal></term>
            <listitem>
                <para>
                  where the /usr/opt directories get mapped in the containerized
                  systems.  Note that this binding will automatically
                  be made by the wizard.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <para>
         Subsequent sections are container names to present to the user.
         These sections have both mandatory and optional keys:
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>path</literal> (Mandatory)</term>
            <listitem>
                <para>
                  The value of this key is the path to the container image in
                  the host filesystem.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>usropt</literal> (Mandatory)</term>
            <listitem>
                <para>
                  The directory that should be bound to /usr/opt in the
                  container.  This binding will be made relative to the
                  <literal>native_tree</literal> value in the
                  <literal>[CONFIG]</literal> section.  For example,
                  if <literal>native_tree</literal> is <filename>/usr/opt</filename>
                  and <literal>usropt</literal> is <literal>opt-buster</literal>,
                  if selected, the container will bind
                  <literal>/usr/opt/opt-buster:/usr/opt</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>bindings</literal> (Optional)</term>
            <listitem>
                <para>
                  If specified these are additional bindings that will be made
                  when the container is activated.  The value is a comma separated
                  list of bindings.  Each binding is of the form
                  <replaceable>nativepath</replaceable> or
                  <replaceable>nativepath:containerpath</replaceable>.
                  The first form will bind <replaceable>nativepath</replaceable>
                  to the same location in the container filesystem.  The second form
                  will bind <replaceable>nativepath</replaceable>
                  to <replaceable>containerpath</replaceable> in the
                  container filesystem.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </refsect1>
    <refsect1>
      <title>EXAMPLE</title>
      <para>
         This example shows a configuration file that's part of the FRIB
         configuration file:
      </para>
      <example>
         <title>Sample Container Configuration File</title>
         <programlisting>
[CONFIG]
native_tree=/usr/opt
container_tree=/non-container

[jessie]
path=/usr/opt/nscl-jessie.img
usropt=opt-jessie
bindings=/usr/opt/include_modules-jessie.sh:/etc/profile.d/module.sh

[buster]
path=/usr/opt/nscl-buster.img
usropt=opt-buster
bindings=/mnt/misc/sw/indep,/mnt/misc/sw/x86_64/all,/usr/lib/x86_64-linux-gnu/modulecmd.tcl

         </programlisting>
      </example>
      <para>
         The <literal>[CONFIG]</literal> section specifies that the directory
         that contains the container <filename>/usr/opt</filename> trees is
         <filename>/usr/opt</filename> and that this will be mapped into all
         containrs at <filename>/non-container</filename>.  Two containers
         are defined: <literal>jessie</literal> and <literal>buster</literal>.
      </para>
      <para>
         As an example, activating the <literal>buster</literal> container
         will be done with a command like:
      </para>
      <informalexample>
         <programlisting>
singularity instance start --bind /usr/opt:/non-container \
   --bind /usr/opt/opt-buster:/usr/opt \
   --bind /mnt/misc/sw/indep \
   --bind /mnt/misc/sw/x86_64/all \
   --bind /usr/lib/x86_64-linux-gnu/modulecmd.tcl \
       /usr/opt/nscl-buster.img buster
       
         </programlisting>
      </informalexample>
    </refsect1>
</refentry>
<!-- /manpage -->