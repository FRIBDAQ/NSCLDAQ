<!-- chapter libraries -->

<chapter>
    <title>Parallel programming framework</title>
    <para>
        There are many types of parallel programming.  One classic model
        for parallel programming is that of
        <firstterm>Communicating Sequential Processes</firstterm> (CSP).
        CSP models a parallel program as a set of sequential, or serial programs
        that talk to each other.  
    </para>
    <para>
        Within CSP two main models exist;
        <itemizedlist>
            <listitem>
                <para>
                    Threaded - when parallelism is confined to a single
                    shared memory multi-core system, where all communication
                    is internal to that system.
                </para>
            </listitem>
            <listitem>
                <para>
                    Distributed - when the application is spread out over some
                    networked set of nodes.  Normally these nodes are
                    interconnected via a high performance low latency
                    <firstterm>network fabric</firstterm>.
                </para>
                <para>
                    Linux, Beowulf clusters are a pretty popular platform
                    on which to build distributed parallel programs.
                </para>
            </listitem>
        </itemizedlist>
    </para>
    <para>
        NSCLDAQ provides a high level library that insulates your program
        from the detailed mechanisms of specific message passing libraries.
        Programs written that only communicate via message passing can be
        easily rehosted from a threaded implementation to a distributed
        implementation, changing only initialization code.
    </para>
    <para>
        In this chapter we'll describe:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                The concepts and classes behind the library.
            </para>
        </listitem>
        <listitem>
            <para>
                The implementation state of the library including the set of
                communication systems that are implemented by the library at this
                time and a roadmap describing planned future developments.
                Pointers will be given to man page starting points for each
                implemented communication scheme.
            </para>
        </listitem>
        <listitem>
            <para>
                How to compile and link programs using this library.
            </para>
        </listitem>
    </itemizedlist>
    <section>
        <title>Concepts and classes</title>
        <para>
            Parallel programs build on top of this library consists of
            objects that communicate via messagse passing.  To limit the
            amount of data copying required, messages can, not only be
            a single block of data but can be a block list that's gathered
            by the library into a single message.
        </para>
        <para>
            The assumption is that a program consists of some source of data
            and that processing these data involve parcelling out work units
            to parallel processing objects. which then fan their
            results back in to processing objects that gather the  data.
        </para>
        <para>
            Thus the programming model has you stringing together a
            pipeline (each element of the pipeline runs in parallel) where
            stages of those pipelines may include stages that run multiple
            processors that operate in parallel on data streaming through the
            pipeline.
        </para>
        <para>
            The following classes, therefore, model several types of
            processing elements that can appear in these data/processing flows:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>CDataSourceElement</classname></term>
                <listitem>
                    <para>
                        These elements are intended to connect the
                        program to concrete sources of data.  In NSCLDAQ
                        these sources can be ring items, files or some
                        other communicating processor (internal or external).
                    </para>
                    <para>
                        These elements are normally at the start of the
                        processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CDataSinkElement</classname></term>
                <listitem>
                    <para>
                        These elements are intended to connect the program
                        to some concrete sink of data.  In NSCLDAQ, sinks can
                        be ring buffers, files or other communicating processors.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CParallelWorker</classname></term>
                <listitem>
                    <para>
                        A generic parallel worker.  This is normally used
                        to encapsulate code that runs in the data parallel
                        segments of the computation.  Normally this
                        encapsulation 
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            From these classes you can see that the computation normally takes
            the form of a pipeline where data comes from a
            <classname>CDataSourceElement</classname> runs through
            several <classname>CParallelWorker</classname> elements
            and then in the end data is emitted from the program via
            a <classname>CDataSinkElement</classname>
        </para>
        <para>
            Having these classes is all well and good, but how do they communicate
            with each other?  Following the pipeline model, each element
            of the computation gets its data from
            a <classname>CReceiver</classname> and sends the results of its
            computation to the next stage of the pipeline
            via a <classname>CSender</classname>.
        </para>
        <para>
            <classname>CReceiver</classname> and
            <classname>CSender</classname> objects encapsulate another
            class derived from
            <classname>CTransport</classname>.  Transport classes are
            actual do the messaging required by the receiver and sender objects.
            In doing so, the contain code specific to the type communication
            library being used (e.g. MPI or ZeroMQ), and they also encapsulate
            a specific communication pattern.
        </para>
        <para>
            Some base classes for transports are:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>CTransport</classname></term>
                <listitem>
                    <para>
                        The abstract base class for all transports.  This class
                        provides the interfaces used by sender and receiver
                        objects to request actual communication.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CFanoutTransport</classname></term>
                <listitem>
                    <para>
                        Abstract base class for transports that fan-out work items
                        to data parallel sections of the program.  In addition
                        to the data transfer interfaces, this class
                        provides interfaces to inform the members of the
                        fanout that there is no more data available.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CFanoutClientTransport</classname></term>
                <listitem>
                    <para>
                        Abstract base class for transports that
                        get data from a fanout transport.  The model provided
                        requires that each client provide a unique integer
                        client identifier.  This class encapsulates interfaces
                        for both setting the id and communicating the id to the
                        other end of the transport.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Thuse the computation can be made up of processing elements that
            get and send data without actually knowing how that's done.  Program
            initialization can select actual transports and bind them into
            processing elements.  If necessary, program initialization can also
            allocate processors to computing resources.
            This allows a computation to be rehosted without the actual
            computing elements being aware of the process.
        </para>
    </section>
    <section>
        <title>Transport implementations</title>
        <para>
            At present only ZeroMQ (ZMQ) transports are supported.  We
            plan to implement MPI transport in the future.  Other transport
            types will be implemented as demand indicates.
        </para>
        <section>
            <title>Details of ZMQ transport implementation</title>
            <para>
                The goal here is not to get into the nitty gritty of ZMQ
                socket types used in the various transports, but to describe
                facilities available to assist you in setting up ZMQ based
                parallel programs. 
            </para>
            <para>
                One facility the library provides is a factory that provides
                you with transport factories for the specific communication
                system you are using.   The factory knows how to create
                transports for communication patterns implemented on top of
                a specific transport library.
            </para>
            <para>
                The <classname>CCommunicatorFactoryMaker</classname>
                singleton class represents this factory of factories.  The
                code fragment below shows how to get a communication
                factory for ZMQ communications:
            </para>
            <informalexample>
                <programlisting>
#include &lt;CCommunicatorFactoryMaker.h&gt;
#include &lt;CCommunicatorFactory.h&gt;
..
..
CCommunicatorFactory* pZmqFactory = CCommunicatorFactoryMaker::getInstance()-&gt;
    create("ZeroMQ CommunicationSystem");
if (!pZmqFactory) {
    std::cerr &lt;&lt; "ZEROMQ factory not in the factory of factories\n";
    exit(-1);
}
....

                </programlisting>
            </informalexample>
            <para>
                One problem that needed solving to provide a generic
                communicator factory was how to identify communication endpoints.
                For example a raw TCP/IP socket uses a host/port pair to
                identify an end point, ZMQ uses an URI to identify end endpoint
                and so on.
            </para>
            <para>
                Communicator factories use unsigned integers to identify
                endpoints.  While this maps directly to e.g. MPI ranks,
                there must be a mechanism for the ZMQ factory to map these
                identifiers onto URIs.
            </para>
            <para>
                This is done by you, providing one or more zmq service map files.
                A zmq service map file is a text file.  Lines beginning with
                <literal>#</literal> are ignored as are lines that consist
                only of whitespace.  Leading and trailing whitespace are also
                ignored.
            </para>
            <para>
                Mapping lines, consist of two fields. The first is an integer
                transport id and the second is the ZMQ URI that will be used
                when that transport endpoint is selected. For example;
            </para>
            <informalexample>
                <literallayout>
    1 tcp://somenode.in.my.network:1234
                </literallayout>
            </informalexample>
            <para>
                Maps the transport identifier <literal>1</literal> to  a TCP
                transport with an endpoing of port number <literal>1234</literal>
                whose server is in a
                system named <literal>somenode.in.my.network</literal>.
            </para>
            <para>
                We therefore need to know, additionally, which transports are
                servers and which are clients.
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Fanout transports are servers and their clients are not.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Fan in sinks are servers fanin sources are not.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        One-to-One sources are servers, clients are not.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                The transport id/URI map is built up by reading all files found in
                
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>$HOME/.zmqservices</literal>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>./zmqservices</literal>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The file pointed to by the environment variable
                        <literal>ZMQ_SERVICES</literal>.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                See the reference information for more about the transport
                types these factories can create.
            </para>
        </section>
    </section>
    <section>
        <title>Compiling and linking parallel programs</title>
        <para>
            This section assumes you've set up the NSCLDAQ environment variables
            before building your code.
        </para>
        <para>
            All headers are in <literal>$DAQINC</literal>, therefore,
            compilations must have <literal>-I$DAQINC</literal> (
            <literal>-I$(DAQINC)</literal> in Makefiles).
        </para>
        <para>
            The library is locaed in <literal>$DAQLIB</literal> It is called
            <filename>libSwTrigger.so</filename>.  It also depends on
            several other libraries in and out of NSCLDAQ:
        </para>
        <informalexample>
            <literallayout>
... -L$DAQLIB -lSwTrigger -ldataformat -ldaqthreads \
    -lDataFlow -lPortManager -ldaqshm -lException -lzmq -Wl,-rpath=$DAQLIB
            </literallayout>
        </informalexample>
        <para>
            In a Makefile you can use environment variable substitution:
        </para>
        <informalexample>
            <literallayout>
... -L$(DAQLIB) lSwTrigger -ldataformat -ldaqthreads \
    -lDataFlow -lPortManager -ldaqshm -lException -lzmq -Wl,-rpath=$(DAQLIB)
            </literallayout>
        </informalexample> 
    </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3daq -->
<refentry>
    <refmeta>
        <refentrytitle>CProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CProcessor</refname>
        <refpurpose>Abtract base class for a CSP process</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CProcessor.h&gt;

class CProcessor
{
public:
    virtual ~CProcessor() {}
    
    virtual void process(void* pData, size_t nBytes, CSender&amp; sender) = 0;
};
        </synopsis>

    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is a key abstract base class for the NSCLDAQ parallel
            processing framework.  The class provides interfaces for a process
            that participates in parallel sequential processing.  The idea
            is that a concrete processor class is encapsulated in a class
            that accepts data from some source.  
        </para>
        <para>
            When data is received the encapsulating class calls then
            <methodname>process</methodname> class handing it both the
            data and a <classname>CSender</classname> object that can
            be used to send data to the next stage of the processing pipeline.
            Concrete implementations must implement this
            <methodname>process</methodname> method.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void</type>
                        <methodname>process</methodname>
                        <methodparam>
                            <type>void*</type><parameter>pData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type><parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CSender&amp;</type><parameter>sender</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the method that concrete classes must implement.
                        When constructing a parallel pgoram, the user normally
                        creates a set of concrete processors that operate on
                        work items producing output data.  These processor
                        objects are then encapsulated in an object that has been
                        bound to a <classname>CReceiver</classname> that
                        accepts work items from the previous stage of the
                        processing pipeline and a
                        <classname>CSender</classname> that is connected
                        to the next stage of that pipeline.
                    </para>
                    <para>
                        The containing object, when run will accept work items
                        from its <classname>CReceiver</classname> and
                        call its processor's <methodname>process</methodname>
                        method.  That method is expected to do whatever
                        application specific processing is required to produce
                        output data and to send that output data to the next
                        stage of the processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>    
<refentry>
    <refmeta>
        <refentrytitle>CProcessingElement</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CProcessingElement</refname>
        <refpurpose>Abstract base class for a CSP processing element</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CProcessingElement&gt;

class CProcessingElement
{
public:
virtual ~CProcessingElement() {}

virtual void operator()()  = 0;
virtual void process(void* pData, size_t nBytes) = 0;
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Processing elements contain flow of control that typically
            accepts data, processes it and then sends resulting data to
            a subsequent stage of the data processing pipeline.
            Concrete <classname>CProcessingElements</classname> often
            construct with parameters that include a
            <classname>CReceiver</classname> to receive the data,
            a <classname>CSender</classname> to send processed data and a
            <classname>CProcessor</classname> to do the actual processing.
        </para>
        <para>
            In the prototoypical processing element, the
            <methodname>operator()</methodname> method will use the objects'
            <classname>CReceiver</classname> to obtain work elements.
            <methodname>process</methodname> would then be called which
            would, in turn, call the <methodname>process</methodname>
            method of an encapsulated <classname>CProcessor</classname>
            object.
        </para>
        <para>
            <methodname>operator()</methodname> would also be responsible
            for knowing when the last work item has been received and
            shutting down the object after that has been processed.
            In a typical, application, an empty data item might be a flag
            that there are no more data items and the processor's
            <methodname>process</methodname> would, in turn, be
            responsible for notifying subsequent stages of the computation,
            if appropriate.
        </para>
        <para>
            Concrete classes must implement both
            <methodname>operator()</methodname> and
            <methodname>process</methodname>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void</type>
                        <methodname>operator()</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is supposed to implement the
                        flow of control of the processing element.
                        Normally this is a loop with the logic like the
                        pseudocode below
                    </para>
                    <informalexample>
                        <programlisting>
do {
workItem = getWorkItem()
process(workItemData, workItemSize)
free the Work item
} while(workItem is not end of data)
Shutdown the object
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void</type>
                        <methodname>process</methodname>
                        <methodparam>
                            <type>void*</type><parameter>pData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type><parameter>nBytes</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Processes a work item of data received by
                        <methodname>operator()</methodname>.  Normally,
                        implementations of this method have the form:
                    </para>
                    <informalexample>
                        <programlisting>
outputData = processTheData(pData, nBytes)
sendToNextStage(outputData)
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CParallelWorker</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CParallelWorker</refname>
        <refpurpose>Base class for a worker that receives fanned out data.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CParallelWorker.h&gt;

class CParallelWorker : public CProcessingElement
{
public:
    CParallelWorker(CFanoutClientTransport&amp; fanin, CSender&amp; sink);
    CParallelWorker(
        CFanoutClientTransport&amp; fanin, CSender&amp; sink,
        uint64_t clientId
    );
    
    virtual void operator()();

protected:
    CSender* getSink();
   
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            In most parallel computations there are segments of the computation
            in which work items fan out to worker processes that operate
            on work items independently and in full parallel with all other
            workers.
        </para>
        <para>
            The NSCLDAQ parallel computing framework provides for transports
            that do that fanout and transports that are clients of those
            fanouts.   This class is a base class that encapsulates a
            receiver that is a fanout client, an arbitrary sender and a
            main control flow that accepts data and asks the unimplemented
            <methodname>process</methodname> method to process it.  Processing
            continues until an empty (zero sized) work item is received.
        </para>
        <para>
            The sender is exposed to subclasses so that it is available
            in <methodname>process</methodname> as implemented by
            concrete classes.  The sender receives the zero length
            work item and is expected to do any shutdown required of the sender.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CParallelWorker</methodname>
                        <methodparam>
                            <type>CFanoutClientTransport&amp; </type><parameter>fanin</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CSender&amp; </type><parameter>sink</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor provides only a fanout
                        client transport and
                        an arbitrary sender.  The user must configure the
                        <parameter>fanin</parameter> transport's clien id
                        prior to running the worker.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CParallelWorker</methodname>
                        <methodparam>
                            <type>CFanoutClientTransport&amp; </type><parameter>fanin</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CSender&amp; </type><parameter>sink</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint64_t </type><parameter>clientId</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor provides the client id of the fanout
                        client transport.  The constructor will configure the
                        <parameter>sink</parameter> transport with that client
                        id.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides the flow of control for the processor.
                        Messages are retrieved from the <parameter>fanin</parameter>
                        transport and  passed to the abstract
                        <methodname>process</methodname> method.
                    </para>
                    <para>
                        Dynamic storage associated with messages is freed by
                        the <methodname>operator()</methodname> and should,
                        not be freed by the concrete subclass
                        <methodname>process</methodname> method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>CSender* </type>
                        <methodname>getSink</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Intended for use by subclasses. This method fetches a
                        pointer to the sender.
                    </para>
                </listitem>
            </varlistentry>               
        </variablelist>
        <para>
            Note that this is still an abstract class as it does not implement
            the <methodname>process</methodname> method.  It does, however,
            provide a typical client flow of control in its
            <methodname>operator()</methodname> method.
            To use this class, you must derive from this and provide a
            <methodname>process</methodname> method.
        </para>

    </refsect1>

</refentry>    

<refentry>
    <refmeta>
        <refentrytitle>CTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTransport</refname>
        <refpurpose>Abstract base class for data transport objects.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;sys/uio.h&gt;
#include &lt;CTransport.h&gt;

class CTransport
{
public:
    virtual  void    recv(void** ppData, size_t&amp; size) = 0;
    virtual  void    send(iovec* parts, size_t numParts) = 0;
    virtual void end();
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Transports are objects that carry data across some high level
            protocol for data transport.  Examples of high level protocols
            are ZeroMQ (ZMQ), MPI, or event raw TCP/IP sockets.
            Transports are normally bound into a
            <classname>CSender</classname> or <classname>CReceiver</classname>
            object.
        </para>
        <para>
            Transport insulate the actual mechanisms of data transport from
            those objects.  Each concrete transport must, at a minimum
            implement the <methodname>recv</methodname> and
            <methodname>send</methodname> methods.  In addition,
            transports may implement the <methodname>end</methodname> method
            which is used to signal for a transport used inside a
            <classname>CSender</classname> that no more data will be transferred
            on that transport.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>void    </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type> size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Abstract interface to receive data from a concrete
                        transport.  <parameter>ppData</parameter> will be
                        written with a pointer to the data received.
                        The storage pointed to must have been dynamically
                        allocated via the <function>malloc()</function>(3)
                        library function.
                    </para>
                    <para>
                        <parameter>size</parameter> will be written with the
                        number of bytes of data received.  Note that all errors
                        should be signalled via exceptions.  While not mandatory,
                        in many transports, a size of 0 is used to indicate end
                        of data.  In that case, the pointer is not meaningful
                        and should not be freed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>void    </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec*</type><parameter> parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes a message to the peer of the transport.
                        See the manual pages for
                        <function>writev</function>(2) for a description of
                        the <type>iovec</type> struct.
                        <parameter>numParts</parameter> are the number of
                        <parameter>parts</parameter> in the message
                    </para>
                    <para>
                        This call mechanism allows messages to be built via
                        a gather mechanism that, in some transports, can
                        minimize the data copies needed to marshall the
                        complete message.
                    </para>
                    <para>
                        Concrete transports must gaurantee that they are
                        done using <parameter>parts</parameter> buffers on
                        return. Thus, if zero copy, asynchronous sends are
                        use by the transport, the <methodname>send</methodname>
                        must block until the send has actually completed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Transports that have a mechanism to signal an end of
                        data should implement this.  The default implementation
                        is to do nothing.  One standard used to indicate
                        an end of data condition is to send a zero length
                        message.  The underlying transport protocol must,
                        however support this if it is to be used.
                    </para>
                </listitem>
            </varlistentry>            
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CSender</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CSender</refname>
        <refpurpose>Encapsulate a transport to send data.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Sender&gt;

class CSender {

public:
    CSender(CTransport&amp; transport);
    
    void sendMessage(iovec* parts, size_t numParts); 
    void sendMessage(void* pBase, size_t nBytes);   
    void end();
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Working in conjunction with a
            <classname>CTransport</classname>, this class provides
            a mechanism to send data to the transports peer using
            some communication pattern. Note that as far
            as the application code is concerned, this is a
            unidirectional data path.  The underlying
            transport or communication pattern may bi-directional
            message exchanges to accomplish a data transfer,
            but that's hidden from the user code.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSender</methodname>
                        <methodparam>
                            <type>CTransport&amp; </type>
                            <parameter>transport</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides the <classname>CSender</classname>
                        with a transport that will be used to
                        send messages to the tranport's peer.
                    </para>
                    <para>
                        When designing mechanisms to implement
                        communication patterns (e.g. fanout),
                        it's recommended that all high level
                        protocol code be implemented in the
                        transport so that the simple code of this
                        class can be used everywhere..
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>sendMessage</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends a multipart message to the peer.
                        <parameter>parts</parameter> describes
                        <parameter>numParts</parameter> message
                        parts.  See
                        <function>writev</function>(2) for a
                        description of the
                        <type>iovec</type> struct.
                    </para>
                    <para>
                        This normally just calls the
                        transport's <methodname>send</methodname>
                        method which does whatever  is needed
                        to marshall the message parts into a
                        message.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>sendMessage</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pBase</parameter>
                        </methodparam>
                        <methodparam>
                            <type> size_t </type><parameter>nBytes</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience method to send a single part
                        message.  You can think of this as being
                        implemented:
                    </para>
                    <informalexample>
                        <programlisting>
...                            
iovec part;
part.iov_len = nBytes;
part.iov_base = pBase;
sendMessage(&part, 1);
...
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Signals the transport there is no more
                        data to transmit.  This is normally
                        done by invoking the transport's
                        <methodname>end</methodname> method.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CReceiver</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CReceiver</refname>
        <refpurpose>Encapsulates a transport to receive data</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CReceiver&gt;

class CReceiver
{
public:
    CReceiver(CTransport&amp; rTransport);
    
    void getMessage(void** ppData, size_t&amp; size);
    CTransport* setTransport(CTransport&amp; rTransport);
    
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class uses a transport to receive data from
            a <classname>CSender</classname>.  Any complex
            communication pattern normally is a collaboration
            implemented by the transports of the
            <classname>CSender</classname> and
            <classname>CReceiver</classname> objects.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CReceiver</methodname>
                        <methodparam>
                            <type>CTransport&amp; </type><parameter>rTransport</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the receiver by binding
                        a transport that will be used for message
                        passing. Note that the receiver object
                        will appear to the user code like
                        a unidirectional pipe of messages that
                        transfer data into the application code
                        that uses it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>getMessage</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData, </parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Gets the next message from the peer.
                        <parameter>ppData</parameter> points to
                        storage for a pointer.  The pointer will
                        be filled in with a pointer to the data
                        received.  The data is dynamically
                        allocated via
                        <function>malloc</function>(3) and must
                        be released via a call to the
                        <function>free</function>(3) function.
                    </para>
                    <para>
                        <parameter>size</parameter> is a reference
                        that will be filled in with the actual number
                        of bytes in the message received.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CTransport* </type>
                        <methodname>setTransport</methodname>
                        <methodparam>
                            <type>CTransport&amp;</type><parameter>rTransport</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Allows a receiver to dyamically set the
                        transport it uses (to
                        <parameter>rTransport</parameter>.
                        A pointer to the previous transport is
                        returned to the caller.
                    </para>
                    <para>
                        If you find yourself using this you should
                        probably reconsider the design of your
                        application's communication scheme.
                    </para>
                </listitem>
            </varlistentry>

    
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CNullTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CNullTransport</refname>
        <refpurpose>Null transport for testing</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CNullTransport.h&gt;

class CNullTransport :  public CTransport
{
    void recv(void** ppData, size_t& size);
    void send(iovec* parts, size_t numParts);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This is a Transport class built for testing.
            See <classname>CTransport</classname>(3daq) for
            information about transports.
            The null transport provides zero length messages
            for each call to <methodname>recv</methodname>.
            Calls to <methodname>send</methodname> don't do
            anything.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CTestTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTestTransport</refname>
        <refpurpose>Transport class for test purposes.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CTestTransport.h&gt;

class CTestTransport : public CTransport
{
public:
    typedef std::vector&lt;uint8_t&gt; message;
    typedef std::deque&lt;message&gt; messageList;
    
public:
    typedef std::vector&lt;message&gt; multipartMessage;
    std::vector&lt;multipartMessage&gt;  m_sentMessages;
    messageList m_messages;

public:
    
    virtual void recv(void** ppData, size_t& size);
    virtual  void    send(iovec* parts, size_t numParts);
    
    void addMessage(void* pData, size_t nBytes);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class provides a transport that can be used
            for unit testing.  Data that have been sent are retained
            for examination.  Data can be put into the object
            for later receipt via <methodname>recv</methodname>
            calls.   In this way a known load of inbound message
            can be injected into users of the transport and
            messages resulting from processing can be
            pulled out to ensure they are as expected.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            See <classname>CTransport</classname>(3daq) for
            a description of the <methodname>send</methodname>
            and <methodname>recv</methodname> methods.
        </para>
        <para>
            The added method for this class is:
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMessage</methodname>
                <methodparam>
                    <type>void*</type><parameter>pData</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter>nBytes</parameter>
                </methodparam>
                <modifier></modifier>
            </methodsynopsis>
        </para>
        <para>
            This method adds the described message to a queue
            of messages that will be retrieved by
            <methodname>recv</methodname> calls.
        </para>
    </refsect1>
    <refsect1>
        <title>TYPES and PUBLIC DATA</title>
        <para>
            The following data types are public:
        </para>
        <variablelist>
            <varlistentry>
                <term><type>message</type></term>
                <listitem>
                    <para>
                        This represents a message or a message
                        part in the case of a multipart message.
                        It's defined to be an
                        <classname>std::vector&lt;uint8_t&gt;</classname>.
                        The elements of the vector are the ordered bytes
                        of the message itself.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>multipartMessage</type></term>
                <listitem>
                    <para>
                        This type represents a sent message
                        which can have more than one part.
                        It's defined as a
                        <classname>std::vector&lt;message&gt;</classname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>messageList</type></term>
                <listitem>
                    <para>
                        This is a list of simple messages.
                        It's used to represent the messages
                        that will be received by
                        <methodname>recv</methodname> and gets
                        loaded by <methodname>addMessagse</methodname>.
                        It is of type
                        <classname>std::deque&lt;message&gt;</classname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>std::vector&lt;multiPartMessage&gt;</classname></term>
                <listitem>
                    <para>
                        This type is used to represent messages
                        that have been sent.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            For testing purposes you may need to see the set of
            messages remaining for consumption via
            <methodname>recv</methodname> and the messages
            that have been sent via <methodname>send</methodname>.
            
        </para>
        <para>
            <varname>m_sendMessages</varname> is of type
            <classname>std::vector&lt;multipartMessage&gt;</classname>
            are the messages sent by <methodname>send</methodname>
            calls.  Each element of the outer vector is a message.
            Each element of the inner vector is a message part
            (the contents of an element described by an
            <type>iovec</type> element).
        </para>
        <para>
            <varname>m_messages</varname> is of type
            <type>messageList</type> and represents the list
            of messages that have not yet been consumed by
            <methodname>recv</methodname>.
            <methodname>addMessage</methodname> adds new messages
            to the back of the <classname>deque</classname> while
            <methodname>recv</methodname> gets the message at the
            front of the <classname>deque</classname>.  If there
            are no remaining messages when
            <methodname>recv</methodname> is called, an empty message
            is returned.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CClientRegistry</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CClientRegistry</refname>
        <refpurpose>Registry of clients.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;stdexcept&gt;
#include &lt;CClientRegistry&gt;

class CClientRegistry {
public:
    void add(uint64_t newId);
    void remove(uint64_t existingId);
    bool hasClient(uint64_t id);
    bool empty();
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Some transports need to be able to identify clients.
            For example, a fanout transport  must, when there's no
            data remaining, send an end to all remaining
            clients.  The <classname>CClientRegistry</classname>
            allows each client to have a unique <type>uint64_t</type>
            identifier.  
        </para>
        <para>
            It provides the facility to add and remove clients,
            to test for the presence of clients and to
            test for an empty client registry.
        </para>
        <para>
            The class prevents client duplication and
            removal of nonexistent clients by throwing
            <classname>std::logic_error</classname>
            exceptions.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>add</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>newId</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>newId</parameter> to the set of
                        identifiers that are registered.  If
                        <parameter>newId</parameter> has already
                        been registered,
                        <classname>std::logic_error</classname> is
                        thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>remove</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>existingId</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the id
                        <parameter>existingId</parameter> from the
                        registry. If that id was not yet registered,
                        a <classname>std::logic_error</classname>
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>bool </type>
                        <methodname>hasClient</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>id</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>true</literal> if
                        <parameter>id</parameter> is in the registry
                        otherwise <literal>false</literal> is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>bool </type>
                        <methodname>empty</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Return <literal>true</literal> if the
                        registry has no entryies.  
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFanoutTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFanoutTransport</refname>
        <refpurpose>Transport to fanout data to several workers.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFanoutTransport.h&gt;

class  CFanoutTransport : public CTransport
{
public:
    virtual void end() = 0;
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Abstract base class for transports that fanout
            data to several parallel workers.  The only
            wrinkle this abstract base class adds is a pure virtual
            <methodname>end</methodname> method.
            This is because when there's no more data to send,
            all clients must be notified of that fact.  That
            notification is done in a transport dependent manner.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFanoutClientTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFanoutClientTransport</refname>
        <refpurpose>Client for a fanout transport</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFanoutClientTransport&gt;

class CFanoutClientTransport : public CTransport
{
public:
    virtual void setId(uint64_t id) = 0;
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This abstract base class is intended to be one of
            many targets for messages sent by
            a <classname>CFanoutTransport</classname> objects.
            It is a transport that provides the
            <methodname>setId</methodname> method which is
            supposed to establish the client id of the
            transport.  Client ids are assumed to be unique
            across all of the clients of a single fanout
            transport.  Note that data should not be received
            prior to setting the id.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemTransport</refname>
        <refpurpose>Base class for ring item transports.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingItemTransport.h&gt;
class CRingItemTransport : public CTransport
{
    
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Placeholder base class for transports that
            carry ring items
            around.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingBufferTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemTransport</refname>
        <refpurpose>Transport for ring items to or from ring buffers.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingBufferTransport.h&gt;

class CRingBufferTransport : public CRingItemTransport
{
    
public:
    CRingBufferTransport(CRingBuffer&amp; writer);        
    CRingBufferTransport(CRingBufferChunkAccess&amp; reader); 
    
    virtual void recv(void** ppData, size_t&amp; size);
    virtual void send(iovec* parts, size_t numParts);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Provides a transport for data to and from a ring buffer.
            Often these are at endpoints of a computation, but
            need not be.
        </para>
        <para>
            Note that there is a constructor for writing and a different
            one for reading. This represents the fundamental
            difference between producers and consumers of ring
            data.  Attempting to receive data from
            a ring transport that's been set up to as a producer
            or attempting to send data to a ring buffer
            that's been setup as a consumer results in a
            <classname>std::logic_error</classname> exception.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingBufferTransport</methodname>
                        <methodparam>
                            <type>CRingBuffer&amp; </type><parameter>writer</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Use this constructor for producers into
                        ring buffers.  Objects constructed with this
                        version of the constructor only support
                        <methodname>send</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingBufferTransport</methodname>
                        <methodparam>
                            <type>CRingBufferChunkAccess&amp; </type><parameter>reader</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This version of the constructor is used
                        for consumers.  Objects constructed
                        in this manner are only capable of
                        <methodname>recv</methodname> calls.
                    </para>
                    <para>
                        The <parameter>reader</parameter> parameter
                        is a reference to a
                        <classname>CRingBufferChunkAccess</classname>
                        class.  See the
                        <classname>CRingBufferChunkAccess</classname>(3daq)
                        class for more information about it, and
                        specifically, how to construct it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type> size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Receives the next ring item from the
                        ring buffer.  Receives from this transport
                        are always receiving a full ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Puts data into the ring buffer. Note that
                        each <type>iovec</type> element does a put into the
                        ring buffer.  Thus, if a ring item is
                        spread across several
                        <type>iovec</type> elements,
                        the put is not atomic.  In many cases,
                        because of the way data are gotten from
                        the ring buffer, this fact is not important.
                    </para>
                </listitem>
            </varlistentry>
    
            
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemFileTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItem FileTransport</refname>
        <refpurpose>Transport ring items to and from files.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingItemFileTransport.h&gt;

class CRingItemFileTransport : public CRingItemTransport
{
    
public:
    CRingItemFileTransport(CRingFileBlockReader&amp; reader); 
    CRingItemFileTransport(io::CBufferedOutput&amp; writer);  
    
    virtual void recv(void** ppData, size_t&amp; size);
    virtual void send(iovec* parts, size_t numParts);
    virtual void end();
};


        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is a transport that carries ring items
            to or from files.  Once created, the transpor is
            only unidirectional and using the wrong data trasnfer
            operation results in a
            <classname>std::runtime_error</classname> exception.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingItemFileTransport</methodname>
                        <methodparam>
                            <type>CRingFileBlockReader&amp; </type><parameter>reader</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates an object that
                        can use <methodname>recv</methodname>
                        to get ring items from a file.
                        See
                        <classname>CRingFileBlockReader</classname>(3daq)
                        for information on how to create that
                        object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingItemFileTransport</methodname>
                        <methodparam>
                            <type>io::CBufferedOutput&amp; </type><parameter>writer</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates an object to
                        put ring items into a file.  <parameter>writer</parameter>
                        is the object that does the I/O.  See
                        <classname>io::CBufferedOutput</classname>(3daq)
                        for information about how to construct
                        tis item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Fetches the next ring item from the file.
                        At end of file the ring item returned is
                        of zero length.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Outputs each part of the message to the
                        ringbuffer.  It's up to the caller to ensure
                        that data put in the ring consists of
                        properly formatted ring items...
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the file is open for write,
                        the buffered writer is flushed ensuring
                        all items have been sent to file.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemTransportFactory</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemTransportFactory</refname>
        <refpurpose>Create and appropriate ring item transport</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingItemTransport.h&gt;
#include &lt;CRingItemTransportFactory.h&gt;

class CRingItemTransportFactory
{
public:
    static CRingItemTransport* createTransport(
        const char* uri, CRingBuffer::ClientMode accessMode
    );
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Creates the ring item transport appropriate to the
            URI protocol type (<literal>tcp:</literal>
            or <literal>file:</literal>), and access mode
            (<classname>CRingBuffer</classname><literal>::producer</literal>
            or <classname>CRingBuffer</classname><literal>::consumer</literal>)
            
        </para>
        <para>
            The transport is created with
            <literal>new</literal> and therefore must be
            freed with <literal>delete</literal> when the
            application no longer needs it.
        </para>
    </refsect1>

</refentry>

<refentry>
    <refmeta>
        <refentrytitle>CZMQTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQTransport</refname>
        <refname>CZMQRawTransport</refname>
        <refpurpose>Base class for ZeroMQ transports</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQTransport.h&gt;

class CZMQTransport : public CTransport {
public:
    CZMQTransport();
    
    void recv(void** ppData, size_t&amp; size);
    void send(iovec* parts, size_t numParts);
    void end();
    
    static zmq::context_t*  getContext();
    operator zmq::socket_t*();
protected:
    void setSocket(zmq::socket_t* pSocket);  

};

 */
class CZMQRawTransport  : public CZMQTransport
{
public:
  CZMQRawTransport(zmq::socket_t* sock);
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            These two classes encapsulate ZeroMQ sockets.
            <classname>CZMQTransport</classname>  is intended
            to be used as a base class for more interesting
            transports using ZeroMQ.
            <classname>CZMQRawTransport</classname>, on the other
            hand, wraps a raw ZeroMQ
            <classname>zmq::socket_t</classname> in a transport.
        </para>
    </refsect1>
    <refsect1>
        <title>CZMQTransport METHODS</title>
        <para>
            This class is not useful in and of itself.
            The intent is that it be a base class and the
            resulting concrete class sets up the
            appropriate <classname>zmq::socket_t</classname>
            and wraps it using the
            <methodname>setSocket</methodname> method
            described below.
        </para>
        <variablelist>
            <varlistentry>
                <term><constructorsynopsis>
                    <methodname>CZMQTransport</methodname>
                    <void />
                </constructorsynopsis></term>
                <listitem>
                    <para>
                        This constructor does not supply
                        a socket on which to transport
                        data.  To create a useful class,
                        the programmer must derive a class from
                        this whose constructor sets up a socket and
                        wraps the base class around it by calling
                        <methodname>setSocket</methodname>
                        below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type> size_t&amp;</type><parameter> size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Receives data on the underlying socket.
                        If the message is a multipart message,
                        all the parts are concatenated into  a
                        single block and that block is returned.
                        If you wish to retain message part boundaries
                        you need to define a higher level data format
                        that an do that.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends a message on the underlying socket.
                        Note that each element of the
                        <parameter>parts</parameter> array is
                        sent as a separate message part
                        (<classname>zmq::message_t</classname> object).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends a message consisting of a
                        single message part with a length of zero.
                        That's a flag that the receiver should
                        not expect any more data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>zmq::context_t*  </type>
                        <methodname>getContext</methodname>
                        <void  />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a factory message to get a singleton
                        ZMQ context object.  A pointer to the
                        application unique context is returned.
                        This context is created on the first call
                        to this method and must not be deleted
                        by the application.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>zmq::socket_t*</type>
                        <methodname>operator zmq::socket_t*();</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                
                <listitem>
                    <para>
                        Conversion operator that allows the
                        object to be treated as it's underlying
                        socket_t for special applications.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>setSocket</methodname>
                        <methodparam>
                            <type>zmq::socket_t* </type><parameter>pSocket</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Intended to be called by  derived classes.
                        This method sets the socket on which
                        communication will take place.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
    </refsect1>
    <refsect1>
        <title>CZMQRawTransport METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CZMQRawTransport</methodname>
                        <methodparam>
                            <type>zmq::socket_t* </type><parameter>sock</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a raw ZMQ socket creates a
                        ZMQ transport around that socket.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQClientTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQClientTransport</refname>
        <refpurpose>ZeroMQ transport that does a connect.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQClientTransport&gt;

class CZMQClientTransport : public CZMQTransport
{
public:
    CZMQClientTransport(const char* pUri, int socketType);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            represents a ZeroMQ transport that performs a
            <methodname>connect</methodname> operation to
            obtain a peer socket.
            <parameter>pUri</parameter> is a ZeroMQ compatible
            URI that specifies the endpoint and
            <parameter>socketType</parameter> is the
            ZeroMQ socket type (e.g. <literal>ZMQ_PULL</literal>).
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQServerTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQServerTransport</refname>
        <refpurpose>ZeroMQ transport that does a listen.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQServerTransport.h&gt;

class CZMQServerTransport : public CZMQTransport
{
public:
    CZMQServerTransport(const char* pUri, int socketType);
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This clss is a ZeroMQ transport for a socket
            that listens for connections rather than invoking
            <methodname>connect</methodname>.
            <parameter>pUri</parameter> is a URi that specifies the
            socket endpoint and <classname>socketType</classname>
            is the ZeroMQ socket type e.g. <literal>ZMQ_PUB</literal>.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQRouterTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQRouterTransport</refname>
        <refpurpose>ZeroMQ transport that's a ROUTER fanout.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQRouterTransport.h&gt;

class CZMQRouterTransport : public CFanoutTransport
{
public:
    CZMQRouterTransport(const char* pUri);
    
    virtual void recv(void** ppData, size_t&amp; size); 
    virtual void send(iovec* parts, size_t numParts);
    virtual void end();

};
 
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class implements a fanout transport using
            the ZeroMQ ROUTER/DEALER communication pattern
            (see <classname>CZMQDealerTransport</classname>)(3daq).
            ZMQ routera use a pull protocol in which each
            worker sends a request for data which is honored
            by the DEALER.
        </para>
        <para>
            The protocol of getting pull requests and then
            providing them is totally transparent to the users
            of this class.  Each call to send sends the data
            as a work item to some worker process
            running the DEALER protocol.
        </para>
        <para>
            Since pull requests require the DEALER to have set up
            an id, the pull requests build up a picture of the
            client ids.  This picture is used by
            <methodname>end</methodname> to ensure that all
            clients see an end condition.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CZMQRouterTransport</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>char* </type><parameter>pUri</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates the
                        <literal>ROUTER</literal> socket and
                        does a bind to ensure that DEALERS
                        can connect.
                        <parameter>pUri</parameter> is the ZeroMQ
                        URI that specifies the socket end point.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void**</type><parameter> ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp;</type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The ROUTER socket only supports sending data.
                        A call to this method results in a
                        <classname>std::logic_error</classname>
                        exception
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends the message indicated to the next
                        worker that requests data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Indicates to all connected clients no
                        more data will be available.  End of data
                        is indicated by a message that contains a
                        single message point with  a zero length.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>

</refentry>
<!-- /manpage -->