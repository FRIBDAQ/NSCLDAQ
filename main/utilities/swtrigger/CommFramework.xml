<!-- chapter libraries -->

<chapter>
    <title>Parallel programming framework</title>
    <para>
        There are many types of parallel programming.  One classic model
        for parallel programming is that of
        <firstterm>Communicating Sequential Processes</firstterm> (CSP).
        CSP models a parallel program as a set of sequential, or serial programs
        that talk to each other.  
    </para>
    <para>
        Within CSP two main models exist;
        <itemizedlist>
            <listitem>
                <para>
                    Threaded - when parallelism is confined to a single
                    shared memory multi-core system, where all communication
                    is internal to that system.
                </para>
            </listitem>
            <listitem>
                <para>
                    Distributed - when the application is spread out over some
                    networked set of nodes.  Normally these nodes are
                    interconnected via a high performance low latency
                    <firstterm>network fabric</firstterm>.
                </para>
                <para>
                    Linux, Beowulf clusters are a pretty popular platform
                    on which to build distributed parallel programs.
                </para>
            </listitem>
        </itemizedlist>
    </para>
    <para>
        NSCLDAQ provides a high level library that insulates your program
        from the detailed mechanisms of specific message passing libraries.
        Programs written that only communicate via message passing can be
        easily rehosted from a threaded implementation to a distributed
        implementation, changing only initialization code.
    </para>
    <para>
        In this chapter we'll describe:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                The concepts and classes behind the library.
            </para>
        </listitem>
        <listitem>
            <para>
                The implementation state of the library including the set of
                communication systems that are implemented by the library at this
                time and a roadmap describing planned future developments.
                Pointers will be given to man page starting points for each
                implemented communication scheme.
            </para>
        </listitem>
        <listitem>
            <para>
                How to compile and link programs using this library.
            </para>
        </listitem>
        <listitem>
            <para>
                Describe a program that uses the library,
                <application>Transformer</application> that allows you
                to append arbitrary data to fragments of data from an event
                builder.
            </para>
        </listitem>
        <listitem>
            <para>
                Describe two other programs that provide powerful
                abilities to edit event data.
            </para>
        </listitem>
    </itemizedlist>
    <section>
        <title>Concepts and classes</title>
        <para>
            Parallel programs build on top of this library consists of
            objects that communicate via messagse passing.  To limit the
            amount of data copying required, messages can, not only be
            a single block of data but can be a block list that's gathered
            by the library into a single message.
        </para>
        <para>
            The assumption is that a program consists of some source of data
            and that processing these data involve parcelling out work units
            to parallel processing objects. which then fan their
            results back in to processing objects that gather the  data.
        </para>
        <para>
            Thus the programming model has you stringing together a
            pipeline (each element of the pipeline runs in parallel) where
            stages of those pipelines may include stages that run multiple
            processors that operate in parallel on data streaming through the
            pipeline.
        </para>
        <para>
            The following classes, therefore, model several types of
            processing elements that can appear in these data/processing flows:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>CDataSourceElement</classname></term>
                <listitem>
                    <para>
                        These elements are intended to connect the
                        program to concrete sources of data.  In NSCLDAQ
                        these sources can be ring items, files or some
                        other communicating processor (internal or external).
                    </para>
                    <para>
                        These elements are normally at the start of the
                        processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CDataSinkElement</classname></term>
                <listitem>
                    <para>
                        These elements are intended to connect the program
                        to some concrete sink of data.  In NSCLDAQ, sinks can
                        be ring buffers, files or other communicating processors.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CParallelWorker</classname></term>
                <listitem>
                    <para>
                        A generic parallel worker.  This is normally used
                        to encapsulate code that runs in the data parallel
                        segments of the computation.  Normally this
                        encapsulation 
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            From these classes you can see that the computation normally takes
            the form of a pipeline where data comes from a
            <classname>CDataSourceElement</classname> runs through
            several <classname>CParallelWorker</classname> elements
            and then in the end data is emitted from the program via
            a <classname>CDataSinkElement</classname>
        </para>
        <para>
            Having these classes is all well and good, but how do they communicate
            with each other?  Following the pipeline model, each element
            of the computation gets its data from
            a <classname>CReceiver</classname> and sends the results of its
            computation to the next stage of the pipeline
            via a <classname>CSender</classname>.
        </para>
        <para>
            <classname>CReceiver</classname> and
            <classname>CSender</classname> objects encapsulate another
            class derived from
            <classname>CTransport</classname>.  Transport classes are
            actual do the messaging required by the receiver and sender objects.
            In doing so, the contain code specific to the type communication
            library being used (e.g. MPI or ZeroMQ), and they also encapsulate
            a specific communication pattern.
        </para>
        <para>
            Some base classes for transports are:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>CTransport</classname></term>
                <listitem>
                    <para>
                        The abstract base class for all transports.  This class
                        provides the interfaces used by sender and receiver
                        objects to request actual communication.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CFanoutTransport</classname></term>
                <listitem>
                    <para>
                        Abstract base class for transports that fan-out work items
                        to data parallel sections of the program.  In addition
                        to the data transfer interfaces, this class
                        provides interfaces to inform the members of the
                        fanout that there is no more data available.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CFanoutClientTransport</classname></term>
                <listitem>
                    <para>
                        Abstract base class for transports that
                        get data from a fanout transport.  The model provided
                        requires that each client provide a unique integer
                        client identifier.  This class encapsulates interfaces
                        for both setting the id and communicating the id to the
                        other end of the transport.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Thuse the computation can be made up of processing elements that
            get and send data without actually knowing how that's done.  Program
            initialization can select actual transports and bind them into
            processing elements.  If necessary, program initialization can also
            allocate processors to computing resources.
            This allows a computation to be rehosted without the actual
            computing elements being aware of the process.
        </para>
    </section>
    <section>
        <title>Transport implementations</title>
        <para>
            At present both ZeroMQ messaging with threaded parallelism
            and OpenMPI distributed are fully supported.  If you have
            other messaging frameworks and paradigms you'd like to have
            supported let us know.
        </para>
        <section>
            <title>Details of ZMQ transport implementation</title>
            <para>
                The goal here is not to get into the nitty gritty of ZMQ
                socket types used in the various transports, but to describe
                facilities available to assist you in setting up ZMQ based
                parallel programs. 
            </para>
            <para>
                One facility the library provides is a factory that provides
                you with transport factories for the specific communication
                system you are using.   The factory knows how to create
                transports for communication patterns implemented on top of
                a specific transport library.
            </para>
            <para>
                The <classname>CCommunicatorFactoryMaker</classname>
                singleton class represents this factory of factories.  The
                code fragment below shows how to get a communication
                factory for ZMQ communications:
            </para>
            <informalexample>
                <programlisting>
#include &lt;CCommunicatorFactoryMaker.h&gt;
#include &lt;CCommunicatorFactory.h&gt;
..
..
CCommunicatorFactory* pZmqFactory = CCommunicatorFactoryMaker::getInstance()-&gt;
    create("ZeroMQ CommunicationSystem");
if (!pZmqFactory) {
    std::cerr &lt;&lt; "ZEROMQ factory not in the factory of factories\n";
    exit(-1);
}
....

                </programlisting>
            </informalexample>
            <para>
                One problem that needed solving to provide a generic
                communicator factory was how to identify communication endpoints.
                For example a raw TCP/IP socket uses a host/port pair to
                identify an end point, ZMQ uses an URI to identify end endpoint
                and so on.
            </para>
            <para>
                Communicator factories use unsigned integers to identify
                endpoints.  While this maps directly to e.g. MPI ranks,
                there must be a mechanism for the ZMQ factory to map these
                identifiers onto URIs.
            </para>
            <para>
                This is done by you, providing one or more zmq service map files.
                A zmq service map file is a text file.  Lines beginning with
                <literal>#</literal> are ignored as are lines that consist
                only of whitespace.  Leading and trailing whitespace are also
                ignored.
            </para>
            <para>
                Mapping lines, consist of two fields. The first is an integer
                transport id and the second is the ZMQ URI that will be used
                when that transport endpoint is selected. For example;
            </para>
            <informalexample>
                <literallayout>
    1 tcp://somenode.in.my.network:1234
                </literallayout>
            </informalexample>
            <para>
                Maps the transport identifier <literal>1</literal> to  a TCP
                transport with an endpoing of port number <literal>1234</literal>
                whose server is in a
                system named <literal>somenode.in.my.network</literal>.
            </para>
            <para>
                We therefore need to know, additionally, which transports are
                servers and which are clients.
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Fanout transports are servers and their clients are not.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Fan in sinks are servers fanin sources are not.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        One-to-One sources are servers, clients are not.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                The transport id/URI map is built up by reading all files found in
                
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>$HOME/.zmqservices</literal>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>./zmqservices</literal>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The file pointed to by the environment variable
                        <literal>ZMQ_SERVICES</literal>.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                See the reference information for more about the transport
                types these factories can create.
            </para>
        </section>
        <section>
            <title>MPI implementation of the framework</title>
            <para>
                Using the common base classes, derived classes that do
                MPI messaging have been built to provide the same
                communications pattern.  In this case, the endpoint IDs
                are simply MPI ranks.
            </para>
            <para>
                While we compile against OpenMPI, any MPI implementation
                should work.   Note that usually MPI programs must be run
                using a helper program.  For exmaple in OpenMPI you must
                use <command>mpirun</command> to start an mpi application.
            </para>
            <para>
                It is possible to write programs that can, at run-time
                select the appropriate communication framework.
                Several NSCLDAQ utilities have been written in this way and
                you can study their initialization source code to get an
                idea of how to accomplish that.
            </para>
        </section>
    </section>
    <section>
        <title>Compiling and linking parallel programs</title>
        <para>
            This section assumes you've set up the NSCLDAQ environment variables
            before building your code.
        </para>
        <para>
            All headers are in <literal>$DAQINC</literal>, therefore,
            compilations must have <literal>-I$DAQINC</literal> (
            <literal>-I$(DAQINC)</literal> in Makefiles).
        </para>
        <para>
            The library is locaed in <literal>$DAQLIB</literal> It is called
            <filename>libSwTrigger.so</filename>.  It also depends on
            several other libraries in and out of NSCLDAQ:
        </para>
        <informalexample>
            <literallayout>
... -L$DAQLIB -lSwTrigger -ldataformat -ldaqthreads \
    -lDataFlow -lPortManager -ldaqshm -lException -lzmq -Wl,-rpath=$DAQLIB
            </literallayout>
        </informalexample>
        <para>
            In a Makefile you can use environment variable substitution:
        </para>
        <informalexample>
            <literallayout>
... -L$(DAQLIB) lSwTrigger -ldataformat -ldaqthreads \
    -lDataFlow -lPortManager -ldaqshm -lException -lzmq -Wl,-rpath=$(DAQLIB)
            </literallayout>
        </informalexample> 
    </section>
</chapter>
<chapter>
    <title>Transformer</title>
    <para>
        Sometimes it's useful to perform some cmoputations on an NSCLDAQ event
        file and append data to parts of the event.  <application>Transformer</application>
        provides the ability to add an arbitrary extension to fragments of event
        built data. It is a parallel program that runs on top of the
        communication framework we've been describing.
    </para>
    <para>
        The program consists of an input stage, a set of parallel workers that
        can add extension to event fragments, a sorter that resorts the ouptut
        of the workers back into time stamp ordered events.  The pipeline of input
        workers sorting and output are parallel processes as is each worker.
    </para>
    <para>
        Transformer allows you to write the code needed to compute the extension
        for any single event fragment.  This code does not have to be
        MPI or thread-aware though it must be thread-safe.  This code is built
        into a shared library which is loaded by <application>Transformer</application>
        at run time.
    </para>
    <para>
        The remainder of this chapter
    </para>
    <orderedlist>
        <listitem>
            <para>
                Describes what your shared library must provide.
            </para>
        </listitem>
        <listitem>
            <para>
                Describes how to build your shared library.
            </para>
        </listitem>

    </orderedlist>
    <note>
        <title>NOTE:</title>
        <para>
            The Transformer man page in 1daq desribes how to run the
            program.
            <classname>CBuiltRingItemExtender</classname>'s manpage
            describes the interfes needed by Transfomer.
        </para>
    </note>
    <section>
        <title>User shared libraries for Transformer</title>
        <para>
            The Transformer uses a set of parallel workers to compute the
            actual extension.  The workers receive blocks of events an
            parcel them off to instances of a <classname>CBuiltRingItemExtender</classname>.
            Each of those instances walks the event fragments in the event
            providing the fragment's ring item to user code embedded in
            a concrete subclass of
            <classname>CBuiltRingItemExtender::CRingItemExtender</classname>.
            The user code must implement the following methods:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>iovec</type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>pRingItem</type><parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Takes the ring item of an event fragment as input and
                        computes the extension for that event fragment. The
                        return value is an <structname>iovec</structname>
                        See the <literal>writev(2)</literal> man page
                        for a description of that struct.
                    </para>
                    <para>
                        If the length of the extension returned is zero,
                        no extension will be added.
                    </para>
                    <para>
                        Refer to <literal>DataFormat.h(3daq)</literal>
                        for information about the <type>pRingItem</type>
                        data type.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void</type>
                        <methodname>free</methodname>
                        <methodparam>
                            <type>iovec&</type><parameter>extension</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Since all extension data must remain valid until the
                        entire event has been formatted, you may find that you
                        need to use dynamic memory to hold your extensions.
                        After an event has been formatted and sent to the
                        sorter, this method is called once for each fragment
                        passing in the iovec as <parameter>extension</parameter>
                        that was returned by <methodname>operator()</methodname>.
                        This method is expected to free any dynamic data  that
                        was created to hold that extension data.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            In addition to a concrete extension class, your shared library
            must provide a factory method the Transforme uses to create
            instances of your class.  Each worker gets its own class instance.
        </para>
    </section>
    <section>
        <title>Building the use shared library</title>
        <para>
            This section walks through coding and building the
            <filename>libTestExtender.so</filename> that's included with
            NSCLDAQ as a demonstration.  This code works with Transformer
            to provide a 16 bit checksum bracketed by flag words for each
            fragment in the event.  You can see the sample user code in its
	    entirety at sf.net/projects/nscldaq in the project's source tree
	    in the file
	    <filename>main/utilities/swtrigger/CTestExtender.cpp</filename>.
	    
        </para>
	<para>
	  Let's start with the class definition:
	</para>
	<example>
	  <title>CTestExtender class definition</title>
	  <programlisting>
class CTestExtender : public CBuiltRingItemExtender::CRingItemExtender
{
private:
   struct Extension {
      uint16_t  s_header;
      uint16_t  s_checksum;     <co id='textend.extensiondef' />
      uint16_t s_trailer;
      
      Extension() {
         s_header = 0xa5a5;
        s_checksum = 0;       <co id='textend.init' />
        s_trailer = 0x5a5a;
      }   
   };

public:
   iovec operator()(pRingItem item);  <co id='textend.functor' />
   void free(iovec&amp; e);           <co id='textend.free' />
};
	  </programlisting>
	</example>
    <calloutlist>
        <callout arearefs='textend.extensiondef'>
            <para>
                This struct represents the data we'll be tacking on the end of
                each fragment of the event.  It's once more important to note
                that:
                <itemizedlist>
                    <listitem>
                        <para>
                            The program only works on event built data.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Our caller will iterate over the fragments in each
                            event and call us once for <emphasis>each</emphasis>
                            fragment in the event.  Of course there's nothing
                            to prevent us from not extending all the fragments.
                            We'll get into how to do that later in the section.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </callout>
        <callout arearefs='textend.init'>
            <para>
                In C++ structs like classes can have constructors.  This
                constructor just initializes the header and trailer items
                to alternating bit set/clear patterns and the checkusm to zero.
                
            </para>
            <para>
                Doing that here avoids cluttering the actual code that uses
                this extension with initialization code.  It also means
                that in the event we use this struct in more than one location
                we won't be repeating initialization code.
            </para>
        </callout>
        <callout arearefs='textend.functor'>
            <para>
                The function call operator must be implemented by all concrete
                subclasses of <classname>CBuiltRingItemExtender::CRingItemExtender</classname>.
                this method is what will be called to provide an extension.
            </para>
            <para>
                The function call operator must return an <structname>iovec</structname>
                struct.  This structure is defined in the
                <literal>writev(2)</literal> manpage.  Fill in the
                <structfield>iov_len</structfield> field to be the size of
                the extension and the <structfield>iov_base</structfield> pointer
                to point to your extension.  If you are not providing an extension
                for a fragment, set  <structfield>iov_len</structfield> to
                <literal>0</literal>.
            </para>
        </callout>
        <callout arearefs='textend.free'>
            <para>
                The program will collect all extensions and weave them into the
                output event once the event has been fully processed.  Therefore,
                the data passed back must have a lifetime that runs over the
                processing of the entire event, rather than just a single
                fragment.  This means specifically, you
                <emphasis>cannot</emphasis> have a single instance of the
                extension struct which you fill in over and over again for
                each fragment.
            </para>
            <para>
                More usually, you'll dynamically allocate the extensions
                (e.g. with <literal>new</literal>).   Once the event is
                processed, the framework iterates over all extensions it was
                given for that event, calling <methodname>free</methodname>
                passing a reference to an iov that is a copy of the one
                returned from a call to <methodname>operator()</methodname>
                for that fragment.  You should not make any assumptions about
                the order in which the <structname>iovec</structname>
                structs are passed to <methodname>free</methodname>.
            </para>
            <para>
                The expectation is that you will release any dynamic storage
                allocated for the extension provided to you.
            </para>
        </callout>
	</calloutlist>
    <para>
        The implementation section of the code consists of two segments.
        The first segment implements the class methods of
        <classname>CTestExtender</classname>.  Having the class defined
        and implemented is not sufficient, however.  You must also provide
        a mechanism for the framework to create instances of that class.
        To do this you must provide a
        <firstterm>factory function</firstterm> the framework can locate
        after it has loaded your shared library into the program.
    </para>
    <para>
        Let's look at the implementation of the <classname>CTestExtender</classname>
        first:
    </para>
    <example>
        <title><classname>CTestExtender</classname> implementation</title>
        <programlisting>
iovec
CTestExtender::operator()(pRingItem item)   <co id='text.functor.impl' />
{
    iovec result;
    result.iov_len = sizeof(Extension);
    Extension* p   = new Extension;        <co id='text.functor.init' />
    result.iov_base= p;


    uint16_t* pItem = reinterpret_cast&lt;uint16_t*&gt;(item);
    for (int i =0; i < item->s_header.s_size/sizeof(uint16_t); i++) { <co id='text.functor.cksum' />
        p-&gt;s_checksum+= *pItem++;
    }

    return result;                                            <co id='text.functor.return' />
}


void
CTestExtender::free(iovec&amp; extension)                 <co id='text.free.impl' />
{
    Extension* pExt = static_cast&lt;Extension*&gt;(extension.iov_base); <co id='text.free.cast'/>
    delete pExt;                                         <co id='text.free.delete' />
}


            
        </programlisting>
    </example>
    <calloutlist>
        <title>The <methodname>operator()</methodname> method implementation.</title>
        <callout arearefs='text.functor.impl'>
            <para>
                This begins the implementation of the <methodname>operator()</methodname>
                method.  Recall that this method recevies a pointer to a
                 ring item that is an event fragment and is expected to
                 return a description of the extension it creates for that fragment.
            </para>
            <para>
                The extension is described by an <structname>iovec</structname>
                structure.  This struct has two fields:
                <variablelist>
                    <varlistentry>
                        <term><structfield>iov_base</structfield></term>
                        <listitem>
                            <para>
                                Should be filled in with a pointer to the
                                extension.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><structfield>iov_len</structfield></term>
                        <listitem>
                            <para>
                                Should be filled in with the size of the
                                extension.  If you don't want to add
                                an extension to this fragment, set
                                <structfield>iov_len</structfield> to zero.
                                In that case, <structfield>iov_base</structfield>
                                is ignored.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </callout>
        <callout arearefs='text.functor.impl'>
            <para>
                This chunk of code defines and initializes the
                function return value <varname>result</varname> to point
                to a newly created extension (recall the constructor we wrote
                will initialize that storage), and sets the lengt to be the
                size of that extension.
            </para>
        </callout>
        <callout arearefs='text.functor.cksum'>
            <para>
                This code computes the checksum into the extension. Recall that
                our constructor initialized that checksum to zero so we can
                directly sum the checksum into that cell.  Note the checksum
                does not include the extension.
            </para>
        </callout>
        <callout arearefs='text.functor.return'>
            <para>
                The <structname>iovec</structname> <varname>result</varname>
                is returned.  Note that since the extension itself was dynamically
                created we've satisfied the lifetime requirement of the extension.
                It will remain in scope until explicitly deleted (see
                <methodname>free</methodname> below).
            </para>
        </callout>
    </calloutlist>
    <calloutlist>
        <title>The <methodname>free</methodname> method implementation.</title>
        <callout arearefs='text.free.impl'>
            <para>
                This is the implementation of the <methodname>free</methodname>
                method.  Recall that this method is obligated to destroy any
                dynamic storage allocated for a single extension.  The
                extension to destroy is described by the parameter
                <parameter>extension</parameter> wich is a reference to an
                <structname>iovec</structname>.
            </para>
            <para>
                The <structfield>iov_base</structfield> pointer points to an
                extension returned by <methodname>operator()</methodname>.
                The <structfield>iov_len</structfield> holds the length of the
                extension.
            </para>
        </callout>
        <callout arearefs='text.free.cast'>
            <para>
                This casts the pointer in <structfield>iov_base</structfield>
                to point to one of our <structname>Extension</structname>
                structs.  If different fragments can get different
                extensions there are several strategies you can use to
                allocate free:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        You can always use
                        <function>malloc/free</function> to allocate
                        storage.  In that case, however, you'll have to manually
                        initialize the storage as calling a constructor is
                        value that's added by <literal>new/delete</literal>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        You can use <structfield>iov_len</structfield> to
                        differentiate between the types of extension and do a
                        cast as we've done, depending on the length of the
                        object you need to delete.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        You can make put all the extension definitions in a
                        class/struct hierarchy with an abstract base and
                        virtual destructors.   If you then cast the
                        <structfield>iov_base</structfield> to point at a
                        base class/struct item, <literal>delete</literal>
                        will use the virtual destructor and class hierarchy
                        information to do the right thing.
                    </para>
                </listitem>
            </itemizedlist>
        </callout>
    </calloutlist>
    <para>
        Let's look at the factory function.  It's actually dirt simple but there
        is one subtlety we need to demonstrate.
    </para>
    <example>
        <title>The factory function</title>
        <programlisting>
extern "C" {                       <co id='text.factory.externc' />
    CTestExtender* createExtender() { <co id='text.factory.name'/>
        return new CTestExtender;     <co id='text.factory.creation'/>
    }

}
        </programlisting>
    </example>
    <calloutlist>
        <callout arearefs='text.factory.externc'>
            <para>
                An important point is that this function is one that the
                framework must be able to locate in the shared object. We
                ensure that in two ways:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Using a specific name (<function>createExtender</function>).
                        In other extension architectures (e.g. Tcl), the external
                        entry point is derived from the name of the shared object.
                        In our case, we only have one shared object to load,
                        so a fixed, required name is good enough.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Using C external bindings.  In C++, function/method
                        overloading is handled by <firstterm>mangling</firstterm>
                        the actual function name.  Name mangling decorates
                        the base function name with other information.                        
                    </para>
                    <para>
                        For
                        example with g++, <methodname>CTestExtender::free</methodname>,
                        becomes
                        <literal> _ZN13CTestExtender4freeER5iovec</literal>.
                        If you squint at this long enough you can see that
                        the decorations include the class in which this
                        function is defined and the type of parameter passed to it.
                    </para>
                    <para>
                        This name mangling is compiler dependent and can even by
                        compiler version dependent.  There's no standard for it.
                        Therefore the safest thing to do is to turn it off.
                        The <literal>extern "C" </literal> declaration indicates
                        to the compiler it should use C external bindings for
                        names in the block it covers.  Thus our factory
                        function is not mangled.
                    </para>
                </listitem>
            </itemizedlist>
        </callout>
        <callout arearefs='text.factory.name'>
            <para>
                As describe previously,  the name of our factory
                function <emphasis>must</emphasis> be
                <function>createExtender</function>.  The framework
                will call it when it needs an instance of our extender class.
                In practice this is once per worker. 
            </para>
            <para>
                In fact when the parallelization strategy is
                <literal>mpi</literal> only worker processes will
                need extension objects and only one per process is needed.
                However if the parallelization strategy is
                <literal>threaded</literal> each worker thread will need
                its own extension object.
            </para>
        </callout>
        <callout arearefs='text.factory.creation'>
            <para>
                The actual implementation is simple. <literal>new</literal>
                is used to create a new instance of the object and a pointer to
                that object is returned to the caller.  Note that in general,
                the lifetime of the object will be the lifetime of the application.
                It will not be destroyed.
            </para>
            <para>
                In the rare cases your extenders do need to be cleanly destroyed,
                there is a mechanism to do that.  You can have a class
                that contains a vector or list of objects created and whose
                destructor deletes the created objects.  An instance of that
                class can be created statically.  The factory function
                then registers each object it creates prior to returning it.
                At program termination time, the static object's destructor is
                called by the C++ run time and it can run through the registry
                of objects deleteing each of them.
                In most (all?) cases this is <emphasis>not necessary</emphasis>.
            </para>
        </callout>
    </calloutlist>
    <para>
        Ok, we have code for our extender.  How do we build it into a shared
        library.    There's no single recipe as the actual compilation and
        link commands will depend on the needs of the library.  There are only
        two requirements:
    </para>
    <orderedlist>
        <listitem>
            <para>
                At compile time, the compiler must generate position independent
                code.  This is because the actual address at which the library
                will be loaded is determined at run time.  To do this use the
                <option>-fPIC</option> option on on the compilation command line.
            </para>
        </listitem>
        <listitem>
            <para>
                At link time, the linker must be told to create a shared object.
                This requires that you supply the <option>-shared</option> on the
                linker command line. You must also use the
                <option>-o</option> flag to specify the name of the shared object.
                If you do not do so, the linker will produce a file named
                <literal>a.out</literal> by default.
            </para>
        </listitem>
    </orderedlist>
    <para>
        Note that the compiler and linker are both generally <command>g++</command>
        or, if MPI has been enabled mpicc for OpenMPI and you'll need
        to have set environment variables needed for OpenMPI appropriately.
    </para>
    </section>
</chapter>

<chapter>
    <title>SoftwareTrigger</title>
    <para>
        This program actually provides a generic ability to add an
        extension <type>uint32_t</type> to the body header of each
        event.  The program is described completely in the
        <literal>1daq</literal> reference section.
    </para>
</chapter>
<chapter>
    <title>EventEditor</title>
    <para>
        The EventEditor provides a very general mechanism for modifying the bodies
        of event fragments for event built data. See the reference entry in
        <literal>1daq</literal>
    </para>
</chapter>
<!-- /chapter -->

<!-- manpage 1daq -->

<refentry>
    <refmeta>
        <refentrytitle>SoftwareTrigger</refentrytitle>
        <manvolnum>1daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>SoftwareTrigger</refname>
        <refpurpose>Classify events for later filtering in the software trigger.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
$DAQBIN/SoftwareTrigger <optional>OPTIONS</optional>...
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This program is classifies events for later filtering.
            It operates by sending blocks of data to a set of parallel
            workers.  The workers add an extra
            <type>uint32_t</type> to the event body headers.
            The events are then resorted by timestamp and output to some
            event sink.  
        </para>
        <para>
            The classification is done by loading a shared library provided
            by the user.  the shared library provides a classification class
            and a factory function that creates the instances of that
            class needed by the application.
        </para>
    </refsect1>
    <refsect1>
        <title>OPTIONS</title>
        <para>
            Most options are mandatory.  Optional options are indicated.
        </para>
        <variablelist>
            <varlistentry>
                <term><option>--help</option> (optional)</term>
                <listitem>
                    <para>
                        Prints brief program help text to stdout.  After printing
                        the help text, the program exits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--help</option> (optional)</term>
                <listitem>
                    <para>
                        Prints out the program's version to stdout. Once the
                        version is output, the program exits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--source</option>=URI</term>
                <listitem>
                    <para>
                        A file or tcp URI that specifies where data will come from.
                        Data are analyzed and sent to the sink as long as there
                         is no end indication from the source.  Note that this
                         means that for ring buffers, the program will run
                         indefinitely.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--sink</option>=URI</term>
                <listitem>
                    <para>
                        A file or tcp URI that specifies where the output
                        data will be written. Note that if this is a
                        tcp URI, the host must be local else an error
                        will abort the program.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--workers</option>=integer (optional)</term>
                <listitem>
                    <para>
                        Specifies the number of parallel workers to be used in threaded
                        parallelism.  Note that for MPI parallelism, the
                        <option>-np</option> option on <command>mpirun</command>
                        can override this value.
                    </para>
                    <para>
                        If not provided, the value of this option defaults to
                        <literal>1</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--clump-size</option>=integer</term>
                <listitem>
                    <para>
                        Specifies the number of ring items that make up a work unit
                        passed to the workers.  If not supplied, this defaults to
                        1 which is almost certainly not optimal both for communication
                        and for post worker timestamp ordering.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--classifier</option>=filename</term>
                <listitem>
                    <para>
                        Provides the path to the shared object that will be loaded.
                        See <literal>CLASSIFIER LIBRARY</literal> below for more
                        information on what that library must contain.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--parallel-strategy</option> = threaded | mpi</term>
                <listitem>
                    <para>
                        Specifies the parallelization strategy/communications
                        infrastructure used.  If <literal>threaded</literal>,
                        all operations are performed on the same system using threading
                        to gain parallelism.  Each worker is a thread.   In addition
                        there are, one each, threads for input,time stamp reordering
                        and output.
                    </para>
                    <para>
                        Note that if <literal>mpi</literal> is selected, you must
                        run the program with <command>mpirun</command>.  The
                        <command>mpirun</command> <option>-np</option> option
                        will be in conflict with th <option>--workers</option>
                        if it is not <literal>numworkers + 3</literal>.  If this is
                        not the case but there are still sufficient processes to
                        run at least one worker, <option>-np</option> overrides
                        <option>--workers</option>.   A message is output
                        indicating this was done, and the application continues.
                        If <option>-np</option> is less than <literal>4</literal>,
                        the mininmum number of processes needed for at least one
                        worker, an error message is output and the application exits.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>

    </refsect1>
    <refsect1>
        <title>CLASSIFIER LIBRARY</title>
        <para>
            In order to incorporate user written classifiers, the user must
            provide a shared library specified by the <option>--classifier</option>
            option.  This shared library must include both an implementation
            of a concrete subclass of <classname>CRingMarkingWorker::Classifier</classname>
            defined in <filename>CRingItemMarkingWorker.h</filename>, and a factory
            function with C external bindings named <function>createClassifier</function>
            that can create instances of the classifier.
        </para>
        <para>
            The classifier must implement a method
        </para>
        <blockquote>
<methodsynopsis>
    <modifier>virtual</modifier>
    <type>uint32_t</type>
    <methodname>operator()</methodname>
    <methodparam>
        <type>CRingItem&amp;</type><parameter>item</parameter>
    </methodparam>
    <modifier></modifier>
</methodsynopsis>
        </blockquote>
        <para>
            This method is expected to produce a <type>uint32_t</type> classification
            value for the <classname>CRingItem</classname> object referenced
            by <parameter>item</parameter>.  The resulting classification
            is appended to the body header and sizes are all adjusted to
            make everything look good.
        </para>
        <para>
            Here's an example of a factory function that produces
            a <classname>TestClassifier</classname> object:
        </para>
        <informalexample>
            <programlisting>
extern "C" {

CRingMarkingWorker::Classifier* createClassifier() {
    return new TestClassifier;
}
}

            </programlisting>
        </informalexample>
        <para>
            Note the use of <literal>extern "C"</literal> to remove
            C++ name mangling.  The function just creates a new classifier
            and returns a pointer to it.
        </para>
        
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>EventFilter</refentrytitle>
        <manvolnum>1daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>EventFilter</refname>
        <refpurpose></refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
$DAQBIN/EventFilter <optional>OPTIONS</optional>...
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This program takes events that have been classified using
            the <application>SoftwareFilter</application> application and
            applies an acceptance criterion.  Events that pass that criterion
            are sent to the accepted output sink.  Optionally events that
            don't pass acceptance are sent to a rejection sink.  
        </para>
        <para>
            The criterion is specified as a mask of bits that must have a specific value.
            It is an error to pass this program unclassified data.
        </para>
    </refsect1>
    <refsect1>
        <title>OPTIONS</title>
        <para>
            Most options are mandatory. The optional ones and the action
            if not supplied are flagged in the listing below.
        </para>
        <variablelist>
           <varlistentry>
            <term><option>--help</option> (optional)</term>
            <listitem>
                <para>
                    Outputs short help information to stdout and then exits.
                    All subsequent options are ignored.
                </para>
            </listitem>
           </varlistentry>
           <varlistentry>
            <term><option>--version</option> (optional)</term>
            <listitem>
                <para>
                    Outputs the program version and exits. Subsequent options are
                    ignored.
                </para>
            </listitem>
           </varlistentry>
           <varlistentry>
            <term><option>--source</option>=URI</term>
            <listitem>
                <para>
                    Specifies the data source as either a file or tcp URI.
                </para>
            </listitem>
           </varlistentry>
           <varlistentry>
            <term><option>--accepted-sink</option>=URI</term>
            <listitem>
                <para>
                    Specifies where accepted events will go.  The URI can
                    be either a file or tcp URI.  If a tcp URI, the host must
                    be local.
                </para>
            </listitem>
           </varlistentry>
           <varlistentry>
            <term><option>--rejected-sink</option>=URI (optional)</term>
            <listitem>
                <para>
                    Specifies where rejected events will go.  The URI can be either a
                    file or tcp URI.  If the URI is a tcpURI, the host must be
                    local.
                </para>
                <para>
                    If this optional option is omitted, rejected data are
                    not retained.
                </para>
            </listitem>
           </varlistentry>
           <varlistentry>
            <term><option>--mask</option>=int</term>
            <listitem>
                <para>
                    Specifies a mask that is bitwise anded with the classification
                    as part of the acceptancd criterion.  See <option>--value</option>
                    below.
                </para>
            </listitem>
           </varlistentry>
           <varlistentry>
            <term><option>--value</option>=int</term>
            <listitem>
                <para>
                    Specifies the value the classifier must have to accept
                    a  event after the mask is applied. In other words. An event
                    is accepted if
                    <literal>classifier &amp; mask == value</literal>.
                </para>
            </listitem>
           </varlistentry>
        </variablelist>
        
    </refsect1>
    
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>Transformer</refentrytitle>
        <manvolnum>1daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>Transformer</refname>
        <refpurpose>Add extensions to fragments of event built data</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
$DAQBIN/Transformer <optional>OPTIONS</optional>...
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <application>Transfomer</application> program accepts event built
            data as input.  For each fragment in each physics event ring item,
            user written code is invoked to supply an extension data block
            that's put on the back end of each fragment.  The
            sizes are adjusted accordingly so that the resulting ring items
            are fully consistent.
        </para>
        <para>
            The application spins up several parallel workers that process
            blocks of events in parallel.  Resulting ring items are
            re-sorted by timestamp before they are emitted to the output
            sink.
        </para>
    </refsect1>
    <refsect1>
        <title>OPTIONS</title>
        <para>
            Most program options are mandatory.  The optional ones will be
            pointed out in the discussion below.
        </para>
        <variablelist>
            <varlistentry>
                <term><option>--help</option> (optional)</term>
                <listitem>
                    <para>
                        Help text is output to stdout and the program
                        exits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--version</option> (optional)</term>
                <listitem>
                    <para>
                        The program name and version are output to
                        stdout and the program exits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--source</option>=URI</term>
                <listitem>
                    <para>
                        Specifies the source of the data to be processed.
                        This can be either a file or a tcp URI.  If this
                        is a tcp URI in general the program will likely not
                        exit but continue processing until forced to exit.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--sink</option>=URI</term>
                <listitem>
                    <para>
                        Specifies where the processed data will go.  This
                        can be
                        a file or tcp URI. If a tcp URI is specified, the host
                        must resolve to the local host.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--workers</option>=int (optional)</term>
                <listitem>
                    <para>
                        Specifies the number of workers to spin up for the
                        computation.  Note that this can be overidden by the
                        <option>-np</option> option specified in
                        <command>mpirun</command> if
                        <option>--paralele-strategy</option> is
                        <literal>mpi</literal>.
                    </para>
                    <para>
                        IF not specified, this defaults to <literal>1</literal>
                        which for anything but trivial computations is probably
                        not sufficient.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--clump-size</option>=int (optional)</term>
                <listitem>
                    <para>
                        The clump size, specified by this option, is the number
                        of ring items that make up a work unit passed to each
                        worker.  Clumping ring items together makes communication
                        and sorting more efficient (sorting can be done by blocks
                        rather than individual ring items).
                    </para>
                    <para>
                        If not specified, this defaults to <literal>1</literal>
                        which likely does not optimize performance.  Unfortunately
                        ther are no good hard and fast rules for recommending
                        the value of this option.  In general large is good, but
                        too large and you either won't have enough workers
                        to parallelize the processing or physical memroy can
                        be oversubscribed.  Furthermore if the source and
                        destinations are tcp URI's, overly large clump-sizes
                        can mean that the output will lag significantly behind
                        the input.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--extendlib</option>=filepath</term>
                <listitem>
                    <para>
                        Provides the path to the shared library that
                        will be used to provide user code.
                        See <literal>SHARED LIBRARY</literal> below for
                        more information about the expectations for the
                        code that lives in that library.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--parallel-strategy</option>= mpi | threaded</term>
                <listitem>
                    <para>
                        Specifies how parallelism will be performedn and how
                        communications between the parallel processes will be handled.
                        <literal>threaded</literal> limits the application to the
                        cores available on a single system.   Each processing element
                        is a thread and ZMQ <literal>inproc</literal> is
                        used to communicate between the threads.
                    </para>
                    <para>
                        <literal>mpi</literal> uses MPI as the parallel model
                        and the communications mechanism MPI provides mechanisms
                        to recruit several systems into the computation and
                        allows this software to run scalably across
                        Linux MPI clusters.
                    </para>
                    <para>
                        If <literal>mpi</literal> parallelism is chosen,
                        the <command>mpirun</command> command must be run and
                        specifies the total number of processes in the application
                        using its <option>-np</option> option.
                        The total number of processes is <literal>nworkers+3</literal>.
                    </para>
                    <para>
                        If <option>-np</option> is inconsistent with
                        <option>--workers</option>, the number of workers is
                        determined by <option>-np</option>
                        <literal>(nworkers = npvalue-3)</literal>.  If this
                        is not the same value as <option>--workers</option> a
                        warning message is output and, if there are sufficient
                        processes for at least one worker, processing continues.
                        If this the value of <option>-np</option> in
                        <command>mpirun</command> is not at least <literal>4</literal>,
                        an error message is output indicating there are
                        not sufficient processes and the program exits.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>SHARED LIBRARY</title>
        <para>
            The <application>Transformer</application> application requires
            that you supply a shared library and specify it with the
            <option>--extendlib</option> option.  This shared library
            must:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Define and implement a concrete subclass of the
                    class <classname>CBuiltRingItemExtender::CRingItemExtender</classname>
                    defined in <filename>CBuiltRingItemExtender.h</filename>.
                </para>
            </listitem>
            <listitem>
                <para>
                    Provide a factory function that can create instances
                    of your class.
                </para>
            </listitem>
        </orderedlist>
        <para>
            The <classname>CBuiltRingitemExtender::CRingItemExtender</classname>
            abstract base class provide an interface definition for the user
            code that computes the extensions that will be added to
            event fragments in a physics event.   Concrete subclasses must
            implmenet two interface methods:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>iovec</type>
                        <methodname>operator()</methodname>
                        <methodparam>
                            <type>pRingItem</type><parameter>item</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>item</parameter> is a pointer to a ring
                        item as defined in <filename>DataFormat.h</filename>.
                        This item is an event fragment in the event currently
                        being operated on by the worker.  
                    </para>
                    <para>
                        The method is expected to create an extension that will
                        be appended to the event fragment.  The return value
                        is an <structname>iovec</structname> as described in
                        the manpage for <function>writev</function>(2).  It has
                        the fields <structfield>iov_len</structfield> which is the
                        size of the extension you create and
                        <structfield>iov_base</structfield> which points to the
                        extension.
                    </para>
                    <para>
                        The storage containing the extension must be valid for
                        the entirety of event processing as events are output using
                        the gather capabilities of the communications framework.
                        Typically, this requirement means that extensions
                        should be dynamically allocated.
                    </para>
                    <para>
                        Note that if your code does not want to provide
                        an extension for the fragment it can set the
                        <structfield>iov_len</structfield> field to
                        <literal>0</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void</type>
                        <methodname>free</methodname>
                        <methodparam>
                            <type>iovec&</type><parameter>extension</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        When the extension storage is no longer needed, the
                        framework calls this method once for each extension that
                        was created for this event.  This method is not
                        called for fragments for which no extension was provided.
                    </para>
                    <para>
                        This method is suppoed to free all storage
                        associated with the extension provided by this
                        <parameter>extension</parameter> parameter.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>EventEditor</refentrytitle>
        <manvolnum>1daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>EventEditor</refname>
        <refpurpose>Edit event fragment bodies.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
<command>$DAQBIN/EventEditor <replaceable>options...</replaceable></command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This program provides the ability to edit the bodies of
            fragments of event built data.  The body of a fragment is,
            in this case, considered to be the body of the ring item
            rather than the  full body which contains the ring item
            header and optional body hedaer.
        </para>
        <para>
            The program recomputes the size of the body and properly
            updates both the ring item header and the fragment header
            size fields prior to outputting the event.
        </para>
        <para>
            The program relies on user code located in a shared library
            whose path is passed to the program at run-time.
        </para>
    </refsect1>
    <refsect1>
        <title>OPTIONS</title>
        <variablelist>
            <varlistentry>
                <term><option>--help</option></term>
                <listitem>
                    <para>
                        Outputs a brief summary of the program options
                        and exits.  All other options are ignored.
                        See <option>--version</option> below, however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--version</option></term>
                <listitem>
                    <para>
                        Prints out the program name and version.  All
                        other options are ignored.  If
                        <option>--help</option> and
                        <option>--version</option> are both specified,
                        only the first of those optiones is acted on and
                        all other options are ignored.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--source</option> <replaceable>URI</replaceable></term>
                <listitem>
                    <para>
                        Specifies the data source.  The data source
                        can specify a ring buffer (local or remote) or a
                         file.   This option is mandatory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--sink</option> <replaceable>URI</replaceable></term>
                <listitem>
                    <para>
                        Specifies the data sink, that is where
                        the edited data are written. The URI can specify
                        either a file or a ring buffer.  If a ring
                        buffer is specified, the host name must either be
                        <literal>localhost</literal> or resolve to the
                        local computer.
                    </para>
                    <para>
                        This option is mandatory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--workers</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Specifies the number of worker threads/processes
                        to start. Workers are handed chunks of events to
                        operate on in parallel.   In addition to the
                        workers there are three more threads/processes:
                    </para>
                    <para>
                        An input thread/process reads data from the
                        data source and distributes chunks of complete
                        ring items to workers on demand.  This
                        distribution of events is load balanced and
                        uses a pull application level protocol.
                    </para>
                    <para>
                        The workers send data to a sorting thread/process
                        which re-orders the data by increasing time-stamp.
                    </para>
                    <para>
                        The sort thread/process sends data to an
                        ouptut thread/process which writes data chunks
                        to the data sink. 
                    </para>
                    <para>
                        Thus processing is a four stage pipeline.
                        Each stage running in parallel while the second
                        stage consists of a farm of workers which work
                        in parallel on segments (clumps) of input data
                        to produce the output data.
                    </para>
                    <para>
                        This option is mandatory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--clump-size</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        The value of this option  is the number of ring items
                        each worker gets in response to a data pull.
                        Larger clump sizes result in better amortizatino
                        of the communications overhead.  Smaller
                        clumps result in better responsiveness at the
                        program's output since the sorter needs to see
                        contributions from all workers before it can
                        sort.
                    </para>
                    <para>
                        This option is optional and defaults to <literal>1</literal>
                        which isn't good for most cases.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--parallel-strategy</option> <replaceable>threaded | mpi</replaceable></term>
                <listitem>
                    <para>
                        Specifies which parallelization library to use.
                        Threaded parallelism runs all processing elements
                        in a single machine and is suitable for use in
                        high core count systems.  MPI parallelism uses
                        OpenMPI for messaging and, using
                        <command>mpirun</command> to start the program,
                        allows you to distribute the computation
                        across several networked nodes.
                    </para>
                    <para>
                        When using mpi parallelism,  the number of
                        processes specified in the mpirun <option>-np</option>
                        flag must be at least 4.  The actual number of
                        workers is computed from <option>-np</option>
                        rather than <option>--workers</option> and is
                        <option>--np</option> - 3.  If this value is
                        not consistent with the value specified by
                        <option>--workers</option> a warning is emitted
                        to the stderr of the rank 0 process.
                    </para>
                    <para>
                        This option is optional and defaults to
                        <literal>threaded</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--editorlib</option> <replaceable>file-path</replaceable></term>
                <listitem>
                    <para>
                        Specifes the path of the shared library that
                        contains the user code that edits the event.
                        See <literal>USER CODE</literal> below for more
                        information as well
                        as <literal>EXAMPLE</literal>.
                    </para>
                    <para>
                        Note that if the library is not in the default
                        library load path, you will need to ensure
                        that your path specification includes enough
                        information to describe the directory e.g.
                        <filename>./libMylib.so</filename> as opposed
                        to <filename>libMylib.so</filename>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>USER CODE</title>
        <para>
            User code is built into a shared library that must
            provide:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Implementation of a class derived from
                    <classname>CBuiltRingItemEditor::BodyEditor</classname>.
                    See <filename>CBuiltRingItemEditor.h</filename>.
                </para>
            </listitem>
            <listitem>
                <para>
                    A factory function with C bindings named
                    <function>createEditor</function>
                    which is called with no parameters and is expected
                    to return a pointer to a new, dynamically created
                    <classname>CBuiltRingItemEditor::BodyEditor</classname>
                    object (or an object from a class derived from that).
                </para>
            </listitem>
        </itemizedlist>
        <para>
            A key data structure that we will be using is a
            <type>CBuiltRingItemEditor::BodySegment</type>.  Objects
            of this type are used to describe chunks of the output
            event body.  This structure allows in-place editing with
            minimum data movements.  That is body segments can be
            chunks of the original event as well as new data.
        </para>
        <para>
            The <type>CBuiltRingItemEditor::BodySegment</type> is a
            struct with the following fields:
        </para>
        <variablelist>
            <varlistentry>
                <term><type>bool</type> <structfield>s_isDynamic</structfield></term>
                <listitem>
                    <para>
                        Specifies if the data described requires
                        deletion once the event has been emitted.
                        The worker process will operate on all events
                        in a chunk before emitting the edited events
                        in that chunk.  If you are adding data to an event
                        that is unique to that event that data must
                        be dynamically allocated and this
                        field in its descriptor must be <literal>true</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>iovec</type> <structfield>s_description</structfield></term>
                <listitem>
                    <para>
                        Describes a chunk of data.  This is a struct
                        as well described in the man pages for
                        <function>writev</function>.   It has a
                        <structfield>iov_base</structfield> which points
                        to the data in the chunk and a
                        <structfield>iov_len</structfield> which contains
                        the number of bytes in that chunk.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The job of the editing class is to produce a vector of
            <type>CBuiltRingItemEditor::BodySegment</type> objects
            that describe the data in the edited body.
        </para>
        <para>
            Let's look at the <classname>CBuiltRingItemEditor::BodyEditor</classname>
            class definition and its methods.
        </para>
        <informalexample>
            <programlisting>
class BodyEditor {
public:
    virtual std::vector&lt;BodySegment&gt; operator()(
        pRingItemHeader pHdr, pBodyHeader hdr, size_t bodySize,
        void* pBody
    )  = 0;
    virtual void free(iovec&amp; item) = 0;
};

            </programlisting>
        </informalexample>
        <para>
            Note that the <type>pRingItemHeader</type> and
            <type>pBodyHeader</type> types are defined
            in <filename>DataFormat.h</filename> and described in the
            reference section <literal>3daq</literal>.
        </para>
        <para>
            <methodname>operator()</methodname> is called for each
            fragment of each event.  <parameter>pHdr</parameter>
            points to the ring item header of that fragment
            (fragments are assumed to be ring items).
            <parameter>hdr</parameter> points to the body header
            of the event.  This program requires that event fragments
            have body headers (as pretty much all do now).
            Finally <parameter>bodySize</parameter> are the
            number of bytes in the body of the fragment ring item
            and <parameter>pBody</parameter> points to that body
        </para>
        <para>
            <methodname>operator()</methodname> returns a vector of
            body segment descriptors that describe what the new
            body will look like.  The method normally should not
            modify the ring item and body headers.   The caller
            will perform any modifications needed for the new
            size of the body.  Here's an example of code that
            returns the original body un-modified:
        </para>
        <informalexample>
            <programlisting>
...
{
    std::vector&lt;BodySegment&gt; result;
    BodySegment body(bodySize, pBody);
    result.push_back(body);
    return result;
    
}
            </programlisting>
        </informalexample>
        <para>
            This is a valid though uninteresting example.
        </para>
        <para>
            When producing data to go in the body, that data must
            typically be dynamically allocated.  This is because the
            entire clump of ring items, and fragments in each event ring
            item are processed before passing the resulting data to
            the sorting thread/process.  Here's sample code to
            insert a uint32_t <literal>0xa5a5a5a5</literal> at the
            beginning of the fragment and a <literal>0x5a5a5a5a</literal>
            after the existing body:
        </para>
        <informalexample>
            <programlisting>
{
    std::vector&lt;BodySegment&gt; result;
    uint32_t* pHeader = new uint32_t(0xa5a5a5a5);
    uint32_t* pTrailer= new uint32_t(0x5a5a5a5a);
    BodySegment descHeader(sizeof(uint32_t), pHeader, true);
    BodySegment body(bodySize, pBody);
    BodySegment descTrailer(sizeof(uint32_t), pTrailer, true);
    
    result.push_back(descHeader);
    result.push_back(body);
    result.push_back(descTrailer);
    return result;
}
            </programlisting>
        </informalexample>
        <para>
            The key point to get here is that it's not necessary to
            open up space for the header by sliding the original data
            down or any other data movement.  Just create the data for
            the header, and trailer and provide descriptors.
            Note that the <structfield>is_isDynamic</structfield> field
            for those items is true.
        </para>
        <para>
            After events have been emitted, the event editor
            goes through the set of descriptors for that event and
            invokes <methodname>free</methodname> for each dynamically
            allocated segment.  This method is passed the
            <structfield>s_description</structfield> field of that description.
            That method should dispose of the dynamic storage associated with
            that descriptor.  For our previous example:
        </para>
        <informalexample>
            <programlisting>
{
    uint32_t* pInt = static_cast&lt;uint32_t*&gt;(item.iov_base);
    delete pInt;
}
            </programlisting>
        </informalexample>
    </refsect1>
    <refsect1>
        <title>EXAMPLE</title>
        <para>
            Let's put together the code in the previous section that
            inserts headers and trailers in each fragment into a
            complete example.
        </para>
        <informalexample>
            <programlisting>
#include &lt;CBuiltRingItemEditor.h&gt;   <co id='eveditor.include' />
#include &lt;DataFormat.h&gt;

class MyEditor : public CBuiltRingItemEditor::BodyEditor
{
    virtual std::vector&lt;BodySegment&gt; operator()(
            pRingItemHeader pHdr, pBodyHeader hdr,    <co id='eveditor.class' />
            size_t bodySize, void* pBody
    );
    virtual void free(iovec&amp; item);
};
virtual std::vector&lt;BodySegment&gt;
MyEditor::operator()(                       <co id='eveditor.functor' />
    pRingItemHeader pHdr, pBodyHeader hdr,
    size_t bodySize, void* pBody
)
{
    std::vector&lt;BodySegment&gt; result;   <co id='eveditor.result' />
    uint32_t* pHeader = new uint32_t(0xa5a5a5a5); <co id='eveditor.newitems' />
    uint32_t* pTrailer = new uint32_t(0x5a5a5a5a);
    
    BodySegment hdr(sizeof(uint32_t), pHeader, true);
    BodySegment body(bodySize, pBody);        <co id='eveditor.descriptor' />
    BodySegment trailer(sizeof(uint32_t), pTrailer, true);
    
    result.push_back(hdr);
    result.push_back(body);                   <co id='eveditor.buildresult' />
    result.push_back(trailer);
    return result;
}
void
MyEditor::free(iovec&amp; item)             <co id='eveditor.free' />
{
    uint32_t* p = static_cast&lt;uint32_t&gt;(item.iov_base);
    delete p;
}


exern "C" {
    CBuiltRingItemEditor::BodyEditor* createEditor()
    {
        return new MyEditor;                 <co id='eveditor.factory' />
    }
}
            </programlisting>
        </informalexample>
        <calloutlist>
            <callout arearefs='eveditor.include'>
                <para>
                    These are the minimal set of headers needed to write
                    editors.  <filename>CBuiltRingItemEditor.h</filename>
                    provides class definitions for the editor including
                    the bsae class for <classname>MyEditor</classname> below.
                </para>
            </callout>
            <callout arearefs='eveditor.class'>
                <para>
                    This is the class definition for the editing class
                    we're providing.  Note how it derives from
                    <classname>CBuiltRingItemEitor::BodyEditor</classname>
                    and promises to supply implementation of its base class's
                    pure virtual methods.
                </para>
            </callout>
            <callout arearefs='eveditor.functor'>
                <para>
                    Here's where we implement the function call operator.
                    See the detailed comments below.
                </para>
            </callout>
            <callout arearefs='eveditor.result'>
                <para>
                    This declares our method's result.  A vector of
                    body segment descriptors.  In our case we'll need three of
                    them.  One for our header word, one for the original body
                    and one for the trailer word.
                </para>
            </callout>
            <callout arearefs='eveditor.newitems'>
                <para>
                    The new items we'll add to the body must remain in scope
                    for an extended period of time (from now until
                    <methodname>free</methodname> is called for them).  Therefore
                    even though they are simple uin32_t objects they must be
                    new'd into existence and initialized.
                </para>
            </callout>
            <callout arearefs='eveditor.descriptor'>
                <para>
                    This section of code builds the three descriptors we need.
                    Note how the ones that describe the header and trailer are
                    marked as dynamic while the original body isn't.
                </para>
            </callout>
            <callout arearefs='eveditor.buildresult'>
                <para>
                    The descriptors are pushed into the return vector in the
                    order in which we want to see them in the final, edited,
                    event.  The resulting vector is returned as the
                    method's value.
                </para>
            </callout>
            <callout arearefs='eveditor.free'>
                <para>
                    Our implementation of <methodname>free</methodname>
                    is invoked for each header and trailer.  We cast the pointer
                    to the data to a uint32_t pointer and delete.
                    Note that if you might have had several types of data
                    you're adding to the event, you may need to use
                    <structfield>iov_len</structfield> to untangle which to
                    delete - or better yet, make them all derive from a common
                    base class with virtual destructors.  You can then cast
                    to that base class and delete.
                </para>
            </callout>
            <callout arearefs='eveditor.factory'>
                <para>
                    The last thing the EventEditor program needs is a way to
                    make the editor objects it will call in each worker thread.
                    The factory function <function>createEditor</function>
                    provides that.  When the shared library is loaded, this
                    entry point is located and invoked to return Body Editor
                    pointers to brand new body editors.
                </para>
            </callout>
        </calloutlist>
    </refsect1>
    
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>FullEventEditor</refentrytitle>
        <manvolnum>1daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>FullEventEditor</refname>
        <refpurpose>Edit the entire body of an event built event.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <cmdsynopsis>
        <command>
$DAQBIN/FullEventEditor <option>option...</option>
        </command>
    </cmdsynopsis>        
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This program allows users to edit the complete body of an event built
            event as a single unit.  User code can extend, replace or use any
            of the data following the <type>uint32_t</type> byte count
            for the event at the first 32 bits of the event body.  The framework
            will touch up the event's ring item header as well as that byte count.
            User code is responsible for updating internal sizes such as
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Fragment header sizes.
                </para>
            </listitem>
            <listitem>
                <para>
                    Fragment ring item header size field.s
                </para>
            </listitem>
            <listitem>
                <para>
                    Fragment body header size fields.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            <literal>OPTIONS</literal> describes the program options while
            <literal>User editor code</literal> describes how to write the user
            editing code that modifies each event.  The code can run with
            workers editing blocks of events in parallel using either threaded
            or MPI parallelism.  The output event stream is re-sored in time-stamp
            order so that output events are in the same order as the un-edited
            input events.
        </para>
    </refsect1>
    <refsect1>
        <title>OPTIONS</title>
        <variablelist>
            <varlistentry>
                <term><option>--source</option> = <replaceable>>URI</replaceable></term>
                <listitem>
                    <para>
                        Specifies the source of data.  The data source must be
                        event built data where the ring items and the fragments
                        of the events have body headers.
                    </para>
                    <para>
                        The URI can be either a file or ring URI.  Ring buffers
                        can be remote if the system running the distributer
                        task is runnning NSCLDAQ.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--sink</option>=<replaceable>URI</replaceable></term>
                <listitem>
                    <para>
                        Specifies where output data are written. This can be
                        a file or ring URI.  If a ring URI, the host must
                        evaluate to the local host and the system actually
                        doing the writing must run NSCLDAQ.  Note that knowing
                        which this is for MPI Parallelism can be difficult.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--workers</option>=<replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Specifies the number of parallel workers that will operate
                        on the data.  Each worker gets clumps of events whose
                        as determined by <option>--clump-size</option> and works
                        on clumps in parallel to all other workers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--clump-size</option>=<replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Specifies the number of events in each work item that
                        a worker gets per work item request.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--paralle-strategy</option>=<replaceable>thread  | mpi</replaceable></term>
                <listitem>
                    <para>
                        Specifies how the program will parallelize.  Note that if
                        <literal>mpi</literal> is chosen the program must
                        be run with <command>mpirun</command> and that program's
                        <option>-np</option> value will determine the actual
                        number of workers that will be used (np - 3 workers will
                        be used).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--editorlib</option>=<replaceable>libpath</replaceable></term>
                <listitem>
                    <para>
                        Specifies the path to a shared object library that
                        contains the code to edit events and a factory
                        function to produce editor objects.
                    </para>
                    <para>
                        For more information, see <literal>User editor code</literal>
                        below.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>User editor code.</title>
        <para>
            The <application>FullEventEditor</application> program depends on
            application specific user code to actually edit the event.  This code
            can modify all data following the size field of the event.   The
            size field, while accessible, will be automatically updated by
            <application>FullEventEditor</application> to reflect the size of the
            modified event body. Furthermore, the size field of the event's ring
            item header will be updated as well to reflect the updated event size.
            Note, however that it is the responsibility of the user editing
            code to update any size fields at the fragment level.  These are at
            least:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    The fragment header size field for modified fragments.
                </para>
            </listitem>
            <listitem>
                <para>
                    The fragment ring item size field for modified fragments.
                </para>
            </listitem>
            <listitem>
                <para>
                    The sizes of any fragment body headers that are extended.
                </para>
            </listitem>

        </orderedlist>
        <para>
            Note that the bodies of fragments may also have sizes that require
            modification.  This is application specific and won't be
            covered here.
        </para>
        <para>
            The user event editing code is supplied to the
            <application>FullEventEditor</application> as a shared object
            library.  The library must contain an <literal>extern "C"</literal>
            entry point named: <function>createFullEventEditor</function>.
            That entry is a function that takes no parameters and returns a new
            instance of an object from a class derived from
            <classname>CFullEventEditor::Editor</classname>.   That object
            will be used by a worker to edit events. 
        </para>
        <para>
            It is important that each call to
            <function>createFullEventEditor</function> return a new object.
            Only in this way is thread-safety maintained in threaded parallelism.
            The objects created will live for the program's lifetime.
        </para>
        <para>
            Let's examine the definition of the
            <classname>CFullEventEditor::Editor</classname> class.  It is defined
            in the <filename>CFullEventEditor.h</filename> header and
            has the following, pure virtual,  methods:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>std::vector&lt;SegmentDescriptor&gt;</type>
                        <methodname> operator()(</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pBody</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is called once for each event in the
                        work units the worker processes.  The application's
                        parallelism ensures this is called once for every event
                        in <emphasis>some</emphasis> instance of the user's code.
                    </para>
                    <para>
                        <parameter>pBody</parameter> is a pointer to the body
                        of the event.  For the event built data this
                        application is intended to edit, this consists of a
                        <type>uint32_t</type> containing the self-inclusive
                        byte count of the body.  While the remainder of the body
                        can be freely edited, once this method returns, the
                        application will modify this field to represent the
                        number of bytes in the modified event body (self-inclusive).
                    </para>
                    <para>
                        The method returns a vector of
                        <type>SegmentDescriptor</type> structs.  Once we've
                        finished documenting this class we'll turn our attention
                        to that struct.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
            
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>free</methodname>
                        <methodparam>
                            <type>iovec&amp; </type><parameter>desc</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Elements of the return vector may be describe
                        either dynamic or or static storage.  When the
                        event description is no longer needed, this method is
                        called for each descriptor that's marked its
                        storage as dynamic.  This method is expected to
                        free that storage.
                    </para>
                </listitem>
            </varlistentry>
               
        </variablelist>
        <para>
            When editing an event, the new event will most likely consist largely
            of the original event with some supplemental data added.  Rather than
            requiring that your code create a new event laid out in memory. The
            application asks you to describe the new event in terms of blocks of
            memory that it will gather into a new event.  This description
            is the return value from <methodname>operator()</methodname>.
        </para>
        <para>
            <methodname>operator()</methodname> returns a vector of
            <type>SegmentDescriptor</type> structs.  Each of those, in turn,
            describes a block of the event and consist of the following
            fields:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                   <type>iovec</type> <structfield>s_description</structfield>
                </term>
                <listitem>
                    <para>
                        Describes the memory extent of the block.  <type>iovec</type>
                        is a struct defined in the header
                        <filename>sys/uio.h</filename>.   It's fields are
                        <structfield>iov_len</structfield>, the length of the
                        block being described and
                        <structfield>iov_base</structfield> a pointer to the
                        block being described.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <type>bool</type> <structfield>s_dynamic</structfield>
                </term>
                <listitem>
                    <para>
                        This should be <literal>true</literal> if your
                        code needs <methodname>free</methodname> to be called
                        when the memory described by
                        <structfield>s_description</structfield> is no longer
                        needed.  You can us this to free any dynamically
                        allocated memory that was used to create this
                        block.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<!-- /manpage -->

<!-- manpage 3daq -->
<refentry>
    <refmeta>
        <refentrytitle>CProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CProcessor</refname>
        <refpurpose>Abtract base class for a CSP process</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CProcessor.h&gt;

class CProcessor
{
public:
    virtual ~CProcessor() {}
    
    virtual void process(void* pData, size_t nBytes, CSender&amp; sender) = 0;
};
        </synopsis>

    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is a key abstract base class for the NSCLDAQ parallel
            processing framework.  The class provides interfaces for a process
            that participates in parallel sequential processing.  The idea
            is that a concrete processor class is encapsulated in a class
            that accepts data from some source.  
        </para>
        <para>
            When data is received the encapsulating class calls then
            <methodname>process</methodname> class handing it both the
            data and a <classname>CSender</classname> object that can
            be used to send data to the next stage of the processing pipeline.
            Concrete implementations must implement this
            <methodname>process</methodname> method.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void</type>
                        <methodname>process</methodname>
                        <methodparam>
                            <type>void*</type><parameter>pData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type><parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CSender&amp;</type><parameter>sender</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the method that concrete classes must implement.
                        When constructing a parallel pgoram, the user normally
                        creates a set of concrete processors that operate on
                        work items producing output data.  These processor
                        objects are then encapsulated in an object that has been
                        bound to a <classname>CReceiver</classname> that
                        accepts work items from the previous stage of the
                        processing pipeline and a
                        <classname>CSender</classname> that is connected
                        to the next stage of that pipeline.
                    </para>
                    <para>
                        The containing object, when run will accept work items
                        from its <classname>CReceiver</classname> and
                        call its processor's <methodname>process</methodname>
                        method.  That method is expected to do whatever
                        application specific processing is required to produce
                        output data and to send that output data to the next
                        stage of the processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>    
<refentry>
    <refmeta>
        <refentrytitle>CProcessingElement</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CProcessingElement</refname>
        <refpurpose>Abstract base class for a CSP processing element</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CProcessingElement&gt;

class CProcessingElement
{
public:
virtual ~CProcessingElement() {}

virtual void operator()()  = 0;
virtual void process(void* pData, size_t nBytes) = 0;
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Processing elements contain flow of control that typically
            accepts data, processes it and then sends resulting data to
            a subsequent stage of the data processing pipeline.
            Concrete <classname>CProcessingElements</classname> often
            construct with parameters that include a
            <classname>CReceiver</classname> to receive the data,
            a <classname>CSender</classname> to send processed data and a
            <classname>CProcessor</classname> to do the actual processing.
        </para>
        <para>
            In the prototoypical processing element, the
            <methodname>operator()</methodname> method will use the objects'
            <classname>CReceiver</classname> to obtain work elements.
            <methodname>process</methodname> would then be called which
            would, in turn, call the <methodname>process</methodname>
            method of an encapsulated <classname>CProcessor</classname>
            object.
        </para>
        <para>
            <methodname>operator()</methodname> would also be responsible
            for knowing when the last work item has been received and
            shutting down the object after that has been processed.
            In a typical, application, an empty data item might be a flag
            that there are no more data items and the processor's
            <methodname>process</methodname> would, in turn, be
            responsible for notifying subsequent stages of the computation,
            if appropriate.
        </para>
        <para>
            Concrete classes must implement both
            <methodname>operator()</methodname> and
            <methodname>process</methodname>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void</type>
                        <methodname>operator()</methodname>
                        <void />
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is supposed to implement the
                        flow of control of the processing element.
                        Normally this is a loop with the logic like the
                        pseudocode below
                    </para>
                    <informalexample>
                        <programlisting>
do {
workItem = getWorkItem()
process(workItemData, workItemSize)
free the Work item
} while(workItem is not end of data)
Shutdown the object
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void</type>
                        <methodname>process</methodname>
                        <methodparam>
                            <type>void*</type><parameter>pData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type><parameter>nBytes</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Processes a work item of data received by
                        <methodname>operator()</methodname>.  Normally,
                        implementations of this method have the form:
                    </para>
                    <informalexample>
                        <programlisting>
outputData = processTheData(pData, nBytes)
sendToNextStage(outputData)
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CParallelWorker</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CParallelWorker</refname>
        <refpurpose>Base class for a worker that receives fanned out data.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CParallelWorker.h&gt;

class CParallelWorker : public CProcessingElement
{
public:
    CParallelWorker(CFanoutClientTransport&amp; fanin, CSender&amp; sink);
    CParallelWorker(
        CFanoutClientTransport&amp; fanin, CSender&amp; sink,
        uint64_t clientId
    );
    
    virtual void operator()();

protected:
    CSender* getSink();
   
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            In most parallel computations there are segments of the computation
            in which work items fan out to worker processes that operate
            on work items independently and in full parallel with all other
            workers.
        </para>
        <para>
            The NSCLDAQ parallel computing framework provides for transports
            that do that fanout and transports that are clients of those
            fanouts.   This class is a base class that encapsulates a
            receiver that is a fanout client, an arbitrary sender and a
            main control flow that accepts data and asks the unimplemented
            <methodname>process</methodname> method to process it.  Processing
            continues until an empty (zero sized) work item is received.
        </para>
        <para>
            The sender is exposed to subclasses so that it is available
            in <methodname>process</methodname> as implemented by
            concrete classes.  The sender receives the zero length
            work item and is expected to do any shutdown required of the sender.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CParallelWorker</methodname>
                        <methodparam>
                            <type>CFanoutClientTransport&amp; </type><parameter>fanin</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CSender&amp; </type><parameter>sink</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor provides only a fanout
                        client transport and
                        an arbitrary sender.  The user must configure the
                        <parameter>fanin</parameter> transport's clien id
                        prior to running the worker.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CParallelWorker</methodname>
                        <methodparam>
                            <type>CFanoutClientTransport&amp; </type><parameter>fanin</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CSender&amp; </type><parameter>sink</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint64_t </type><parameter>clientId</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor provides the client id of the fanout
                        client transport.  The constructor will configure the
                        <parameter>sink</parameter> transport with that client
                        id.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>operator()</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides the flow of control for the processor.
                        Messages are retrieved from the <parameter>fanin</parameter>
                        transport and  passed to the abstract
                        <methodname>process</methodname> method.
                    </para>
                    <para>
                        Dynamic storage associated with messages is freed by
                        the <methodname>operator()</methodname> and should,
                        not be freed by the concrete subclass
                        <methodname>process</methodname> method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>CSender* </type>
                        <methodname>getSink</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Intended for use by subclasses. This method fetches a
                        pointer to the sender.
                    </para>
                </listitem>
            </varlistentry>               
        </variablelist>
        <para>
            Note that this is still an abstract class as it does not implement
            the <methodname>process</methodname> method.  It does, however,
            provide a typical client flow of control in its
            <methodname>operator()</methodname> method.
            To use this class, you must derive from this and provide a
            <methodname>process</methodname> method.
        </para>

    </refsect1>

</refentry>    

<refentry>
    <refmeta>
        <refentrytitle>CTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTransport</refname>
        <refpurpose>Abstract base class for data transport objects.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;sys/uio.h&gt;
#include &lt;CTransport.h&gt;

class CTransport
{
public:
    virtual  void    recv(void** ppData, size_t&amp; size) = 0;
    virtual  void    send(iovec* parts, size_t numParts) = 0;
    virtual void end();
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Transports are objects that carry data across some high level
            protocol for data transport.  Examples of high level protocols
            are ZeroMQ (ZMQ), MPI, or event raw TCP/IP sockets.
            Transports are normally bound into a
            <classname>CSender</classname> or <classname>CReceiver</classname>
            object.
        </para>
        <para>
            Transport insulate the actual mechanisms of data transport from
            those objects.  Each concrete transport must, at a minimum
            implement the <methodname>recv</methodname> and
            <methodname>send</methodname> methods.  In addition,
            transports may implement the <methodname>end</methodname> method
            which is used to signal for a transport used inside a
            <classname>CSender</classname> that no more data will be transferred
            on that transport.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>void    </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type> size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Abstract interface to receive data from a concrete
                        transport.  <parameter>ppData</parameter> will be
                        written with a pointer to the data received.
                        The storage pointed to must have been dynamically
                        allocated via the <function>malloc()</function>(3)
                        library function.
                    </para>
                    <para>
                        <parameter>size</parameter> will be written with the
                        number of bytes of data received.  Note that all errors
                        should be signalled via exceptions.  While not mandatory,
                        in many transports, a size of 0 is used to indicate end
                        of data.  In that case, the pointer is not meaningful
                        and should not be freed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>void    </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec*</type><parameter> parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes a message to the peer of the transport.
                        See the manual pages for
                        <function>writev</function>(2) for a description of
                        the <type>iovec</type> struct.
                        <parameter>numParts</parameter> are the number of
                        <parameter>parts</parameter> in the message
                    </para>
                    <para>
                        This call mechanism allows messages to be built via
                        a gather mechanism that, in some transports, can
                        minimize the data copies needed to marshall the
                        complete message.
                    </para>
                    <para>
                        Concrete transports must gaurantee that they are
                        done using <parameter>parts</parameter> buffers on
                        return. Thus, if zero copy, asynchronous sends are
                        use by the transport, the <methodname>send</methodname>
                        must block until the send has actually completed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Transports that have a mechanism to signal an end of
                        data should implement this.  The default implementation
                        is to do nothing.  One standard used to indicate
                        an end of data condition is to send a zero length
                        message.  The underlying transport protocol must,
                        however support this if it is to be used.
                    </para>
                </listitem>
            </varlistentry>            
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CSender</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CSender</refname>
        <refpurpose>Encapsulate a transport to send data.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;Sender&gt;

class CSender {

public:
    CSender(CTransport&amp; transport);
    
    void sendMessage(iovec* parts, size_t numParts); 
    void sendMessage(void* pBase, size_t nBytes);   
    void end();
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Working in conjunction with a
            <classname>CTransport</classname>, this class provides
            a mechanism to send data to the transports peer using
            some communication pattern. Note that as far
            as the application code is concerned, this is a
            unidirectional data path.  The underlying
            transport or communication pattern may bi-directional
            message exchanges to accomplish a data transfer,
            but that's hidden from the user code.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CSender</methodname>
                        <methodparam>
                            <type>CTransport&amp; </type>
                            <parameter>transport</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides the <classname>CSender</classname>
                        with a transport that will be used to
                        send messages to the tranport's peer.
                    </para>
                    <para>
                        When designing mechanisms to implement
                        communication patterns (e.g. fanout),
                        it's recommended that all high level
                        protocol code be implemented in the
                        transport so that the simple code of this
                        class can be used everywhere..
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>sendMessage</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends a multipart message to the peer.
                        <parameter>parts</parameter> describes
                        <parameter>numParts</parameter> message
                        parts.  See
                        <function>writev</function>(2) for a
                        description of the
                        <type>iovec</type> struct.
                    </para>
                    <para>
                        This normally just calls the
                        transport's <methodname>send</methodname>
                        method which does whatever  is needed
                        to marshall the message parts into a
                        message.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>sendMessage</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pBase</parameter>
                        </methodparam>
                        <methodparam>
                            <type> size_t </type><parameter>nBytes</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience method to send a single part
                        message.  You can think of this as being
                        implemented:
                    </para>
                    <informalexample>
                        <programlisting>
...                            
iovec part;
part.iov_len = nBytes;
part.iov_base = pBase;
sendMessage(&part, 1);
...
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Signals the transport there is no more
                        data to transmit.  This is normally
                        done by invoking the transport's
                        <methodname>end</methodname> method.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CReceiver</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CReceiver</refname>
        <refpurpose>Encapsulates a transport to receive data</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CReceiver&gt;

class CReceiver
{
public:
    CReceiver(CTransport&amp; rTransport);
    
    void getMessage(void** ppData, size_t&amp; size);
    CTransport* setTransport(CTransport&amp; rTransport);
    
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class uses a transport to receive data from
            a <classname>CSender</classname>.  Any complex
            communication pattern normally is a collaboration
            implemented by the transports of the
            <classname>CSender</classname> and
            <classname>CReceiver</classname> objects.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CReceiver</methodname>
                        <methodparam>
                            <type>CTransport&amp; </type><parameter>rTransport</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the receiver by binding
                        a transport that will be used for message
                        passing. Note that the receiver object
                        will appear to the user code like
                        a unidirectional pipe of messages that
                        transfer data into the application code
                        that uses it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>getMessage</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData, </parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Gets the next message from the peer.
                        <parameter>ppData</parameter> points to
                        storage for a pointer.  The pointer will
                        be filled in with a pointer to the data
                        received.  The data is dynamically
                        allocated via
                        <function>malloc</function>(3) and must
                        be released via a call to the
                        <function>free</function>(3) function.
                    </para>
                    <para>
                        <parameter>size</parameter> is a reference
                        that will be filled in with the actual number
                        of bytes in the message received.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>CTransport* </type>
                        <methodname>setTransport</methodname>
                        <methodparam>
                            <type>CTransport&amp;</type><parameter>rTransport</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Allows a receiver to dyamically set the
                        transport it uses (to
                        <parameter>rTransport</parameter>.
                        A pointer to the previous transport is
                        returned to the caller.
                    </para>
                    <para>
                        If you find yourself using this you should
                        probably reconsider the design of your
                        application's communication scheme.
                    </para>
                </listitem>
            </varlistentry>

    
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CNullTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CNullTransport</refname>
        <refpurpose>Null transport for testing</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CNullTransport.h&gt;

class CNullTransport :  public CTransport
{
    void recv(void** ppData, size_t& size);
    void send(iovec* parts, size_t numParts);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This is a Transport class built for testing.
            See <classname>CTransport</classname>(3daq) for
            information about transports.
            The null transport provides zero length messages
            for each call to <methodname>recv</methodname>.
            Calls to <methodname>send</methodname> don't do
            anything.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CTestTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTestTransport</refname>
        <refpurpose>Transport class for test purposes.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CTestTransport.h&gt;

class CTestTransport : public CTransport
{
public:
    typedef std::vector&lt;uint8_t&gt; message;
    typedef std::deque&lt;message&gt; messageList;
    
public:
    typedef std::vector&lt;message&gt; multipartMessage;
    std::vector&lt;multipartMessage&gt;  m_sentMessages;
    messageList m_messages;

public:
    
    virtual void recv(void** ppData, size_t& size);
    virtual  void    send(iovec* parts, size_t numParts);
    
    void addMessage(void* pData, size_t nBytes);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class provides a transport that can be used
            for unit testing.  Data that have been sent are retained
            for examination.  Data can be put into the object
            for later receipt via <methodname>recv</methodname>
            calls.   In this way a known load of inbound message
            can be injected into users of the transport and
            messages resulting from processing can be
            pulled out to ensure they are as expected.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            See <classname>CTransport</classname>(3daq) for
            a description of the <methodname>send</methodname>
            and <methodname>recv</methodname> methods.
        </para>
        <para>
            The added method for this class is:
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMessage</methodname>
                <methodparam>
                    <type>void*</type><parameter>pData</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter>nBytes</parameter>
                </methodparam>
                <modifier></modifier>
            </methodsynopsis>
        </para>
        <para>
            This method adds the described message to a queue
            of messages that will be retrieved by
            <methodname>recv</methodname> calls.
        </para>
    </refsect1>
    <refsect1>
        <title>TYPES and PUBLIC DATA</title>
        <para>
            The following data types are public:
        </para>
        <variablelist>
            <varlistentry>
                <term><type>message</type></term>
                <listitem>
                    <para>
                        This represents a message or a message
                        part in the case of a multipart message.
                        It's defined to be an
                        <classname>std::vector&lt;uint8_t&gt;</classname>.
                        The elements of the vector are the ordered bytes
                        of the message itself.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>multipartMessage</type></term>
                <listitem>
                    <para>
                        This type represents a sent message
                        which can have more than one part.
                        It's defined as a
                        <classname>std::vector&lt;message&gt;</classname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>messageList</type></term>
                <listitem>
                    <para>
                        This is a list of simple messages.
                        It's used to represent the messages
                        that will be received by
                        <methodname>recv</methodname> and gets
                        loaded by <methodname>addMessagse</methodname>.
                        It is of type
                        <classname>std::deque&lt;message&gt;</classname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>std::vector&lt;multiPartMessage&gt;</classname></term>
                <listitem>
                    <para>
                        This type is used to represent messages
                        that have been sent.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            For testing purposes you may need to see the set of
            messages remaining for consumption via
            <methodname>recv</methodname> and the messages
            that have been sent via <methodname>send</methodname>.
            
        </para>
        <para>
            <varname>m_sendMessages</varname> is of type
            <classname>std::vector&lt;multipartMessage&gt;</classname>
            are the messages sent by <methodname>send</methodname>
            calls.  Each element of the outer vector is a message.
            Each element of the inner vector is a message part
            (the contents of an element described by an
            <type>iovec</type> element).
        </para>
        <para>
            <varname>m_messages</varname> is of type
            <type>messageList</type> and represents the list
            of messages that have not yet been consumed by
            <methodname>recv</methodname>.
            <methodname>addMessage</methodname> adds new messages
            to the back of the <classname>deque</classname> while
            <methodname>recv</methodname> gets the message at the
            front of the <classname>deque</classname>.  If there
            are no remaining messages when
            <methodname>recv</methodname> is called, an empty message
            is returned.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CClientRegistry</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CClientRegistry</refname>
        <refpurpose>Registry of clients.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;stdexcept&gt;
#include &lt;CClientRegistry&gt;

class CClientRegistry {
public:
    void add(uint64_t newId);
    void remove(uint64_t existingId);
    bool hasClient(uint64_t id);
    bool empty();
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Some transports need to be able to identify clients.
            For example, a fanout transport  must, when there's no
            data remaining, send an end to all remaining
            clients.  The <classname>CClientRegistry</classname>
            allows each client to have a unique <type>uint64_t</type>
            identifier.  
        </para>
        <para>
            It provides the facility to add and remove clients,
            to test for the presence of clients and to
            test for an empty client registry.
        </para>
        <para>
            The class prevents client duplication and
            removal of nonexistent clients by throwing
            <classname>std::logic_error</classname>
            exceptions.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>add</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>newId</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds <parameter>newId</parameter> to the set of
                        identifiers that are registered.  If
                        <parameter>newId</parameter> has already
                        been registered,
                        <classname>std::logic_error</classname> is
                        thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>remove</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>existingId</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the id
                        <parameter>existingId</parameter> from the
                        registry. If that id was not yet registered,
                        a <classname>std::logic_error</classname>
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>bool </type>
                        <methodname>hasClient</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>id</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>true</literal> if
                        <parameter>id</parameter> is in the registry
                        otherwise <literal>false</literal> is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>bool </type>
                        <methodname>empty</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Return <literal>true</literal> if the
                        registry has no entryies.  
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFanoutTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFanoutTransport</refname>
        <refpurpose>Transport to fanout data to several workers.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFanoutTransport.h&gt;

class  CFanoutTransport : public CTransport
{
public:
    virtual void end() = 0;
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Abstract base class for transports that fanout
            data to several parallel workers.  The only
            wrinkle this abstract base class adds is a pure virtual
            <methodname>end</methodname> method.
            This is because when there's no more data to send,
            all clients must be notified of that fact.  That
            notification is done in a transport dependent manner.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CFanoutClientTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CFanoutClientTransport</refname>
        <refpurpose>Client for a fanout transport</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CFanoutClientTransport&gt;

class CFanoutClientTransport : public CTransport
{
public:
    virtual void setId(uint64_t id) = 0;
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This abstract base class is intended to be one of
            many targets for messages sent by
            a <classname>CFanoutTransport</classname> objects.
            It is a transport that provides the
            <methodname>setId</methodname> method which is
            supposed to establish the client id of the
            transport.  Client ids are assumed to be unique
            across all of the clients of a single fanout
            transport.  Note that data should not be received
            prior to setting the id.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemTransport</refname>
        <refpurpose>Base class for ring item transports.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingItemTransport.h&gt;
class CRingItemTransport : public CTransport
{
    
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Placeholder base class for transports that
            carry ring items
            around.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingBufferTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemTransport</refname>
        <refpurpose>Transport for ring items to or from ring buffers.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingBufferTransport.h&gt;

class CRingBufferTransport : public CRingItemTransport
{
    
public:
    CRingBufferTransport(CRingBuffer&amp; writer);        
    CRingBufferTransport(CRingBufferChunkAccess&amp; reader); 
    
    virtual void recv(void** ppData, size_t&amp; size);
    virtual void send(iovec* parts, size_t numParts);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Provides a transport for data to and from a ring buffer.
            Often these are at endpoints of a computation, but
            need not be.
        </para>
        <para>
            Note that there is a constructor for writing and a different
            one for reading. This represents the fundamental
            difference between producers and consumers of ring
            data.  Attempting to receive data from
            a ring transport that's been set up to as a producer
            or attempting to send data to a ring buffer
            that's been setup as a consumer results in a
            <classname>std::logic_error</classname> exception.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingBufferTransport</methodname>
                        <methodparam>
                            <type>CRingBuffer&amp; </type><parameter>writer</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Use this constructor for producers into
                        ring buffers.  Objects constructed with this
                        version of the constructor only support
                        <methodname>send</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingBufferTransport</methodname>
                        <methodparam>
                            <type>CRingBufferChunkAccess&amp; </type><parameter>reader</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This version of the constructor is used
                        for consumers.  Objects constructed
                        in this manner are only capable of
                        <methodname>recv</methodname> calls.
                    </para>
                    <para>
                        The <parameter>reader</parameter> parameter
                        is a reference to a
                        <classname>CRingBufferChunkAccess</classname>
                        class.  See the
                        <classname>CRingBufferChunkAccess</classname>(3daq)
                        class for more information about it, and
                        specifically, how to construct it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type> size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Receives the next ring item from the
                        ring buffer.  Receives from this transport
                        are always receiving a full ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Puts data into the ring buffer. Note that
                        each <type>iovec</type> element does a put into the
                        ring buffer.  Thus, if a ring item is
                        spread across several
                        <type>iovec</type> elements,
                        the put is not atomic.  In many cases,
                        because of the way data are gotten from
                        the ring buffer, this fact is not important.
                    </para>
                </listitem>
            </varlistentry>
    
            
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemFileTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItem FileTransport</refname>
        <refpurpose>Transport ring items to and from files.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingItemFileTransport.h&gt;

class CRingItemFileTransport : public CRingItemTransport
{
    
public:
    CRingItemFileTransport(CRingFileBlockReader&amp; reader); 
    CRingItemFileTransport(io::CBufferedOutput&amp; writer);  
    
    virtual void recv(void** ppData, size_t&amp; size);
    virtual void send(iovec* parts, size_t numParts);
    virtual void end();
};


        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is a transport that carries ring items
            to or from files.  Once created, the transpor is
            only unidirectional and using the wrong data trasnfer
            operation results in a
            <classname>std::runtime_error</classname> exception.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingItemFileTransport</methodname>
                        <methodparam>
                            <type>CRingFileBlockReader&amp; </type><parameter>reader</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates an object that
                        can use <methodname>recv</methodname>
                        to get ring items from a file.
                        See
                        <classname>CRingFileBlockReader</classname>(3daq)
                        for information on how to create that
                        object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingItemFileTransport</methodname>
                        <methodparam>
                            <type>io::CBufferedOutput&amp; </type><parameter>writer</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates an object to
                        put ring items into a file.  <parameter>writer</parameter>
                        is the object that does the I/O.  See
                        <classname>io::CBufferedOutput</classname>(3daq)
                        for information about how to construct
                        tis item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Fetches the next ring item from the file.
                        At end of file the ring item returned is
                        of zero length.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Outputs each part of the message to the
                        ringbuffer.  It's up to the caller to ensure
                        that data put in the ring consists of
                        properly formatted ring items...
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void</type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        If the file is open for write,
                        the buffered writer is flushed ensuring
                        all items have been sent to file.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemTransportFactory</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemTransportFactory</refname>
        <refpurpose>Create and appropriate ring item transport</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingItemTransport.h&gt;
#include &lt;CRingItemTransportFactory.h&gt;

class CRingItemTransportFactory
{
public:
    static CRingItemTransport* createTransport(
        const char* uri, CRingBuffer::ClientMode accessMode
    );
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Creates the ring item transport appropriate to the
            URI protocol type (<literal>tcp:</literal>
            or <literal>file:</literal>), and access mode
            (<classname>CRingBuffer</classname><literal>::producer</literal>
            or <classname>CRingBuffer</classname><literal>::consumer</literal>)
            
        </para>
        <para>
            The transport is created with
            <literal>new</literal> and therefore must be
            freed with <literal>delete</literal> when the
            application no longer needs it.
        </para>
    </refsect1>

</refentry>

<refentry>
    <refmeta>
        <refentrytitle>CZMQTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQTransport</refname>
        <refname>CZMQRawTransport</refname>
        <refpurpose>Base class for ZeroMQ transports</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQTransport.h&gt;

class CZMQTransport : public CTransport {
public:
    CZMQTransport();
    
    void recv(void** ppData, size_t&amp; size);
    void send(iovec* parts, size_t numParts);
    void end();
    
    static zmq::context_t*  getContext();
    operator zmq::socket_t*();
protected:
    void setSocket(zmq::socket_t* pSocket);  

};

 */
class CZMQRawTransport  : public CZMQTransport
{
public:
  CZMQRawTransport(zmq::socket_t* sock);
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            These two classes encapsulate ZeroMQ sockets.
            <classname>CZMQTransport</classname>  is intended
            to be used as a base class for more interesting
            transports using ZeroMQ.
            <classname>CZMQRawTransport</classname>, on the other
            hand, wraps a raw ZeroMQ
            <classname>zmq::socket_t</classname> in a transport.
        </para>
    </refsect1>
    <refsect1>
        <title>CZMQTransport METHODS</title>
        <para>
            This class is not useful in and of itself.
            The intent is that it be a base class and the
            resulting concrete class sets up the
            appropriate <classname>zmq::socket_t</classname>
            and wraps it using the
            <methodname>setSocket</methodname> method
            described below.
        </para>
        <variablelist>
            <varlistentry>
                <term><constructorsynopsis>
                    <methodname>CZMQTransport</methodname>
                    <void />
                </constructorsynopsis></term>
                <listitem>
                    <para>
                        This constructor does not supply
                        a socket on which to transport
                        data.  To create a useful class,
                        the programmer must derive a class from
                        this whose constructor sets up a socket and
                        wraps the base class around it by calling
                        <methodname>setSocket</methodname>
                        below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type> size_t&amp;</type><parameter> size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Receives data on the underlying socket.
                        If the message is a multipart message,
                        all the parts are concatenated into  a
                        single block and that block is returned.
                        If you wish to retain message part boundaries
                        you need to define a higher level data format
                        that an do that.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends a message on the underlying socket.
                        Note that each element of the
                        <parameter>parts</parameter> array is
                        sent as a separate message part
                        (<classname>zmq::message_t</classname> object).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends a message consisting of a
                        single message part with a length of zero.
                        That's a flag that the receiver should
                        not expect any more data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static </modifier>
                        <type>zmq::context_t*  </type>
                        <methodname>getContext</methodname>
                        <void  />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Provides a factory message to get a singleton
                        ZMQ context object.  A pointer to the
                        application unique context is returned.
                        This context is created on the first call
                        to this method and must not be deleted
                        by the application.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>zmq::socket_t*</type>
                        <methodname>operator zmq::socket_t*();</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                
                <listitem>
                    <para>
                        Conversion operator that allows the
                        object to be treated as it's underlying
                        socket_t for special applications.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected</modifier>
                        <type>void </type>
                        <methodname>setSocket</methodname>
                        <methodparam>
                            <type>zmq::socket_t* </type><parameter>pSocket</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Intended to be called by  derived classes.
                        This method sets the socket on which
                        communication will take place.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
    </refsect1>
    <refsect1>
        <title>CZMQRawTransport METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CZMQRawTransport</methodname>
                        <methodparam>
                            <type>zmq::socket_t* </type><parameter>sock</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a raw ZMQ socket creates a
                        ZMQ transport around that socket.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQClientTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQClientTransport</refname>
        <refpurpose>ZeroMQ transport that does a connect.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQClientTransport&gt;

class CZMQClientTransport : public CZMQTransport
{
public:
    CZMQClientTransport(const char* pUri, int socketType);
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            represents a ZeroMQ transport that performs a
            <methodname>connect</methodname> operation to
            obtain a peer socket.
            <parameter>pUri</parameter> is a ZeroMQ compatible
            URI that specifies the endpoint and
            <parameter>socketType</parameter> is the
            ZeroMQ socket type (e.g. <literal>ZMQ_PULL</literal>).
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQServerTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQServerTransport</refname>
        <refpurpose>ZeroMQ transport that does a listen.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQServerTransport.h&gt;

class CZMQServerTransport : public CZMQTransport
{
public:
    CZMQServerTransport(const char* pUri, int socketType);
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This clss is a ZeroMQ transport for a socket
            that listens for connections rather than invoking
            <methodname>connect</methodname>.
            <parameter>pUri</parameter> is a URi that specifies the
            socket endpoint and <classname>socketType</classname>
            is the ZeroMQ socket type e.g. <literal>ZMQ_PUB</literal>.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQRouterTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQRouterTransport</refname>
        <refpurpose>ZeroMQ transport that's a ROUTER fanout.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQRouterTransport.h&gt;

class CZMQRouterTransport : public CFanoutTransport
{
public:
    CZMQRouterTransport(const char* pUri);
    
    virtual void recv(void** ppData, size_t&amp; size); 
    virtual void send(iovec* parts, size_t numParts);
    virtual void end();

};
 
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class implements a fanout transport using
            the ZeroMQ ROUTER/DEALER communication pattern
            (see <classname>CZMQDealerTransport</classname>)(3daq).
            ZMQ routera use a pull protocol in which each
            worker sends a request for data which is honored
            by the DEALER.
        </para>
        <para>
            The protocol of getting pull requests and then
            providing them is totally transparent to the users
            of this class.  Each call to send sends the data
            as a work item to some worker process
            running the DEALER protocol.
        </para>
        <para>
            Since pull requests require the DEALER to have set up
            an id, the pull requests build up a picture of the
            client ids.  This picture is used by
            <methodname>end</methodname> to ensure that all
            clients see an end condition.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CZMQRouterTransport</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>char* </type><parameter>pUri</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor creates the
                        <literal>ROUTER</literal> socket and
                        does a bind to ensure that DEALERS
                        can connect.
                        <parameter>pUri</parameter> is the ZeroMQ
                        URI that specifies the socket end point.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void**</type><parameter> ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp;</type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The ROUTER socket only supports sending data.
                        A call to this method results in a
                        <classname>std::logic_error</classname>
                        exception
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends the message indicated to the next
                        worker that requests data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Indicates to all connected clients no
                        more data will be available.  End of data
                        is indicated by a message that contains a
                        single message point with  a zero length.
                    </para>
                </listitem>
            </varlistentry>

        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQDealerTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQDealerTransport</refname>
        <refpurpose>Peer, receiver for CZMQRouterTransport(3daq)</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis> 
#inclucde &lt;CZMQDealerTransport.h&gt;
class CZMQDealerTransport : public CFanoutClientTransport
{

public:
    CZMQDealerTransport(const char* pUri);
    CZMQDealerTransport(const char* pUri, uint64_t id);
    
    void recv(void** ppData, size_t&amp; size);
    void send(iovec* parts, size_t numParts);
    void setId(uint64_t id);

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The ZMQ Router/Dealer communication pattern provides
            mechanism to fan work units out to parallel workers.
            The Router, whose transport is
            <classname>CZMQRouterTransport</classname>(3daq)
            is the fanout.  The workers receive data via this
            class.
        </para>
        <para>
            The transports hide the details of requesting data
            and stripping delimeters.  From the users's point of
            view the worker just does a call to
            <methodname>recv</methodname> and a work unit is
            returned.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <classname>CZMQDealerTransport</classname> is a
            unidirectional transport that can only receive data.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CZMQDealerTransport</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>char*</type>
                            <parameter>pUri</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor just supplies
                        <parameter>pUri</parameter> the
                        ZMQ URI specifying the communication
                        endpoint agreed upon by the Router and
                        Dealer.
                    </para>
                    <para>
                        This method of construction requires that
                        you call
                        <methodname>setId</methodname> 
                        to establish the client id prior to
                        transferring data with
                        <methodname>recv</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CZMQDealerTransport</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>char* </type><parameter>pUri</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint64_t</type><parameter> id</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor supplies both the
                        endpoint URI (<parameter>pUri</parameter>),
                        and the client id;
                        <parameter>id</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Receives data from the peer.  The process
                        of requesting data, receiving the multipart
                        message, stripping the delimeter and
                        reassembling the message payload into
                        a single blob is done
                        by this method, transparent to the caller.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodname>send</methodname>
                </term>
                <listitem>
                    <para>
                        This is not a legal method.
                        If you call this,
                        a <classname>std::logic_error</classname>
                        is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void </type>
                        <methodname>setId</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>id</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CDataSinkElement</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CDataSinkElement</refname>
        <refpurpose>Forward data to some sink.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CDataSinkElement.h&gt;

class CDataSinkElement : public CProcessingElement
{
public:
    CDataSinkElement(CReceiver&amp; src, CSender&amp; sink);
    
    virtual void operator()();
    virtual void process(void* pData, size_t nBytes);

};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is intended to be used at the end
            of the processing pipeline.  It simply accepts
            work items and sends them to a sink.  A usual
            application transforms a set of input work items
            into an output set via a parallel application.
        </para>
        <para>
            While the last stage of that computation could output
            those data, it would then be more work to
            insert additional processing layers in the application
            as it's incrementally built and tested.
            Having a dedicated processing element to output
            data allows for that code to live on its own
            where additional processing stages could be inserted
            prior to it.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CDataSourceElement</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CDataSourceElement</refname>
        <refpurpose>Fan out a data source without transformations</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CDataSourceElement.h&gt;

class CDataSourceElement : public CProcessingElement
{
public:
    CDataSourceElement(CReceiver&amp; source, CFanoutTransport&amp; fanout);
    
    virtual void operator()();
    virtual void process(void* pData, size_t nBytes);

};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This is a processor that can be used when a source
            of data needs to be fanned out as work items to
            a parallel array of worker processes.  The
            <parameter>fanout</parameter> parameter is
            a fanout transport.  As each elemet is
            received from whatever the source is, it is
            sent to the <parameter>fanout</parameter> transport
            which will distribute it to the workers.
        </para>
        <para>
            When an end is detected on the input stream,
            defined as a zero length message, an end indication
            is sent to the <parameter>fanout</parameter> transport
            which ensures that all workers get an end condition.
            At that point, the <methodname>operator()</methodname>
            returns.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemZMQSourceElement</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemZMQSourceElement</refname>
        <refpurpose>Fanout ring items from some data source.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingItemZMQDataSource.h&gt;

class CRingItemZMQSourceElement : public CDataSourceElement
{
public:
    typedef struct _Message {
        uint64_t  s_timestamp;
        size_t    s_nBytes;
        void*     s_pData;
    } Message, *pMessage;

    
public:
    CRingItemZMQSourceElement(
        const char* ringUri, const char* routerUri, size_t chunkSize=1
    );
    virtual ~CRingItemZMQSourceElement() {}
    virtual void operator()();             // Override b/c process frees memory.
    virtual void process(void* pData, size_t nBytes);

};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            A fanout data source which extracts a timestamp
            from ring items and prepends it to work items.
            This is meant to work with parallel workers that
            must then re-sort the data in timestamp order
            using e.g. <classname>CRingItemSorter</classname>(3daq).
        </para>
        <para>
            See <classname>CRingItemMarkingWorker</classname>
            for one example of a worker that can make use of the
            data from this source.
        </para>
        <para>
            Each work item consist of several ring items determined
            by the <parameter>chunkSize</parameter> at construction
            time.  Ring items come from
            <parameter>ringUri</parameter> which is either a
            <literal>tcp:</literal> or <literal>file:</literal>
            URI specifying a source of ring items.  The
            <parameter>routerUri</parameter> provides the endpoint
            of a ZMQ Router fanout transport that will be used
            to send work units to worker processes.
        </para>
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <para>
            Each work item consists of a block of items
            Each of those
            items in the block contains the following fields
        </para>
        <variablelist>
            <varlistentry>
                <term><type>uint64_t</type>  <structfield>s_timestamp</structfield></term>
                <listitem>
                    <para>
                        The timestamp either extracted from the
                        ring item or a sensibly assigned time-stamp
                        that will allow a sorting stage to
                        reconstruct  (for the most part) the
                        original order of the ring items.  For
                        the most part means that there can be cases
                        when non Physics items will come slightly
                        out of order due to the manner in which
                        they were assigned timestamps.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>size_t </type><structfield>s_nBytes</structfield></term>
                <listitem>
                    <para>
                        The number of bytes of data in the
                        ring item that follows.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>uint8_t</type><structfield>data[]</structfield></term>
                <listitem>
                    <para>
                        The ring item.
                    </para>
                </listitem>
            </varlistentry>      
        </variablelist>
        <para>
            Here's a  code fragment that shows
            how to process a work item from this data source.
            On entry to the fragment, <varname>pData</varname> points
            to the work item and <varname>dataSize</varname>
            is the full size of the fragment.
        </para>
        <informalexample>
            <programlisting>
#include &lt;DataFormat.h&gt;
#include &lt;stdint.h&gt;

struct Item {
    uint64_t s_timestamp;
    uint32_t s_ringItemSize;
    uint8_t  s_data[];
};
...

uint8_t* p = static_cast&lt;pData&gt;(pData);
while (dataSize) {
    Item* pItem = reinterpret_cast&lt;Item*&gt;(p);
    uint64_t stamp = pItem-&gt;s_timestamp;
    pRingItem pR   = reinterpret_cast&lt;pRingItem&gt;(pItem->s_data);
    
    processTheRingItem(pR, stamp);
    
    size_t nItemSize = sizeof(uint64_t) + sizeof(uint32_t) + pItem->s_ringItemSize;
    p += nItemSize;
    dataSize -= nItemSize;
}
free(pData);
            </programlisting>
        </informalexample>
    </refsect1>
</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemMarkingWorker</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemMarkingWorker</refname>
        <refpurpose>Strategy pattern for classifying ring items</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingMarkingWorker&gt;

class CRingMarkingWorker : public CParallelWorker
{
public:
    class Classifier {
    public:
        virtual uint32_t operator()(CRingItem& item) = 0;
    };
    
public:
    CRingMarkingWorker(
        CFanoutClientTransport&amp; fanin, CSender&amp; sink, uint64_t clientId,
        Classifier* pClassifier
    );
    virtual ~CRingMarkingWorker() {}
    virtual void process(void* pData, size_t nBytes);

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            One of the main purposes of the parallel processing
            framework is to set up software triggers. In NSCLDAQ
            these operate in two stages.  The first stage
            classifies ring items with a uint32_t value.
            The second stage retains or discards items by
            applying an acceptance criterion to this classification.
        </para>
        <para>
            Note that only <literal>PHYSICS_EVENT</literal> items
            get classified.  The classification is carried with
            the ring item as an extension to that item's body
            header.  This class provides a framework that
            allows the user to simply report back the classification.
            All the work of getting work items, formatting the
            output ring items and sending them on to the next
            stage of processing are taken care of by this class.
        </para>
        <para>
            The data processed by this class are assumed to have come
            from a <classname>CRingItemZMQDataSource</classname>
            or any other data source that produces the
            same output format.  The data source is
            assumed to be a fanout data source as classification
            may be computationally intensive enough to
            be worth parallelization.
        </para>
        <para>
            Construction of one of these therefore requires:
        </para>
        <variablelist>
            <varlistentry>
                <term><parameter>fanin</parameter></term>
                <listitem>
                    <para>
                        The fanout client transport that
                        is getting data from the fanout
                        transport.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter> sink</parameter></term>
                <listitem>
                    <para>
                        The sender that will be used to ship
                        the resulting work items to the
                        next stage of processing.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>clientId</parameter></term>
                <listitem>
                    <para>
                        The client id that will be configured
                        into <parameter>fanin</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>pClassifier</parameter></term>
                <listitem>
                    <para>
                        A pointer to a concrete subclass of
                        <classname>CRingMarkingWorker::Classfier</classname>.
                        This is an application specific class who's
                        <methodname>operator()</methodname> knows
                        how to compute and return the
                        uint32_t classification of a ring item
                        passed by reference.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Data sent on the <parameter>sink</parameter> will
            have the same format as the data received, however
            each block containing a physics item
            will be a uint32_t longer than before
            to accomodate the classification value.  The
            ring item size and body header size field will be
            modified to appropriately reflect this.
        </para>
    </refsect1>
    <refsect1>
        <title>OUTPUT DATA FORMAT</title>
        <para>
            The messages sent by this class are suitable
            for input to the
            <classname>CRingItemSorter</classname>(3daq).
            The consist of first a uint32_t client id followed
            by an array of timestamp, ring items pairs
            The message size and
            iterating through the ring items can be used to
            determine the number of ring items present.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemSorter</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemSorter</refname>
        <refpurpose>Re-sort a stream of ring items by timestamp</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
class CRingItemSorter  : public CProcessingElement
{
public:
    
    typedef struct _Item {
        uint64_t s_timestamp;
        RingItem s_item;
    } Item, *pItem;

                                                // signature.
public:
    CRingItemSorter(
        CReceiver&amp; fanin, CSender&amp; sink, uint64_t window, size_t nWorkers
    );
    
    virtual void operator()();
    virtual void process(void* pData, size_t nBytes);
};


        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Processor that emits ring items in timestamp sorted order.
            The input stream of data is that produced by e.g.
            <classname>CRingItemMarkingWorker</classname>.
            That consist of a uint32_t client id, followed by
            an array of uint64_timstamp/ring items pairs.
            The output of this worker is a stream of
            ring item arrays.  This is suitable for use with
            a <classname>CRingBlockDataSink</classname>.
        </para>
        <para>
            When constructing this a <parameter>fanin</parameter>
            receiver must be provided to get data from the workers.
            this receiver must be capable of fanning in the
            data from all workers.
        </para>
        <para>
            <parameter>sink</parameter> provides the sender to
            pass data to the next stage.
            <parameter>window</parameter> is an obsolete parameter
             and no longer used.
             <parameter>nWorkers</parameter> is the number
             of workers fanning into this stage of processing.
        </para>
        <para>
            As each receiver sends an end of data, it is marked
            as exited.  When the last remaining receiver has
            sent its end and all data sorted and emitted,
            an end is sent to the sender.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CThreadedProcessingElement</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CThreadedProcessingElement</refname>
        <refpurpose>Run a processing element ina thread.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CThreadedProcessingElement.h&gt;

class CThreadedProcessingElement : public Thread
{
public:
    CThreadedProcessingElement(CProcessingElement* processor);
    
    virtual void run();
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            In shared memory multiprocessing parallelism,
            it's often simplest to run each parallel processing
            element in a thread of its own.  Each thread then
            gets scheduled to available cores in the system
            by the underlying scheduler.  This class
            leverages the <classname>Thread</classname>(3daq)
            class in NSCLDAQ to embed a
            <classname>CProcessingElement</classname> in a thread
            of execution.
        </para>
        <para>
            When the application initialization code runs a threaded
            parallel program, it sets up all the transports,
            senders and reveivers, creates the processors and
            then constructs a <classname>CThreadedProcessingElement</classname>
            for each processor.  Processors are then started
            using the <classname>Thread</classname> class's
            <methodname>start</methodname> method. 
            When the thread begins execution it will call
            the <methodname>operator()</methodname> method of the
            <parameter>processor</parameter> it was constructed
            with.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQRingItemThreadedWorker</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQRingItemThreadedWorker</refname>
        <refpurpose>ZeroMQ Threaded worker for ZeroMQ</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQRingItemThreadedProcessingElement.h&gt;

class CZMQRingItemThreadedWorker : public CThreadedProcessingElement
{
public:
    CZMQRingItemThreadedWorker(
        const char* routerUri, uint64_t clientId, CSender& sender,
        CProcessor* processor
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The constructor of this class constructs its base
            class with a <classname>CZMQRingItemWorker</classname>
            as its processor.
            <parameter>routerUri</parameter> is the ZMQ router
            URI, clientId is the id of the ROUTER client
            (Dealer) this thread represents.
            <parameter>sender</parameter> is the
            sender to which data are sent and
            <parameter>processor</parameter> provides the per
            work item processing.
        </para>
        <para>
            For the expectations of the <parameter>processor</parameter>
            see <classname>CZMQRingItemWorker</classname>(3daq).
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQRingItemSourceThread</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQRingItemSourceThread</refname>
        <refpurpose>Provide a thread that routes ring items from a source</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQRingItemSourceThread.h&gt;
class CZMQRingItemSourceThread : public CThreadedProcessingElement
{
public:
    CZMQRingItemSourceThread(const char* ringUri, const char* routerUri);

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Provides a thread that takes ring items from
            some data source specified by
            <parameter>ringUri</parameter> and, using the
            ZeroMQ Router/Dealer pattern ROUTER running on
            <parameter>routerUri</parameter> fans them
            out as work items for parallel processing.
        </para>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CCommunicatorFactory</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CCommuniatorFactory</refname>
        <refpurpose>Create transports for an underlying communication scheme.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CCommunicatorFactory.h&gt;

class CCommunicatorFactory
{
public:
    virtual CTransport* createFanoutTransport(int endPointId) =0;
    virtual CTransport* createFanoutClient(int endpointId, int clientId) =0;
    virtual CTransport* createFanInSource(int endpointId) = 0;
    virtual CTransport* createFanInSink(int endpointId) = 0;
    virtual CTransport* createOneToOneSource(int endpointId) = 0;
    virtual CTransport* createOneToOneSink(int endpointid) = 0;
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Pure abstract transport factory.   Parallel programs
            can feature a variety of communication patterns.
            This factory is an abstract base class for factories
            that know how to create transport objects for
            several common communication factories.
        </para>
        <para>
            The idea is that application initialization
            code would use an appropriate factory to
            create the transports it needs.  Use of factories
            would make changing the communications methods as
            easy as changing the factory used to create
            the transports.
        </para>
        <para>
            As different communication schemes will have differing
            ways to specify communication endpoints.  specifications
            are reduced to integers in this scheme.
            A concrete factory will, in general, need a
            mechanism to convert these integers into native
            endp;oint specifications.
            How this is done is factory specific.
            See e.g. <classname>CZMQCommunicatorFactory</classname>(3daq).
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            Note that all of these methods return a
            <classname>CTransport</classname>*. The pointer pointer
            points to a transport object the concrete factory
            created with <literal>new</literal>.  Furthermore,
            in this class, all methods are pure virtual and
            must be implemented in a concrete factory.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CTransport* </type>
                        <methodname>createFanoutTransport</methodname>
                        <methodparam>
                            <type>int </type><parameter>endPointId</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a transport that fans out
                        data to multiple clients that operate
                        with data parallelism.  <parameter>endpointId</parameter>
                        identifies any endpoint needed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CTransport* </type>
                        <methodname>createFanoutClient</methodname>
                        <methodparam>
                            <type>(int </type><parameter>endpointId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>clientId</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a transport that receives data from
                        a fanout. The endpoint of the fanout
                        is identified by <parameter>endpoingId</parameter>.
                        The client's id is
                        <parameter>clientId</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CTransport* </type>
                        <methodname>createFanInSource</methodname>
                        <methodparam>
                            <type>int </type><parameter>endpointId</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a transport that is a source
                        for fanned in data.  The endpoint of the transport
                        is identified by <parameter>endpointId</parameter>
                        In general there will be one of these that
                        will send data to a single client with a
                        transport created by
                        <methodname>createFanInSink</methodname>
                        below with the same
                        <parameter>endpointId</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CTransport* </type>
                        <methodname>createFanInSink</methodname>
                        <methodparam>
                            <type>int </type><parameter>endpointId</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a sink of data from a
                        fan in source with the same
                        <parameter>endpointId</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CTransport* </type>
                        <methodname>createOneToOneSource</methodname>
                        <methodparam>
                            <type>int </type><parameter>endpointId</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a transport for the source of
                        data for a pipeline of data.
                        The data are consumed by the transport
                        created by <methodname>createOneToOneSink</methodname>
                        below with the same
                        <parameter>endpointId</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>CTransport* </type>
                        <methodname>createOneToOneSink</methodname>
                        <methodparam>
                            <type>int </type><parameter>endpointid</parameter>
                        </methodparam>
                        <modifier>= 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates the sink of a pipeline of data.
                        The resulting transport receives data sent
                        by a transport created with
                        <methodname>createOnToOneSource</methodname>
                        with the same <parameter>endpointId</parameter>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CZMQCommunicatorFactory</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CZMQCommunicatorFactory</refname>
        <refpurpose>Communicator factory for ZeroMQ</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CZMQCommunicatorFactory.h&gt;

class CZMQCommunicatorFactory : public CCommunicatorFactory
{
public:
    CZMQCommunicatorFactory();

    virtual CTransport* createFanoutTransport(int endpointId);
    virtual CTransport* createFanoutClient(int endpointId, int clientId);
    virtual CTransport* createFanInSource(int endpointId) ;
    virtual CTransport* createFanInSink(int endpointId);
    virtual CTransport* createOneToOneSource(int endpointId);
    virtual CTransport* createOneToOneSink(int endpointid);

    std::string getUri(int endpointId);

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This is a factory specialized for the ZeroMQ
            communications system.  See
            <classname>CCommunicatorFactory</classname>
            for more information.  This manpage will only
            describe the ZeroMQ (ZMQ) specific information
            about this factory.
        </para>
        <para>
            Native ZMQ specifies endpoints as URI's  The URI's
            describe the communcations mechanism using the
            URI protocol to specify its own transport mechanism
            (e.g. tcp or inproc etc.) and the remainder of the
            URI to specify transport specific information.
            For example, <literal>tcp://somehost.net:1234</literal>
            specifies a TCP/IP port on smoehost.net port number
            1234.  <literal>inproc://myendpoint</literal> specifies
            a process internal communication transport named
            <literal>myendpoint</literal>.
        </para>
        <para>
            This rich space of URIs must, in some way be mapped
            to factory endpoint ids, which are integer (and back
            for that matter).  The ZMQ factory does this by
            allowing the user to specify end point mapping files.
            Three endpoint mapping files can be specified and
            <emphasis>all</emphasis> are read allowing endpoints
            to be user specific, project specific and run specific.
            The end point files are:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <filename>~/.zmqservices</filename>
                </para>
            </listitem>
            <listitem>
                <para>
                    <filename>./zmqservices</filename>
                </para>
            </listitem>
            <listitem>
                <para>
                    The file pointed to by the envronment
                    variable <literal>ZMQ_SERVICES</literal>.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Only the files you need must actually exist (the
            <literal>ZMQ_SERVICES</literal> environment variable
            need not be defined), however at least one endpoint
            file must exist for the factory to function. See
            <literal>ENDPOINT FILE FORMAT</literal> for the format
            of these endpoint files.
        </para>
        <para>
            ZMQ factory creational method map as follows
            to ZMQ sockets:
        </para>
        <variablelist>
            <varlistentry>
                <term><methodname>createFanoutTransport</methodname></term>
                <listitem>
                    <para>
                        Creates a ZMQ_ROUTER socket as a server.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>createFanoutClient</methodname></term>
                <listitem>
                    <para>
                        Creates a ZMQ_DEALER socket as a client.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>createFanInSource</methodname></term>
                <listitem>
                    <para>
                        Creates a ZMQ_PUSH socket as a client.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>createFanInSink</methodname></term>
                <listitem>
                    <para>
                        Creates a ZMQ_PULL socket as a server.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>createOneToOneSource</methodname></term>
                <listitem>
                    <para>
                        Creates a ZMQ_PUSH socket as a client.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>createOnToOneSink</methodname></term>
                <listitem>
                    <para>
                        Creates a ZMQ_PULL socket as a server.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>

        <para>
            To support special needs, the factory adds the
            method <methodname>getUri</methodname>.  This method
            takes an integer endpoint id as a parameter and
            returns an <type>std::string</type> containing the
            Uri that corresponds to that end point.
        </para>
        <para>
            Any use of an endpoint id that does not have a mapping
            (including calls to <methodname>getUri</methodname>)
            results in a <classname>std::invalid_argument</classname>
            exception.
        </para>
    </refsect1>
    <refsect1>
        <title>ENDPOINT FILE FORMAT</title>
        <para>
            Endpoint files are used to create a correspondence between
            integer endpointId values and ZMQ endpoint Uris.
            These files are textual.  Leading and trailing
            whitespace characters
            on each line are ignored.
            Empty lines are ignored.  Lines whose first
            non-whitespace character is <literal>#</literal> are
            ignored as well.
        </para>
        <para>
            All of these make it possible for you to create
            readable and well commented endpoint files.
        </para>
        <para>
            Each line that is not ignored must have two fields.
            The first field is an integer endpoint id.
            The second field is a string that specifies
            the URI that endpoint Id corresponds to.
        </para>
    </refsect1>
    

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CCommunicatorFactoryMaker</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CCommunicatorFactoryMaker</refname>
        <refpurpose>Create communication factories.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CCommunicatorFactoryMaker.h&gt;


typedef CCreator&lt;CCommunicatorFactory&gt; CommunicatorFactoryCreator;
typedef CExtensibleFactory&lt;CCommunicatorFactory&gt; CommunicatorFactoryFactory;

class CCommunicatorFactoryMaker : public CommunicatorFactoryFactory
{

public:
    static CCommunicatorFactoryMaker* getInstance();
};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Provides a factory that produces a communicator
            factory given a textual description of the
            communication mechanism.  This factory is a singleton
            object.  Construction is not possible. You must
            invoke <methodname>getInstance</methodname> to
            obtain a pointer to the singleton factory object.
        </para>
        <para>
            See the <classname>CExtensibleFactory</classname>(3daq)
            manual page for information about how to
            construct a factory and how to register
            additional factories you might have.
        </para>
        <para>
            The following factories are registered by the singleton
            automatically:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>ZeroMQ Communcation system</literal></term>
                <listitem>
                    <para>
                        Creates a
                        <classname>CZMQCommunicatorFactory</classname>
                        object.   See
                        <classname>CZMQCommunicatorFactory</classname>(3daq)
                        for more information.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CMPITransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CMPITransport</refname>
        <refpurpose>Base class for transports using MPI for communication.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CMPITransport_mpi.h&gt;

class CMPITransport : public CTransport
{
public:
    CMPITransport();
    CMPITransport(int currentReceiver);
    
    virtual  void    recv(void** ppData, size_t&amp; size);
    virtual  void    send(iovec* parts, size_t numParts);
    virtual  void    end();
    
    // MPI specific stuff:
    
    int setReceiver(int rank);
    int getReceiver() const;
    int getLastReceivedTag() const;
    int getLastReceivedRank() const;
    MPI_Comm setCommunicator(MPI_Comm newComm);
    
protected:
    static const int endTag  = 0;    // Tag signifying end of data
    static const int dataTag =  1;   // Tag signifying data    
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This is the base class for transports that use the Message Passing
            Interface (MPI) for communication.  Note that MPI applications
            normally require a helper program (e.g. <command>mpirun</command>)
            to be started.
        </para>
        <para>
            MPI application endpoints are ranks.  By default these are ranks
            within the communicator named <literal>MPI_COMM_WORLD</literal>.
            It is possible, however, for applications to build groups of processes
            that perform communication using sub-set communicators.  Doing that
            is beyond the scope fo this library, however there is support for
            using such communicators.
        </para>
        <para>
            Note that in addition to being able to target specific
            receivers with messages, each message has a tag
            associated with it.  The framework uses those tags
            as follows:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <literal>1</literal> - indicates data are being transferred.
                </para>
            </listitem>
            <listitem>
                <para>
                    <literal>0</literal> - indicates no more data is available
                    from the peer.
                </para>
            </listitem>
        </itemizedlist>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CMPITransport</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Base class.  Note that no receiver has been selected
                        and the user must set a receiver prior to the first
                        communication using <methodname>setReceiver</methodname>.
                        The communicator use, unless later set using
                        <methodname>setCommunicator</methodname> will be
                        <literal>MPI_COMM_WORLD</literal>, the communicator
                        for the entire application.
                    </para>
                    
                    
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CMPITransport</methodname>
                        <methodparam>
                            <type>int</type><parameter>currentReceiver</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor sets the receiver peer as
                        <parameter>currentReceiver</parameter>.   This
                        is intended for use by derived classes implementing
                        e.g. pipelining to communicate from one stage of the
                        pipeline to another (not fan-in).  Unless later
                        overridden by calls to <methodname>setReceiver</methodname>,
                        all sends will be directed to the process indicated by
                        <parameter>currentReceiver</parameter>'s rank.  Note
                        that unless modified by a call to
                        <methodname>setCommunicator</methodname> that rank
                        is evaluated in the <literal>MPI_COMM_WORLD</literal>
                        communicator.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>void    </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Receives data.  By default, this allows receipt of messages
                        from any sender with any tag.
                        <methodname>getLastReceivedRank</methodname> and
                        <methodname>getLastReceivedTag</methodname> can be used
                        to determine the source and tag of the last message.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>void    </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends a message to the current receiver.  The
                        message is gathered from parts specified by
                        <parameter>parts</parameter>.  See the man page for
                        <function>writev</function> for the definition of
                        <type>iovec</type>.  <parameter>numParts</parameter>
                        specifies the number of parts.
                    </para>
                    <para>
                        The message is sent with a tag of <literal>1</literal>
                        indicating the message is data
                    </para>
                </listitem>
            </varlistentry>
    
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual  </modifier>
                        <type>void    </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends an empty message with tag <literal>0</literal>.
                        This indicates to the peer that no more data is
                        available to be sent.
                    </para>
                </listitem>            
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int </type>
                        <methodname>setReceiver</methodname>
                        <methodparam>
                            <type>int</type><parameter> rank</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the target of the next send to be
                        <parameter>rank</parameter> in the current communicator.
                        The method returns the rank of the receiver
                        prior to this call.  If there was no prior receiver,
                        the method returns <literal>-1</literal> wich is not
                        a legal process rank.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int </type>
                        <methodname>getLastReceivedTag</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the tag of the most recently received message.
                        If the object has not yet received a message,
                        <literal>-1</literal> is returned. Note that
                        <literal>-1</literal> is, I think, a legal MPI tag so
                        I strongly suggest not using it in applications that
                        rely on this framework.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int </type>
                        <methodname>getLastReceivedRank</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the rank of the process from which the
                        most recently received message came.  If no messages
                        have been received yet, <literal>-1</literal> is
                        returned, which is an illegal rank.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>MPI_Comm </type>
                        <methodname>setCommunicator</methodname>
                        <methodparam>
                            <type>MPI_Comm </type><parameter>newComm</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the communicator that will be used to send and receive
                        messages to <parameter>newComm</parameter>.  This is our
                        one concession to support multiple communicators and
                        process groups.  The return value of this method is the
                        previous communicator and will always be legal because
                        the communicator the object is initialized with is
                        <literal>MPI_COMM_WORLD</literal>.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CMPIFanoutTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CMPIFanoutTransport</refname>
        <refpurpose>Fanout data over MPI to multiple workers.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CMPIFanoutTransport_mpi.h&gt;

class CMPIFanoutTransport : public CMPITransport, public CFanoutTransport
{

public:
    CMPIFanoutTransport();
    CMPIFanoutTransport(MPI_Comm communicator);

    virtual void recv(void** ppData, size_t&amp; size);
    virtual void send(iovec* parts,  size_t numParts);
    virtual void end();

    static const int dataRequestTag  = 2; 
};
        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This transport provides the supplier side of mechanism to fanout
            data chunks to multiple workers.  Fanouts allow for worker
            processes to operate in parallel on distinct chunks of data.
            Clients of this data accept it using a
            <classname>CMPIFanoutClientTransport</classname> class.
        </para>
        <para>
            At a low level, the protocol used is a pull protocol. When a worker
            is ready for data, it requests it by sending this rank an empty
            message with a <literal>dataRequestTag</literal> (value is
            <literal>2</literal>).  <methodname>send</methodname> operations
            read the next data request message and respond by sending the
            requested data to the rank that sent the data request.
        </para>
        <para>
            As each process sends a data request, it is rememebered and end
            of data is handled by sending end of datas as requested until all
            registered requestors have received the end..
        </para>
    </refsect1>
    <refsect1>
        <title>METHOD</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CMPIFanoutTransport</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a new fanout transport using the
                        default communicator
                        (<literal>MPI_COMM_WORLD</literal>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CMPIFanoutTransport</methodname>
                        <methodparam>
                            <type>MPI_Comm </type><parameter>communicator</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the transport using an alternate
                        <parameter>communicator</parameter>.  Note that
                        since the transport is not point to point, there's not
                        a concept of the receiver rank. 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp;</type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Throws an <classname>std::logic_error</classname>
                        as this transport is uni-dicectional.
                    </para>
                    
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends the message to the next requestor using the underlying
                        transport. You can think of this as having the
                        following pseudocode implementation:
                    </para>
                    <informalexample>
                        <programlisting>

get request message using base class recv.
get rank of request message sender after ensuring the tag is a data request tag.
set receive rank of base class.
send message using base class send.

                        </programlisting>
                    </informalexample>
                    <para>
                        Note that in the above pseudo code, if the
                        message received when getting the data request is non-empty,
                        or is not tagged by a <literal>dataRequestTag</literal>,
                        the method throws a <classname>std::logic_error</classname>
                        exception
                    </para>
                    <para>
                        Note as well that request messages from first time requestors
                        result in the rank of the requestor being entered in
                        a registry of clients.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type> void </type>
                        <methodname>end</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sends an end to all clients.  The pseudo code for this
                        is essentially:
                    </para>
                    <informalexample>
                        <programlisting>
while the client registry is not empty:
    get a data request as in <methodname>send</methodname>
    send an end message to the requestor.
    Remove the requestor from the client registry.
endwhile
                        </programlisting>
                    </informalexample>
                    <para>
                        Note that it's therefore important for there not to
                        be so many workers
                        for a small data set that some of them never get any data.
                        If that happens, it's possible the client registry can be
                        empty before some of those workers requested data and
                        received end messages.
                    </para>
                    <para>
                        For very small data sets, it might be wise to only
                        constitute a single worker.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CMPIFanoutClientTransport</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CMPIFanoutClientTransport</refname>
        <refpurpose>Worker side of a fanout transport (client).</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CMPIFanoutClientTransport_mpi.h&gt;

class CMPIFanoutClientTransport
    : public CMPITransport, public CFanoutClientTransport
{
public:
    CMPIFanoutClientTransport(int distributor);
    CMPIFanoutClientTransport(
        MPI_Comm communicator, int distributor
    );

    virtual void recv(void** ppData, size_t&amp; size);
    virtual void send(iovec* parts,  size_t numParts);
    virtual void setId(uint64_t id) {} 

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Objects of this class should be used to get data from
            a fanout tranposrt (MPI).  Note that for MPI transports, the
            ID of the client is always its rank in the communicator.  This implies
            that the communicator used by the fanout and its client must be the
            same.  This also implies that the
            <methodname>setId</methodname> method, in fact, actually does nothing.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CMPIFanoutClientTransport</methodname>
                        <methodparam>
                            <type>int </type><parameter>distributor</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a fanout client using the default
                        communicator (<literal>MPI_COMM_WORLD</literal>).
                        <parameter>distributor</parameter> is the rank of the
                        process that is fanning out the data (the one with
                        the <classname>CFanoutMPITransport</classname> object).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CMPIFanoutClientTransport</methodname>
                        <methodparam>
                            <type>MPI_Comm </type><parameter>communicator</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type><parameter>distributor</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        This constructor also accepts a
                        <parameter>communicator</parameter> that will be used for
                        all message passing. This communicator must be the same
                        as the one used by the peer
                        <classname>CMPIFanoutTransport</classname> object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>recv</methodname>
                        <methodparam>
                            <type>void** </type><parameter>ppData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t&amp; </type><parameter>size</parameter>
                        </methodparam>
                         
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Gets data from the fanout.  A pointer to the received
                        data (when done, the application must call
                        <function>free</function> to release it) is
                        stored in <parameter>ppData</parameter>.  The
                        number of bytes of data received are stored in
                        <parameter>size</parameter>.
                    </para>
                    <para>
                        The pseudo code for this can be though of as:
                    </para>
                    <informalexample>
                        <programlisting>
send request for data to <literal>distributor</literal>.
receive message from distributor.
                        </programlisting>
                    </informalexample>
                    <para>
                        Note that the caller needs to ensure the data received
                        are not an end.  While this could be done by asking
                        for the message tag, a more transport portable method
                        is to check for an empty message.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>send</methodname>
                        <methodparam>
                            <type>iovec* </type><parameter>parts</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>numParts</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Since this transport is unidirectional at the application
                        level, this method throws a
                        <classname>std::logic_error</classname> exception.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void  </type>
                        <methodname>setId</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>id</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This operation is provided as required by the
                        base class but is a No-op as the client id is always
                        the class of the program in the communicator used to
                        construct the object.  This communicator must be the
                        same one used to construct the
                        peer <classname>CMPIFanoutTransport</classname>
                        object.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingItemMPIDataSource</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingItemMPIDataSource</refname>
        <refpurpose>Fanout clumps of ring items.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingItemMPIDataSource.h&gt;

class CRingItemMPIDataSource : public CRingItemBlockSourceElement
{
public:
    CRingItemMPIDataSource(const char* ringUri,  size_t chunkSize=1);

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class fans out data from ring buffer structured files or
            live ring buffers.  To use this, construct it and then call
            the base class's <methodname>operator()</methodname> functor
            method.  The object then reads data from the ring item data
            source and fans it out to its clients until there's no more
            data (never for a live ring, end of file for a file).
        </para>
        <para>
            The constructor parameter <parameter>ringUri</parameter>
            identifiles the data source and can be either a file
            (<literal>file:</literal> protocol URI) or a live ring
            (<literal>tcp:</literal> protocol URI).
        </para>
        <para>
            The <parameter>chunkSize</parameter> parameter allows you to tune
            the performance efficiency of the transport.  Each message will
            <parameter>cunkSize</parameter> complete ring items unless an
            end file is hit prior to filfilling this obligations.
        </para>
    </refsect1>

</refentry>
<!-- /manpage -->
