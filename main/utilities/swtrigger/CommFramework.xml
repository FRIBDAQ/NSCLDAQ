<!-- chapter libraries -->

<chapter>
    <title>Parallel programming framework</title>
    <para>
        There are many types of parallel programming.  One classic model
        for parallel programming is that of
        <firstterm>Communicating Sequential Processes</firstterm> (CSP).
        CSP models a parallel program as a set of sequential, or serial programs
        that talk to each other.  
    </para>
    <para>
        Within CSP two main models exist;
        <itemizedlist>
            <listitem>
                <para>
                    Threaded - when parallelism is confined to a single
                    shared memory multi-core system, where all communication
                    is internal to that system.
                </para>
            </listitem>
            <listitem>
                <para>
                    Distributed - when the application is spread out over some
                    networked set of nodes.  Normally these nodes are
                    interconnected via a high performance low latency
                    <firstterm>network fabric</firstterm>.
                </para>
                <para>
                    Linux, Beowulf clusters are a pretty popular platform
                    on which to build distributed parallel programs.
                </para>
            </listitem>
        </itemizedlist>
    </para>
    <para>
        NSCLDAQ provides a high level library that insulates your program
        from the detailed mechanisms of specific message passing libraries.
        Programs written that only communicate via message passing can be
        easily rehosted from a threaded implementation to a distributed
        implementation, changing only initialization code.
    </para>
    <para>
        In this chapter we'll describe:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                The concepts and classes behind the library.
            </para>
        </listitem>
        <listitem>
            <para>
                The implementation state of the library including the set of
                communication systems that are implemented by the library at this
                time and a roadmap describing planned future developments.
                Pointers will be given to man page starting points for each
                implemented communication scheme.
            </para>
        </listitem>
        <listitem>
            <para>
                How to compile and link programs using this library.
            </para>
        </listitem>
    </itemizedlist>
    <section>
        <title>Concepts and classes</title>
        <para>
            Parallel programs build on top of this library consists of
            objects that communicate via messagse passing.  To limit the
            amount of data copying required, messages can, not only be
            a single block of data but can be a block list that's gathered
            by the library into a single message.
        </para>
        <para>
            The assumption is that a program consists of some source of data
            and that processing these data involve parcelling out work units
            to parallel processing objects. which then fan their
            results back in to processing objects that gather the  data.
        </para>
        <para>
            Thus the programming model has you stringing together a
            pipeline (each element of the pipeline runs in parallel) where
            stages of those pipelines may include stages that run multiple
            processors that operate in parallel on data streaming through the
            pipeline.
        </para>
        <para>
            The following classes, therefore, model several types of
            processing elements that can appear in these data/processing flows:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>CDataSourceElement</classname></term>
                <listitem>
                    <para>
                        These elements are intended to connect the
                        program to concrete sources of data.  In NSCLDAQ
                        these sources can be ring items, files or some
                        other communicating processor (internal or external).
                    </para>
                    <para>
                        These elements are normally at the start of the
                        processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CDataSinkElement</classname></term>
                <listitem>
                    <para>
                        These elements are intended to connect the program
                        to some concrete sink of data.  In NSCLDAQ, sinks can
                        be ring buffers, files or other communicating processors.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CParallelWorker</classname></term>
                <listitem>
                    <para>
                        A generic parallel worker.  This is normally used
                        to encapsulate code that runs in the data parallel
                        segments of the computation.  Normally this
                        encapsulation 
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            From these classes you can see that the computation normally takes
            the form of a pipeline where data comes from a
            <classname>CDataSourceElement</classname> runs through
            several <classname>CParallelWorker</classname> elements
            and then in the end data is emitted from the program via
            a <classname>CDataSinkElement</classname>
        </para>
        <para>
            Having these classes is all well and good, but how do they communicate
            with each other?  Following the pipeline model, each element
            of the computation gets its data from
            a <classname>CReceiver</classname> and sends the results of its
            computation to the next stage of the pipeline
            via a <classname>CSender</classname>.
        </para>
        <para>
            <classname>CReceiver</classname> and
            <classname>CSender</classname> objects encapsulate another
            class derived from
            <classname>CTransport</classname>.  Transport classes are
            actual do the messaging required by the receiver and sender objects.
            In doing so, the contain code specific to the type communication
            library being used (e.g. MPI or ZeroMQ), and they also encapsulate
            a specific communication pattern.
        </para>
        <para>
            Some base classes for transports are:
        </para>
        <variablelist>
            <varlistentry>
                <term><classname>CTransport</classname></term>
                <listitem>
                    <para>
                        The abstract base class for all transports.  This class
                        provides the interfaces used by sender and receiver
                        objects to request actual communication.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CFanoutTransport</classname></term>
                <listitem>
                    <para>
                        Abstract base class for transports that fan-out work items
                        to data parallel sections of the program.  In addition
                        to the data transfer interfaces, this class
                        provides interfaces to inform the members of the
                        fanout that there is no more data available.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CFanoutClientTransport</classname></term>
                <listitem>
                    <para>
                        Abstract base class for transports that
                        get data from a fanout transport.  The model provided
                        requires that each client provide a unique integer
                        client identifier.  This class encapsulates interfaces
                        for both setting the id and communicating the id to the
                        other end of the transport.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Thuse the computation can be made up of processing elements that
            get and send data without actually knowing how that's done.  Program
            initialization can select actual transports and bind them into
            processing elements.  If necessary, program initialization can also
            allocate processors to computing resources.
            This allows a computation to be rehosted without the actual
            computing elements being aware of the process.
        </para>
    </section>
    <section>
        <title>Transport implementations</title>
        <para>
            At present only ZeroMQ (ZMQ) transports are supported.  We
            plan to implement MPI transport in the future.  Other transport
            types will be implemented as demand indicates.
        </para>
        <section>
            <title>Details of ZMQ transport implementation</title>
            <para>
                The goal here is not to get into the nitty gritty of ZMQ
                socket types used in the various transports, but to describe
                facilities available to assist you in setting up ZMQ based
                parallel programs. 
            </para>
            <para>
                One facility the library provides is a factory that provides
                you with transport factories for the specific communication
                system you are using.   The factory knows how to create
                transports for communication patterns implemented on top of
                a specific transport library.
            </para>
            <para>
                The <classname>CCommunicatorFactoryMaker</classname>
                singleton class represents this factory of factories.  The
                code fragment below shows how to get a communication
                factory for ZMQ communications:
            </para>
            <informalexample>
                <programlisting>
#include &lt;CCommunicatorFactoryMaker.h&gt;
#include &lt;CCommunicatorFactory.h&gt;
..
..
CCommunicatorFactory* pZmqFactory = CCommunicatorFactoryMaker::getInstance()-&gt;
    create("ZeroMQ CommunicationSystem");
if (!pZmqFactory) {
    std::cerr &lt;&lt; "ZEROMQ factory not in the factory of factories\n";
    exit(-1);
}
....

                </programlisting>
            </informalexample>
            <para>
                One problem that needed solving to provide a generic
                communicator factory was how to identify communication endpoints.
                For example a raw TCP/IP socket uses a host/port pair to
                identify an end point, ZMQ uses an URI to identify end endpoint
                and so on.
            </para>
            <para>
                Communicator factories use unsigned integers to identify
                endpoints.  While this maps directly to e.g. MPI ranks,
                there must be a mechanism for the ZMQ factory to map these
                identifiers onto URIs.
            </para>
            <para>
                This is done by you, providing one or more zmq service map files.
                A zmq service map file is a text file.  Lines beginning with
                <literal>#</literal> are ignored as are lines that consist
                only of whitespace.  Leading and trailing whitespace are also
                ignored.
            </para>
            <para>
                Mapping lines, consist of two fields. The first is an integer
                transport id and the second is the ZMQ URI that will be used
                when that transport endpoint is selected. For example;
            </para>
            <informalexample>
                <literallayout>
    1 tcp://somenode.in.my.network:1234
                </literallayout>
            </informalexample>
            <para>
                Maps the transport identifier <literal>1</literal> to  a TCP
                transport with an endpoing of port number <literal>1234</literal>
                whose server is in a
                system named <literal>somenode.in.my.network</literal>.
            </para>
            <para>
                We therefore need to know, additionally, which transports are
                servers and which are clients.
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Fanout transports are servers and their clients are not.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Fan in sinks are servers fanin sources are not.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        One-to-One sources are servers, clients are not.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                The transport id/URI map is built up by reading all files found in
                
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        <literal>$HOME/.zmqservices</literal>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <literal>./zmqservices</literal>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The file pointed to by the environment variable
                        <literal>ZMQ_SERVICES</literal>.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                See the reference information for more about the transport
                types these factories can create.
            </para>
        </section>
    </section>
    <section>
        <title>Compiling and linking parallel programs</title>
        <para>
            This section assumes you've set up the NSCLDAQ environment variables
            before building your code.
        </para>
        <para>
            All headers are in <literal>$DAQINC</literal>, therefore,
            compilations must have <literal>-I$DAQINC</literal> (
            <literal>-I$(DAQINC)</literal> in Makefiles).
        </para>
        <para>
            The library is locaed in <literal>$DAQLIB</literal> It is called
            <filename>libSwTrigger.so</filename>.  It also depends on
            several other libraries in and out of NSCLDAQ:
        </para>
        <informalexample>
            <literallayout>
... -L$DAQLIB -lSwTrigger -ldataformat -ldaqthreads \
    -lDataFlow -lPortManager -ldaqshm -lException -lzmq -Wl,-rpath=$DAQLIB
            </literallayout>
        </informalexample>
        <para>
            In a Makefile you can use environment variable substitution:
        </para>
        <informalexample>
            <literallayout>
... -L$(DAQLIB) lSwTrigger -ldataformat -ldaqthreads \
    -lDataFlow -lPortManager -ldaqshm -lException -lzmq -Wl,-rpath=$(DAQLIB)
            </literallayout>
        </informalexample> 
    </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3daq -->
<refentry>
    <refmeta>
        <refentrytitle>CProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CProcessor</refname>
        <refpurpose>Abtract base class for a CSP process</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CProcessor.h&gt;

class CProcessor
{
public:
    virtual ~CProcessor() {}
    
    virtual void process(void* pData, size_t nBytes, CSender&amp; sender) = 0;
};
        </synopsis>

    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This class is a key abstract base class for the NSCLDAQ parallel
            processing framework.  The class provides interfaces for a process
            that participates in parallel sequential processing.  The idea
            is that a concrete processor class is encapsulated in a class
            that accepts data from some source.  
        </para>
        <para>
            When data is received the encapsulating class calls then
            <methodname>process</methodname> class handing it both the
            data and a <classname>CSender</classname> object that can
            be used to send data to the next stage of the processing pipeline.
            Concrete implementations must implement this
            <methodname>process</methodname> method.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>
                        <type>void</type>
                        <methodname>process</methodname>
                        <methodparam>
                            <type>void*</type><parameter>pData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type><parameter>nBytes</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CSender&amp;</type><parameter>sender</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the method that concrete classes must implement.
                        When constructing a parallel pgoram, the user normally
                        creates a set of concrete processors that operate on
                        work items producing output data.  These processor
                        objects are then encapsulated in an object that has been
                        bound to a <classname>CReceiver</classname> that
                        accepts work items from the previous stage of the
                        processing pipeline and a
                        <classname>CSender</classname> that is connected
                        to the next stage of that pipeline.
                    </para>
                    <para>
                        The containing object, when run will accept work items
                        from its <classname>CReceiver</classname> and
                        call its processor's <methodname>process</methodname>
                        method.  That method is expected to do whatever
                        application specific processing is required to produce
                        output data and to send that output data to the next
                        stage of the processing pipeline.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    
    <refentry>
        <refmeta>
            <refentrytitle>CProcessingElement</refentrytitle>
            <manvolnum>3daq</manvolnum>
        </refmeta>
        <refnamediv>
            <refname>CProcessingElement</refname>
            <refpurpose>Abstract base class for a CSP processing element</refpurpose>
        </refnamediv>
        <refsynopsisdiv>
            <synopsis>
#include &lt;CProcessingElement&gt;

class CProcessingElement
{
public:
    virtual ~CProcessingElement() {}
    
    virtual void operator()()  = 0;
    virtual void process(void* pData, size_t nBytes) = 0;
};

            </synopsis>
        </refsynopsisdiv>
        <refsect1>
            <title>DESCRIPTION</title>
            <para>
                Processing elements contain flow of control that typically
                accepts data, processes it and then sends resulting data to
                a subsequent stage of the data processing pipeline.
                Concrete <classname>CProcessingElements</classname> often
                construct with parameters that include a
                <classname>CReceiver</classname> to receive the data,
                a <classname>CSender</classname> to send processed data and a
                <classname>CProcessor</classname> to do the actual processing.
            </para>
            <para>
                In the prototoypical processing element, the
                <methodname>operator()</methodname> method will use the objects'
                <classname>CReceiver</classname> to obtain work elements.
                <methodname>process</methodname> would then be called which
                would, in turn, call the <methodname>process</methodname>
                method of an encapsulated <classname>CProcessor</classname>
                object.
            </para>
            <para>
                <methodname>operator()</methodname> would also be responsible
                for knowing when the last work item has been received and
                shutting down the object after that has been processed.
                In a typical, application, an empty data item might be a flag
                that there are no more data items and the processor's
                <methodname>process</methodname> would, in turn, be
                responsible for notifying subsequent stages of the computation,
                if appropriate.
            </para>
            <para>
                Concrete classes must implement both
                <methodname>operator()</methodname> and
                <methodname>process</methodname>.
            </para>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>void</type>
                            <methodname>operator()</methodname>
                            <void />
                            <modifier> = 0</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This method is supposed to implement the
                            flow of control of the processing element.
                            Normally this is a loop with the logic like the
                            pseudocode below
                        </para>
                        <informalexample>
                            <programlisting>
do {
    workItem = getWorkItem()
    process(workItemData, workItemSize)
    
} while(workItem is not end of data)
Shutdown the object
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>void</type>
                            <methodname>process</methodname>
                            <methodparam>
                                <type>void*</type><parameter>pData</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type><parameter>nBytes</parameter>
                            </methodparam>
                            <modifier>=0</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Processes a work item of data received by
                            <methodname>operator()</methodname>.  Normally,
                            implementations of this method have the form:
                        </para>
                        <informalexample>
                            <programlisting>
outputData = processTheData(pData, nBytes)
sendToNextStage(outputData)
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
    </refentry>
    
</refentry>
<!-- /manpage -->