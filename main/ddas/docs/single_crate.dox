/**
@page single_crate Single-Crate System Setup Guide

@authors Aaron Chester, Ron Fox, Jeromy Tompkins
@date 4/3/24

@tableofcontents

@attention This single-crate system setup guide is specific to DDAS systems running NSCLDAQ 12 and later, which has a handful of major features that which were not part of previous releases:
1. The module data readout and sorting processes are decoupled. As a consequence, readout program data sources must be configured in a slightly different manner.
2. The DDAS codebase has been refactored into NSCLDAQ, there is no need to source a DDAS setup script in e.g. /usr/opt/ddas.
3. External clock readout has been absorbed into the main readout program. There is no longer a separate version of the DDAS readout for this purpose.
4. As of XIA API major version 3, settings files are saved in JSON format. Files with names like crate_1.json are the JSON version of the binary settings files generally named crate_1.set for previous XIA API releases.

@section sec_singlecrate_intro Introduction
@par
This document describes the simplest DDAS setup: A single PXI crate with one
digitizer. Throughout, there will be suggestions on how to expand this setup so
that it has several digitizers. This material is organized as follows:

- First, an overview of the components of a single crate DDAS system are given.
- Second, we provide a guide to setting up the hardware. A pulser will be used as a signal source.
- The configuration files for the @ref cfgpixie16 "system" and @ref modevtlen "expected event length" required by DDAS are described.
- @ref qtscope "QtScope" will be used to obtain an initial parameter setup.
- We will set up a @ref readout "readout" so that data can be taken from the sample setup. We'll also look at a dump of the data from the simple setup with and without waveforms.
- We'll show how to set up the ReadoutGUI and event builder so that data can be taken, built into events, recorded, and made available for online analysis.
- We will set up a simple SpecTcl tailoring for data with and without waveforms.
- We will import the data into ROOT so that offline analysis can @ref ddasdumper "proceed with that tool".

@section sec_singlecrate_components Components of a DDAS System
@par
DDAS data acquisition systems and online analysis rely on several hardware and
software components:

- A PXI Crate. PXI is an extension to the compact PCI standard that supports precision timing.
- One or more XIA digitizer cards.
- An interface between an NSCL spdaq system and the PXI crate or a crate-resident single-board computer (SBC). These two options will be referred to as the data-collection computer.
- A readout program that runs in the data-collection computer that reads data from the digitizer cards and places them into a <em>raw ringbuffer</em>. This readout program is the interface between the PXI crate and the NSCLDAQ software.
- A sorter program which reads data from a raw ringbuffer, maintains a master list of sorted hits, and outputs those hits into a <em>sorted ringbuffer</em> for event building.
- An event builder. The event builder takes data from sorted ringbuffers, builds events that satisfy a coincidence interval using the DDAS timestamp and places those built events in an <em>output ringbuffer</em>. Note that while in principle the event builder is not necessary for single-crate systems, using it for those systems maintains a common event format between single- and multi-crate systems.
- A ReadoutShell instance that manages readout, sorting, event logging and event building.
- A SpecTcl tailored to decode DDAS data and analyze it in an experiment-specific manner.

@par
The following figure shows a schematic representation of a DDAS hardware configuration using one crate:

@image html single_crate/hardware_schematic.png "A schematic DDAS hardware configuration. A PXI crate with an SBC used as the data-collection computer and a single Pixie module is connected via the NSCL DAQ network to an analysis computer." height=400px

@par
The data flow through such a system looks like:

@image html single_crate/dataflow.png "Data flow through a DDAS system running NSCLDAQ 12. Note the separation of module data readout and sorting, which were previously part of a single process. This configuration enables much higher data readout speeds." height=800px

@par
A couple of points are worth noting:
- The analysis computer is not strictly necessary. All of the software can be run on the data-collection computer.
- In the usual production configuration (i.e. during an experiment) the only program that will run on the data-collection computer is the readout program. All other pieces of the software shown on the above figure will run other places.
- For multi-crate systems, the schematics can be expanded by adding additional crates to the hardware diagram and additional readout and sort paths feeding the event builder to the data flow diagram.
- Adding additional digitizers to an already-configured system is (mostly) just a matter of editing the system configuration files.

@section sec_singlecrate_setup Setting Up a Single-Crate System
@par
The DDAS software is installed as part of the NSCLDAQ software package. There may be several versions of NSCLDAQ installed concurrently on lab computers. In general these will be located under /usr/opt/daq on FRIB computer systems. Each NSCLDAQ installation has a version number MM.mm-eee where MM refers to the major version, mm to the minor version, and eee to an edit level e.g. 12.0-017 with major version 12, minor version 0, and edit level 15. Edit-level changes reflect minor defect fixes or enhancements, minor-version changes reflect more impactful bugfixes or enhancements. Major version changes are generally quite significant and may require significant rewrites of user code.

@par
Each NSCLDAQ version's top-level directory includes a `daqsetup.bash` script which can be sourced to set the following environment variables:
- `DAQROOT`- Points to the top-level NSCLDAQ installation directory (containing the `daqsetup.bash` script.
- `DAQBIN` - Points to `$DAQROOT`/bin, the directory containing NSCLDAQ executables.
- `DAQLIB` - Points to `$DAQROOT`/lib, the directory containing NSCLDAQ libraries which DDAS applications and user code may need to link against.
- `DAQINC` - Points to `$DAQROOT`/include, the directory containing NSCLDAQ header files including those for DDAS.
- `DAQSHARE` - Points to `$DAQROOT`/share, a directory containing documentation, program skeletons, and scripts.

@subsection sec_singlecrate_plx Loading the PLX Kernel Driver
@par
Users are no longer required to load the PLX kernel module by hand on each data-readout computer installed as part of your DDAS system. The kernel module is loaded automatically on system startup.

@subsection sec_singlecrate_config Configuration Files Needed by NSCL DDAS
@par
Many of the DDAS software components require a set of configuration files to be in the current working directory. These configuration files describe the configuration of modules in a crate and point at a settings file containing the parameters used by the digital signal-processing (DSP) algorithms for each module in use. By convention a directory subtree is used to hold the configuration files for each crate. The tree will look something like:

@verbatim
home-directory
      |
      +--- readout
              |
              +--- crate_1  (configuration for crate 1).
              +--- crate_2  (configuration for crate 2 if needed).
              ...
              +--- crate_n  (configuration for last crate, n).
@endverbatim

@par
We can expand the full directory tree for a single-crate system:

@verbatim
home-directory
     |
     +-- readout
            |
            +--- crate_1
                    |
                    +--- cfgPixie16.txt
                    +--- modevtlen.txt
                    +--- crate_1.json

@endverbatim

@par
An example crate_1 directory which can be copied to your system can be found at `$DAQSHARE`/ddasreadout/crate_1. This example directory contains the necessary configuration files to run a DDAS system. The files are:
- cfgPixie16.txt - Indicates where modules are installed in the crates and points to a parameter settings file containing their DSP settings. See the documentation for this file @ref cfgpixie16 "here".
- modevtlen.txt - Describes the number of 32-bit words in a hit for each module. See the documentation for this file @ref modevtlen "here".
- crate_1.json - An XIA API 4 parameter settings file.

@par
See 

@note While `$DAQSHARE`/ddasreadout/crate_1 contains a valid set of configuration files for DDAS, there is no guarantee that the configuration files or settings file in the example directory are correct for any given system. You will may need to edit all of these files in order to get your system running correctly. Typical changes are:
- cfgPixie16.txt must be modified to reflect the layout of modules in your crate. The path to the settings file must be correct.
- The name of the JSON settings file must match that within the cfgPixie16.txt file.
- modevtlen.txt must be modified to reflect your actual event sizes if extra data words from e.g. QDC sums or trace data is expected.

@section sec_singlecrate_setup Setting Up a Single-Crate System
@par
This part of the guide will discuss in detail how to setup a single-crate DDAS system with a single XIA digitizer card. You must:
1. Ensure that there is an SBC or fiber interface in slot 1 of the PXI crate (the most common case). If a fiber interface is used, the fiber must be connected to the interface card and a PCI bridge card on the data-collection computer. The data-collection computer must be connected to the DAQ network.
2. Install a Pixie module configured as a clock master in slot 2 of your crate.
3. Attach signals to the digitizer inputs. One of the nice things about digital data acquisition modules is that only minimal signal conditioning is required and the modules themselves handle triggering. For this tutorial we're going to take singles data. The modules actually support very sophisticated internal triggering modes as well as cross-module trigger processing via a front-panel trigger bus.
4. Configure your DSP settings.

@par
Step 1 is relatively straightforward and need not be discussed further. Steps 2-4 are more complex and will be covered in detail in the subsequent sections.

@warning SBCs, fiber cards and modules are **NOT** hot-swappable. **DO NOT** connect or disconnect SBCs, fiber cards or modules from the crate while it is powered on. Before installing or replacing any DDAS hardware, ensure that the crate is powered off.

@subsection sec_singlecrate_clock Configuring a Clock Master Module
@par
When using several DDAS cards it is important to synchronize the digitizer clocks between them. This is done by setting the jumper block JP01 appropriately. The jumper block is a set of pins located on the board near the backplane connectors, shown on the figure below in the red box. Configure the connections between these pins with jumpers. In case your setup consists of a single module, be sure to configure the jumpers to match the top diagram for the PXI clock master.

@image html single_crate/board_and_jumpers.png "[Left] A Pixie-16 board with the location of the JP01 jumper block shown in the red box. [Right] Schematic of the  jumper settings for distributing the clock across the PXI backplane for a single-crate system. Top: PXI clock master jumper settings (slot 2). Bottom: PXI clock recipient jumper settings (slots 3-14). Figures reprinted from 'Pixie-16 User Manual', Version 3.06, XIA LLC." height=400px

@par
In this configuration your clock-master module must be installed in slot 2. If more modules are added to the system, their jumper configuration should match the configuration shown on the bottom right of the above figure.

@subsection sec_singlecrate_testsignal Configuring an Input Signal
@par
A test signal from a pulser is used for this tutorial. Setup the pulser to output pulses that rise quickly but have an approximately 50 &mu;s decay time. The test pulse should be negative (-) polarity, have an input voltage of less than 1 V and a frequency less than 5 kHz. Connect the test signal to channel 0 of the digitizer 

@subsection sec_singlecrate_configfiles Example configuration files
@par
The setup described in this tutorial uses a single digitizer installed in slot 2 of the PXI crate. Our DSP settings are stored in the file crate_1.json in a readout directory on our development system. Our cfgPixie16.txt file looks like:

@verbatim
1  # crateID
1  # number of modules
2  # slot for mod 0
/user/0400x/ddas_xiatest/readout/crate_1/crate_1.json
@endverbatim

@par
The modevtlen.txt file must consist of (at least) a single line specifying that there are 4 expected data words (no optional settings are enabled).

@subsection sec_singlecrate_setdpp Configuring DSP Settings Using QtScope
@par
Once you have a correctly configured working directory, it is time to program the module with appropriate settings for the test signal. The QtScope program is used to view input waveforms and set DSP parameters. QtScope is installed as part of the NSCLDAQ software package and should be run by:
1. `source /usr/opt/daq/12.1-xiaapi4/daqsetup.bash`.
2. `$DAQBIN/qtscope`

@image html single_crate/qtscope_unbooted.PNG "The QtScope GUI state on startup. Note that most GUI elements besides [Boot system], [About], and [Exit] on the system toolbar are disabled." width=1200px

@par
The QtScope GUI will launch. See the @ref qtscope "QtScope documentation" for more details, only the basics are covered in this guide. Most features of the GUI are inaccessible (greyed out) until the modules have been booted. To boot the modules, click the **[Boot system]** button. QtScope will print some information on the terminal where it was launched. A successful boot will look something like:

@verbatim
------------------------
Initializing PXI access...
System initialized successfully.
Found Pixie-16 module #0, Rev = 15, S/N = 1150, Bits = 16, MSPS = 250

Booting Pixie-16 module #0
        ComFPGAConfigFile:  /usr/opt/ddas/firmware/2.2-000/firmware/syspixie16_current_16b250m.bin
        SPFPGAConfigFile:   /usr/opt/ddas/firmware/2.2-000/firmware/fippixie16_current_16b250m.bin
        DSPCodeFile:        /usr/opt/ddas/firmware/2.2-000/dsp/Pixie16_current_16b250m.ldr
        DSPVarFile:         /usr/opt/ddas/firmware/2.2-000/dsp/Pixie16_current_16b250m.var
        DSPParFile:         /user/0400x/ddas_xiatest/readout/crate_1/crate_1.json
------------------------------------------------------

All modules ok
QtScope system configuration complete!
@endverbatim

@par
If the boot fails, detailed error messages are written to Pixie16Msg.log and qtscope.log. Looking at the information contained in these log files should provide some context for the boot error and may point to a solution.

@subsubsection sec_singlecrate_conditioning Analog Signal Conditioning
@par
The first thing we must do is setup the ADC for our input signal. First, lets look at a trace. Click the **[Read trace]** button until you see a full waveform trace. Here is an example trace:

@image html single_crate/qtscope_badpol.PNG "A raw pulser trace captured by QtScope. The DSP settings have not been properly configured for the test pulse, see the text for details."

@par
No matter the input signal polarity, the QtScope canvas should display a positive-polarity signal. Knowing that, two things immidiately jump out about the above example:
1. The displayed signal polarity is wrong. This is an indication that a negative-polarity signal is assumed to be positive by the Pixie DSP FPGA.
2. The signal is clipped. That is, the pulse is out of range of the ADC, in this case, extending below 0.

@par
In order to correct these issues we need to configure some channel DSP settings on the module. Clicking on the **[Channel DSP]** button will open a popup menu that looks like:

@image html analog_singnal_start.PNG "The QtScope analog signal conditioning tab." width=600px

@par
Our pulser test signal is plugged in to channel 0. Using the combo box in the polarity column, select negative (-) polarity for channel 0. Click the **[Apply]** button at the bottom of the channel DSP window to program the module with the new settings. Our analog signal tab now looks like:

@image html analog_singnal_goodpol.PNG "The QtScope analog signal conditioning tab with the polarity on channel 0 set correctly for our negative-polarity test signal." width=600px

@par
If we acquire another trace with these settings, we see:

@image html qtscope_tracesat.PNG "A raw pulser trace captured by QtScope. The pulse polarity has been set correctly (the pulse is displayed with positve polarity), but the waveform is still clipped and overflows the ADC." width=1200px

@par
While the signal polarity has been configured correctly, the trace is still clipped, this time at the top of the ADC range. The DC offset must be adjusted such that the digitized signal falls within the voltage range of the ADC. Fortunately, the Pixie modules have a way of determining this offset automatically. Click the **[Channel DSP]** button to again bring up the channel DSP manager popup window. Clicking the **[Adjust offsets]** button on the AnalogSignal tab will prompt the module to automatically determine good DC offset values. By default, the DC offset will be automatically set such that the signal baseline sits at approximately 10% of the full ADC range. Do not forget to click the **[Apply]** button after adjusting the offsets!

@image html analog_singnal_conditioned.PNG "The QtScope analog signal conditioning tab after automatic adjustment of the DC offset values." width=600px

@par
Reading another waveform gives the expected signal:

@image html qtscope_goodtrace.PNG "A raw pulser trace captured by QtScope with correctly configured polarity and DC offset. The full pulse is within the voltage range of the ADC." width=1200px

@subsubsection sec_singlecrate_trigger Configuring the Trigger Filter
@par
Next we will configure the trigger settings for our test signal. Open the channel DSP manager window and select the TriggerFilter tab. This tab contains the DSP settings which parameterize the trapezoidal filter used to construct a leading-edge trigger for the input signal. An in-depth discussion of trapezoidal filters and other pulse-processing methods are beyond the scope of this guide; for more information refer to @ref sec_singlecrate_reading.

@par
Our test signal has a fixed amplitude and pulse shape and very little noise. Note that in general only some (or none!) of these things may be true. We will use a triangular filter with a risetime of 100 ns and a gap of 0 ns. The triangular filter is simply a special case of a trapezoidal filter with a gap equal to 0. The value of the trigger threshold must be set such that we can trigger on the input test pulse; because we have a fixed-height pulse, there is not much to do here: We set the trigger to have a risetime of 100 ns, gap of 0 ns, and a threshold of 50. Once the settings are applied, note that the channel DSP GUI reports a trigger risetime of 104 ns: the filter parameter values must be an integer number of FPGA clock cycles and are automatically rounded to a valid value if they are not. Because the 250 MSPS modules use a 125 MHz FPGA, the filter lengths must be an integer multiple of 8 ns.

@image html trigger_filter_settings.PNG "The trigger filter settings for our test pulse. A triangular filter (gap = 0 ns) is used. Note that the risetime and gap of the filter must be integer multiples of the signal-processing FPGA clock cycyle which is equal to 10 ns for 100 MSPS and 500 MSPS modules and 8 ns for 250 MSPS modules." width=600px

@note In a production setup, the trigger threshold should typically be set as low as possible without triggering on noise and is detector- and environment-specific. 

@subsubsection sec_singlecrate_enefilter Configuring the Energy Filter and Pole-Zero Correction
@par
Next we will configure the settings necessary to generate a good energy spectrum from our test pulse. We should expect to see a high-resolution Gaussian energy response without any background. Make sure that the Channel Selection Box is set to display results from the channel the test signal is plugged into and that the "Read all" option is disabled. Start a histogram run by ensuring that "Energy hist." is displayed in the drop-down menu in the Run Control Box of the Acquisition Toolbar and clicking **[Beigin run]**. You should see the text

@verbatim
Beginning histogram run in Mod. 0
@endverbatim

@par
appear in the terminal window you used to launch QtScope. Click the **[Read data]** button a few times to read data into the histogram. If the DSP are set improperly, you might see the following:

@image html energy_bad.PNG "An energy spectrum for our test pulse acquired with bad energy DSP settings. The response is not Gaussian and is much broader than one would expect from a pulser signal." width=1200px

@par
Click the **[End run]** button to stop taking data. When the run is ended, an end-of-run message and run statistics are printed to the terminal where QtScope is running:

@verbatim
Ended histogram run in Mod. 0
Module 0 channel 0 input 1503.21 output 1503.21 livetime 48.5719 runtime 48.5719
Module 0 channel 1 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 2 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 3 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 4 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 5 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 6 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 7 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 8 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 9 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 10 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 11 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 12 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 13 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 14 input 0 output 0 livetime 48.5719 runtime 48.5719
Module 0 channel 15 input 0 output 0 livetime 48.5719 runtime 48.5719
@endverbatim

@par
where the input and output count rates give the rates of seen and accepted triggers (in triggers per second). The livetime and realtime count the amount of time (in seconds) the system was live and the total length of the run. System deadtime is calculable from these values: deadtime = (1 - livetime)/realtime.

@par
The energy response for our test signal is clearly non-Gaussian and has a resolution of approximately 1.8% FWHM. This is an indication that the DSP settings which govern the energy response are not set correctly. Four DSP parameters govern the energy response: the energy filter risetime, gap, and filter range which parameterize the trapezoidal filter used to determine the energy, and the tau parameter which sets the pole-zero correction for the filter output.

@par
The filter range parameter controls how many samples are averaged together prior to the energy filtering logic. In general this value should be set to the smallest value which can accomodate the filter length you want to use. The energy filter risetime and gap again parameterize the trapezoidal filter. The gap, which cannot be 0 for the energy filter, should be set to a value longer than the longest-expected risetime from your input signal. Optimizing the risetime depends on the particular properties of the signal, expected rate, desired resolution, etc., which depend on your particular system. The tau parameter should be set to the decay time constant of the input signal (for example, from a preamplifier).

@par
For our test signal, a risetime of 600 ns, gap of 256 ns and tau of 50 &mu;s are reasonable initial guesses based on how we configured the signal from the pulser:

@image html energy_settings.png "The EnergyFilter [left] and Tau [right] DSP settings used for our test signal in channel 0." width=1200px

@par
Once applied, a new energy spectrum is acquired:

@image html energy_good.PNG "An energy spectrum for our test pulse acquired with good energy DSP settings. Note the Gaussian-like signal shape and improved energy resolution compared to the previous settings." width=1200px

@par
The peak more closely resembles the expected Gaussian shape, and the energy resolution is improved to approximately 0.2% FWHM. Further optimizations to the resolution and signal shape may be possible by varying the aforementioned parameters; this manner of detailed optmization is left as an exercise for the reader.

@subsubsection sec_singlecrate_save Save Your Updated Settings
@par
Once your test channel DSP is set to your satisfaction, save your settings by clicking the **[Save settings]** button. Enter a file name and click the "Save" button. Make sure to update your cfgPixie16.txt file so that it points to your updated settings file if needed!

@subsection sec_singlecrate_readout Taking Data With ddasReadout
@par
Now that you have a good settings file, you can take data using a readout program. In this section we will:
- Run the `ddasReadout` program, the readout driver for DDAS systems,
- Run the NSCLDAQ `dumper` program to look at raw event data,
- Take a bit of data and describe its format.
@par
Full documentation for the `ddasReadout` program is available @ref readout "here".

@par
The DDAS readout program does not need to be modified by you. It uses a set of configuration files that are expected to live in the current working directory when readout is run. These files were discussed in @ref sec_singlecrate_config. In the previous step you should have generated a new settings file and edited your cfgPixie16.txt file if necessary. The modevtlen.txt file must be edited to reflect the size of the events we expect coming from each module. We are using only a single module and not taking waveforms from that module. Since the modevtlen.txt file format is simply the size of an event, in 32-bit units, from each digitizer's channels, one digitizer per line, in the same order as the cfgPixie16.txt file, the contents of this file should be:

@verbatim
4
@endverbatim

@par
which is the default Pixie channel data length in 32-bit words.

@subsection sec_singlecrate_readoutgui Running ddasReadout Using the ReadoutGUI

@subsection sec_singlecrate_cutiepy Analyzing Data With CutiePy

@section sec_singlecrate_conclusion Conclusions
@par
This concludes the single-crate setup tutorial. You should now have a good understanding of how to perform the basic steps necessary to configure a simple DDAS system to take data. The modules have many features which are not discussed in detail in this section, including a digitial CFD for precision timing, the ability to run complex coincidence triggers, or take additional data such as QDC sums or, more commonly, ADC trace data. Refer to the @ref qtscope "QtScope Manual" for more information.

@section sec_singlecrate_reading Further Reading
- G.F. Knoll, "Radiation Detection and Measurement," (John Wiley and Sons, Hoboken, NJ, USA, 2010), Fourth Edition. Specifically Chapters 16 (Pulse Processing) and 17 (Pulse Shaping, Counting, and Timing).

*/