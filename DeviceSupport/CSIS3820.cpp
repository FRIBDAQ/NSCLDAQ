/*
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions 
either of that version or of any later version published by the Free Software 
Foundation.  If the Program does not specify a version number of this License,
 you may choose any version ever published by the Free Software Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author to 
ask for permission.  For software which is copyrighted by the Free Software 
Foundation, write to the Free Software Foundation; we sometimes make 
exceptions for this.  Our decision will be guided by the two goals of 
preserving the free status of all derivatives of our free software and of 
promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN 
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE 
THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND 
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, 
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO 
LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR 
THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), 
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES.

		     END OF TERMS AND CONDITIONS '
*/

#include <config.h>

#include "CSIS3820.h"
#include <string>
#include <stdio.h>
#include <stdlib.h>

#ifdef HAVE_STD_NAMESPACE
using namespace std;
#endif


static const int ModuleSize(0xb00);


// Below are register offsets into the module:

				// CSR
static const unsigned long CSR(0);
static const unsigned int  LEDOn(1);
static const unsigned int  LEDOff(0x10000);
static const unsigned int  LEDIsOnMask(1);
static const unsigned int  ISARMED(0x1000000);
static const unsigned int  SCALERENABLED(0x10000);
static const unsigned int  MCSENABLED(0x40000);
static const unsigned int  ENABLEREFPULSER(0x40);
static const unsigned int  DISABLEREFPULSER(0x400000);
static const unsigned int  ENABLETESTPULSER(0x30);
static const unsigned int  DISABLETESTPULSER(0x300000);
static const unsigned int  REFPULSERON(0x40);
static const unsigned int  TESTPULSERON(0X30);

				// Module Id/Firmware register

static const unsigned long IdAndFirmware(0x4);
				// The id part of the register:
static const unsigned int  IDShift(16);
static const unsigned int  IDMask(0xffff); // After shift that is.
				// The revlevel part:
static const unsigned int  REVMask(0xff);  // Revision fields 8bits
static const unsigned int  MAJORShift(8); 


                               // Acquisition mode register

static const unsigned int ACQMode(0x100);
static const unsigned int OperatingModeMask(0x70000000);
static const unsigned int InputModeMask(0x0070000);
static const unsigned int LatchModeMask(0x00000070);
static const unsigned int NONCLEARINGMODE(1);

				//  Reset key register.

static const unsigned int RESET(0x400);

				// Clear channels key register.

static const unsigned int CLEAR(0x40c);   //???

				// Latch key register...

static const unsigned int LATCH(0x410);

				// Arm key register...

static const unsigned int ARM(0x414);


				// key registers to enable/disable.

static const unsigned int ENABLE(0x418);
static const unsigned int DISABLE(0x41c);


				// The scaler counters:

static const unsigned int SHADOWCOUNTERS(0x800); // Shadow regs.
static const unsigned int COUNTERS(0xa00);  // Live counters.
static const unsigned int ChannelCount(32); // # channels.

/*!
   Construct a module object.  The module object is the software entity
   through which the device will be controlled.

   The default mode of the device is a latching scaler with
   inputs in InputLatchInhibitAllAndLatch (inputs configured to
   support external latch as well as inhibits on the external latch
   and all counters.

   We also arrange the LNE source to be front panel (VME Key is
   always a valid option).

   \param base (unsigned long [in])
      base address of the module.
   \param crate (int [in] = 0):
      Crate in which the module lives.

   \throw string
     If the module cannot be mapped a string describing the problem is thrown
*/
CSIS3820::CSIS3820(unsigned long base, int crate) throw (string) :
  CModule32(base, ModuleSize, crate)
{

  ULong_t ModuleInfo = getModuleInfo();

  int     id         = ((ModuleInfo >> IDShift) & IDMask);

  if(id != 0x3820) {
    ThrowString("CSIS3820::CSIS3820",
	      "Base address does not point to an SIS3820 module");
  }
  Reset();

  // Setup the module to default mode:

  

}

/*!
   Returns the revision level of the module as a floating point value of the
   form major.minor.
*/
double
CSIS3820::getRevision() const
{
  int id = getModuleInfo();
  
  int minor = id & REVMask;
  int major = ((id >> MAJORShift) && REVMask);
  char versionstring[100];
  sprintf(versionstring, "%d.%d", major, minor);
  return atof(versionstring);
}

/*!
   Return the module information (id and firmware) register:
*/
int
CSIS3820::getModuleInfo() const
{
  return peek(IdAndFirmware);
}
/*!
    Turn on the user led.  This is done by turning on the 
    bottom bit in the CSR.
*/
void
CSIS3820::LightOn() const
{
  setCSR(LEDOn);
}
/*!
   Turn off the user led.  This is done by turning on the
   16'th bit of the CSR (numbered from 0).
*/
void
CSIS3820::LightOff() const
{
  setCSR(LEDOff);
}

/*!
   Return the current contents of the CSR.  This 
   is required if nothing else to make my test suite's run
   but may be of interest to users as well. It's harmless since
   I'm only giving read access.
*/
unsigned int
CSIS3820::getCsr() const 
{
  return peek(CSR);
}
/*!
   Utility function to return the value of the Acquisition 
   mode register.
*/
unsigned long
CSIS3820::getAcqMode() const
{
  return peek(ACQMode);
}
/*!
  Reset the module.  Module goes back to its power up state
  but does not take the time to do self tests (this is instantaneous).

*/
void
CSIS3820::Reset() const
{
  Key(RESET);
}

/*!
    Set the operating mode to whatever the user requests.
    At present the following mode are supported:
    - CSIS3820::OperatingMode::LatchingScaler
        Count freely as indicated by the front panel inputs.
	Latch signals from the front panel will transfer counts
        to the shadow registers from where they can be read.
        Scaler registers can also be read while counting (non
	latched mode).
   All other modes will cause an exception to be thrown.

   \param mode  (CSIS3820::OperatingMode  [in]):
       The desired operating mode.  See the text above for
       restrictions.

   \throws string
       If the operating mode is illegal.
*/
void
CSIS3820::setOperatingMode(CSIS3820::OperatingMode mode)  const
  throw (string)
{
  const char* pLeader("CSIS3820::setOperatingMode");
  switch (mode) {
  case LatchingScaler:
    {
      unsigned long  
	CurrentMode = getAcqMode();
      CurrentMode   = (CurrentMode & ~getOperatingMode()) | mode;
      setAcqMode(CurrentMode);
    }
    break;
  case MultiChannelScaler:
    ThrowString(pLeader, 
		"MultiChannel mode  unsupported at this time.");
  case HistogrammingScaler:
    ThrowString(pLeader,
		"Histogramming mode unsupported at this time");
  case RamTestScaler:
    ThrowString(pLeader,
		"Ramtest mode unsupported at this time");
    
  default:
    ThrowString(pLeader,
		"Unknown operating mode requested");
  }
}
/*!
  Return the current operating mode.
*/
CSIS3820::OperatingMode
CSIS3820::getOperatingMode() const
{
  unsigned long CurrentMode = getAcqMode();
  CurrentMode &= OperatingModeMask;
  return static_cast<OperatingMode>(CurrentMode);
}

/*!
   Set the input mode of the module.
   The input mode defines which inputs do what on the module.
   Since the module is run by an FPGA, these are highly programmable.
   The following modes are supported (undescribed inputs do 
   nothing):
   - CSIS3820::NoInputs - The Inputs do nothing.
   - CSIS3820::InputLatchInhibitLatch  
   \verbatim  
       Input1 is an external latch signal.  
       Input 4 inhibits this latch.
   \endverbatim
   - CSIS3820::InputLatchInhibitAllAdnLatch
   \verbatim
      Input1 is an External latch signal.
      Input3 inhibits the counting on all channels.
      Input4 inhibits the external latch.
    \endverbatim
   - CSIS3820::InputLatchInhibitAll
    \verbatim
      Input1 is an external latch signal.
      Input4 inhibits all scaler channels.
    \endverbatim
   - CSIS3820::InhibitGroups
    \verbatim
      Input1 Inhibits counting in channels 1-8
      Input2 Inhibits counting in channels 9-16
      Input3 Inhibits counting in channels 17-24
      Input4 Inhibits counting in channels 25-32
    \endverbatim
    - InputReserved{5,6,7} not unimplemented in the module.

    \param mode  (CSIS3820::InputMode [in])
       desired new input mode.

    \throws string
      If an invalid input mode is specified.
*/
void
CSIS3820::setInputMode(CSIS3820::InputMode mode) const throw (string)
{
  const char* pLeader("CSIS3820::setInputMode");
  switch (mode) {
    // Valid modes:
  case NoInputs:
  case InputLatchInhibitLatch:
  case InputLatchInhibitAllAndLatch:
  case InputLatchInhibitAll:
  case InhibitGroups:
    {
      unsigned long current = getAcqMode();
      current = (current & ~getInputMode()) | mode;
      setAcqMode(current);
    }
    break;

    // Invalid modes:
  case InputLNEHiscal:
    if (getRevision() >= 1.1) {
      unsigned long current = getAcqMode();
      current = (current & ~getInputMode()) | mode;
      setAcqMode(current);

    }
    else {
      ThrowString(pLeader, "InputLNEHiscal requires FW rev 1.1 and above!");
    }
  case InputLNEInhAllExtClear:
    if (getRevision() >= 1.5) {
      unsigned long current = getAcqMode();
      current = (current & ~getInputMode()) | mode;
      setAcqMode(current);
    }
    else {
      ThrowString(pLeader,"InputLNEInhAllExtClear requires FW rewv 1.5 and above.");
    }
  case InputReserved7:
    
    ThrowString(pLeader,
		"Unimplemented input mode requested (InputReserved*)");
    // Unknown mode:
  default:
    ThrowString(pLeader,
		"Unrecognized input mode requested");
  }
}

/*!
   Return the current input mode.
   We are helped by the fact that the input mode enum is set
   up so that the values are the values stored in the bitfield,
   already appropriately positioned:
   \return CSIS3820::InputMode
      The current input mode.
*/
CSIS3820::InputMode
CSIS3820::getInputMode() const
{
  unsigned long mode = getAcqMode();
  mode &= InputModeMask;
  return static_cast<InputMode>(mode);
}

/*!
    Set the source of the latch request.
    The latch request will copy all scalers to the shadow
    registers within 5ns, where they will be stable and can be read.
    The modes defined by the module are:
    - LatchVMEOnly - Latching can only be done via a VME request.
    - LatchFP      - Latching is done by VME request or by   
                     a pulse on the front panel.
    - Latch10Mhz   - Latches are done by the VME or whenever
                     the scaler's 10Mhz clock ticks.
    - LatchChannelN - \em (unsupported) Latch is done by
                     counts in a selected channel
    - LatchPresetN  - \em (unsupported) Latch is done when the
                      value of a counter reaches the present value.
    - LatchReserved{5,6,7} - \em (unsupported) modes the hardware
                    does not suport.

    \param mode (CSIS3820::CLNESource [in]):
       The latch mode to be selected.

    \throw string
       if the latch mode is unsupported.

*/
void
CSIS3820::setLatchSource(LNESource mode) const
  throw (string)
{

  const char* pLeader("CSIS3820::SetLatchSource");

  switch (mode) {
    // supported modes.
  case LatchVMEOnly:
  case LatchFP:
  case Latch10Mhz:

    {
      unsigned long acqmode = getAcqMode();
      acqmode    = (acqmode & ~getLatchSource()) | mode;
      setAcqMode(acqmode);
    }
    break;

    // unsupported modes.

  case LatchChannelN:
  case LatchPresetN:
  case LatchReserved5:
  case LatchReserved6:
  case LatchReserved7:
    ThrowString(pLeader,
		"Unsupported latch mode.");

    // unrecognized mode.

  default:
    ThrowString(pLeader,
		"Unrecognized latch mode ");
  }
  
}
/*!
   Return the current value of the latching mode.
*/
CSIS3820::LNESource
CSIS3820::getLatchSource() const
{
  unsigned long mode = getAcqMode();
  return static_cast<LNESource>(mode & LatchModeMask);
}

/*!
  Arm the module. To count, the module must be armed and
  enabled.

 */
void
CSIS3820::Arm() const
{
  Key(ARM);
}

/*!
  Determine if the module is armed.
*/
bool
CSIS3820::isArmed() const
{
  unsigned int csr = getCsr();
  return ((csr & ISARMED) != 0);

}
/*!
   Enable the scaler.
*/
void
CSIS3820::Enable() const
{
  Key(ENABLE);

}
/*!
  Disable the scaler.
*/
void 
CSIS3820::Disable() const
{
  Key(DISABLE);
}
/*!
   Return true if the module is enabled.
   note that in order to deal with future developments 
   supporting MCS mode, Enabled is defined as either of the
   SCALERENABLED and MCSENABLED bits set in the csr.
*/
bool
CSIS3820::isEnabled() const
{
  unsigned int csr = getCsr();
  return ((csr & (SCALERENABLED | MCSENABLED)) != 0);
}

/*!
    Select the input of channel 1 to be the reference pulser.
    The reference pulser is a 50Mhz crystal oscillator. Note
    that 25Mhz test mode has priority over this setting.
*/
void
CSIS3820::EnableReferencePulser() const
{
  setCSR(ENABLEREFPULSER);
}
/*!
   Turn off the reference pulser going into channel 1. After this,
   channel 1 is a normal scaler that counts whenever it sees an
   input pulse on the front panel.
*/
void 
CSIS3820::DisableReferencePulser() const
{
  setCSR(DISABLEREFPULSER);
}
/*!
   Return true if the reference pulser is currently enabled
  into channel 1 of the module
  \return bool
  - true if the reference pulser is on.
  - false if not.
*/
bool
CSIS3820::isReferencePulserEnabled() const
{
  unsigned int csr = getCsr();
  return ((csr & REFPULSERON) != 0);
}


/*!
  Enable the 25Mhz test pulser to clock all scaler channels.
  This setting overrides the reference pulser setting if both 
  are set.
*/
void
CSIS3820::EnableTestCounter() const
{
  setCSR(ENABLETESTPULSER);
}
/*!
  Disable the 25Mhz test pulser.
*/
void 
CSIS3820::DisableTestCounter() const
{
  setCSR(DISABLETESTPULSER);
}
/*!
  True if the 25Mhz test pulser is enabled into all the channels.
  \return bool
  - true the 25Mhz test pulser is on.
  - false the 25Mhz test pulser is off.
*/
bool
CSIS3820::isTestCounterOn() const
{
  unsigned int csr = getCsr();
  return ((csr & TESTPULSERON) == TESTPULSERON); // not simple bits.
}
/*!
  Clear all the channels via write to the clear key register.

 */
void
CSIS3820::ClearChannels() const
{
  Key(CLEAR);
}
/*!
  Disable the auto clear on the latch function. After this 
  is called, the scaler counters will not clear when latched but
  will continue to count.
  
 */
void 
CSIS3820::DisableClearOnLatch() const
{
  unsigned long mode = getAcqMode();
  mode |= NONCLEARINGMODE;
  setAcqMode(mode);
}
/*!
   Enable the autoclear on latch function.
  After this is called scaler counters will be cleare when
  latched...and then continue to count.
*/
void
CSIS3820::EnableClearOnLatch() const
{
  unsigned long mode = getAcqMode();
  mode &= ~NONCLEARINGMODE;
  setAcqMode(mode);
}

/*!
  Read a channel of the scaler.  Note that this reads the live
  scaler channels, not the latched scalers.  To read latched
  scaler values, use ReadLatchedChannel

  \param num (unsigned int [in]):
     The channel number in the range [0,ChannelCount).
  
  \return unsigned long 
     The instantaneous channel value.

   \note
     Reading a channel also causes a latch of the counters
     into the shadow registers.  In other words it's synchronous
     (within 5ns) to read one channel and then read the rest
     with ReadLatchedChannel e.g.

*/
unsigned long
CSIS3820::ReadChannel(unsigned int num) const
{

  ValidChannel(num, "CSIS3820::ReadChannel");
  return peek(ChannelOffset(COUNTERS, num));

}

/*!
   Reads all scaler counters.  See ReadChannel for more information
   about what this means and when it might be inappropriate.
   \param buffer  (unsigned long* [out]):
      Pointer to a 32 long buffer to hold the scaler values.
*/
void
CSIS3820::ReadAllChannels(unsigned long* buffer) const
{
  for(unsigned int i =0; i < ChannelCount; i++) {
    *buffer++ = ReadChannel(i);
  }
}
/*!
   Latch the current counters into the shadow registers.
   Once this has been done, the channels can be read via
   ReadLatchedChannel and ReadAllLatchedChannesl

*/
void
CSIS3820::Latch() const
{
  Key(LATCH);
}
/*!
   Read a specific channel from the latched channel 
   (shadow) registers.  In latch mode, the LNE or Latch operation
   (either front panel or Latch function) transfers the scaler
   counter values to shadow registers where they remain stable
   until the next latch function.

   The transfer takes 5ns.  This function reads a channel
   of these registers. 
   \param num (unsigned int [in]):
       The number of the channel to read, must be in the range
       [0, 32).

   \return unsigned long
     The value of the latched register for that channel.
     
   \throw string
     If the channel value is out of range.

*/
unsigned long
CSIS3820:: ReadLatchedChannel(unsigned int num) const
{
  ValidChannel( num, "CSIS3820::ReadLatchedChannel");
  return peek(ChannelOffset(SHADOWCOUNTERS,num));

}
/*!
    Read all latched channels.  See ReadLatchedChannel and Latch
    for more information, however this function reads the values
    of all shadow registers into a user buffer.
    \param buffer (unsigned long* [out]):
       user buffer of ChannelCount longs to hold the channel values.

*/
void
CSIS3820:: ReadAllLatchedChannels(unsigned long* buffer) const
{
  for(int i =0; i < ChannelCount; i++) {
    *buffer++ = ReadLatchedChannel(i);
  }
}
/*!
   This convenience function does a Latch and then a call to
   ReadAllLatchedChannels.

   \param buffer (unsigned long * [out]):
     Pointer to user buffer to hold the scalers.
*/
void
CSIS3820:: LatchAndRead(unsigned long* buffer) const
{
  Latch();
  ReadAllLatchedChannels(buffer);
}
///////////////////////////// Utilities ////////////////////////

/*!
   Utility function to set a new value for the acquisition mode
   register:
*/
void
CSIS3820::setAcqMode(unsigned long value) const
{
  poke(value, ACQMode);
}

/*!
   Write a value to the CSR:
*/
void
CSIS3820::setCSR(unsigned int long data) const
{
  poke(data, CSR);
}
/*!
   Throws a string exception if the channel number passed in is not
   a valid channel.
   \param chan (unsigned int [in]):
      The number of the channel to check.
   \param pWhere (const char* pWhere):
      The where context for the string.
   \throw string
      If the channel is out of range.
*/
void
CSIS3820::ValidChannel(unsigned int chan, 
		       const char *pWhere) throw (string)
{
  if(chan >= ChannelCount) {
    char msg[100];
    sprintf(msg, "Channel %d is out of range must be in [0,32)",
	    chan);
    ThrowString(pWhere, msg);
  }
}
/*!
   Returns the offset into the module associated with a channel.
   \param base  (unsigned long):
      Base of the register page, usually either COUNTERS or
      SHADOWCOUNTERS (in future may be in the fifo/ram).
   \param chan (unsigned int):
      Channel number to compute the offset for.
   \return unsigned long
     The offset at which the channel can be read.
*/
unsigned long
CSIS3820:: ChannelOffset(unsigned long base, 
				     unsigned int  chan)
{
  return base + chan*sizeof(unsigned long);
}
