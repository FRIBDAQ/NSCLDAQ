<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML 4.3//EN"
             "/usr/share/xml/docbook/schema/dtd/4.3/docbookx.dtd"

          >
<book>
<bookinfo>
    <title>Guide to using external scaler triggers</title>
    <author><firstname>Ron</firstname><surname>fox</surname>
    </author>
</bookinfo>
<preface>
    <title>Preface </title>
    <para>
        Starting with nscldaq-8.1-pre5, the production and high performanc production
        readout software are now capable of accepting external scaler triggers.
        This new feature allows users to override the default timed scaler trigger
        with either a pre-written or custom built scaler trigger manager.
    </para>
    <para>
        This document describes this facility.  In particular we describe:
        <itemizedlist>
            <listitem><para>
                An overview of this new feature and how to select it.
                </para>
            </listitem>
            <listitem><para>
                The pre-built scaler trigger classes, how to create instances (objects) of them
                so that they can be registered as scaler triggers.
                      </para>
            </listitem>
            <listitem><para>
                How to write your own custom scaler trigger classes.
                      </para>
            </listitem>
        </itemizedlist>
    </para>
    <para>
        Every effort has been made to ensure the accuracy of this document.  If, however
        you discover errors, please report them to the NSCL Data Acquisition system
        defect tracking database so that we can fix them as soon as possible.  The
        NSCL Data Acquisition system defect tracking system can be accessed at:
        <ulink url="http://daqbugs.nscl.msu.edu" />
    </para>
</preface>

<chapter>
    <title>An overview of scaler triggers</title>
    <para>
        By default NSCL readout software periodically reads a set of scalers.
        These scalers are generally used to track the counting rates in detectors
        used in an experiment.  Prior to nscldaq-8.1-pre5, scaler readout was triggered
        periodically, and there was no way for users to override this periodic trigger.
    </para>
    <para>
        With nscldaq-8.1-pre5 and later, a formal scheme for triggering scaler readout
        was added to the production readout software.
        This scheme relies on trigger objects registered to the production readout
        experiment.  By default a periodic trigger is registered.   It is possible
        for users to override this trigger by registering either a pre-built scaler
        trigger type or even by producing and registering their own scaler trigger objects.
    </para>
    <para>
        Key players in this are:
        <itemizedlist>
            <listitem><para>
                The CExperiment object which manages both event and scaler triggers
                when the run is active.
                </para>
            </listitem>
            <listitem>
                <para>
                    A hierarchy of scaler trigger classes derived from the abstract
                    base class CScalerTrigger
                </para>
            </listitem>
            <listitem>
                <para>
                    The ability of the user to add code to the
                    <classname>CMyExperiment</classname>::<function>SetupScalers</function>
                    function that creates a trigger object and registers it to replace
                    the default periodic trigger.
                </para>
            </listitem>
        </itemizedlist>
    </para>
    <para>
        Perhaps the simplest way to illustrate how this is done is to show some code
        where the user has chosen to substitute a pre-built trigger for the periodic
        scaler trigger.  In this example, the user is substituting the
        <classname>CCAENV977ScalerTrigger</classname> for the periodic trigger.
        This trigger uses the 15'th bit (numbered from 0)
        of a CAEN V977 coincidence/output register
        to trigger scaler readout.
    </para>
    <para>
        In this example, all code shown are modifications made to the
        <filename>Skeleton.cpp</filename> of the production readout software:

        <example>
            <title>Substituting a <classname>CCAENV977ScalerTrigger</classname>
                    scaler trigger</title>
            <programlisting>
    ...
    #include &lt;CCAENV977ScalerTrigger.h&gt;  <co id="ex1Include" />
    ...
    void
    CMyExperiment::SetupScalers(CExperiment&amp; rExperiment)
    {
        CReadoutMain::SetupScalers(rExperiment);

       // Insert your code below this comment.

        rExperiment.setScalerTrigger(new CCAENV977ScalerTrigger(0x12340000)); <co id="ex1Register" />
            ....


    }

            </programlisting>
        </example>
    </para>
    <para>
        The numbers below refer to the numbers in the example:
        <calloutlist>
            <callout arearefs="ex1Include"><para>
                This line includes the header file that defines the pre-written trigger
                clases the user has chosen as a scaler trigger</para>
            </callout>
            <callout arearefs="ex1Register"><para>
                This line creates a new <classname>CCAENV977ScalerTrigger</classname>
                object for a module with base address 0x12340000 in VME crate 0.
                The call to <function>setScalerTrigger</function> for the experiment
                object replaces the currently registered scaler trigger (the default
                periodic trigger) with the CCAENV977ScalerTrigger that was created</para>
            </callout>
        </calloutlist>
    </para>
    <para>
        In most cases, you can use a pre-written scaler trigger.  Read the next
        chapter to learn about the pre-written scaler trigger classes, and how to
        create instances of them.
    </para>
    <para>
        If none of the pre-written trigger classes will work for your application
        continue reading as it is possible to write your own trigger class and register
        it as the scaler trigger.
    </para>
</chapter>

<chapter>
    <title>Using pre-written scaler trigger classes</title>
    <para>
        Several pre-written scaler trigger classes are supplied with the
        production readout libraries:
        <variablelist>
            <varlistentry>
                <term><classname>CTimedScalerTrigger</classname></term>
                <listitem><para>
                            This is the default scaler trigger type.  When initialized,
                            it records the value of the <varname>frequency</varname>
                            variable.  It indicates a trigger approximately every
                            <varname>frequency</varname> seconds.
                          </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CCAENV262ScalerTrigger</classname></term>
                <listitem><para>
                            This scaler trigger uses a CAEN V262 I/O register to
                            provide scaler triggers in a manner completely analagous to
                            the <firstterm>vme trigger</firstterm>.  It is not possible
                            to a single CAEN V262 as both the event and scaler triggers.
                          </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CCAENV977ScalerTrigger</classname></term>
                <listitem><para>
                            This scaler trigger uses a CAEN V977 I/O register to
                            provide scaler triggers on the last input.  It is possible
                            to share this trigger module with one used to provide event
                            triggers.
                          </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CCBDCES8210ScalerTrigger</classname></term>
                <listitem><para>
                            This scaler trigger uses the IT4 input of a CES
                            CBD 8210 parallel branch highway driver to trigger
                            scaler readout.  This module can be shared with one used
                            to provide event triggers.
                            <warning><para>
                                        The CES CBD8210 module is obsolete and no longer
                                        maintainable the NSCL DAQ support group strongly
                                        discourages you from using this module in new
                                        setups.  We also encourage users of this module
                                        to migrate away from it to e.g. the
                                        Wiener VC32/CC32 module set, or to a VME based
                                        system.
                                     </para>
                            </warning>
                          </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </para>

    <sect1>
        <title>The <classname>CTimedScalerTrigger</classname> trigger</title>
        <para>
            The <classname>CTimedScalerTrigger</classname> trigger is the default
            scaler trigger module.  If the user does not register a replacement,
            an object of this class will be used to trigger periodic scaler readouts.
        </para>
        <para>
            The constructor prototype of this trigger is shown below:
            <example>
                <title><classname>CTimedScalerTrigger</classname> constructor</title>
                <programlisting>
                    #include &lt;CTimedScalerTrigger.h&gt;  <co id="tstHeader" />
                    ...
                    CTimedScalerTrigger(CExperiment* pExperiment); <co id="tstConstruct" />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs="tstHeader">
                    <para>
                        If you have code that uses a <classname>CTimedScalerTrigger</classname>
                        object you should include <filename>&lt;CTimedScalerTrigger.h&gt;</filename>
                        This header defines the class and its interfaces.
                    </para>
                </callout>
                <callout arearefs="tstConstruct">
                    <para>
                        The constructor of the <classname>CTimedScalerTrigger</classname>
                        takes a pointer to the experiment object
                        (<classname>CExperiment*</classname>).  The scaler trigger
                        uses the experiment object to determine the elapsed run time.
                        The trigger will also reference the TCL variable
                        <varname>frequency</varname> to determine the number of seconds
                        between scaler readouts.
                    </para>
                </callout>
            </calloutlist>
        </para>
        <para>
            Below is an example that shows how to explicitly request that scalers be
            read via the timed scaler trigger.
            <example>
                <title>Explicitly requesting the timed scaler trigger</title>
                <programlisting>
   ...
    #include &lt;CTimedScalerTrigger.h&gt;
    ...
    void
    CMyExperiment::SetupScalers(CExperiment&amp; rExperiment)
    {
        CReadoutMain::SetupScalers(rExperiment);

       // Insert your code below this comment.

        rExperiment.setScalerTrigger(new CTimedScalerTrigger(&amp;rExperiment));
        ....

    }
                </programlisting>
            </example>
        </para>
    </sect1>

    <sect1>
        <title>The <classname>CCAENV262ScalerTrigger</classname> trigger</title>
        <para>
            The <classname>CCAENV262ScalerTrigger</classname> trigger supports
            accepting scaler triggers from a CAEN V262 I/O register.
            This register is the same module that is used to accept standard
            VME triggers for the production readout software.
        </para>
        <para>
            The CAEN V262 module does not have latching inputs.  It is therefore
            necessary to externall latch the trigger to the module either with a
            gate and delay generator in latch mode, or via an NSCL latch module.
            The trigger for the scaler should be plugged into the IN 0 NIM input.
            When the trigger has been accepted the SHP2 output will be pulsed.
            At that time, the trigger latch can be cleared.
        </para>
        <para>
            If your experiment is using a VME trigger based on the CAEN V262 module
            it is important that if you choose to use a CAEN V262 module for scaler
            triggers that it be configured to a base addresss that does not match
            that of the CAEN v262 module used to supply VME triggers.  Choose a base
            address other than 0x444400.  An application note at:
            <ulink url="http://docs.nscl.msu.edu/daq/appnotes/vmeaddress.html" />
            provides information to help you lay out your VME address map.
        </para>
        <para>
            To use the CAEN V262 as a scaler trigger you must:
            <orderedlist>
                <listitem><para>
                            Configure and install a CAEN V262 module into one of the
                            VME crates in your system.  Write down the base address
                            you used to configure this module as you will need it later.
                          </para>
                </listitem>
                <listitem><para>
                            Arrange external trigger logic that latches the scaler trigger
                            into the module's IN 0 until the SHP 2 output is pulsed
                          </para>
                </listitem>
                <listitem>
                    <para>
                        Modify <filename>Skeleton.cpp</filename> to create a
                        <classname>CCAENV262ScalerTrigger</classname> object with the
                        base address you wrote down in step 1 above, and register it
                        with the experiment to be your scaler trigger.
                    </para>
                </listitem>
            </orderedlist>
        </para>
        <para>
            The example below documents the prototype of the
            <classname>CCAENV262ScalerTrigger</classname> constructor.
            <example>
                <title>The <classname>CCAENV262ScalerTrigger </classname> constructor.</title>
                <programlisting>
                    ...
     #include &lt;CCAENV262ScalerTrigger.h&gt;  <co id="v262Header" />
     ...
     CCAENV262ScalerTrigger(unsigned long base, unsigned long vmeCrate = 0); <co id="v262Const" />
     ...
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs="v262Header">
                    <para>
                        The <filename>&lt;CCAENV262ScalerTrigger.h&gt;</filename>
                        must be included in any source code files that use the
                        <classname>CCAENV262ScalerTrigger</classname> class. This header
                        file defines the class structure and its interfaces.
                    </para>
                </callout>
                <callout arearefs="v262Const">
                    <para>
                        The parameters of the constructor for the
                        <classname>CCAENV262ScalerTrigger</classname> class
                        define where in the VME space the module used for the trigger is
                        located:
                        <segmentedlist>
                            <segtitle>Parameter</segtitle>
                            <segtitle>Data Type</segtitle>
                            <segtitle>Usage</segtitle>
                            <seglistitem>
                                <seg><parameter>base</parameter></seg>
                                <seg><classname>unsigned long</classname></seg>
                                <seg>
                                    The base address of the module.  This should be the
                                    value set in the module rotary switch with two extra
                                    hexadecimal zeroes appened.  So if the rotary switches
                                    are set to be 1234, this should be <constant>0x123400</constant>
                                </seg>
                            </seglistitem>
                            <seglistitem>
                                <seg><parameter>vmeCreate</parameter></seg>
                                <seg><classname>unsigned long</classname></seg>
                                <seg>
                                    The number of the VME crate the module is installed
                                    in. The <application>cratelocator</application>
                                    can be used to determine which VME crate is which
                                    on a multi-crate system.  The default value is
                                    <constant>0</constant> which is the VME crate number
                                    assigned to crates in a single crate system.
                                </seg>
                            </seglistitem>
                        </segmentedlist>
                    </para>
                </callout>
            </calloutlist>
        </para>
        <para>
            The example below illustrates this for a CAEN V262 module configured with
            a base address of 0x123400 installed in VME crate 1.
            <example>
                <title>Installing a <classname>CCAENV262ScalerTrigger</classname></title>
                <programlisting>
   ...
    #include &lt;CCAENV262ScalerTrigger.h&gt;
    static const int scalerTriggerBase = 0x123400; // Modify this to match your module
    static const int scalerTriggerCrate= 1;        // Modify to match your crate.
    ...
    void
    CMyExperiment::SetupScalers(CExperiment&amp; rExperiment)
    {
        CReadoutMain::SetupScalers(rExperiment);

       // Insert your code below this comment.

        rExperiment.setScalerTrigger(new CCAENV262ScalerTrigger(scalerTriggerBase,
                                                                scalerTriggerCrate));
            ....

    }
                </programlisting>
            </example>
        </para>
    </sect1>

    <sect1>
        <title>The <classname>CCAENV977ScalerTrigger</classname> trigger</title>
        <para>
            The <classname>CCAENV977ScalerTrigger</classname> trigger allows you
            to use a CAEN V977 coincidence/pattern register bit to trigger scaler readout.
            You may use this module for both an event and scaler trigger.  The event
            trigger will respond to all but bit 15 (numbered from 0).  The scaler trigger
            will respond to bit 15.
        </para>
        <para>
            To use the CAEN V977 as scaler trigger you must:
            <orderedlist>
                <listitem>
                    <para>
                    Configure and install one of these units in a VME crate in your setup.
                    See the application note at
                    <ulink url="http://docs.nscl.msu.edu/daq/appnotes/vmeaddress.html" />
                    for some guidelines on choosing an unused base address for the module.
                    Once you  have chosen the base address, set the module rotary switches
                    accordingly and write this base address down.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Set up external electonics to assert both the
                        module gate and bit 15 when you want the scaler readout to be
                        triggered.  The CAEN V977 latches data presented during the gate
                        time so it is not necessary to arrange an external latch.
                        </para>
                </listitem>
                <listitem>
                    <para>
                        Modify the <filename>Skeleton.cpp</filename> file to
                        create a instance of the
                        <classname>CCAENV977ScalerTrigger</classname> module and
                        to register it as your scaler trigger.
                    </para>
                </listitem>
            </orderedlist>
        </para>

        <para>
            The constructor for <classname>CCAENV977ScalerTrigger</classname>
            is defined as shown in the example
            below:
            <example>
                <title>The <classname>CCAENV977ScalerTrigger</classname> constructor</title>
                <programlisting>
            #include &lt;CCAENV977ScalerTrigger.h&gt;  <co id="v977Header" />
            CCAENV977ScalerTrigger(unsigned long base, unsigned int vmeCrate = 0); <co id="v977Constr" />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs="v977Header">
                    <para>
                        The <filename>&lt;CCAENV977ScalerTrigger.h&gt;</filename>
                        header defines the <classname>CCAENV977ScalerTrigger</classname>
                        class and its interfaces.  This header file should be included
                        in any C++ source file that uses that class>
                    </para>
                </callout>
                <callout arearefs="v977Constr">
                    <para>
                        The parameters of the constructor for the
                        <classname>CAENV977ScalerTrigger</classname> class are:
                        <segmentedlist>
                            <segtitle>Parameter</segtitle>
                            <segtitle>Data Type</segtitle>
                            <segtitle>Description</segtitle>
                            <seglistitem>
                                <seg><parameter>base</parameter></seg>
                                <seg><classname>unsigned long</classname></seg>
                                <seg>
                                    The base address you assigned to the module when you
                                    set its rotary switches
                                </seg>
                            </seglistitem>
                            <seglistitem>
                                <seg><parameter>vmeCrate</parameter></seg>
                                <seg><classname>unsigned int</classname></seg>
                                <seg>
                                    The number of the VME crate in which you installed the
                                    module.  The <application>cratelocator</application>
                                    program can be used to determine which VME crate
                                    your module is installed in.  The default for this parameter
                                    is <constant>0</constant> which is suitable for single
                                    VME crate systems.
                                </seg>
                            </seglistitem>
                        </segmentedlist>
                    </para>
                </callout>
            </calloutlist>
        </para>
        <para>
            The example below shows how to create a <classname>CCAENV977ScalerTrigger</classname>
            object and set it as the scaler trigger.
            <example>
                <title>Using the CCAENV977ScalerTrigger to trigger scaler readouts</title>
                <programlisting>
   ...
    #include &lt;CCAENV977ScalerTrigger.h&gt;
    ...
    // Modify these to reflect your choices

    static const unsigned long scalerTriggerBase = 0x12340000;
    static const unsigned long scalerTriggerCrate= 0;
    ...
    void
    CMyExperiment::SetupScalers(CExperiment&amp; rExperiment)
    {
        CReadoutMain::SetupScalers(rExperiment);

       // Insert your code below this comment.

        rExperiment.setScalerTrigger(new CCAENV977ScalerTrigger(scalerTriggerBase,
                                                                scalerTriggerCrate));
            ....

    }
                </programlisting>
            </example>
        </para>
    </sect1>

    <sect1>
        <title>The <classname>CCBDCES8210ScalerTrigger</classname> trigger </title>
        <warning>
            <para>
                The CES CBD8210 parallel branch driver module is no longer maunfactured
                and cannot be repaired if broken.  The NSCL Data acquisitions group
                recommends that no new setups use this module and that
                existing setups that use this module migrate towards either the
                Wiener VC/CC32 module set for CAMAC instrumentation or away from
                CAMAC to VME based systems.
          </para>
        </warning>
        <para>
            The <classname>CCBDCES8210ScalerTrigger</classname> class supports
            using the IT4 input of a CES CBD8210 parallel branch highway driver
            as the scaler readout trigger.  The event trigger (the IT2 input) can also
            run through the same module.
        </para>
        <para>
            To use the CES CBD8210 as a scaler trigger you must:
            <orderedlist>
                <listitem><para>
                            Choose a branch to use.  Note that the branch number
                            implies a VME crate number as well.
                          </para>
                </listitem>
                <listitem><para>
                            Arrange external electronics to pulse the IT4 input of
                            the branch driver module you are using as the trigger.
                          </para>
                </listitem>
            </orderedlist>
        </para>
        <para>
            The <classname>CCBDCES8210ScalerTrigger</classname> class has the
            following construction parameters:
            <example>
                <title>Constructing a CCBDCES8210ScalerTrigger</title>
                <programlisting>
    #include &lt;CCBDCES8210ScalerTrigger.h&gt;   <co id="cbdHeader" />
    CCBDCES8210ScalerTrigger(int b = 0);          <co id="cbdConstruct" />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs="cbdHeader">
                    <para>
                        The <filename>&lt;CCBDCES8210ScalerTrigger&gt;</filename>
                        header should be included in every source code module that
                        will be interacting with <classname>CCBDCES8210ScalerTrigger</classname>
                        objects.  This header defines the class and its interfaces.
                    </para>
                </callout>
                <callout arearefs="cbdConstruct">
                    <para>
                        The parameter of the constructor is the number of the
                        CES CBD8210 branch highway branch.  This defaults to 0.
                    </para>
                </callout>
            </calloutlist>
        </para>
        <para>
            The example below shows how to use the
            <classname>CCBDCES8210ScalerTrigger</classname> to provide scaler readout
            triggers.
            <example>
                <title>Using the CES 8210 to provide scaler triggers</title>
                <programlisting>
   ...
    #include &lt;CCBDCES8210ScalerTrigger.h&gt;
    ...
    // Modify these to reflect your choices

    static const unsigned long scalerTriggerBranch = 1;
    ...
    void
    CMyExperiment::SetupScalers(CExperiment&amp; rExperiment)
    {
        CReadoutMain::SetupScalers(rExperiment);

       // Insert your code below this comment.

        rExperiment.setScalerTrigger(new CCBDCES8102ScalerTrigger(scalerTriggerBranch));
            ....

    }
                </programlisting>
            </example>
        </para>
    </sect1>

</chapter>

<chapter>
    <title>Writing custom scaler trigger classes </title>
    <para>
        If none of the pre-written scaler trigger classes described in the previous
        chapter are suitable for your application, you can write your own scaler trigger.
        Scaler triggers are classes that inherit from the abstract base class
        <classname>CScalerTrigger</classname> which is defined in the header
        <filename>&lt;CScalerTrigger.h&gt;</filename>.
        The important parts of this header are shown below:
        <informalexample>
            <programlisting>
class CScalerTrigger
{
public:
  CScalerTrigger();
  virtual ~CScalerTrigger();
private:                                         <co id="baseCanonicals" />
  CScalerTrigger(const CScalerTrigger&amp; rhs);
  CScalerTrigger&amp; operator=(const CScalerTrigger&amp; rhs);
  int operator==(const CScalerTrigger&amp; rhs) const;
  int operator!=(const CScalerTrigger&amp; rhs) const;
public:

  //  The members below are usually overridden by concreate subclasses.
  //  only operator() must be overridden, all others have a default no-op
  //  implementation:

  virtual bool operator()()  = 0;             <co id="baseFunctor" />
  virtual void Initialize();                  <co id="baseInit" />
  virtual void Cleanup();                     <co id="baseCleanup" />
};

            </programlisting>
        </informalexample>
        <calloutlist>
            <callout arearefs="baseCanonicals">
                <para>
                    It is not necessary to define copy constructor, assignment,
                    and equality/inequality comparison operators.  These are private
                    in the base class and never implemented to ensure that
                    attempts to use them will result in errors at program link time.
                </para>
            </callout>
            <callout arearefs="baseFunctor">
                <para>
                    Your scaler trigger class must implement a function call operator.
                    This opertor is called to determine if the conditions necessary to
                    read scalers have been met.  If scalers should be read, this
                    function should return <constant>true</constant>, if not,
                    <constant>false</constant>.
                </para>
            </callout>
            <callout arearefs="baseInit">
                <para>
                    If your scaler trigger must do some initialization prior to the
                    run being made active, it should override and implement this
                    function to perform those actions.  If your scaler trigger does
                    not provide an <function>Initialize</function> member, the default
                    is a function that does nothing
                </para>
            </callout>
            <callout arearefs="baseCleanup">
                <para>
                    If your scaler trigger must do some cleanup as the run is becoming
                    inactive, it should override and implement this function to
                    perform those actions.  If your scaler trigger does not
                    provide a <function>Cleanup</function> member, the default is
                    a function that does nothing.
                </para>
            </callout>
        </calloutlist>
    </para>
    <para>
        The example below shows the definition and implementation of the simplest
        form of Scaler trigger. <classname>CNoScalerTrigger</classname>  This scaler trigger can be used
        when your data taking application does not need to read any scalers.
        <example>
            <title>The <classname>CNoScalerTrigger</classname></title>
            <programlisting>
                #include &lt;CScalerTrigger.h&gt;              <co id="nullInclude" />
                class CNoScalerTrigger : public CScalerTrigger <co id="nullDerive" />
                {
                public:
                   virtual bool operator()() {                 <co id="nullFunctor" />
                        return false;
                    }
                };
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs="nullInclude">
                <para>
                    In order to write a scaler trigger you must include the
                    &lt;CScalerTrigger.h&gt; header.  This header defines the base
                    class for all scaler trigger classes.
                </para>
            </callout>
            <callout arearefs="nullDerive" >
                <para>
                    All scaler triggers must be public derivations of the base class
                    <classname>CScalerTrigger</classname>  this line declares a new
                    class definition for <classname>CNoScalerTrigger</classname> that
                    is derived from <classname>CScalerTrigger</classname>.
                </para>
            </callout>
            <callout arearefs="nullFunctor">
                <para>
                    All scaler triggers must implement <function>operator()</function>
                    The implementation for the <classname>CNoScalerTrigger</classname>
                    is a function that always returns <constant>false</constant>.
                    This ensures that a scaler readout will never occur if a
                    <classname>CNoScalerTrigger</classname> scaler trigger object is
                    registered on the experiment object.
                </para>
            </callout>
        </calloutlist>
    </para>

</chapter>

<appendix>
    <title>Annotated source code for the <classname>CTimedScalerTrigger</classname> class</title>
    <para>
        For instructive purposes,we supply the entire header and source code for
        the <classname>CTimedScalerTrigger</classname> class.
        If you are contemplating writing a custom
        scaler trigger study of this example may be helpful.
    </para>
    <para>
        <example>
            <title><filename>&lt;CTimedScalerTrigger.h&gt;</filename></title>
            <programlisting>
#ifndef __CTIMEDSCALERTRIGGER_H           <co id="ctsIncludeGuard" />
#define __CTiMEDSCALERTRIGGER_H
#include &lt;CScalerTrigger.h&gt;         <co id="ctsBaseInclude" />

//  Forward classes::

class CExperiment;                        <co id="ctsForward" />

/*!
    This class is a scaler trigger that can be used to do a timed periodic
    trigger of scaler readouts..  This trigger will in general be registered
    by default and must be overidden by the user if they want something different.

    We depend on the following:
    - The application has a ge5tScalerPeriod() member
    - The experiment has a GetElapsedTime function.

*/
class CTimedScalerTrigger : public CScalerTrigger     <co id="ctsInherit" />
{
private:
  CExperiment*    m_pExperiment;                     <co id="ctsExperimentMember" />
  unsigned int    m_nLastTrigger;                    <co id="ctsLastTriggerMember" />
  unsigned int    m_nNextTrigger;                    <co id="ctsNextTriggerMember" />
  unsigned int    m_nTriggerInterval;                <co id="ctsIntervalMember" />

public:
  // Constructors and other canonicals.

  CTimedScalerTrigger(CExperiment* pExperiment);    <co id="ctsConstructor" />
  virtual ~CTimedScalerTrigger();                   <co id="ctsDestructor"  />
private:                                            <co id="ctsForbidden"   />
  CTimedScalerTrigger(const CTimedScalerTrigger&amp; rhs);
  CTimedScalerTrigger&amp; operator=(const CTimedScalerTrigger&amp; rhs);
  int operator==(const CTimedScalerTrigger&amp; rhs) const;
  int operator!=(const CTimedScalerTrigger&amp; rhs) const;
public:

  // Overrides:

  virtual void Initialize();                       <co id="ctsInitialize" />
  virtual bool operator()();                       <co id="ctsFunctor" />
};

#endif

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs="ctsIncludeGuard">
                <para>
                    This #ifdef is used to ensure that if the header is included twice
                    in the same compilation the class will not be doubly defined.  All
                    headers should have an <firstterm>ifdef gaurd</firstterm> like this.
                </para>
            </callout>
            <callout arearefs="ctsBaseInclude">
                <para>
                    Since the <classname>CTimedScalerTrigger</classname> class has
                    <classname>CScalerTrigger</classname> as its base class, the
                    <filename>&lt;CScalerTrigger.h&gt;</filename> header must be included
                    to provide the compiler with the details about the structure of that
                    class.
                </para>
            </callout>
            <callout arearefs="ctsForward">
                <para>
                    This declaration allows the use of the type <classname>CExperiment</classname>
                    as long
                    as the details of the type are not needed.  The
                    <classname>CTimedScalerTrigger</classname> class contains a data
                    member that is  a pointer to a <classname>CExperiment</classname>.
                    While it would be possible to just include the
                    <filename>&lt;CExperiment&gt;</filename> header, this can lead to cases
                    where header files will have circular dependencies that cannot be
                    resolved by the compiler.  A good rule of thumb is to do a
                    <firstterm>forward class definition</firstterm> like this wherever
                    possible in header files, reserving the include of the header
                    until the implementation file.
                </para>
            </callout>
            <callout arearefs="ctsInherit">
                <para>
                    This line informs the compiler that we are defining a new
                    class named <classname>CTimedScalerTrigger</classname>, and that
                    this class should inherit all of the data and methods of the
                    <classname>CScalerTrigger</classname> base class.   This has
                    several implications.  The two that are important for this case are
                    that <classname>CScalerTrigger</classname> defines a set of interfaces
                    scaler triggers provide and override, and that a
                    <classname>CScalerTrigger*</classname> or
                    <classname>CScalerTrigger&amp;</classname>
                    that points to an object that is actually a
                    <classname>CTimedScalerTrigger</classname> will exhibit the run-time
                    behavior of a <classname>CTimedScalerTrigger</classname>.  This
                    second property is called <firstterm>polymorphism</firstterm> and
                    is an essential component of object-oriented programming systems.
                </para>
            </callout>
            <callout arearefs="ctsExperimentMember">
                <para>
                    The <varname>m_pExperiment</varname> pointer will point to the
                    <classname>CExperiment</classname> object that controls the active
                    readout.  The implementation of this class will make use of some
                    services exported by that object.
                </para>
            </callout>
            <callout arearefs="ctsLastTriggerMember">
                <para>
                    The <varname>m_nLastTrigger</varname> member will be used to store
                    the time at which the previous trigger fired.
                </para>
            </callout>
            <callout arearefs="ctsNextTriggerMember">
                <para>
                    The <varname>m_nNextTrigger</varname> member will store the earliest
                    time at which it is ok to declare a scaler trigger.
                </para>
            </callout>
            <callout arearefs="ctsIntervalMember">
                <para>
                    The <varname>m_nTriggerInterval</varname> will store the time in
                    seconds between each trigger.
                </para>
            </callout>
            <callout arearefs="ctsConstructor">
                <para>
                    A constructor is declared and will be implemented.  The constructor
                    is a function that takes action when an object of this type is created.
                    In this case, our constructor will initialize the data members to
                    appropriate initial values.  This includes setting the
                    <varname>m_pExperiment</varname> variable.
                </para>
            </callout>
            <callout arearefs="ctsDestructor">
                <para>
                    Declares a destructor.  A destructor is called when an object of the
                    type is destroyed either because it was <function>delete</function>ed,
                    or because it went out of scope.
                </para>
            </callout>
            <callout arearefs="ctsForbidden">
                <para>
                    These functions are forbidden.  Forbiddenness is enforced by declaring
                    the functions private, and never implementing them.  This means that
                    if an external object attempts to call them, the compiler will catch
                    this as a violation of the privacy of these functions.  If a function
                    of <classname>CTimedScalerTrigger</classname> calls themm,
                    the linker will notice that the functions are not defined.
                </para>
            </callout>
            <callout arearefs="ctsInitialize">
                <para>
                    The <classname>CTimedScalerTrigger</classname> class will need to
                    implement an override to the functionality of  the
                    <function>Initialize</function> function.
                </para>
            </callout>
            <callout arearefs="ctsFunctor">
                <para>
                    As is the case for all concrete scaler triggers a
                    <function>operator()</function> must be implemented.
                </para>
            </callout>
        </calloutlist>

    </para>
    <para>
        <example>
            <title><filename>CTimedScalerTrigger.cpp</filename></title>
            <programlisting>
#include &lt;config.h&gt;
#ifdef HAVE_STD_NAMESPACE
using namespace std;
#endif


#include &lt;CTimedScalerTrigger.h&gt;       <co id="implIncludes" />
#include &lt;CExperiment.h&gt;
#include &lt;CReadoutMain.h&gt;



/*!
   Construct a timed scaler trigger.  At construction time
   we just need to save the experiment object pointer.

   \param pExperiment CExperiment*
       Pointer to the experiment
*/
CTimedScalerTrigger::CTimedScalerTrigger(CExperiment* pExperiment) :  <co id="implConstruct" />
  m_pExperiment(pExperiment),
  m_nLastTrigger(0),
  m_nNextTrigger(0),
  m_nTriggerInterval(0)
{

}
/*!
   Destructor is basically a no op.
*/
CTimedScalerTrigger::~CTimedScalerTrigger()
{
}

/*!
    Initialization requires that we figure out when 'now' is, the
    scaler periodicity and when we read the next scaler.
*/
void
CTimedScalerTrigger::Initialize()               <co id="implInitialize" />
{
  m_nLastTrigger     = m_pExperiment-&gt;GetElapsedTime(); // start timing from 'now'.
  m_nTriggerInterval = CReadoutMain::getInstance()-&gt;getScalerPeriod()*10; // 10'ths
  m_nNextTrigger     = m_nLastTrigger + m_nTriggerInterval;

}

/*!
   Check for the trigger.  We have a trigger if the current elaspsed time
   is >= the next trigger time.  In that case we'll need to compute the
   next trigger time as well as return true.
*/
bool
CTimedScalerTrigger::operator()()            <co id="implFunctor" />
{
  unsigned int now = m_pExperiment-&gt;GetElapsedTime();
  bool     triggered= false;
  if (now &gt;= m_nNextTrigger) {
    triggered = true;
    m_nLastTrigger = now;
    m_nNextTrigger = now + m_nTriggerInterval;
  }
  return triggered;
}
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs="implIncludes">
                <para>
                    We need to include the following headers:
                    <variablelist>
                        <varlistentry>
                            <term><filename>&lt;CTimedScalerTrigger.h&gt;</filename></term>
                            <listitem>
                                <para>
                                    The header for the class this file implements.
                                    This defines the class and its interfaces so that
                                    the compiler knows that what we implement is what is
                                    defined.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><filename>&lt;CExperiment.h&gt;</filename></term>
                            <listitem>
                                <para>
                                    The header for the <classname>CExperiment</classname>
                                    class.  This class provides services for the experiment
                                    as a whole. the <classname>CTimedScalerTrigger</classname>
                                    class will make use of the interfaces that access the
                                    time the run has been active.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><filename>&lt;CReadoutMain.h&gt;</filename></term>
                            <listitem>
                                <para>
                                    Each Readout program has a singleton
                                    <classname>CReadoutMain</classname> object.  This
                                    object includes interfaces that allow access to
                                    experiment wide settings, including various
                                    run state variables that we will need.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </callout>
            <callout arearefs="implConstruct">
                <para>
                    Construction of the <classname>CTimedScalerTrigger</classname> object
                    requires that the <parameter>pExperiment</parameter> pointer be saved
                    so that the experiment object's services can be accessed by the other
                    member functions.  <parameter>pExperiment</parameter> is stored in the
                    member data <varname>m_pExperiment</varname>
                </para>
            </callout>
            <callout arearefs="implInitialize">
                <para>
                    The <function>Initialize</function> member is called when the
                    run is about to become active.  This can happen both because the
                    run has begun or because a paused run is being resumed.
                    <itemizedlist>
                        <listitem>
                            <para>
                                We use the <function>GetElapsedTime</function>
                                function in the experiment object to store the
                                start time of the current time interval in
                                <varname>m_nLastTrigger</varname>
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                We use the <function>getScalerPeriod</function>
                                function in the <classname>CReadoutMain</classname>
                                singleton to obtain the value of the
                                <varname>frequency</varname> Tcl variable.
                                Note the use of the class function
                                <function>CReadoutMain::getInstance</function>
                                to return a pointer to the one and only
                                <classname>CReadoutMain</classname> object.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The time for the next trigger is then computed and
                                stored in <varname>m_nNextTrigger</varname>.
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </callout>
            <callout arearefs="implFunctor">
                <para>
                    The <function>operator()</function> is called to poll for a scaler
                    trigger.  If the current elapsed run time is &ge; the next trigger
                    time, it's time to declare a trigger.  The subsequent trigger time
                    is computed and the function returns <constant>true</constant>.
                    if the current elapsed run time is &lt; the next trigger time,
                    the operator returns <constant>false</constant>
                </para>
            </callout>
        </calloutlist>
    </para>
</appendix>

</book>
