<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>Using NSCLDAQ and SpecTcl with a CAEN V785 Peak-Sensing ADC</title>
      <author><firstname></firstname><surname></surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>Feb 5, 2015</date>
             <authorinitials></authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
      <title>PREFACE</title>
        <para>
          This paper's purpose is to guide the reader in setting up and reading
          out data from a CAEN V785 peak sensing ADC. It covers the electronics
          that will be needed and how to set them up. It will show how to modify
          the production readout (V11.0) software skeleton to readout data from
          the adc. Testing for the code is also covered to a limited extent.
        </para>
        <para>
          This paper assumes that you are
        </para>
        <itemizedlist>
          <listitem><para>
              Somewhat familiar with Linux.
          </para></listitem>
          <listitem><para>
              Familiar with the C++ programming language at a basic level.
          </para></listitem>
          <listitem><para>
              Familiar with an oscilloscope.
          </para></listitem>
        </itemizedlist>
        <para>
          Final version of the software are available for download at:
          <emphasis>MAKE THE LINK CORRECT!</emphasis>
        </para>
        <para>
          Every effort has been made to ensure the accuracy of this document.
          As authors we take very seriously reports of mistakes, omissions, and
          unclear documentation. If you come across a part of the document you
          think is wrong, needs expansion, or is not clearly worded, please
          report this to &lt;helpme@nscl.msu.edu&gt;. We will correct this problem
          as soon as possible and, if you like, credit you publicly in the
          document for finding and helping us fix this issue.
        </para>
    </chapter>

    <chapter>
        <title>The electronics</title>
        <para>
          The CAEN V785 is a 12-bit, 32-channel analog-to-digital converter that
          returns a digitized value of the maximum voltage that occurs during the
          time a gate is present. The input signal must be positive and less
          than 4V. The V785 is a VME-based module. For a complete understanding
          of the module I suggest that you obtain a copy of the product manual,
          available as a PDF at http://www.caen.it/  
        </para>
        <section>
          <title>A minimal electronics setup</title>

          <para>
            The following items will be needed to build our simple setup:
          </para>

          <itemizedlist>
            <listitem>
              <para>CAEN V785 ADC module</para>
            </listitem>
            <listitem>
              <para>VME Crate</para>
            </listitem>
            <listitem>
              <para>SBS Bit3 PCI/VME bus interface</para>
            </listitem>
            <listitem>
              <para>NIM Crate</para>
            </listitem>
            <listitem>
              <para>NIM Spectroscopy amplifier of some sort</para>
            </listitem>
            <listitem>
              <para>NIM Discriminator</para>
            </listitem>
            <listitem>
              <para>Two channels of NIM Gate and delay generator</para>
            </listitem>
            <listitem>
              <para>NIM Signal splitter</para>
            </listitem>
            <listitem>
              <para>LEMO to Ribbon cable converter</para>
            </listitem>
            <listitem>
              <para>Pulser</para>
            </listitem>
            <listitem>
              <para>50-Ohm LEMO terminator</para>
            </listitem>
            <listitem>
              <para>An assortment of LEMO cables</para>
            </listitem>
            <listitem>
              <para>A 34-conductor ribbon cable with 3M connectors on each end</para>
            </listitem>
            <listitem>
              <para>An oscilloscope</para>
            </listitem>
          </itemizedlist>

          <figure>
            <title>A simple electronics setup for the CAEN V785</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="figures/ss785_electronics_block_diagram.png"
                  format="PNG"/> 
              </imageobject>
            </mediaobject>
          </figure>

          <para>
           Before starting be sure that you can secure all of these items, many
           are available through the NSCL electronics pool. Figure 1-1 shows
           the complete setup of the system, due to the varying amount of
           familiarity of readers to the electronics, a brief description of
           the component and what the signal coming out of it should look like
           will be given.
          </para>

          <para>
            We will first look at the signal from the pulser. A pocket will
            work well for this. A pocket pulsers will give a small negative
            pulse, but we will invert it later. The signal directly from the
            pulser will look like figure 1-2 when viewed on a scope. The pulser
            only works when terminated with 50 Ohms.
          </para>

          <para>
            The pulser will run directly into a NIM based amplifier. This
            amplifer serves two purposes. First it will amplify our signal
            helping it stand out against any noise we might have in the
            channel. It will also invert the negative pulser signal giving us
            the positive signal that is required by the V785. The signal coming
            from the bi-polar output of the amplifier will look like figure
            1-3. Adjust the gain on the amplifier until you output signal has
            an amplitude of about 2V
          </para>

          <figure>
            <title>Pulser Output Signal</title>
            <graphic fileref="figures/ss785_pulser_output.png"
              format="PNG"/>
          </figure>
          <figure>
            <title>Amplifer Output Signal</title>
            <graphic fileref="figures/ss785_amplifier_output.png" format="PNG"/>
          </figure>

          <para>
            After you are happy with the signal from the amplifier plug the
            bipolar output into the splitter. The splitter will simply split
            the signal much like a "T" but will keep the 50? termination needed
            by the pulser
          </para>

          <para>
            After you are happy with the signal from the amplifier plug the
            bipolar output into the splitter. The splitter will simply split
            the signal much like a "T" but will keep the 50? termination needed
            by the pulser.
          </para>
          <para>
            <emphasis>NOTE:</emphasis> Ribbon cable can difficult to work with
            because it is easy to get it twisted and lose track, of which end
            is which. To avoid this look carefully at the coloring on the cable
            you are using and be sure it is plugged in the correct channel of
            the ADC.
          </para>

          <para>
            The other output from the splitter will go into a discriminator.
            This could be either a leading edge or a constant fraction
            discriminator. The job of the discriminator is determine when a
            signal has occurred and to put out a logic signal when it does. The
            discriminator will have a threshold knob, be sure that the
            threshold is set above any background noise that may be present so
            that the discriminator only trips on the pulser signal. It will be
            useful to look at the both the logic pulse and the signal from the
            amplifier at the same time when setting the threshold value. Figure
            1-4 shows what you will see.
          </para>

          <figure>
            <title>Amplified Signal with Logic Pulser</title>
            <graphic fileref="figures/ss785_amplified_signal_with_logic_pulse.png"
              format="PNG"/>
          </figure>

          <para>
            When the threshold is set to a reasonable level, connect one of the
            dis- criminator outputs to the start of one channel of your gate
            and delay gen- erator. The gate and delay generator will generate a
            gate when it receives a logic signal from the discriminator. When
            looking at the signal from the amplifier and the gate at the same
            time on the scope, the signal pulse should fall within the gate as
            seen in figure 1-5. If the gate is occurring too early you can use
            the gate and delay generator to delay the gate or to make the gate
            last longer. If the gate is too late you need to delay the signal
            pulse, that can be done using a delay module, or by adding cable
            delay. When you are happy with the gate timing, plug it into one of
            the LEMO connectors on the CAEN V785 labeled gate, put a 50 Ohm
            terminator in the other one.
          </para>

          <figure>
            <title>Amplified Signal and Gate</title>
            <graphic fileref="figures/ss785_amplified_signal_with_gate.png"
              format="PNG"/>
          </figure>

          <para>
            The second output of the discriminator will go to a second gate and
            delay channel; this combined with the CAEN V262 will trigger the
            computer when there is data on the V785. This channel will be run
            in latched mode meaning that it will be given both a start and a
            stop signal for the gate. The output signal will start being "true"
            when the start signal is received and stops being "true" when the
            stop signal is received. The start signal is the signal from the
            discriminator. The discriminator output will go to the IN0 of the
            CAEN V262 I/O module. The stop signal is generated by the computer
            to indicate it has responded to the trigger. That signal is present
            at the SHP2 output of the V262 and should be connected to the stop
            on the gate and delay generator.
          </para>

          <para>
            At this point your setup should be complete. Now is good time to
            make sure that your setup is the same as Figure 1-1. If everything
            is setup correctly the BUSY and DRDY lights on the V785 should be
            lit up.
          </para>
          <para>
            <emphasis>NOTE:</emphasis> At this point your setup should be
            complete. Now is good time to make sure that your setup is the same
            as Figure 1-1. If everything is setup correctly the BUSY and DRDY
            lights on the V785 should be lit up
          </para>
        </section>
    </chapter>
    <chapter>
        <title>Setting up the software</title>
        <para>
           The software modifications needed to make the above setup work can
           be divided into three tasks: 
         </para>
        <orderedlist>
          <listitem>
            <para>Telling the software what electronics we are using.</para>
          </listitem>
          <listitem>
            <para>Telling the software how to respond to event triggers.</para>
          </listitem>
          <listitem>
            <para>Telling the software how to analyze the data acquired.</para>
          </listitem>
        </orderedlist>

        <section>
          <title>Readout software</title>
          <para>
            In order to tell the software about our electronics, we are going to
            develop a C++ class for our module.  That class will be a derived
            class but we don't need to concern ourselves with the details of
            the parent class. Like all of the software tailoring we need to do,
            most of the details are hidden and we need only to fill in a few
            holes.
          </para>

          <para>
            The following commands will make a new directory and copy the
            skeleton files to it:
          </para>
          <screen>
mkdir -p ~/experiment/readout
cd ~/experiment/readout
cp /usr/opt/nscldaq/11.0/skeletons/sbs/* .
          </screen>

          <section>
            <title>Modifying the Readout Skeleton</title>

            <para>
              Now that we have obtained a copy of the Skeleton file we can
              begin to think about the modifications we need to make. We need
              to tell the software what kind of module we are using, how to
              initialize it, how to clear it, and how to read it. We will do
              this by creating a class called by MyEventSegment. In order to
              follow good coding practice and to make our code as versatile as
              possible we will write our class in two separate files, a header
              file and an implementation file. Start by creating a file called
              MyEventSement.h. It should look like this:
            </para>

            <example>
              <title>Header for MyEventSegment</title>
              <programlisting>
/*
  This is the header file to define the MyEventSegment class, which
  is derived from CEventSegment. This class can be used to read
  out any number of CAEN modules covered by the CAENcard class.
  Those cards include the V785, V775, and V792.
  6Chapter 2. Setting up the software
  Tim Hoagland
  11/3/04
  s04.thoagland@wittenberg.edu
*/

#ifndef MYEVENTSEGMENT_H                          <co  id="ex0_inc_protect"/>
#define MYEVENTSEGMENT_H

#include &lt;CEventSegment.h&gt;
#include &lt;CDocumentedPacket.h&gt;
#include &lt;CAENcard.h&gt;

// Declares a class derived from CEventSegment
class MyEventSegment : public CEventSegment               <co id="ex0_class_decl"/>
{
  private:
    CDocumentedPacket m_myPacket;                         <co id="ex0_docpacket"/>
    CAENcard          m_module;                           <co id="ex0_module_ptr"/>

  public:
    MyEventSegment(short slot, unsigned short Id);        <co id="ex0_ctor"/>
    virtual void initialize();                            <co id="ex0_init"/> 
    virtual void clear();                                 <co id="ex0_clear"/>
    virtual size_t read(void* pBuffer, size_t maxwords);  <co id="ex0_read"/>
};
#endif 
              </programlisting>
              <para>
                The header defines the class, its internal data and the services
                it exports to the readout framework. Refer to the circled
                numbers in the listing above when reading the following
                explanation
              </para>

              <calloutlist>
                <callout arearefs='ex0_inc_protect'>
                  <para>
                   Each header should protect itself against being included more
                   than once per compilation unit. This #ifndef directive and
                   the subsequente #define do this. The first time the header is
                   included, MYEVENTSEGMENT_H is not defined, and the #ifndef
                   is true. This causes MYEVENTSEGMENT_H to be defined, which
                   prevents subsequent inclusions from doing anything.
                  </para> 
                </callout> 
                <callout arearefs='ex0_class_decl'>
                  <para>
                    The class we are defining, MyEventSegment, implements the
                    services of a base class called CEventSegment. Anything that
                    reads out a chunk of the experiment is an event segment and
                    must be derived from the CEventSegment base class.
                  </para> 
                </callout> 
                <callout arearefs='ex0_docpacket'>
                  <para>
                    By convention in SBS Readout, events are segmented into 
                    packets. A packet
                    is a leading inclusive word count followed by a word that identifies
                    the contents of the packet followed by the packet body.
                    The m_MyPacket is member data for the class. It is a
                    CDocumentedPacket. Documented packets do the book-keeping
                    associated with maintaining the packet structure as well
                    as documenting their presence in documentation records
                    written at the beginning of the run.
                  </para> 
                </callout> 
                <callout arearefs='ex0_module_ptr'>
                  <para>
                    The support software for the CAEN V785 ADC is itself a
                    class: CAENcard. We will create an object of this class in
                    order to access the module. 
                  </para> 
                </callout> 
                <callout arearefs='ex0_ctor'>
                  <para>
                   This line declares the constructor for MyEventSegment. A
                   constructor is a function that is called to initialize the
                   data of an object when the object is being created
                   (constructed). 
                  </para> 
                </callout> 
                <callout arearefs='ex0_init'>
                  <para>
                    The Initialize member function is called whenever the run is
                    about to become active. If hardware or software requires
                    initialization, it can be done here. This function will be
                    called both when a run is begun as well as when a run is
                    resumed.
                  </para> 
                </callout> 
                <callout arearefs='ex0_clear'>
                  <para>
                    The clear method is called when it is appropriate
                    to clear any data that may have been latched into the
                    digitizers. This occurs at the beginning of a run and after
                    each event is read out.
                  </para> 
                </callout> 
                <callout arearefs='ex0_read'>
                  <para>
                   The read method is called in response to a trigger.
                   This member must read the part of the event that is managed
                   by this event segment. 
                  </para> 
                </callout> 
              </calloutlist>
            </example>

            <para>
              We will also create an implementation file: MyEventSegment.cpp.
              This file will implement the member functions that were defined by
              MyEventSegment.h above. The contents of this file are shown below:
            </para>

            <example>
              <title>Impementation of CMyEventSegment</title>
              <programlisting>
/*
This software is Copyright by the Board of Trustees of Michigan
State University (c) Copyright 2015.
You may use this software under the terms of the GNU public license
(GPL). The terms of this license are described at:
http://www.gnu.org/licenses/gpl.txt
Author:
Ron Fox
NSCL
Michigan State University
East Lansing, MI 48824-1321
*/

/*
  This is the implementation file for the MyEventSegment
  class. This class defines funtions that can be used to
  readout any module covered in the CAENcard class. These
  include the V785, V775, and V792
  Tim Hoagland
  11/3/04
  s04.thoagland@wittenberg.edu
*/
#include &lt;config.h&gt;
#include &lt;string&gt;

#ifdef HAVE_STD_NAMESPACE                             <co id="ex1_ifdef_std"/>
using namespace std;
#endif

// Set the polling limit for a timeout
static int CAENTIMEOUT = 50;

#include "MyEventSegment.h"                             <co id="ex1_include_hdr"/>

// Packet version -should be changed whenever major changes are made
// to the packet structure.
static const char* pPacketVersion = "1.0";                    <co id="ex1_pkt_version"/>

//constructor set Packet details
MyEventSegment::MyEventSegment(short slot, unsigned short Id):
  m_myPacket(Id,"My Packet","Sample documented packet",pPacketVersion),
  m_module(slot)                                        <co id="ex1_mod_ptr_init"/> 
                                                        <co id="ex1_initlist"/>
{
}

// Is called right after the module is created. All one time Setup
// should be done now.
void MyEventSegment::initialize()
{
  m_module.reset();                                        <co id="ex1_mod_ptr_reset"/>
  clear();
}

// Is called after reading data buffer
void MyEventSegment::clear()
{
  // Clear data buffer
  m_module.clearData();                                    <co id="ex1_mod_ptr_clearData"/> 
}

//Is called to readout data on m_module
size_t MyEventSegment::read(void* pBuffer, size_t maxsize)
{
  // Loop waits for data to become ready
  for(int i=0;i&lt;CAENTIMEOUT; i++) {                      <co id="ex1_poll_for_data"/>

    // If data is ready stop looping
    if(m_module.dataPresent()) {
      break;
    }
  }

  int nBytesRead=0;
  // Tests again that data is ready 
  if(m_module.dataPresent())
  {
    // Opens a new Packet
    uint16_t* pBuf = reinterpret_cast&lt;uint16_t*&gt;(pBuffer);
    pBuf = m_myPacket.Begin(pBuf);                                 <co id="ex1_pkt_begin"/> 
    // Reads data into the Packet 
    nBytesRead = m_module.readEvent(pBuf);                         <co id="ex1_readEvent"/> 
    // Closes the open Packet
    pBuf = m_myPacket.End(pBuf+nBytesRead/sizeof(uint16_t));       <co id="ex1_pkt_end"/> 
  }

  // compute number of bytes added to buffer
  return nBytesRead;                                               <co id="ex1_return_buffer"/> 
}
              </programlisting>

              <calloutlist>
                <callout arearefs='ex1_ifdef_std'>
                  <para>
                    The lines beginning with the include of config.h aneending
                    with the #endif near here are boilerplate that is required
                    for all implementation (.cpp) files for Readout skeletons
                    at version 8.0 and later.
                  </para>
                </callout>
                <callout arearefs='ex1_include_hdr'>
                  <para>
                    In order to get access to the class definition, we must
                    include the header that we wrote that defines the class
                  </para>
                </callout>
                <callout arearefs='ex1_pkt_version'>
                  <para>
                    Recall that we will be putting our event segment into a
                    packet. The packet will be managed by a documented packet
                    (CDocumentedPacket) object. This packet can document the
                    revision level, or version of the structure of its body.
                    The string pPacketVersion will document the revision level
                    of the packet body for our packet.
                  </para>
                </callout>
                <callout arearefs='ex1_initlist'>
                  <para>
                    This code in the constructor is called an initializer.
                    Initializers are basically constructor calls that are used
                    to construct base classes and data members of an object
                    under construction. The Id constructor parameter is used as
                    the id of the m_MyPacket CDocumentedPacket. The three
                    strings that follow are, respectively, a packet name, a
                    packet description and the packet body revision level.
                    These items are put in the documentation entry for the
                    packet that is created by the packet at the beginning of
                    the run.
                  </para>
                </callout>
                <callout arearefs='ex1_mod_ptr_init'>
                  <para>
                    The constructor body creates a new CAENcard object,
                    assigning a pointer to it to the member variable module.
                    The constructor's slot is used as the geographical address
                    of the module.
                  </para>
                </callout>
                <callout arearefs='ex1_mod_ptr_reset'>
                  <para>
                    This code initializes the CAEN V785 module by resetting it
                    to the default data taking settings, and then invoking our
                    Clear member function to clear any data that may be
                    latched.
                  </para>
                </callout>
                <callout arearefs='ex1_mod_ptr_clearData'>
                  <para>
                    This code clears any data that is latched in the module
                  </para>
                </callout>
                <callout arearefs='ex1_poll_for_data'>
                  <para>
                    The CAEN V785 requires about 6textmus to convert once it is
                    given a gate. It is possible for the software to start
                    executing the Read member function before conversion is
                    complete. This loop repeatedly invokes dataPresent for the
                    module. This function returns true when the module has
                    buffered conversions. At that time, control breaks out of
                    the loop.
                  </para>
                </callout>
                <callout arearefs='ex1_pkt_begin'>
                  <para>
                   This call to the Begin member of our documented packet
                   indicates that we are starting to read data into the body of
                   the packet. The code reserves space for the word count, and
                   writes the packet id.  The return value is a "pointer" to
                   the body of the packet. 
                  </para>
                </callout>
                <callout arearefs='ex1_readEvent'>
                  <para>
                    Data are read from the ADC into the packet.
                  </para>
                </callout>
                <callout arearefs='ex1_pkt_end'>
                  <para>
                    The size of the packet is written to the space reserved for
                    it. The packet is closed, and a "pointer" is returned to
                    the next free word in the buffer.
                  </para>
                </callout>
                <callout arearefs='ex1_return_buffer'>
                  <para>
                    The number of bytes that have been filled in the buffer
                    as a result of this method is returned. It is computed by
                    taking the distance between the begin and end of the buffer
                    just filled, i.e. the number of uint16_t elements added, and
                    then converting to bytes.
                  </para>
                </callout>
              </calloutlist>
            </example>

            <para>
              The numbers below refer to the circled numbers in the example
              above.
            </para>
          </section>

          <section>
            <title>Integrating your event segment with Readout</title>

            <para>
              Once you have created one or more event segments, you must
              register them with the Readout software.  Whenever the Readout
              software must do something to its event segments, it calls the
              appropriate member function in each event segment that has been
              registered, in the order in which it has been registered.
            </para>

            <para>
              Edit <literal>Skeleton.cpp</literal>. Towards the top of that
              file, after all the other #include statements, add:
            </para>

            <programlisting>
#include "MyEventSegment.h"
            </programlisting>

            <para>
              This is necessary because we will be creating an object of class
              MyEventSegment.
            </para>

            <para>
              Next, locate the function
              <literal>CMyExperiment::SetupReadout</literal> Modify it to
              create an instance of <literal>MyEventSegment</literal> and to
              register that instance as in the italicized code below 
            </para>

            <programlisting>
void
CMyExperiment::SetupReadout(CExperiment* pExperiment)
{
  assert(pExperiment!=0);
  CReadoutMain::SetupReadout(pExperiment);
  pExperiment->AddEventSegment(new MyEventSegment(10, 0xff00));
}
            </programlisting>

            <para>
              This code creates a new event segment for a CAEN V785 in slot 10,
              which will be read out into a packet with ID 0xff00.
            </para>
          </section>

          <section>
            <title>Making your Readout Executable</title>
            <para>
              Now that you have an event segment written, created an instance
              of it and registered it with the Readout, you must build an
              executable Readout program
            </para>

            <para>
              To build the program, you must edit the Makefile supplied with
              the skeleton code so that it knows about your additional program
              files. Locate the line that reads:
            </para>

            <programlisting>
Objects=Skeleton.o
            </programlisting>

            <para>
              Modify it so that it reads:
            </para>

            <programlisting>
Objects=Skeleton.o MyEventSegment.o
            </programlisting>

            <para>
              Save this edit, exit the editor and type:
            </para>

            <programlisting>
make
            </programlisting>

            <para>
              This will attempt to compile your readout software into an
              executable program called Readout. If the make command fails, fix
              the compilation errors indicated by it and retry until you get an
              error free compilation
            </para>
          </section>

          <section>
            <title>Testing the Readout Software</title>

            <para>
              The Readout program must run on a system that is physically
              connected to the VME crate containing your digitizers. Note that
              the ReadoutShell tool can be used to wrap your program with a
              Graphical user interface (GUI), and run it on the requested
              remote system. While debugging your software we do not recommend
              this. It's better just to run the software from the command line,
              or under control of the gdb symbolic debugger (see man gdb for
              more information about this extremely powerful debugging tool).
            </para>

            <para>
              In this section we will show how to use the command line to
            </para>

            <itemizedlist>
              <listitem>
                <para>
                 Start up a very simple low level event dumping program.
                </para> 
              </listitem>
              <listitem>
                <para>
                 Start your Readout program, start a run, stop a run, and exit. 
                </para> 
              </listitem>

              <listitem>
                <para>
                  Interpret the event dumps created while the run is active.
                </para>
              </listitem>
            </itemizedlist>

            <para>
              The program provided by NSCLDAQ that prints formatted raw data
              output to a terminal is called
              <command>dumper</command>. It can be attached to the ringbuffer
              that is receiving the output data of the Readout program and be
              used to inspect the raw data.
            </para>

            <variablelist>
              <varlistentry>
                <term>/usr/opt/nscldaq/current/bin/dumper</term>
                <listitem>
                  <para>
                    Dumps contents of ring items to the screen as formatted text.
                  </para>
                </listitem>
              </varlistentry>
            </variablelist>

            <para>
              To start the <command>dumper</command> program, log onto any
              computer on the same network as the one physically connected to
              the VME crate in which your CAEN V785 has been installed.
              Typically this is the same machine, but it doesn't have to be.
              To launch the program, you have to specify the hostname of the
              computer running the Readout program and also the name of the
              ringbuffer to connect to. The default values for these are
              "localhost" and your username. Assuming the Readout
              program is running locally (i.e. hostname=localhost) and your user
              name is "user0", you would type either:
            </para>

            <screen>
<literal>spdaqxx&gt;</literal> <command>/usr/opt/daq/current/bin/dumper
  --source=tcp://localhost/user0</command>
            </screen>
            <para>
              or equivalently,
            </para>
            <screen>
<literal>spdaqxx&gt;</literal> <command>/usr/opt/daq/current/bin/dumper</command>
            </screen>

            <para>
              The data rate is often high which causes the dumper to print out a
              streaming list of numbers that are impossible to read unless the
              program stops. For this reason, it is
              generally useful to limit the number of ring items processed by
              the dumper with the
              <option>--count</option> option. The value provided to this at
              launch determines the number of items process before exiting.
            </para>

            <para>
              To start the readout software, form another terminal session to
              the computer that is connected to your VME crate, set the default
              directory to where you built your software and start the Readout
              program.
            </para>

            <screen>
<literal>spdaqxx&gt;</literal> <command>cd ~/experiment/readout</command>
<literal>spdaqxx&gt;</literal> <command>./Readout</command>
            </screen>

            <para>
              When Readout starts, it will prompt you for input with a
              <literal>%</literal> symbol.
            </para>
            <para>
              The Readout program you have built runs an extended Tcl
              interpreter. Tcl is a scripting language that is widely used
              throughout the NSCL as an extension language. It provides a
              common base language for programming applications. Each program
              in turn extends this language with a set of commands that allow
              you to control the application itself. 
            </para>

            <para>
              The commands we will be working with are:
            </para>

            <variablelist>
              <varlistentry>
                <term><emphasis>begin</emphasis></term>

                <listitem>
                  <para>
                    Begins a run. From the point of view of your code, the
                    initialize and clear member functions of your event segment
                    will be called. The Readout framework will continually check
                    whether your trigger is satisfied and then call the
                    read member function of your event segment when it is.
                  </para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term><emphasis>end</emphasis></term>
                <listitem>
                  <para>
                    Ends a run. The readout framework stops responding to
                    triggers.
                  </para>
                </listitem>
              </varlistentry>
            </variablelist>

            <para>
              Tell the readout program to start a run:
            </para>

            <screen>
% <command>begin</command>
            </screen>
            <para>
              The dumper terminal session should now start spewing stuff at you.
              If the trigger rate is high, you may need to stop the run to be
              able to read the buffers. To do this type: end to the Readout
              program.
            </para>

            <para>
               When the run starts, dumper dumps the headers of several
               non-event buffers. As each event buffer is filled with data
               collected by the read member function in your event segment,
               dumper will dump the buffer header and the first event in the
               buffer. This might look a bit like this:
            </para>

            <screen>
              <computeroutput>
asdfsdf
              </computeroutput>
            </screen>

            <para>
              Focus on the section below the word Event:. This is a hexadecimal
              representation of the data in the first event of the buffer. The
              event that we made starts with 47, this is the total number of
              words (in hex) that exist in the event. The size of the event is
              filled in by the Readout framework. The next word is the number of
              words in our packet (in hex). This word is filled in by our
              documented packet. The third word is the packet id in this case
              0xff00 This word is also filled in by our documented packet
              object. The remainder of the event is the data from the ADC
              hardware. The next two words are the ADC header; if you break
              these down into binary representation the first five bits will be
              the slot where the V785 is located. If the packet ID and slot
              number are both correct then you are ready to move on to modifying
              the SpecTcl Skeleton.
            </para>

            <para>
              Complete documentation of the data read from the ADC hardware is
              given by the CAEN V785 manual.  This manual can be found online at
              CAEN website: http://www.caen.it/
            </para>

            <para>
              Exit the Readout program by typing the following to the Readout
              program:
            </para>

            <screen>
% <command>exit</command>
            </screen>

          </section>
        </section>
    </chapter>
</book>
