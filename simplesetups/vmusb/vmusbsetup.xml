
<!--     chapter simple-setups -->

<chapter>
  <title>A Simple VMUSBReadout Experiment Tutorial</title>


  <section>
    <title>Introduction</title>

    <para>
      NSCLDAQ distributes with it a program called VMUSBReadout that supports
      the readout of the Wiener VM-USB VME controller. The following document
      will instruct the reader in how to set up a basic experiment consisting of
      a CAEN V785 peak sensing analog-to-digital converter, a CAEN V775
      time-to-digital converter, and a Struck SIS3820 32-channel latching
      scaler. The level at which this tutorial is written assumes the following: 
    </para>

    <itemizedlist>
      <listitem>
        <para>Little to no programming experience</para>
      </listitem>
      <listitem>
        <para>Access to the required electronics</para>
      </listitem>
      <listitem>
        <para>Ability to wire up signal processing circuit from a block diagram</para>
      </listitem>
      <listitem>
        <para>The reader has already read the
          <application>VMUSBReadout</application> User's Guide found at the
          NSCLDAQ <ulink url="http://docs.nscl.msu.edu/daq">website</ulink> or
          in the <filename>/usr/opt/nscldaq/11.0/share/pdfs</filename>
          directory.  
        </para> 
      </listitem>
    </itemizedlist>

    <para>
      In addition to simply setting up the experiment, the user will be
      instructed at how to interpret the output of the devices using the dumper
      program. If you are unfamiliar with the VMUSBReadout program, you can
      find a complete user's guide for the
      <application>VMUSBReadout</application> in the comprehensive NSCLDAQ
      documentation.
    </para>

  </section>

  <section>
    <title>Setting up the Electronics</title>

    <para>
      In this section, the reader will be walked through setting up a simple
      DAQ for processing a pulser. In order to set up the following circuit, the
      user must acquire at least the following electronics:
    </para>

    <itemizedlist>
      <listitem>
        <para>Wiener VM-USB controller</para>
      </listitem>
      <listitem>
        <para>CAEN V775 time-to-digital converter</para>
      </listitem>
      <listitem>
        <para>CAEN V785 peak-sensing analog-to-digital converter</para>
      </listitem>
      <listitem>
        <para>Struck SIS3820 32-channel scaler</para>
      </listitem>
      <listitem>
        <para>Gate and delay generator</para>
      </listitem>
      <listitem>
        <para>Delay module</para>
      </listitem>
      <listitem>
        <para>Constant-fraction discriminator</para>
      </listitem>
      <listitem>
        <para>Plenty of lemo cables</para>
      </listitem>
      <listitem>
        <para>Ribbon cable or a handful of twisted pair cables</para>
      </listitem>
      <listitem>
        <para>ECL-to-NIM converter</para>
      </listitem>
      <listitem>
        <para>Pulser</para>
      </listitem>
      <listitem>
        <para>VME crate</para>
      </listitem>
      <listitem>
        <para>NIM crate</para>
      </listitem>
    </itemizedlist>

    <para>
      Rather than detail how to plug each cable into each module, th
      electronics diagram for the digitizers is provided in <xref linkend="v775v785blockdiagram"
        endterm="v775v785blockdiagram-title"/>.
    </para>

    <figure id="v775v785blockdiagram">
      <title id="v775v785blockdiagram-title">
        Block diagram of the V775 and V785 wiring
      </title>
      <graphic fileref="v785v775sis3820setup.eps"/>
    </figure>

    <figure id="sis3820blockdiagram">
      <title id="sis3820blockdiagram-title">
        Block diagram of SIS3820 scaler wiring
      </title>
      <graphic fileref="sis3820blockdiagram.png"/>
    </figure>
  </section>

  <section id="daqconfig">
    <title id="daqconfig-title">
      The Configuration Files
    </title>

    <para>
      Because we are using hardware that is already supported by
      <application>VMUSBReadout</application>, the only tasks left
      are to create the <filename>daqconfig.tcl</filename> and
      <filename>ctlconfig.tcl</filename> scripts.
    </para>

    <para>
      The <filename>ctlconfig.tcl</filename> script is the configuration file
      for the slow-controls subsystem. In this situation, it will be an empty file
      because we are not attempting to use slow-controlled capabilities. We can
      quickly generate an empty file with the <command>touch</command> program
      at the command line. Here is how that works.
    </para>

    <screen>
<literal>spdaqXX&gt;</literal> <command>touch ctlconfig.tcl</command>
    </screen>

    <para>
      The next step is to build our <filename>daqconfig.tcl</filename> script.
      In that file, we will declare the V785, V775, and SIS3820 and add them to
      stacks. Doing so will cause them to be initialized at the beginning
      of each run, read out during triggers, and then transitioned back to an
      inactive mode at the end of each run. The V785 and V775 will be read out
      using a chained block transfer for each event trigger, and the SIS3820 will
      be periodically read using an internally generated trigger. We will
      therefore, need to define two separate stacks.
    </para>
    
    <section>
      <title>The event stack</title>
      <para>
        We will begin with defining the stack that will read out our digitizer.
        Because this stack will read out the event data, we will refer to it as
        the "event stack". To begin setting up this stack, we have to first
        construct the device instances for the V785 and V775. Both of these
        conveniently share the same Tcl command ensemble, because they are
        essentially identical pieces of hardware. The command ensemble that create
        their device instances is called <command>adc</command>. It takes a set of
        options that are accepted for both V785 and V775 devices and then some
        more specialized options only valid for either the V785 and V775. The
        first module we will create is the V785. To do so we add the following
        lines to our <filename>daqconfig.tcl</filename> file:
      </para>

      <programlisting>
set adcThresh [list 10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 ]  <co id="vmusb-ss-v785-thresh"/>
adc create v785 0x11110000                      <co id="vmusb-ss-v785-create"/>
adc config v785 -geo 10 -threshold $adcThresh   <co id="vmusb-ss-v785-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-v785-thresh">
          <para>
            The V785 takes a list of 32 integers for its
            <option>-threshold</option> option. Each integer corresponds to the
            threshold for a channel. The first element of the list corresponds to
            channel 0 and the last to channel 31. For making our code more
            organized, we define a variable named <literal>adcThresh</literal>
            that will hold the list of 32 integers we created. Note that we
            created the list using a Tcl <command>list</command> command. This
            simply just returns a properly formatted Tcl list. The
            <command>set</command> command assigns the list to the variable.
          </para>
        </callout>
        <callout arearefs="vmusb-ss-v785-create">
          <para>
            A new adc device instance is created with the name
            <literal>v785</literal>. The base address of the V785 in our crate is
            provided as the last argument to the line. 
          </para>
        </callout>
        <callout arearefs="vmusb-ss-v785-config">
          <para>
            The device instance named <literal>v785</literal> is configured. We
            specify via the <option>-geo</option> option which slot it lives in.
            This value will label the data outputted by the device during each
            readout cycle. It is important that this corresponds to the correct
            slot index the card is situated in. We also pass the list wof
            thresholds to the <option>-thresholds</option> option. The
            <literal>$</literal> syntax dereferences the variable
            <literal>adcThresh</literal> and returns the list
            that it refers to.
          </para>
        </callout>
      </calloutlist>


      <para>
        Using an an almost identical recipe, we will create a device instance for
        the V775. We want to define the time range of the TDC so we will configure
        the <option>-timescale</option> option.
      </para>

      <programlisting>
set tdcThresh [list 10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 ]
adc create v775 0x22220000                      <co id="vmusb-ss-v775-create"/>
adc config v775 -geo 11 -threshold $tdcThresh   
adc config v775 -timescale 150                  <co id="vmusb-ss-v775-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-v775-create">
          <para>
            Just like the V785, we create the device instance using the
            <command>create</command> subcommand. The name we can refer to this
            device later in the script will be <literal>v775</literal>. The 
            base address for the module is 0x22220000.
          </para>
        </callout>
        <callout arearefs="vmusb-ss-v775-config">
          <para>
            The first line of configuration is almost identical to the V785
            besides the different slot number and the different variable name
            holding the threshold list. The second line of configuration though
            establishes the time range of the TDC as a maximum 150 ns.  
          </para>
        </callout>
      </calloutlist>


      <para>
        We now have two device instances defined in the configuration script. If
        we wanted to, we could immediately construct a stack using the
        <command>stack</command> command ensemble and pass our
        <literal>v775</literal> and <literal>v785</literal> device instance to it.
        However, we intend to read out our devices using a chained block transfer
        technique. A chained block transfer is an optimized means for reading out
        multiple devices. Instead of having to set up a block transfer from one
        device and then again from the second device, we can set up one block
        transfer and that reads out all of the devices in order. This
        functionality is implemented by the V785 and V775 rather than the VM-USB.
        To the VM-USB, this is just like a normal block transfer. To set this up
        in our <filename>daqconfig.tcl</filename> file we need to use the
        <command>caenchain</command> command. Here is how we do that:
      </para>

      <programlisting>
caenchain create chain                  <co id="vmusb-ss-chain-create"/>
caenchain config chain -base 0x12000000 -modules [list v775 v785] <co
          id="vmusb-ss-chain-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-chain-create">
          <para>
            This line creates a device instance for the chained block transfer. We
            can refer to it by its name <literal>chain</literal> later in the
            file.
          </para>
        </callout>
        <callout arearefs="vmusb-ss-chain-config">
          <para>
            The chained block transfer works by accessing the devices via a
            different address than their individual base addresses. In fact, by
            sending commands to this address, all of the modules who understand it
            can respond simultaneously. Some implementation require a multicast
            address as well as a chained block transfer address, the base address
            we provide for the Caen modules is dual purpose. It is important that
            only the top 8-bits of the base address provided here is used.
            Furthermore, we have also added the <literal>v775</literal> and
            <literal>v785</literal> device instances for chained readout. The
            order of these modules should reflect the order in which they reside
            in the crate. The leftmost module in the crate should be the first
            module in the list and the rightmost module should be the last in the
            list.
          </para>
        </callout>
      </calloutlist>

      <para>
        The <command>caenchain</command> extends the idea of a device instance,
        because it does not really reflect a piece of hardware. Rather it is
        more of a virtual piece of hardware that handles the readout of multiple
        physical pieces of hardware. With it created and configured, we are
        ready to create our stack and we will only register the
        <literal>chain</literal> to the stack.  Here is how that works
      </para>


      <programlisting>
stack create evtStack                             
stack config evtStack -modules [list chain] -trigger nim1 <co
  id="vmusb-ss-evtstack-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-evtstack-config">
          <para>
            A single element list containing <literal>chain</literal> is added to
            the stack. Because our <literal>v775</literal> and
            <literal>v785</literal> are registered to the <literal>chain</literal>
            they will indirectly be read out. The <option>-trigger</option> option
            is passed a value of <literal>nim1</literal> to indicate that the
            stack will be triggered for execution whenever a logic pulse arrives
            at NIM input 1.
          </para>
        </callout>
      </calloutlist>

    </section>
    <!-- end of event stack section -->

    <section>
      <title>The scaler stack</title>

      <para>
        With the event stack already defined, we now turn to the definition of
        the stack responsible for reading out the SIS3820. Because this stack
        will deal with scaler data, it will be referred to as the scaler stack.
        The procedure for setting up the scaler stack is the same as for the
        event stack. First we create a device instance for the SIS3820 and then
        we add it to a stack.
      </para>

      <para>
        The Tcl command ensemble responsible for creating, configuring, and
        querying the state of an SIS3820 is named <command>sis3820</command>.
        There are two options that can be configured for the device instances it
        creates and we will only use the <option>-base</option> option. This
        will take the base address of the actual VME module. When this is added
        to a stack, it will cause the VM-USB to read all 32 channels of the
        device it is associated with. Let's add the following line to the bottom
        of our <filename>daqconfig.tcl</filename> file:
      </para>

      <programlisting>
sis3820 create sclr 0x38000000        
      </programlisting>

      <para>
        The scaler can then be added to a stack later by its name
        <literal>sclr</literal>. We will do that right now. Creating the stack
        for the scaler readout is done as normal using the
        <command>stack</command>. However, to define this a scaler stack that
        gets periodically read out we need to specify different values for the
        options.
      </para>

      <programlisting>
stack create sclrStack                    
stack config sclrStack -modules [list sclr] -trigger scaler -period 2 <co
          id="vmusb-ss-sclrstack-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-sclrstack-config">
          <para>
            Purposing a stack for scaler readout is accomplished by passing
            <literal>scaler</literal> for the <option>-trigger</option>
            argument. Not only does this enable periodic execution of the stack,
            but it also labels the stack as index 1.
            <application>VMUSBReadout</application> will treat the data read by
            this stack specifically as scaler data and turn it into ring items
            of type PERIODIC_SCALERS. The <option>-period</option> option was
            passed a value of 2 to specify that we want the readout period to be
            2 seconds.
          </para>
        </callout>
      </calloutlist>

      <para>
        The scaler stack is now complete.
      </para>

    </section><!-- end of scaler stack -->

  </section><!-- end of configuration scripts -->

  <section>
    <title>Running VMUSBReadout</title>

    <para>
      There is a detailed overview of how to run
      <application>VMUSBReadout</application> in the comprehensive documentation
      of NSCLDAQ. In this section we will assume that that has been read already
      and we will proceed by defining a simple launcher script.
    </para>

    <para>
      Unless you intend to keep your configuration scripts in the directory
      <filename>~/config</filename>, you are required to specify the location of
      the configuration scripts at launch. To avoid this, we will generate a
      short bash script that will launch
      <application>VMUSBReadout</application> with the local configuration
      scripts. To do so, we create a script called <filename>govmusb</filename>
      that has the following contents.
    </para>

    <programlisting>
#!/bin/sh                           <co id="vmusb-ss-launch-shebang"/>

$DAQBIN/VMUSBReadout --daqconfig=$PWD/daqconfig.tcl --ctlconfig=$PWD/ctlconfig.tcl <co id="vmusb-ss-launch-guts"/>
    </programlisting>


    <calloutlist>
      <callout arearefs="vmusb-ss-launch-guts">
        <para>
          We assume that the DAQBIN environment variable has been specified by
          sourcing the <filename>daqsetup.bash</filename> script. If you have
          not done this, you can source the script by doing (at the NSCL):
        </para>
        <screen>
<literal>spdaqXX&gt;</literal> <command>unset DAQROOT</command>
<literal>spdaqXX&gt;</literal> <command>source /usr/opt/nscldaq/11.0/daqsetup.bash</command>
        </screen>
        <para>
          The <literal>PWD</literal> environment is defined by default and
          stands for "present working directory." Note that this implies that
          the configuration scripts must live in the directory that the
          <filename>govmusb</filename> script is executed from.
        </para>
      </callout>
    </calloutlist>

    <para>
      To make the script executable, we have to change the permissions. Unless
      you want to prevent other people from executing the launcher script you
      can let all users execute it. To do that we use the
      <command>chmod</command> command. 
    </para>

    <screen>
<literal>spdaqXX&gt;</literal> <command>chmod a+x govmusb</command>
    </screen>

    <para>
      At this point you should be able to start up
      <application>VMUSBReadout</application> by executing the script. That is
      done by doing:
    </para>
    <screen>
<literal>spdaqXX&gt;</literal> <command>./govmusb</command>
    </screen>

    <para>
      At the prompt of VMUSBReadout, you can use the <command>begin</command>,
      <command>end</command>, <command>pause</command>, and
      <command>resume</command> commands to start, stop, pause, and resume runs.
    </para>
  </section>

  <section>
    <title>
      Understanding the Output
    </title>

    <para>
      The output of the program can be inspected by attaching the
      <application>dumper</application> program to the ring buffer receiving the
      data outputted from <application>VMUSBReadout</application>. Because we
      did not provide a different ring buffer at the command line when launching
      our program, the output will go to a ring buffer whose name is the same as
      your username. This is actually the default value of the
      <option>--source</option> command line option of the dumper program. As a
      result we can attach the <application>dumper</application> with the
      following command from a different terminal than the one running
      <application>VMUSBReadout</application>.
    </para>

    <screen>
<literal>spdaqXX&gt;</literal> <command>dumper</command>
    </screen>

    <para>
      If the run is active, you should see data printing to your screen. You can
      kill the <application>dumper</application> program by pressing
      <literal>CTL-C</literal>. A cleaner way to do this in the future is to
      provide <application>dumper</application> with a finite number of ring
      items to process. For example, to process 10 ring items and then exit, one
      would enter:
    </para>

    <screen>
<literal>spdaqXX&gt;</literal> <command>dumper --count=10</command>
    </screen>

    <section>
      <title>Event data</title>
    <para>
      However you do this, you should see event output that might look like this:
    </para>

    <screen>
      <computeroutput>
-----------------------------------------------------------
Event 34 bytes long
Body Header:
Timestamp:    5764974207242862948
SourceID:     0
Barrier Type: 0
0010 0100 5200 4d7f 5001 0c08 5400 0100
5a00 4de4 5801 0c05 5c00 ffff ffff ffff
ffff
-----------------------------------------------------------
      </computeroutput>
    </screen>

    <para>
      From the <application>VMUSBReadout</application> user's guide, we know
      that the first 16-bit word is the event header produced by the VM-USB
      itself. The most-significant four bits specify that the data corresponds
      to stack 0 and the least significant 12 bits specify that there are
      sixteen 16-bit words that follow. This is very sensible because we only
      defined a single event stack and we can count the remaining data words.
    </para>

    <para>
      The remaining 16 words must be understood according to the data format of
      the V785 and V775. Each of these devices outputs a series of 32-bit words
      bookended by header and end-of-event words. Bits 24-26 uniquely identifies
      betweeen those two words and the data words. The format also uses the most
      significant five bits (bits 27-31) for the geographic address. The
      geographic address should be the same value we provided for the
      <option>-geo</option> option. For that reason, we expect that bits 27-31 of
      each 32-bit word can be used to identify whether the data originated from
      the V775 or the V785. Before we start parsing the data further, let's
      group the 16-bit words in the output into 32-bit words.
    </para>

    <screen>
0x0010        <co id="vmusb-ss-rawdata-evthdr"/>
0x52000100    <co id="vmusb-ss-rawdata-v775hdr"/>
0x50014d7f    <co id="vmusb-ss-rawdata-v775data"/>
0x54000c08    <co id="vmusb-ss-rawdata-v775eoe"/>
0x5a000100    <co id="vmusb-ss-rawdata-v785hdr"/>
0x58014def    <co id="vmusb-ss-rawdata-v785data"/>
0x5c000c05    <co id="vmusb-ss-rawdata-v785eoe"/>
0xffffffff   
0xffffffff    <co id="vmusb-ss-rawdata-ffff"/> 
    </screen>

    <calloutlist>
      <callout arearefs="vmusb-ss-rawdata-evthdr">
        <para>
          VM-USB event header. This is just 16-bits.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v775hdr">
        <para>
          Header word for the V775 identified by bits 24-26 being the value 2. The
          most-significant 5 bit of this number is 10, which matches what was defined for
          the <option>-geo</option> option of the v775. Other information
          encoded in this header are the crate index (bits 16-23) and the number
          of data words before the end-of-event word (bits 12-16). The header
          tells us that the module resides in crate 0 and that there is a single
          data word that follows.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v775data">
        <para>
          This is the lone data word for the V775 identified by bits 24-26 being
          0. Bits 27-31 still contain a geographic address of 10 as it should.
          Bits 16-20 identify the channel number for the data, bits 0-11 identify
          the value and bits 12 and 13 are the underflow and overflow bits. We can
          use this information to understand that digitized value did not
          underflow or overflow and resulted in the value 3455.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v775eoe">
        <para>
          As we expect by header word of the V775, this is the end of event word.
          We know this for sure because bits 24-26 store the value 4. Once again
          the bits 27-31 store the value 10 so the word originated from the
          V775. The lower 24 bits store the event count, which converts to 3079
          in decimal.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v785hdr">
        <para>
          This word is the first word of the V785. It is a header word that
          corresponds to slot 11 and crate 0. There is one data word that follows
          prior to the end-of-event word.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v785data">
        <para>
          Here is the data for the V785. It corresponds to channel 1 and has a
          value f 3567. 
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v785eoe">
        <para>
          Here is the end-of-event word for the V785. It corresponds to event
          number 3077.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-ffff">
        <para>
          The 0xffffffff is what is returned by the devices when they complete
          their block transfer. There are two of these because each module is
          emitting BERR to signify they are done being read out.
        </para>
      </callout>
    </calloutlist>

    <para>
      In the above output, it is apparent that the event count of the V775 and
      V785 differ by 2 events, the V775 having seen two more events than the V785.
      Such a condition is not terribly worrisome in this case, because the V775
      is initialized prior to the V785. Because the initialization process is done
      before the VM-USB transitions to autonomous mode, the timing is
      controlled by the speed at which a VM-USB can execute interactive commands
      and the speed at which the software operates. Such timing is indeterminate
      because the operation system scheduler plays a role. It should be expected
      that the time between clearing the V775 and V785 is on the order of
      milliseconds. If the rate is around 1 kHz, then it is possible that
      multiple triggers occur after the V775 has been cleared and the V785
      clears.
    </para>



    </section>

    <section>
      <title>Scaler data</title>

      <para>
        If your most recent dump of the data using
        <application>dumper</application> did not include any scaler items in
        the output, you should run the <application>dumper</application> again
        in such a way that excludes processing ring items of type PHYSICS_EVENT.
      </para>

      <screen>
<literal>spdaqXX&gt;</literal> <command>$DAQBIN/dumper --count=5 --exclude=PHYSICS_EVENT</command>
      </screen>

      <para>
        The output should include at least one ring item that has the following
        look:
      </para>

      <screen>
        <computeroutput>
Tue Mar 10 15:12:56 2015 : Scalers:
Interval start time: 10 end: 12 seconds in to the run

Body Header:
Timestamp:    0
SourceID:     0
Barrier Type: 0
Scalers are incremental
Index         Counts                 Rate
    0              0                 0.00
    1              0                 0.00
    2              0                 0.00
    3              0                 0.00
    4              0                 0.00
    5              0                 0.00
    6              0                 0.00
    7              0                 0.00
    8              0                 0.00
    9              0                 0.00
   10              0                 0.00
   11              0                 0.00
   12              0                 0.00
   13              0                 0.00
   14              0                 0.00
   15              0                 0.00
   16            513                 256.50
   17              0                 0.00
   18              0                 0.00
   19              0                 0.00
   20              0                 0.00
   21              0                 0.00
   22              0                 0.00
   23              0                 0.00
   24              0                 0.00
   25              0                 0.00
   26              0                 0.00
   27              0                 0.00
   28              0                 0.00
   29              0                 0.00
   30              0                 0.00
   31              0                 0.00
-----------------------------------------------------------
        </computeroutput>
      </screen>

      <para>
        There is much less to be explained here than for the event data.
        The scaler stack read out all 32 channels of data from the SIS3820
        during each stack execution, so the dump shows 32 channels of data. In
        my test setup, I had only plugged in a single input to the SIS3820 at
        channel 16. The SIS3820 was operated as an incremental scaler as well,
        which means that after every read the device was cleared. In the
        information section above the actual scaler values, you also see that
        the scaler values account for the time between 10 and 12 seconds after
        the run began.
      </para>
    </section>
  </section>
</chapter>
