
<!--     chapter simple-setups -->

<chapter>
  <title>A Simple VMUSBReadout Experiment Tutorial</title>


  <section>
    <title>Introduction</title>

    <para>
      NSCLDAQ distributes with it a program called VMUSBReadout that supports
      the readout of the Wiener VM-USB VME controller. The following document
      will instruct the reader in how to set up a basic experiment consisting of
      a CAEN V785 peak sensing analog-to-digital converter, a CAEN V775
      time-to-digital converter, and a Struck SIS3820 32-channel latching
      scaler. The level at which this tutorial is written assumes the following: 
    </para>

    <itemizedlist>
      <listitem>
        <para>Little to no programming experience</para>
      </listitem>
      <listitem>
        <para>Access to the required electronics</para>
      </listitem>
      <listitem>
        <para>Ability to wire up signal processing circuit from a block diagram</para>
      </listitem>
      <listitem>
        <para>The reader has already read the
          <application>VMUSBReadout</application> User's Guide found at the
          NSCLDAQ <ulink url="http://docs.nscl.msu.edu/daq">website</ulink> or
          in the <filename>/usr/opt/nscldaq/11.0/share/pdfs</filename>
          directory.  
        </para> 
      </listitem>
    </itemizedlist>

    <para>
      In addition to simply setting up the experiment, the user will be
      instructed at how to interpret the output of the devices using the dumper
      program. If you are unfamiliar with the VMUSBReadout program, you can
      find a complete user's guide for the
      <application>VMUSBReadout</application> in the comprehensive NSCLDAQ
      documentation.
    </para>

  </section>

  <section>
    <title>Setting up the Electronics</title>

    <para>
      In this section, the reader will be walked through setting up a simple
      DAQ for processing a pulser. In order to set up the following circuit, the
      user must acquire at least the following electronics:
    </para>

    <itemizedlist>
      <listitem>
        <para>Wiener VM-USB controller</para>
      </listitem>
      <listitem>
        <para>CAEN V775 time-to-digital converter</para>
      </listitem>
      <listitem>
        <para>CAEN V785 peak-sensing analog-to-digital converter</para>
      </listitem>
      <listitem>
        <para>Struck SIS3820 32-channel scaler</para>
      </listitem>
      <listitem>
        <para>Gate and delay generator</para>
      </listitem>
      <listitem>
        <para>Delay module</para>
      </listitem>
      <listitem>
        <para>Constant-fraction discriminator</para>
      </listitem>
      <listitem>
        <para>Plenty of lemo cables</para>
      </listitem>
      <listitem>
        <para>Ribbon cable or a handful of twisted pair cables</para>
      </listitem>
      <listitem>
        <para>ECL-to-NIM converter</para>
      </listitem>
      <listitem>
        <para>Pulser</para>
      </listitem>
      <listitem>
        <para>VME crate</para>
      </listitem>
      <listitem>
        <para>NIM crate</para>
      </listitem>
    </itemizedlist>

    <para>
      Rather than detail how to plug each cable into each module, th
      electronics diagram for the digitizers is provided in <xref linkend="v775v785blockdiagram"
        endterm="v775v785blockdiagram-title"/>.
    </para>

    <figure id="v775v785blockdiagram">
      <title id="v775v785blockdiagram-title">
        Block diagram of the V775 and V785 wiring
      </title>
      <graphic fileref="v785v775sis3820setup.eps"/>
    </figure>

    <figure id="sis3820blockdiagram">
      <title id="sis3820blockdiagram-title">
        Block diagram of SIS3820 scaler wiring
      </title>
      <graphic fileref="sis3820blockdiagram.png"/>
    </figure>
  </section>

  <section id="daqconfig">
    <title id="daqconfig-title">
      The Configuration Files
    </title>

    <para>
      Because we are using hardware that is already supported by
      <application>VMUSBReadout</application>, the only tasks left
      are to create the <filename>daqconfig.tcl</filename> and
      <filename>ctlconfig.tcl</filename> scripts.
    </para>

    <para>
      The <filename>ctlconfig.tcl</filename> script is the configuration file
      for the slow-controls subsystem. In this situation, it will be an empty file
      because we are not attempting to use slow-controlled capabilities. We can
      quickly generate an empty file with the <command>touch</command> program
      at the command line. Here is how that works.
    </para>

    <screen>
<literal>spdaqXX&gt;</literal> <command>touch ctlconfig.tcl</command>
    </screen>

    <para>
      The next step is to build our <filename>daqconfig.tcl</filename> script.
      In that file, we will declare the V785, V775, and SIS3820 and add them to
      stacks. Doing so will cause them to be initialized at the beginning
      of each run, read out during triggers, and then transitioned back to an
      inactive mode at the end of each run. The V785 and V775 will be read out
      using a chained block transfer for each event trigger, and the SIS3820 will
      be periodically read using an internally generated trigger. We will
      therefore, need to define two separate stacks.
    </para>
    
    <section>
      <title>The event stack</title>
      <para>
        We will begin with defining the stack that will read out our digitizer.
        Because this stack will read out the event data, we will refer to it as
        the "event stack". To begin setting up this stack, we have to first
        construct the device instances for the V785 and V775. Both of these
        conveniently share the same Tcl command ensemble, because they are
        essentially identical pieces of hardware. The command ensemble that create
        their device instances is called <command>adc</command>. It takes a set of
        options that are accepted for both V785 and V775 devices and then some
        more specialized options only valid for either the V785 and V775. The
        first module we will create is the V785. To do so we add the following
        lines to our <filename>daqconfig.tcl</filename> file:
      </para>

      <programlisting>
set adcThresh [list 10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 ]  <co id="vmusb-ss-v785-thresh"/>
adc create v785 0x11110000                      <co id="vmusb-ss-v785-create"/>
adc config v785 -geo 10 -threshold $adcThresh   <co id="vmusb-ss-v785-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-v785-thresh">
          <para>
            The V785 takes a list of 32 integers for its
            <option>-threshold</option> option. Each integer corresponds to the
            threshold for a channel. The first element of the list corresponds to
            channel 0 and the last to channel 31. For making our code more
            organized, we define a variable named <literal>adcThresh</literal>
            that will hold the list of 32 integers we created. Note that we
            created the list using a Tcl <command>list</command> command. This
            simply just returns a properly formatted Tcl list. The
            <command>set</command> command assigns the list to the variable.
          </para>
        </callout>
        <callout arearefs="vmusb-ss-v785-create">
          <para>
            A new adc device instance is created with the name
            <literal>v785</literal>. The base address of the V785 in our crate is
            provided as the last argument to the line. 
          </para>
        </callout>
        <callout arearefs="vmusb-ss-v785-config">
          <para>
            The device instance named <literal>v785</literal> is configured. We
            specify via the <option>-geo</option> option which slot it lives in.
            This value will label the data outputted by the device during each
            readout cycle. It is important that this corresponds to the correct
            slot index the card is situated in. We also pass the list wof
            thresholds to the <option>-thresholds</option> option. The
            <literal>$</literal> syntax dereferences the variable
            <literal>adcThresh</literal> and returns the list
            that it refers to.
          </para>
        </callout>
      </calloutlist>


      <para>
        Using an an almost identical recipe, we will create a device instance for
        the V775. We want to define the time range of the TDC so we will configure
        the <option>-timescale</option> option.
      </para>

      <programlisting>
set tdcThresh [list 10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 \
                    10 10 10 10  10 10 10 10 ]
adc create v775 0x22220000                      <co id="vmusb-ss-v775-create"/>
adc config v775 -geo 11 -threshold $tdcThresh   
adc config v775 -timescale 150                  <co id="vmusb-ss-v775-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-v775-create">
          <para>
            Just like the V785, we create the device instance using the
            <command>create</command> subcommand. The name we can refer to this
            device later in the script will be <literal>v775</literal>. The 
            base address for the module is 0x22220000.
          </para>
        </callout>
        <callout arearefs="vmusb-ss-v775-config">
          <para>
            The first line of configuration is almost identical to the V785
            besides the different slot number and the different variable name
            holding the threshold list. The second line of configuration though
            establishes the time range of the TDC as a maximum 150 ns.  
          </para>
        </callout>
      </calloutlist>


      <para>
        We now have two device instances defined in the configuration script. If
        we wanted to, we could immediately construct a stack using the
        <command>stack</command> command ensemble and pass our
        <literal>v775</literal> and <literal>v785</literal> device instance to it.
        However, we intend to read out our devices using a chained block transfer
        technique. A chained block transfer is an optimized means for reading out
        multiple devices. Instead of having to set up a block transfer from one
        device and then again from the second device, we can set up one block
        transfer and that reads out all of the devices in order. This
        functionality is implemented by the V785 and V775 rather than the VM-USB.
        To the VM-USB, this is just like a normal block transfer. To set this up
        in our <filename>daqconfig.tcl</filename> file we need to use the
        <command>caenchain</command> command. Here is how we do that:
      </para>

      <programlisting>
caenchain create chain                  <co id="vmusb-ss-chain-create"/>
caenchain config chain -base 0x12000000 -modules [list v775 v785] <co
          id="vmusb-ss-chain-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-chain-create">
          <para>
            This line creates a device instance for the chained block transfer. We
            can refer to it by its name <literal>chain</literal> later in the
            file.
          </para>
        </callout>
        <callout arearefs="vmusb-ss-chain-config">
          <para>
            The chained block transfer works by accessing the devices via a
            different address than their individual base addresses. In fact, by
            sending commands to this address, all of the modules who understand it
            can respond simultaneously. Some implementation require a multicast
            address as well as a chained block transfer address, the base address
            we provide for the Caen modules is dual purpose. It is important that
            only the top 8-bits of the base address provided here is used.
            Furthermore, we have also added the <literal>v775</literal> and
            <literal>v785</literal> device instances for chained readout. The
            order of these modules should reflect the order in which they reside
            in the crate. The leftmost module in the crate should be the first
            module in the list and the rightmost module should be the last in the
            list.
          </para>
        </callout>
      </calloutlist>

      <para>
        The <command>caenchain</command> extends the idea of a device instance,
        because it does not really reflect a piece of hardware. Rather it is
        more of a virtual piece of hardware that handles the readout of multiple
        physical pieces of hardware. With it created and configured, we are
        ready to create our stack and we will only register the
        <literal>chain</literal> to the stack.  Here is how that works
      </para>


      <programlisting>
stack create evtStack                             
stack config evtStack -modules [list chain] -trigger nim1 <co
  id="vmusb-ss-evtstack-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-evtstack-config">
          <para>
            A single element list containing <literal>chain</literal> is added to
            the stack. Because our <literal>v775</literal> and
            <literal>v785</literal> are registered to the <literal>chain</literal>
            they will indirectly be read out. The <option>-trigger</option> option
            is passed a value of <literal>nim1</literal> to indicate that the
            stack will be triggered for execution whenever a logic pulse arrives
            at NIM input 1.
          </para>
        </callout>
      </calloutlist>

    </section>
    <!-- end of event stack section -->

    <section>
      <title>The scaler stack</title>

      <para>
        With the event stack already defined, we now turn to the definition of
        the stack responsible for reading out the SIS3820. Because this stack
        will deal with scaler data, it will be referred to as the scaler stack.
        The procedure for setting up the scaler stack is the same as for the
        event stack. First we create a device instance for the SIS3820 and then
        we add it to a stack.
      </para>

      <para>
        The Tcl command ensemble responsible for creating, configuring, and
        querying the state of an SIS3820 is named <command>sis3820</command>.
        There are two options that can be configured for the device instances it
        creates and we will only use the <option>-base</option> option. This
        will take the base address of the actual VME module. When this is added
        to a stack, it will cause the VM-USB to read all 32 channels of the
        device it is associated with. Let's add the following line to the bottom
        of our <filename>daqconfig.tcl</filename> file:
      </para>

      <programlisting>
sis3820 create sclr 0x38000000        
      </programlisting>

      <para>
        The scaler can then be added to a stack later by its name
        <literal>sclr</literal>. We will do that right now. Creating the stack
        for the scaler readout is done as normal using the
        <command>stack</command>. However, to define this a scaler stack that
        gets periodically read out we need to specify different values for the
        options.
      </para>

      <programlisting>
stack create sclrStack                    
stack config sclrStack -modules [list sclr] -trigger scaler -period 2 <co
          id="vmusb-ss-sclrstack-config"/>
      </programlisting>

      <calloutlist>
        <callout arearefs="vmusb-ss-sclrstack-config">
          <para>
            Purposing a stack for scaler readout is accomplished by passing
            <literal>scaler</literal> for the <option>-trigger</option>
            argument. Not only does this enable periodic execution of the stack,
            but it also labels the stack as index 1.
            <application>VMUSBReadout</application> will treat the data read by
            this stack specifically as scaler data and turn it into ring items
            of type PERIODIC_SCALERS. The <option>-period</option> option was
            passed a value of 2 to specify that we want the readout period to be
            2 seconds.
          </para>
        </callout>
      </calloutlist>

      <para>
        The scaler stack is now complete.
      </para>

    </section><!-- end of scaler stack -->

  </section><!-- end of configuration scripts -->

  <section>
    <title>Running VMUSBReadout</title>

    <para>
      There is a detailed overview of how to run
      <application>VMUSBReadout</application> in the comprehensive documentation
      of NSCLDAQ. In this section we will assume that that has been read already
      and we will proceed by defining a simple launcher script.
    </para>

    <para>
      Unless you intend to keep your configuration scripts in the directory
      <filename>~/config</filename>, you are required to specify the location of
      the configuration scripts at launch. To avoid this, we will generate a
      short bash script that will launch
      <application>VMUSBReadout</application> with the local configuration
      scripts. To do so, we create a script called <filename>govmusb</filename>
      that has the following contents.
    </para>

    <programlisting>
#!/bin/sh                           <co id="vmusb-ss-launch-shebang"/>

$DAQBIN/VMUSBReadout --daqconfig=$PWD/daqconfig.tcl --ctlconfig=$PWD/ctlconfig.tcl <co id="vmusb-ss-launch-guts"/>
    </programlisting>


    <calloutlist>
      <callout arearefs="vmusb-ss-launch-guts">
        <para>
          We assume that the DAQBIN environment variable has been specified by
          sourcing the <filename>daqsetup.bash</filename> script. If you have
          not done this, you can source the script by doing (at the NSCL):
        </para>
        <screen>
<literal>spdaqXX&gt;</literal> <command>unset DAQROOT</command>
<literal>spdaqXX&gt;</literal> <command>source /usr/opt/nscldaq/11.0/daqsetup.bash</command>
        </screen>
        <para>
          The <literal>PWD</literal> environment is defined by default and
          stands for "present working directory." Note that this implies that
          the configuration scripts must live in the directory that the
          <filename>govmusb</filename> script is executed from.
        </para>
      </callout>
    </calloutlist>

    <para>
      To make the script executable, we have to change the permissions. Unless
      you want to prevent other people from executing the launcher script you
      can let all users execute it. To do that we use the
      <command>chmod</command> command. 
    </para>

    <screen>
<literal>spdaqXX&gt;</literal> <command>chmod a+x govmusb</command>
    </screen>

    <para>
      At this point you should be able to start up
      <application>VMUSBReadout</application> by executing the script. That is
      done by doing:
    </para>
    <screen>
<literal>spdaqXX&gt;</literal> <command>./govmusb</command>
    </screen>

    <para>
      At the prompt of VMUSBReadout, you can use the <command>begin</command>,
      <command>end</command>, <command>pause</command>, and
      <command>resume</command> commands to start, stop, pause, and resume runs.
    </para>
  </section>

  <section>
    <title>
      Understanding the Output
    </title>

    <para>
      The output of the program can be inspected by attaching the
      <application>dumper</application> program to the ring buffer receiving the
      data outputted from <application>VMUSBReadout</application>. Because we
      did not provide a different ring buffer at the command line when launching
      our program, the output will go to a ring buffer whose name is the same as
      your username. This is actually the default value of the
      <option>--source</option> command line option of the dumper program. As a
      result we can attach the <application>dumper</application> with the
      following command from a different terminal than the one running
      <application>VMUSBReadout</application>.
    </para>

    <screen>
<literal>spdaqXX&gt;</literal> <command>dumper</command>
    </screen>

    <para>
      If the run is active, you should see data printing to your screen. You can
      kill the <application>dumper</application> program by pressing
      <literal>CTL-C</literal>. A cleaner way to do this in the future is to
      provide <application>dumper</application> with a finite number of ring
      items to process. For example, to process 10 ring items and then exit, one
      would enter:
    </para>

    <screen>
<literal>spdaqXX&gt;</literal> <command>dumper --count=10</command>
    </screen>

    <section>
      <title>Event data</title>
    <para>
      However you do this, you should see event output that might look like this:
    </para>

    <screen>
      <computeroutput>
-----------------------------------------------------------
Event 34 bytes long
Body Header:
Timestamp:    5764974207242862948
SourceID:     0
Barrier Type: 0
0010 0100 5200 4d7f 5001 0c08 5400 0100
5a00 4de4 5801 0c05 5c00 ffff ffff ffff
ffff
-----------------------------------------------------------
      </computeroutput>
    </screen>

    <para>
      From the <application>VMUSBReadout</application> user's guide, we know
      that the first 16-bit word is the event header produced by the VM-USB
      itself. The most-significant four bits specify that the data corresponds
      to stack 0 and the least significant 12 bits specify that there are
      sixteen 16-bit words that follow. This is very sensible because we only
      defined a single event stack and we can count the remaining data words.
    </para>

    <para>
      The remaining 16 words must be understood according to the data format of
      the V785 and V775. Each of these devices outputs a series of 32-bit words
      bookended by header and end-of-event words. Bits 24-26 uniquely identifies
      betweeen those two words and the data words. The format also uses the most
      significant five bits (bits 27-31) for the geographic address. The
      geographic address should be the same value we provided for the
      <option>-geo</option> option. For that reason, we expect that bits 27-31 of
      each 32-bit word can be used to identify whether the data originated from
      the V775 or the V785. Before we start parsing the data further, let's
      group the 16-bit words in the output into 32-bit words.
    </para>

    <screen>
0x0010        <co id="vmusb-ss-rawdata-evthdr"/>
0x52000100    <co id="vmusb-ss-rawdata-v775hdr"/>
0x50014d7f    <co id="vmusb-ss-rawdata-v775data"/>
0x54000c08    <co id="vmusb-ss-rawdata-v775eoe"/>
0x5a000100    <co id="vmusb-ss-rawdata-v785hdr"/>
0x58014def    <co id="vmusb-ss-rawdata-v785data"/>
0x5c000c05    <co id="vmusb-ss-rawdata-v785eoe"/>
0xffffffff   
0xffffffff    <co id="vmusb-ss-rawdata-ffff"/> 
    </screen>

    <calloutlist>
      <callout arearefs="vmusb-ss-rawdata-evthdr">
        <para>
          VM-USB event header. This is just 16-bits.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v775hdr">
        <para>
          Header word for the V775 identified by bits 24-26 being the value 2. The
          most-significant 5 bit of this number is 10, which matches what was defined for
          the <option>-geo</option> option of the v775. Other information
          encoded in this header are the crate index (bits 16-23) and the number
          of data words before the end-of-event word (bits 12-16). The header
          tells us that the module resides in crate 0 and that there is a single
          data word that follows.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v775data">
        <para>
          This is the lone data word for the V775 identified by bits 24-26 being
          0. Bits 27-31 still contain a geographic address of 10 as it should.
          Bits 16-20 identify the channel number for the data, bits 0-11 identify
          the value and bits 12 and 13 are the underflow and overflow bits. We can
          use this information to understand that digitized value did not
          underflow or overflow and resulted in the value 3455.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v775eoe">
        <para>
          As we expect by header word of the V775, this is the end of event word.
          We know this for sure because bits 24-26 store the value 4. Once again
          the bits 27-31 store the value 10 so the word originated from the
          V775. The lower 24 bits store the event count, which converts to 3079
          in decimal.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v785hdr">
        <para>
          This word is the first word of the V785. It is a header word that
          corresponds to slot 11 and crate 0. There is one data word that follows
          prior to the end-of-event word.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v785data">
        <para>
          Here is the data for the V785. It corresponds to channel 1 and has a
          value f 3567. 
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-v785eoe">
        <para>
          Here is the end-of-event word for the V785. It corresponds to event
          number 3077.
        </para>
      </callout>
      <callout arearefs="vmusb-ss-rawdata-ffff">
        <para>
          The 0xffffffff is what is returned by the devices when they complete
          their block transfer. There are two of these because each module is
          emitting BERR to signify they are done being read out.
        </para>
      </callout>
    </calloutlist>

    <para>
      In the above output, it is apparent that the event count of the V775 and
      V785 differ by 2 events, the V775 having seen two more events than the V785.
      Such a condition is not terribly worrisome in this case, because the V775
      is initialized prior to the V785. Because the initialization process is done
      before the VM-USB transitions to autonomous mode, the timing is
      controlled by the speed at which a VM-USB can execute interactive commands
      and the speed at which the software operates. Such timing is indeterminate
      because the operation system scheduler plays a role. It should be expected
      that the time between clearing the V775 and V785 is on the order of
      milliseconds. If the rate is around 1 kHz, then it is possible that
      multiple triggers occur after the V775 has been cleared and the V785
      clears.
    </para>



    </section>

    <section>
      <title>Scaler data</title>

      <para>
        If your most recent dump of the data using
        <application>dumper</application> did not include any scaler items in
        the output, you should run the <application>dumper</application> again
        in such a way that excludes processing ring items of type PHYSICS_EVENT.
      </para>

      <screen>
<literal>spdaqXX&gt;</literal> <command>$DAQBIN/dumper --count=5 --exclude=PHYSICS_EVENT</command>
      </screen>

      <para>
        The output should include at least one ring item that has the following
        look:
      </para>

      <screen>
        <computeroutput>
Tue Mar 10 15:12:56 2015 : Scalers:
Interval start time: 10 end: 12 seconds in to the run

Body Header:
Timestamp:    0
SourceID:     0
Barrier Type: 0
Scalers are incremental
Index         Counts                 Rate
    0              0                 0.00
    1              0                 0.00
    2              0                 0.00
    3              0                 0.00
    4              0                 0.00
    5              0                 0.00
    6              0                 0.00
    7              0                 0.00
    8              0                 0.00
    9              0                 0.00
   10              0                 0.00
   11              0                 0.00
   12              0                 0.00
   13              0                 0.00
   14              0                 0.00
   15              0                 0.00
   16            513                 256.50
   17              0                 0.00
   18              0                 0.00
   19              0                 0.00
   20              0                 0.00
   21              0                 0.00
   22              0                 0.00
   23              0                 0.00
   24              0                 0.00
   25              0                 0.00
   26              0                 0.00
   27              0                 0.00
   28              0                 0.00
   29              0                 0.00
   30              0                 0.00
   31              0                 0.00
-----------------------------------------------------------
        </computeroutput>
      </screen>

      <para>
        There is much less to be explained here than for the event data.
        The scaler stack read out all 32 channels of data from the SIS3820
        during each stack execution, so the dump shows 32 channels of data. In
        my test setup, I had only plugged in a single input to the SIS3820 at
        channel 16. The SIS3820 was operated as an incremental scaler as well,
        which means that after every read the device was cleared. In the
        information section above the actual scaler values, you also see that
        the scaler values account for the time between 10 and 12 seconds after
        the run began.
      </para>
    </section>
  </section>

  <section>
    <title>Developing a Tailored SpecTcl</title>

    <para>
      The dumper is not the most useful tool for understanding the data read
      out by the electronics. Instead we should be using
      <application>SpecTcl</application> for that purpose, because it provides a
      much more straightforward and intuitive way to inspect data. To use
      SpecTcl, we have to teach it how to retrieve the salient features of our
      data and store them as tree parameters. Tree parameters are objects that
      behave as though the are plain old double values. What makes them special
      is that they are histogrammable entities. By unpacking raw data into tree
      parameters, we can use SpecTcl to quickly define histograms from them. 
    </para>
    <para>
    An example of a
      simple SpecTcl implementation for unpacking a single V775 exists in conjunction with the
      SBS Readout framework. To not repeat what has already been demonstrated,
      this will demonstrate how to develop a SpecTcl whose parsing utilities are
      separated from the SpecTcl framework. In principle, the parsing class used
      here could be reused in other analysis framework like ROOT. It will also
      demonstrate a modern style of implementing C++ that leverages some newer
      C++11 features, like the range-based for loop.
    </para>
    <section>
      <title>Acquiring the Skeleton</title>

      <para>
        There is a good deal of boilerplate code that goes into developing a
        tailored SpecTcl. To avoid rewriting a lot of that code, you can start
        from the "skeleton" implementation. This provides a fully functional
        SpecTcl application that can be easily modified to support our specific
        needs. Getting the skeleton can be achieved by doing:
      </para>

      <screen>
<literal>spdaqXX&gt;</literal> <command>mkdir MySpecTcl</command>
<literal>spdaqXX&gt;</literal> <command>cd MySpecTcl</command>
<literal>spdaqXX&gt;</literal> <command>cp /usr/opt/spectcl/3.4/Skel/* .</command>
      </screen>

      <para>
        It does not matter all that much which specific version is used so long
        as it is at least version 3.4. Prior to version 3.4 there was no support
        for the NSCLDAQ 11.0 data format. Because our data has been acquired
        using an 11.0 version VMUSBReadout, it is therefore not possible to
        analyze it using an older version of SpecTcl.
      </para>
      
    </section>


    <section>
      <title>Writing our Event Processor</title>

      <para>
        SpecTcl has an analysis engine in it that handles all of the
        input/output type operations for the user. It can do so because it
        understands how to read raw data from an input stream and parse it into
        entities of a given data format. Once it has determined the type of
        entity, it passes it to an analysis pipeline for processing. The
        details of the processing is very experiment specific and must be
        provided by the experimenter. This is done by deriving a new class from
        the EventProcessor class and then registering it to the pipeline. Our
        derived EventProcessor will get passed the beginning of each physics
        event body for processing.
      </para>

      <para>
        We intend to write an event processor that clearly separates the
        SpecTcl-like dependencies from the unpacking code. It will be named
        CRawUnpacker because it will operate on the raw data format. The
        CRawUnpacker will be responsible for doing SpecTcl related things, like
        storing data into tree parameters, using a SpecTcl independent unpacking
        routine. The latter will be a class named CRawADCUnpacker that will
        parse the data format produced by the V785 and V775 and store the
        resulting information in ParsedADCEvent objects. 
      </para>

      <para>
        It is good practice in C++ to declare the capabilities of our class in a
        header file and then implement those capabilities in a source file.
        Doing so makes the code more flexible, reusable, and less bloated. We
        will follow this practice while implementing our SpecTcl, which means we
        have four files to create. 
        
      </para>

      <section>
        <title>CRawUnpacker</title>
        <para>Without further ado, let's start by defining
          our CRawUnpacker header file, <filename>CRawUnpacker.h</filename>
        </para>

        <programlisting>
#ifndef CRAWUNPACKER_H
#define CRAWUNPACKER_H

#include &lt;config.h&gt;
#include "CRawADCUnpacker.h"
#include &lt;EventProcessor.h&gt;
#include &lt;TreeParameter.h&gt;
#include &lt;cstdint&gt;
#include &lt;cstddef&gt;

class CRawUnpacker : public CEventProcessor
{
  private:
    CRawADCUnpacker      m_unpacker;
    CTreeParameterArray  m_values;

  public:
    CRawUnpacker();
    virtual ~CRawUnpacker();

    virtual Bool_t operator()(const Address_t pEvent,
                              CEvent&amp; rEvent,
                              CAnalyzer&amp; rAnalyzer,
                              CBufferDecoder&amp; rDecoder);
  private:
    Bool_t unpack(TranslatorPointer&lt;std::uint32_t&gt; begin, 
                  std::size_t nLongWords);
};

#endif 
        </programlisting>

        <para>
          The implementation of our CRawUnpacker class will be found in the source
          file <filename>CRawUnpacker.cpp</filename>. This is naturally a bit longer of a
          file, because it includes the implementation code. The constructors and
          destructors are nearly trivial and will be dealt with in one fell
          swoop.
        </para>

        <programlisting>
#include "CRawUnpacker.h"
#include &lt;TreeParameter.h&gt;
#include &lt;TranslatorPointer.h&gt;
#include &lt;BufferDecoder.h&gt;
#include &lt;TCLAnalyzer.h&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

using namespace std;

CRawUnpacker::CRawUnpacker()
  : m_unpacker(),
    m_values("t",4096,0.0,4095.0,"channels",64,0)
{
}

CRawUnpacker::~CRawUnpacker()
{
}
        </programlisting>

        <para>
          The more interesting code occurs in the operator() and unpack() methods.
          The operator() method is responsible for the actual processing of the
          data as well as telling SpecTcl what the size
          of the event is. It will
          just handle the calculation and reporting of the event size and then
          delegate the parsing and handling of the results to the unpack() method.
          <tip>
            <para>
              At least one event processor is required to set the event size
              and to avoid introducing confusing bugs into your SpecTcl, it is best
              practice to only do this in the first event processor of the pipeline.
            </para>
          </tip>
          The resulting operator() method will look like this:
        </para>

        <programlisting>
Bool_t
CRawUnpacker::operator()(const Address_t pEvent, 
                        CEvent&amp; rEvent, 
                        CAnalyzer&amp; rAnalyzer, 
                        CBufferDecoder&amp; rDecoder)
{
  TranslatorPointer&lt;uint16_t&gt; p(*rDecoder.getBufferTranslator(), pEvent);
  CTclAnalyzer&amp; a(dynamic_cast&lt;CTclAnalyzer&amp;&gt;(rAnalyzer));

  size_t  size = (*p++ &amp; 0x0fff);

  // the event header is exclusive so the actual size of the full event
  // is actually the 
  a.SetEventSize((size+1)*sizeof(uint16_t));

  size_t nLongWords = size*sizeof(uint16_t)/sizeof(uint32_t);

  return unpack(p, nLongWords);
}
        </programlisting>

        <para>
          The unpack() method implementation will look like this:
        </para>

        <programlisting>
Bool_t 
CRawUnpacker::unpack(TranslatorPointer&lt;uint32_t&gt; begin,
                     size_t nLongWords)
{
  auto end = begin+nLongWords;

  try {
    vector&lt;ParsedADCEvent&gt; events = m_unpacker.parseAll(begin, end);
    int offset = 0;
    for (auto&amp; event : events) {
      offset = (event.s_geo-10)*32;
      for (auto&amp; chanData : event.s_data) {
        m_values[chanData.first+offset] = chanData.second;
      }
    }
  } catch (exception&amp; exc) {
    cout &lt;&lt; "Parsing Failed! Reason=" &lt;&lt; exc.what() &lt;&lt; endl;
    return kfFALSE;
  }
                                    
  return kfTRUE;
}
        </programlisting>

        <para>
          That is it for the implementation ofthe CRawUnpacker class. Before
          moving on, I would like to explain the motivation for the unpack()
          method. It is not obvious why its contents could not have just been
          included as the body of the operator() method. They very well could have
          and it would have worked perfectly fine for our specific setup. However,
          splitting it off makes our event processor much more reusable.
        </para>
        <para>
          One of the reasons NSCLDAQ 11.0 was created was for better support of
          event building. The very presence of the capability makes it likely that
          we might want to use it. Separating the the unpack() from the operator()
          is aimed at supporting this scenario. The event builder outputs data
          that looks a bit different than the input data it receives, because it
          appends extra information to each item and then groups those together.
          In the lingo of the event builder, PHYSICS_EVENT ring items that enter
          the event builder are transformed into fragments that are glommed into
          built ring items of type PHYSICS_EVENT. The built ring item has a body
          stuffed with fragments. If we tried to parse the body of one of these
          using our operator() as it is currently implemented, SpecTcl would fail
          miserably.  However, the same data that this parser understands is
          present in that built ring item. It is just buried deeply in a fragment.
          So the logic in this unpacker is still useful if we can traverse through
          the structure of the built body. By separating the unpack() method from
          the operator() method, we can call it once the right part of the data
          has been found. You might be wondering why we don't call the operator()
          method.  The reason is that the operator method is responsible for
          reporting the event size. In a built ring item, the value this would
          extract would be incorrect. The unpack() method allows us to bypass it.
        </para>
      </section> <!-- end of CRawUnpacker -->


      <section>
        <title>The CRawADCUnpacker Class</title>

        <para>
          The CRawUnpacker depends on the presence of a parser class for the
          V785 and V775 class. That will be implemented in the CRawADCUnpacker
          class. I had stated that I would do this in a framework independent
          way. I will do so by showing a simpler example that depends on the
          TranslatorPointer&lt;uint32_t&gt; type for simplicity and then will
          explain how to generalize this afterwords. This will keep the example
          accessible to more people that don't need their code 100% independent
          but will at the same time provide those who do have the need a clear
          path forward.
        </para>

        <para>
          We will begin by describing the problem this class will solve. In the
          most fundamental sense, we have to work our way sequentially through
          the data, identify each piece, store the information in a framework
          independent entity, and identify when we are done. By doing this we
          will in essence validate the structure of the data. If it is different
          than we expect, then we cannot gaurantee that we understand it and
          will fail. If we do not encounter an error, we will return our
          platform independent type filled with the parsed information. Let's
          start by defining that type, which we will call ParsedADCEvent.
        </para>

        <programlisting>
#ifndef CRAWADCUNPACKER_H
#define CRAWADCUNPACKER_H

#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;cstdint&gt;
#include &lt;TranslatorPointer.h&gt;

struct ParsedADCEvent
{
  int s_geo;
  int s_crate;
  int s_count;
  int s_eventNumber;
  std::vector&lt;std::pair&lt;int, std::uint16_t&gt; &gt; s_data;
};

#endif
        </programlisting>

        <para>
          The ParsedADCEvent contains all of the information that we care to
          keep from a complete event. The data for each channel will be stored
          as a pair in an a vector. The first element of each pair will be the
          channel number while the second element will be the digitized value. 
        </para>

        <para>
          The next thing we need to do is define the CRawADCUnpacker class
          itself. Two entry points will be provided for public use. One of them
          is used by the CRawUnpacker class, parseAll(), and it iteratively
          calls the second, parseSingle(). We will focu primarily on the
          implementation of parseSingle() because it is the true parsing
          routine. The parseSingle() method depends on a handful of helper
          methods that will be explained as they come up. Here is the class
          declaration of the CRawADCUnpacker. In CRawADCUnpacker.h, it would
          follow the end of the ParsedADCEvent delcaration but precede the
          #endif preprocessor directive.
        </para>

        <programlisting>
class CRawADCUnpacker 
{
  public:
    using Iter=TranslatorPointer&lt;std::uint32_t&gt;;

  private:
    enum ProcessingMode {HEADER_MODE, DATA_MODE, EOE_MODE, DONE_MODE};

  public:
    std::vector&lt;ParsedADCEvent&gt; 
      parseAll(Iter&amp; begin, Iter&amp; end);

    std::pair&lt;Iter, ParsedADCEvent&gt;
      parseSingle(Iter&amp; begin, Iter&amp; end);

  private:
    bool isHeader(std::uint32_t word);
    bool isData(std::uint32_t word);
    bool isEOE(std::uint32_t word);

    void unpackHeader(std::uint32_t word, ParsedADCEvent&amp; event);
    void unpackDatum(std::uint32_t word, ParsedADCEvent&amp; event);
    Iter
      unpackData(Iter&amp; begin, Iter&amp; end, ParsedADCEvent&amp; event);
    void unpackEOE(std::uint32_t word, ParsedADCEvent&amp; event);
};
          
        </programlisting>

        <para>
          We know that the data from the ADC must come in a specific order.  The
          event header should come first followed by a sequence of data words,
          and then ultimately an end of event or trailer word.  Furthermore, the
          header word is descriptive about how many data words exist so by
          reading it we will know when to expect the end of event word. If the
          data we are parsing violates this structure, then something bad has
          happened. To enforce this ordering, the parser will operate as a
          simple state machine. At any given point, we will know that the data
          should be either a header word, data word, or end-of-event word. Once
          we have completed each parsing stage, we update the state to handle
          the next stage. For simplicity and readability, we do this using an
          enum called ProcessingMode. It has 4 states: HEADER_MODE, DATA_MODE,
          EOE_MODE, and DONE_MODE. Here is the code for the parseSingle()
          method and includes that we need to add to our
          <filename>CRawADCUnpacker.cpp</filename> file:
        </para>

        <programlisting>
pair&lt;CRawADCUnpacker::Iter,ParsedADCEvent&gt; 
  CRawADCUnpacker::parseSingle(Iter&amp; begin, Iter&amp; end)
{
  
  auto iter = begin;
  ParsedADCEvent event;

  ProcessingMode mode = HEADER_MODE;

  while (iter != end) {
    if (mode==HEADER_MODE) {  

      unpackHeader(*iter++, event);
      mode = DATA_MODE;

    } else if (mode==DATA_MODE) {
      int nWords = event.s_count;
      auto dataEnd = iter+nWords;

      if ((dataEnd > end) || (dataEnd == end)) {
        string errmsg("CRawADCUnpacker::parseSingle() ");
        errmsg += "Incomplete event found in buffer.";
        throw runtime_error(errmsg);
      }

      iter = unpackData(iter, dataEnd, event);
      mode = EOE_MODE;

    } else if (mode==EOE_MODE) {

      unpackEOE(*iter++,event);

      mode = DONE_MODE;


      // we are done
      break;
    }

  }

  return make_pair(iter,event);
}
        </programlisting>

        <para>
          As you can see, there are many supporting pieces. We will look at them
          one by one, beginning with the unpackHeader() method.
        </para>

        <programlisting>
bool CRawADCUnpacker::isHeader(uint32_t word)
{
  return ((word&amp;TYPE_MASK)==TYPE_HDR);
}


void CRawADCUnpacker::unpackHeader(uint32_t word, ParsedADCEvent&amp; event)
{
  if (! isHeader(word) ) {
    string errmsg = "CRawADCUnpacker::parseHeader() ";
    errmsg += "Found non-header word when expecting header. ";
    errmsg += "Word=";
    errmsg += to_string(word);
    throw runtime_error(errmsg);
  }

  event.s_geo   = ((word &amp; GEO_MASK)&gt;&gt;GEO_SHIFT);
  event.s_crate = ((word &amp; HDR_CRATE_MASK)&gt;&gt;HDR_CRATE_SHIFT);
  event.s_count = ((word &amp; HDR_COUNT_MASK)&gt;&gt;HDR_COUNT_SHIFT);
}
        </programlisting>

        <para>
          The data words are unpacked in a bit more fancy method called
          unpackData(). It loops through a range of words designated by its
          arguments, calling unpackDatum() on each one. The unpackDatum() is
          very similar to unpackHeader() method in that it extracts specific
          pieces of data from the data word it is passed. The difference is that
          the values it extracts for the channel and value are paired together
          are stored in the vector of the event. This is what those look like:
        </para>

        <programlisting>
bool CRawADCUnpacker::isData(uint32_t word)
{
  return ((word&amp;TYPE_MASK)==TYPE_DATA);
}


void CRawADCUnpacker::unpackDatum(uint32_t word, ParsedADCEvent&amp; event)
{
  if (! isData(word) ) {
    string errmsg = "CRawADCUnpacker::unpackDatum() ";
    errmsg += "Found non-data word when expecting data.";
    throw runtime_error(errmsg);
  }

  int channel   = ((word &amp; DATA_CHANMASK)&gt;&gt;DATA_CHANSHIFT);
  uint16_t data = (word &amp; DATA_CONVMASK);

  auto chanData = make_pair(channel,data);
  event.s_data.push_back(chanData);
}


CRawADCUnpacker::Iter 
CRawADCUnpacker::unpackData(Iter&amp; begin, 
                            Iter&amp; end,
                            ParsedADCEvent&amp; event)
{
  // only allocate memory once because we know how much we need already
  event.s_data.reserve(event.s_count);

  auto iter = begin;
  while(iter != end) {

    unpackDatum(*iter, event); 

    ++iter;
  }

  return iter;
}
        </programlisting>

        <para>
          Finally, we reach the unpackEOE() method. Once again, this is
          extremely similar to the unpackHeader() method, moreso than the
          unpackDatum() method. Here is the code for that.
        </para>

        <programlisting>
bool CRawADCUnpacker::isEOE(uint32_t word)
{
  return ((word&amp;TYPE_MASK)==TYPE_TRAIL);
}

void CRawADCUnpacker::unpackEOE(uint32_t word, ParsedADCEvent&amp; event)
{
  if (! isEOE(word) ) {
    string errmsg = "CRawADCUnpacker::unpackEOE() ";
    errmsg += "Found non-data word when expecting data.";
    throw runtime_error(errmsg);
  }
  
  event.s_eventNumber = (word &amp; TRAIL_COUNT_MASK);
}
        </programlisting>

        <para>
          Alright, now that we have the parseSingle() method defined and
          understood, we can go back to the
          parseAll() method. It is very simple and resemble the unpackData()
          method in that it just calls parseSingle() until it is done. The only
          differences are that it stores each ADC event into a list for
          returning and has to protect itself from processing the BERR words
          (0xffffffff) that follow the more meaningful data. Here is the
          parseAll() implementation:
        </para>

        <programlisting>
vector&lt;ParsedADCEvent&gt; 
CRawADCUnpacker::parseAll(Iter&amp; begin,
                          Iter&amp; end)
{
  vector&lt;ParsedADCEvent&gt; parsedData;

  auto iter = begin;
  while (iter != end) {

    if (*iter != 0xffffffff) {
      auto result = parseSingle(iter,end);

      parsedData.push_back(result.second);
      iter = result.first;
    } else {
      ++iter;
    }
  } 

  return parsedData;
}
        </programlisting>

        <para>
          That is it for the unpacker. Let me now explain what would need to be
          done to make this fully independent of SpecTcl. The only dependency
          that this has on SpecTcl are some header files and the
          <literal>TranslatorPointer&lt;uint32_t&gt;</literal> type. What may
          not be terribly clear is that the
          <literal>TranslatorPointer&lt;uint32_t&gt;</literal> behaves almost
          identically to a <literal>uint32_t*</literal>. In that case, one could
          just as well use a <literal>uint32_t*</literal> pointer in its stead.
          You may wonder why I didn't do this already. Well, the kicker is that
          a TranslatorPointer is able to automatically handle byte-order
          swapping if the data requires it. A plain old pointer is not so smart.
          You will only be bitten by this if the data in the data stream was
          generated in such a way that swapping bytes is necessary. Only you are
          the one who knows this if you venture outside the world of SpecTcl. If
          you have to swap bytes, this becomes a bit less portable and you will
          need to create your own byte-swapping smart pointer. The good news is
          that it is little difficulty to accomodate any solution you have
          concerning the TranslatorPointer. Because we hid this behind a
          typedef, we only need to change the <literal>Iter</literal> alias to
          be a different type. Done. Arguably the more general solution would be
          to transform the class into a template itself where the
          <literal>Iter</literal> is the template parameter. Doing so requires
          more changes to the code but would not have to be recompiled whenever
          you wanted to change the type. The most important thing here is that
          these changes never require a change to the actual implementation
          code. The only requirement is that whatever you choose to use for the
          iterator implements the operators used. Any random access iterator
          will fulfill that requirement, but you need not go so far to implement
          all requirements of a random access iterator.
          As for the included headers, you can
          use preprocessor conditionals for this. If you are building with
          SpecTcl, then you will need the proper headers, otherwise, you should
          not include them.
        </para>
      </section> <!-- end of CRawADCUnpacker -->

      
    </section> <!-- end of event processor -->

    <section>
      <title>Setting up the Event Processing Pipeline</title>

      <para>
        The <filename>MySpecTclApp.cpp</filename> contains the code the defines
        the event processing pipeline. We need to add an instance of the
        CRawUnpacker class to it in order for our code to execute. You will
        notice that in MySpecTclApp.cpp there are already a handful of
        predefined event processors that are registered to the pipeline. We need
        to make the following changes. First, find the following two line:
      </para>

      <programlisting>
static CFixedEventUnpacker Stage1;
static CAddFirst2          Stage2;
      </programlisting>

      <para>
        You should replace the two lines with a single line:
      </para>

      <programlisting>
static CRawUnpacker gRawStage;
      </programlisting>

      <para>
        You will also need to add the following line to the list of includes at
        the top of the file.
      </para>

      <programlisting>
#include "CRawUnpacker.h"        
      </programlisting>

      <para>
        The next thing you need to do is find the method called
        <literal>CMySpecTclApp::CreateAnalysisPipeline()</literal>. In it your
        should replace the entire body to look like:
      </para>

      <programlisting>
void 
CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
{
  RegisterEventProcessor(gRawStage, "Raw");
}
      </programlisting>

      <para>
        With that, SpecTcl will pass every ring item of type PHYSICS_EVENT to
        our event processor.
      </para>
    </section>

    <section>
      <title>
        Building SpecTcl
      </title>

      <para>
        Because we have added two extra classes to the SpecTcl application, we
        need to ensure that they are added to the build. That is easily done by
        modifying the OBJECTS variable. You should edit your
        <filename>Makefile</filename> to look like this:
      </para>

      <programlisting>
OBJECTS=MySpecTclApp.o CRawUnpacker.o CRawADCUnpacker.o
      </programlisting>

      <para>
        Furthermore, because we have made use of a handful of C++11 features, we
        need to ensure that the compiler operates in the C++11 mode. This is
        accomplished with the <literal>-std=c++11</literal> flag. You should add
        it to the <literal>USERCXXFLAGS</literal> variable. In the end, that
        line will resemble this:
      </para>

      <programlisting>
USERCXXFLAGS= -std=c++11
      </programlisting>

      <para>
        We can now compile our program. You should see this succeed with no
        errors. Compilation is initiated by the <command>make</command> command.
      </para>

      <screen>
<literal>spdaqXX&gt;</literal> <command>make</command>
      </screen>

    </section>
  </section>

</chapter>

<!-- /chapter -->
