/*
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions 
either of that version or of any later version published by the Free Software 
Foundation.  If the Program does not specify a version number of this License,
 you may choose any version ever published by the Free Software Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author to 
ask for permission.  For software which is copyrighted by the Free Software 
Foundation, write to the Free Software Foundation; we sometimes make 
exceptions for this.  Our decision will be guided by the two goals of 
preserving the free status of all derivatives of our free software and of 
promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN 
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE 
THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND 
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, 
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO 
LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR 
THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), 
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES.

		     END OF TERMS AND CONDITIONS
*/
static const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved";

using namespace std;

/*=========================================================================*/
// DAQBufferPage.cc     
//
// Author:
//		Eric Kasten
//		NSCL
//		Michigan State University
//		East Lansing, MI 48824-1321
//		mailto:kasten@nscl.msu.edu
//

/**
* @class Class DAQBufferPage
* @brief Buffer data blocks for constructing buffers.
*
* DAQBufferPages are buffer data blocks that are assigned a
* header identifying the current state of the data block.
* This information is used primarily for reassembly of buffers 
* following their routing to remote sinks
*
* @author  Eric Kasten
* @version 0.4.0
*/

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <setjmp.h>
#include <sys/time.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#ifndef MAINEXTERNS_H
#include <mainexterns.h>
#endif

#ifndef DAQKEYRING_H
#include <DAQKeyRing.h>
#endif

#ifndef DAQBUFFERPAGE_H
#include <DAQBufferPage.h>
#endif

#ifndef DAQMAIN_H
#include <DAQMain.h>
#endif


#ifndef DAQSTATUS_H
#include <DAQStatus.h>
#endif

#ifndef DAQLINK_H
#include <DAQLink.h>
#endif

#define PAGE_DUMP_CHARCOUNT 29

extern int daq_debug_level;
static DAQNodeId default_nid;

/*==============================================================*/
/** @fn DAQBufferPage()
* @brief Default constructor.
*
* Default constructor. 
*
* @param None
* @return this
*/                                                             
DAQBufferPage::DAQBufferPage() 
{
  Nullify();
}

/*==============================================================*/
/** @fn DAQBufferPage(const DAQShmseg& aSeg,long aStart,long aLength, bool inithead)
* @brief Constructor with shared memory initializer.
*
* Constructor that initializes the underlying page with the 
* specified shared memory segment.
*
* @param aSeg The shared memory segment for initializing this page.
* @param aStart Starting position of this page in shared memory.
* @param aLength Length of this page.
* @param inithead True if the the page header needs initialization.
* @return this
*/                                                             
DAQBufferPage::DAQBufferPage(const DAQShmseg& aSeg,long aStart,long aLength,bool inithead) {
  Init(aSeg,aStart,aLength,inithead); 
}

/*==============================================================*/
/** @fn DAQBufferPage(const DAQBufferPage& aPage)
* @brief Copy constructor.
*
* Copy constructor.  Copy another buffer page into this one.
*
* @param aPage The buffer page to copy.
* @return this
*/                                                             
DAQBufferPage::DAQBufferPage(const DAQBufferPage& aPage) {
  Init(aPage);
}

/*==============================================================*/
/** @fn ~DAQBufferPage()
* @brief Destructor.
*
* Destroy this buffer page.  Essentially sets the internal
* buffer page data structures to a null state.
*
* @param None
* @return None
*/                                                             
DAQBufferPage::~DAQBufferPage()
{
  Nullify();
}

/*==============================================================*/
/** @fn Init(const DAQShmseg& aSeg,long aStart,long aLength, bool inithead)
* @brief Initialize this buffer page.
*
* Initialize the underlying page with the 
* specified shared memory segment.
*
* @param aSeg The shared memory segment for initializing this page.
* @param aStart Starting position of this page in shared memory.
* @param aLength Length of this page.
* @param inithead True if the the page header needs initialization.
* @return this
*/                                                             
void DAQBufferPage::Init(const DAQShmseg& aSeg,long aStart,long aLength,bool inithead) {
  sync_self;
    Nullify();
  
    if (aStart >= 0) {
      seg = aSeg;
      headstart = aStart;
      pagestart = aStart + sizeof(DAQBufferPageHeader);
      pagelength = aLength - sizeof(DAQBufferPageHeader);
  
      pHead = (DAQBufferPageHeader*)(&seg[headstart]);
      if (inithead) {
        pHead->dirty = 0;
        pHead->neverdirty = 0;
        pHead->readonly = 0;
        pHead->xmit = 0;
        pHead->release = 0;
        pHead->lastpage = 1;
        pHead->inuse = 1;
        pHead->oob = 0;
        pHead->ref = 0;
        pHead->owner= getpid();
        pHead->user = getuid();
        pHead->tag = 0;
        pHead->pos = 0;
        pHead->reqlen = 0;
        pHead->usedlen = 0;
        pHead->bytelen = 0;
        pHead->id = 0;
        pHead->node = default_nid.Get().val;
      }
    }
  sync_end; // self
}

/*==============================================================*/
/** @fn Init(const DAQBufferPage& aPage)
* @brief Initialize this page with another buffer page.
*
* Initialize this page with the contents of another buffer page.
* Essentially copies the other page into this one.
*
* @param aPage A buffer page to copy to this one.
* @return None
*/                                                             
void DAQBufferPage::Init(const DAQBufferPage& aPage) {
  sync_self;
    Nullify();
    CopyToThis(aPage);
  sync_end;
}

/*==============================================================*/
/** @fn Duplicate(DAQBufferPage& aPage)
* @brief Duplicate this buffer page.
*
* Duplicate this buffer page into another page specified
* as a parameter.
*
* @param aPage The target page of the duplication.
* @return The duplicate page
*/                                                             
DAQBufferPage& DAQBufferPage::Duplicate(DAQBufferPage& aPage)
{
  sync_self;
  sync_begin(aPage);
    int len = 0;
    char *pFrom = NULL;
    char *pTo = NULL;

    pFrom = (char *)pHead;
    pTo = (char *)(aPage.pHead);
    len = pagelength + sizeof(DAQBufferPageHeader);

    if ((pFrom != NULL)&&(pTo != NULL)&&(len > 0)) {
      memcpy(pTo,pFrom,len);
    }

    return(aPage);
  sync_end; // aPage
  sync_end; // self
}             

/*==============================================================*/
/** @fn DuplicateData(DAQBufferPage& aPage)
* @brief Duplicate this page's data into another page.
*
* Duplicate this page's data into another page specified as a
* parameter.  Essentially copyies the data portion of this
* buffer page into another buffer page.
*
* @param aPage The target page of the copy.
* @return The target buffer page for the copy.
*/                                                             
DAQBufferPage& DAQBufferPage::DuplicateData(DAQBufferPage& aPage)
{
  sync_self;
  sync_begin(aPage);
    int len = 0;
    char *pFrom = NULL;  
    char *pTo = NULL;  

    pFrom = (char *)GetData();
    pTo = (char *)(aPage.GetData());
    len = pagelength;

    if ((pFrom != NULL)&&(pTo != NULL)&&(len > 0)) {
      memcpy(pTo,pFrom,len);
    }
  
    return(aPage);
  sync_end; // aPage
  sync_end; // self
}

/*==============================================================*/
/** @fn Nullify()
* @brief Nullify this buffer page.
*
* Nullify this buffer page.  Essentially set the underlying
* shared memory segment data to null such that the page has
* no cargo capacity and is not assigned a shared memory
* segment.
*
* @param None
* @return None
*/                                                             
void DAQBufferPage::Nullify() 
{
  sync_self;
    pHead = NULL;
    headstart = -1;
    pagestart = -1;
    pagelength = 0;
    clocktick = 0; 
    frozen = 0; 
    clserv = COS_RELIABLE;
  sync_end; // self;
}

/*==============================================================*/
/** @fn IsNull()
* @brief Check if this buffer page is null.
*
* Check if this buffer page is null.  A buffer page is null
* if has no assigned shared memory segment.
*
* @param None
* @return None
*/                                                             
bool DAQBufferPage::IsNull()
{
  sync_self;
    return(pagestart < 0);
  sync_end;
}

/*==============================================================*/
/** @fn GetLength()
* @brief Get the length of the buffer page data.
*
* Get the length of the buffer page data space.  This length
* does not include the page header.
*
* @param None
* @return The length of the page data.
*/                                                             
long DAQBufferPage::GetLength()
{
  sync_self;
    return(pagelength);
  sync_end;
}

/*==============================================================*/
/** @fn GetStart()
* @brief Get the start of the page data.
*
* Get the start of the page data in the assigned shared memory
* segment.  This is not the start of the header, but the start
* of page data.
*
* @param None
* @return The start position of the page data.
*/                                                             
long DAQBufferPage::GetStart()
{
  sync_self;
    return(pagestart);
  sync_end;
}

/*==============================================================*/
/** @fn ResetNode()
* @brief Reset the node id to point to this node.
*
* Reset the node id (network host) to point to this node.
*
* @param None
* @return The node id where this page was created.
*/                                                             
void DAQBufferPage::ResetNode() {
  sync_self;
    if (pHead != NULL) {
      pHead->node = default_nid.Get().val;
    }
  sync_end;
}

/*==============================================================*/
/** @fn GetSeg()
* @brief Get the shared memory segment.
*
* Get the shared memory segment assigned to this buffer page.
*
* @param None
* @return The shared memory segment assigned to this page.
*/                                                             
DAQShmseg& DAQBufferPage::GetSeg()
{
  sync_self;
    return(seg);
  sync_end;
}

/*==============================================================*/
/** @fn CopyToThis(const DAQBufferPage& aPage)
* @brief Copy another buffer page to this one.
*
* Copy another buffer page into this one.  Essentially, points
* this page at the same shared memory segments and locations as
* the specified page.  The data and headers are not duplicated,
* but instead simply rereferenced by this page.
*
* @param aPage The page to copy to this one.
* @return A reference to this page.
*/                                                             
DAQBufferPage& DAQBufferPage::CopyToThis(const DAQBufferPage& aPage) {
  sync_self;
    seg = aPage.seg;
    pagestart = aPage.pagestart;
    pagelength = aPage.pagelength;
    headstart = aPage.headstart;
    pHead = aPage.pHead;
    return(*this);
  sync_end;
}

/*==============================================================*/
/** @fn Freeze()
* @brief Freeze this page's state.
*
* Free this page's state.  If a page is frozen, other objects
* should not update the state of this page (e.g., change header
* bits).  Setting a page as frozen will not stop updates, but
* is used by other server functions for coordination.  This
* method is recursive in the sense that a page can be frozen 
* more than once and must be thawed an equal number of times
* prior to becoming available for update.
*
* @param None
* @return None
*/                                                             
void DAQBufferPage::Freeze()
{
  sync_self;
    frozen++;
  sync_end; // self
}

/*==============================================================*/
/** @fn Thaw()
* @brief Thaw this page.
*
* If this page is frozen then decrement the freeze count.
* If a page is frozen, other objects
* should not update the state of this page (e.g., change header
* bits).  Setting a page as frozen will not stop updates, but
* is used by other server functions for coordination.  This
* method is recursive in the sense that a page can be frozen 
* more than once and must be thawed an equal number of times
* prior to becoming available for update.
* 
* @param None
* @return None
*/                                                             
void DAQBufferPage::Thaw()
{
  sync_self;
    if (frozen) frozen--;
  sync_end; // self
}

/*==============================================================*/
/** @fn IsFrozen()
* @brief Check if this page is frozen.
*
* Check if this page is frozen.  
* If a page is frozen, other objects
* should not update the state of this page (e.g., change header
* bits).  Setting a page as frozen will not stop updates, but
* is used by other server functions for coordination.  This
* method is recursive in the sense that a page can be frozen 
* more than once and must be thawed an equal number of times
* prior to becoming available for update.
* 
* @param None
* @return If this page is frozen.
*   @retval true If this page is frozen.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsFrozen()
{
  sync_self;
    return(frozen > 0);
  sync_end;
}

/*==============================================================*/
/** @fn operator=(const DAQBufferPage& aPage)
* @brief Assignment operator.
*
* Assign another page to this one.
*
* @param aPage The page to assign to this one.
* @return A reference to this page.
*/                                                             
DAQBufferPage& DAQBufferPage::operator=(const DAQBufferPage& aPage) {
  sync_self;
    CopyToThis(aPage);
    return(*this);
  sync_end;
}

/*==============================================================*/
/** @fn operator==(const DAQBufferPage& aPage) const
* @brief Check if this page is equal to another. 
*
* Check if this page is equal to another.  Equality 
* is determined by checking if the shared memory segment,
* start and length are in use by this page are equivalent
* to the one specified. 
*
* @param aPage The page for testing equivalence against.
* @return If this page is equivalent to the other page.
*   @retval !=0 If the pages are equal. 
*   @retval 0 If the pages are not equal. 
*/                                                             
int DAQBufferPage::operator==(const DAQBufferPage& aPage) const {
  sync_self;
  sync_begin(aPage);
    return ((seg == aPage.seg)&&
          (headstart == aPage.headstart)&&
          (pagestart == aPage.pagestart)&&
          (pagelength == aPage.pagelength));
  sync_end; // aPage
  sync_end; // self
}

/*==============================================================*/
/** @fn void toStream(PrintStreamIface& aStream)
* @brief Print to a PrintStream.
*
* Print this object on a PrintStream.
*
* @param aStream The PrintStream.
* @return None
*/                                                             
void DAQBufferPage::toStream(PrintStreamIface& aStream) {
  sync_self;
    aStream.printf("PageStart=%ld,PageLength=%ld,HeadStart=%ld,COS=",(long)pagestart,(long)pagelength,(long)headstart);
  
    if (clserv == COS_RELIABLE) aStream.print("Reliable");
    else aStream.print("Unreliable");
  
    aStream.printf(",Tick=%ld,Frozen=%d",clocktick,frozen);
  
    if (pHead == NULL) {
      aStream.print(",Header=[--------- Owner=- Tag=- Pos=- Id=- Node=-]");
    } else {
      aStream.print(",Header=[");
  
      if (pHead->oob) aStream.print("!");
      else aStream.print("-");
  
      if (pHead->dirty) aStream.print("D");
      else aStream.print("-");
  
      if (pHead->modified) aStream.print("M");
      else aStream.print("-");
  
      if (pHead->neverdirty) aStream.print("N");
      else aStream.print("-");
  
      if (pHead->readonly) aStream.print("R");
      else aStream.print("-");
  
      if (pHead->xmit) aStream.print("X");
      else aStream.print("-");
  
      if (pHead->release) aStream.print("F");
      else aStream.print("-");
  
      if (pHead->lastpage) aStream.print("L");
      else aStream.print("-");
  
      if (pHead->inuse) aStream.print("U");
      else aStream.print("-");
  
      aStream.printf(" Owner=%d Tag=%d Pos=%d ReqLen=%d UsedLen=%d ByteLen=%d Ref=%d Id=%d User=%d Node=%s:%d]",pHead->owner,pHead->tag,pHead->pos,pHead->reqlen,pHead->usedlen,pHead->bytelen,pHead->ref,pHead->id,pHead->user,inet_ntoa(pHead->node.ipv4_addr),pHead->node.pid);
    }
  
    aStream.print(",Segment=[");
    aStream.print(seg);
    aStream.print("]");
  sync_end; // self
}

/*==============================================================*/
/** @fn operator[](const int idx)
* @brief Subscripting operator for this page.
*
* Return the byte at the specified position within the
* data portion of this page.
*
* @param idx The position from which to retrieve a byte.
* @return A reference to the specified byte.
* @throw DAQOutOfBounds If the array index is out of bounds.
*/                                                             
char& DAQBufferPage::operator[] (const int idx)
{
  sync_self;
    static char garbage = '\0';

    if ((idx >= pagelength)||(idx < 0)) {
      LOG_AND_THROW(daq_exception_factory.CreateException(DAQCSTR("DAQBufferPage::operator[]() Array index out of bounds"),DAQEXCPID(DAQOutOfBounds)));
      return(garbage);  // Keeps ANSII happy :-) 
    }
  
    if (pHead->readonly) { // Readonly, return a copy to prevent mutation
      garbage = seg[idx+pagestart];
      return(garbage);
    } else {   // Not readonly set the dirty bit and return real thing
      pHead->dirty = 1;
      return(seg[idx+pagestart]);
    }
  sync_end; // self
}

/*==============================================================*/
/** @fn SetDirty()
* @brief Set the dirty bit.
*
* Set the dirty bit.  The dirty bit is a header bit typically used
* to indicate that data in the page has been altered and that
* the page can be processed (e.g, routed).
*
* @param None
* @return The current state of the dirty bit.
*   @retval true If the dirty bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::SetDirty() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);
    if (pHead->dirty) aBool = true;
    if (pHead->modified) pHead->dirty = 1;     // Only bother if the page
                                             // has been modified.
    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn ResetDirty()
* @brief Reset the dirty bit.
*
* Reset the dirty bit.  The dirty bit is a header bit typically used
* to indicate that data in the page has been altered and that
* the page can be processed (e.g. routed).
*
* @param None
* @return The current state of the dirty bit.
*   @retval true If the dirty bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::ResetDirty() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->dirty) aBool = true;
    pHead->dirty = 0;
    pHead->modified = 0;  // If it isn't dirty it can't be modified

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn SetLastPage()
* @brief Set the last page bit.
*
* Set the last page bit.  The last page bit is a header bit 
* typically used to indicate that this page is the last page
* in buffer.
*
* @param None
* @return The current state of the last page bit.
*   @retval true If the last page bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::SetLastPage() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);
    if (pHead->lastpage) aBool = true;
    pHead->lastpage = 1;    

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn ResetLastPage()
* @brief Reset the last page bit.
*
* Reset the last page bit.  The last page bit is a header bit 
* typically used to indicate that this page is the last page
* in a buffer.
*
* @param None
* @return The current state of the last page bit.
*   @retval true If the last page bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::ResetLastPage() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->lastpage) aBool = true;
    pHead->lastpage = 0;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn SetInUse()
* @brief Set the inuse bit.
*
* Set the inuse bit.  The inuse bit is a header bit 
* typically used to indicate that this page is currently
* being used (e.g., as part of a buffer).
*
* @param None
* @return The current state of the inuse bit.
*   @retval true If the inuse bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::SetInUse() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->inuse) aBool = true;
    pHead->inuse = 1;    

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn ResetInUse()
* @brief Reset the inuse bit.
*
* Reset the inuse bit.  The inuse bit is a header bit 
* typically used to indicate that this page is currently
* being used (e.g., as part of a buffer).
*
* @param None
* @return The current state of the inuse bit.
*   @retval true If the inuse bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::ResetInUse() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->inuse) aBool = true;
    pHead->inuse = 0;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn SetOOB()
* @brief Set the out-of-band bit.
*
* Set the out-of-band bit.  The out-of-band bit is a header bit 
* typically used to indicate that this page is out-of-band
* or priority data.  Out-of-band data must be
* entirely contained within a single page.
*
* @param None
* @return The current state of the out-of-band bit.
*   @retval true If the out-of-band bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::SetOOB() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->oob) aBool = true;
    pHead->oob = 1;    

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn ResetOOB()
* @brief Reset the out-of-band bit.
*
* Reset the out-of-band bit.  The out-of-band bit is a header bit 
* typically used to indicate that this page is out-of-band
* or priority data.  Out-of-band data must be
* entirely contained within a single page.
*
* @param None
* @return The current state of the out-of-band bit.
*   @retval true If the out-of-band bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::ResetOOB() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->oob) aBool = true;
    pHead->oob = 0;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn SetModified()
* @brief Set the modified bit.
*
* Set the modified bit.  The modified bit is a header bit 
* typically used to indicate that this page has been modified.
* Used for helping determine the state of dirty bit.
*
* @param None
* @return The current state of the modified bit.
*   @retval true If the modified bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::SetModified () {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->modified) aBool = true;
    pHead->modified = 1;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn ResetModified()
* @brief Reset the modified bit.
*
* Reset the modified bit.  The modified bit is a header bit 
* typically used to indicate that this page has been modified.
* Used for helping determine the state of dirty bit.
*
* @param None
* @return The current state of the modified bit.
*   @retval true If the modified bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::ResetModified() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->modified) aBool = true;
    pHead->modified = 0;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn SetXmit()
* @brief Set the transmit bit.
*
* Set the transmit bit.  The transmit bit is a header bit 
* typically used to indicate that this page can be routed.
*
* @param None
* @return The current state of the transmit bit.
*   @retval true If the transmit bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::SetXmit() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->xmit) aBool = true;
    pHead->xmit = 1;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn ResetXmit()
* @brief Reset the transmit bit.
*
* Reset the transmit bit.  The transmit bit is a header bit 
* typically used to indicate that this page can be routed.
*
* @param None
* @return The current state of the transmit bit.
*   @retval true If the transmit bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::ResetXmit() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->xmit) aBool = true;
    pHead->xmit = 0;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn SetRelease()
* @brief Set the release bit.
*
* Set the release bit.  The release bit is a header bit 
* typically used to indicate that this page can be released.
*
* @param None
* @return The current state of the release bit.
*   @retval true If the release bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::SetRelease() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->release) aBool = true;
    pHead->release = 1;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn ResetRelease()
* @brief Reset the release bit.
*
* Reset the release bit.  The release bit is a header bit 
* typically used to indicate that this page can be released.
*
* @param None
* @return The current state of the release bit.
*   @retval true If the release bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::ResetRelease() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(false);

    if (pHead->release) aBool = true;
    pHead->release = 0;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn SetNeverDirty()
* @brief Set the never dirty bit.
*
* Set the never dirty bit.  The never dirty bit is a header bit 
* typically used to indicate that this page should never be
* considered dirty.
*
* @param None
* @return The current state of the never dirty bit.
*   @retval true If the never dirty bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::SetNeverDirty() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(true);

    if (pHead->neverdirty) aBool = true;
    pHead->neverdirty = 1;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn ResetNeverDirty()
* @brief Reset the never dirty bit.
*
* Reset the never dirty bit.  The never dirty bit is a header bit 
* typically used to indicate that this page should never be
* considered dirty.
*
* @param None
* @return The current state of the never dirty bit.
*   @retval true If the never dirty bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::ResetNeverDirty() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(true);

    if (pHead->neverdirty) aBool = true;
    pHead->neverdirty = 0;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn SetReadOnly()
* @brief Set the read-only bit.
*
* Set the read-only bit.  The read-only bit is a header bit 
* typically used to indicate that this page should be treated as
* read only.
*
* @param None
* @return The current state of the read-only bit.
*   @retval true If the never read-only is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::SetReadOnly() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(true);

    if (pHead->readonly) aBool = true;
    pHead->readonly = 1;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn ResetReadOnly()
* @brief Reset the read-only bit.
*
* Reset the read-only bit.  The read-only bit is a header bit 
* typically used to indicate that this page should be treated as
* read only.
*
* @param None
* @return The current state of the read-only bit.
*   @retval true If the never read-only is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::ResetReadOnly() {
  sync_self;
    bool aBool = false;

    if (pHead == NULL) return(true);

    if (pHead->readonly) aBool = true;
    pHead->readonly = 0;

    return(aBool);
  sync_end; // self
}

/*==============================================================*/
/** @fn SetOwner(pid_t aOwner)
* @brief Set the owner of this page.
*
* Set the owning process of this page.
*
* @param aOwner The process id of the owning process.
* @return None
*/                                                             
void DAQBufferPage::SetOwner(pid_t aOwner) {
  sync_self;
    if (pHead != NULL) pHead->owner = aOwner;
  sync_end; // self
}

/*==============================================================*/
/** @fn SetUser(uid_t aUser)
* @brief Set the user associated with this page.
*
* Set the user id of the user associated with this page.
*
* @param aUser The uid of the user associated with this page.
* @return None
*/                                                             
void DAQBufferPage::SetUser(uid_t aUser) {
  sync_self;
    if (pHead != NULL) pHead->user = aUser;
  sync_end; // self
}

/*==============================================================*/
/** @fn SetPos(long aPos)
* @brief Set the position of this page within a parent object.
*
* Set the position of this page within a parent object
* (e.g, a buffer).
*
* @param aPos The position within a parent object.
* @return None
*/                                                             
void DAQBufferPage::SetPos(long aPos) {
  sync_self;
    if (pHead != NULL) pHead->pos = aPos;
  sync_end; // self
}

/*==============================================================*/
/** @fn SetCOS(int aCOS)
* @brief The class-of-service under which this page is delivered.
*
* Set the class-of-service under which this page is delivered.
* Typically, the class-of-service is something like RELIABLE or
* UNRELIABLE.
*
* @param aCOS The class-of-service for this page.
* @return None
*/                                                             
void DAQBufferPage::SetCOS(int aCOS) {
  sync_self;
    clserv = aCOS;
  sync_end; // self
}

/*==============================================================*/
/** @fn SetClockTick(DAQServClockTick_t aTick)
* @brief Set the pseudo clock tick of this buffer.
*
* Set the pseudo clock tick of this buffer. This is used
* (among other things) during routing to determine order
* during the routing process.
*
* @param aTick The associated pseudo clock tick.
* @return None
*/                                                             
void DAQBufferPage::SetClockTick(DAQServClockTick_t aTick) {
  sync_self;
    clocktick = aTick;
  sync_end; // self
}

/*==============================================================*/
/** @fn SetReqLen(long aLen)
* @brief Set the requested length of the parent object.
*
* Set the requested length of the parent object (e.g., buffer)
* that this page belongs to.  This length is in native parent
* object units (such as words or double words).
*
* @param aLen The requested length.
* @return None
*/                                                             
void DAQBufferPage::SetReqLen(long aLen) {
  sync_self;
    if (pHead != NULL) pHead->reqlen = aLen;
  sync_end; // self
}

/*==============================================================*/
/** @fn SetByteLen(long aLen)
* @brief Set the byte length of the parent object.
*
* Set the byte length of the parent object.
*
* @param aLen The byte length of the parent object.
* @return None
*/                                                             
void DAQBufferPage::SetByteLen(long aLen) {
  sync_self;
    if (pHead != NULL) pHead->bytelen = aLen;
  sync_end; // self
}

/*==============================================================*/
/** @fn SetUsedLen(long aLen)
* @brief Set the used length of the parent object.
*
* Set the used length of the parent object.  This is usually
* in native units of the parent object (e.g., words, double words).
*
* @param aLen The used length.
* @return None
*/                                                             
void DAQBufferPage::SetUsedLen(long aLen) {
  sync_self;
    if (pHead != NULL) pHead->usedlen = aLen;
  sync_end; // self
}

/*==============================================================*/
/** @fn SetObjId(unsigned int aId)
* @brief Set the parent object Id.
*
* Set the id of the parent object.  Used for identifing what
* composite object (e.g, buffer) this page belongs to.
*
* @param aId The parent object id.
* @return None
*/                                                             
void DAQBufferPage::SetObjId(unsigned int aId) {
  sync_self;
    if (pHead != NULL) pHead->id = aId;
  sync_end; // self
}

/*==============================================================*/
/** @fn SetTag(unsigned int aTag)
* @brief Set the routing tag.
*
* Set the routing tag for this page.
*
* @param aTag The routing tag.
* @return None
*/                                                             
void DAQBufferPage::SetTag(unsigned int aTag) {
  sync_self;
    if (pHead != NULL) pHead->tag = aTag;
  sync_end; // self
}

/*==============================================================*/
/** @fn IsDirty()
* @brief Check if the dirty bit is set.
*
* Check the dirty bit.  The dirty bit is a header bit typically used
* to indicate that data in the page has been altered and that
* the page can be processed (e.g, routed).
*
* @param None
* @return The current state of the dirty bit.
*   @retval true If the dirty bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsDirty() {
  sync_self;
    if (pHead == NULL) return(false);
    if (pHead->dirty) return(true);
    else return(false);
  sync_end; // self
}

/*==============================================================*/
/** @fn IsModified()
* @brief Check if the modified bit is set.
*
* Check the modified bit.  The modified bit is a header bit 
* typically used to indicate that this page has been modified.
* Used for helping determine the state of dirty bit.
*
* @param None
* @return The current state of the modified bit.
*   @retval true If the modified bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsModified() {
  sync_self;
    if (pHead == NULL) return(false);
    if (pHead->modified) return(true);
    else return(false);
  sync_end; // self
}

/*==============================================================*/
/** @fn IsXmit()
* @brief Check if the transmit bit is set.
*
* Check the transmit bit.  The transmit bit is a header bit 
* typically used to indicate that this page can be routed.
*
* @param None
* @return The current state of the transmit bit.
*   @retval true If the transmit bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsXmit() {
  sync_self;
    if (pHead == NULL) return(false);
    if (pHead->xmit) return(true);
    return(false);
  sync_end; // self
}

/*==============================================================*/
/** @fn IsReleased()
* @brief Check if the release bit is set.
*
* Check the release bit.  The release bit is a header bit 
* typically used to indicate that this page can be released.
*
* @param None
* @return The current state of the release bit.
*   @retval true If the release bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsReleased() {
  sync_self;
    if (pHead == NULL) return(false);
    if (pHead->release) return(true);
    else return(false);
  sync_end; // self
}

/*==============================================================*/
/** @fn IsLastPage()
* @brief Check if the last page bit is set.
*
* Check the last page bit.  The last page bit is a header bit 
* typically used to indicate that this page is the last page
* in buffer.
*
* @param None
* @return The current state of the last page bit.
*   @retval true If the last page bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsLastPage() {
  sync_self;
    if (pHead == NULL) return(false);
    if (pHead->lastpage) return(true);
    else return(false);
  sync_end; // self
}

/*==============================================================*/
/** @fn IsInUse()
* @brief Check if the inuse bit is set.
*
* Check the inuse bit.  The inuse bit is a header bit 
* typically used to indicate that this page is currently
* being used (e.g., as part of a buffer).
*
* @param None
* @return The current state of the inuse bit.
*   @retval true If the inuse bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsInUse() {
  sync_self;
    if (pHead == NULL) return(false);
    if (pHead->inuse) return(true);
    else return(false);
  sync_end; // self
}

/*==============================================================*/
/** @fn IsOOB()
* @brief Check if the out-of-band bit is set.
*
* Check the out-of-band bit.  The out-of-band bit is a header bit 
* typically used to indicate that this page is out-of-band
* or priority data.  Out-of-band data must be
* entirely contained within a single page.
*
* @param None
* @return The current state of the out-of-band bit.
*   @retval true If the out-of-band bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsOOB() {
  sync_self;
    if (pHead == NULL) return(false);
    if (pHead->oob) return(true);
    else return(false);
  sync_end; // self
}

/*==============================================================*/
/** @fn IsNeverDirty()
* @brief Check if the never dirty bit is set.
*
* Check the never dirty bit.  The never dirty bit is a header bit 
* typically used to indicate that this page should never be
* considered dirty.
*
* @param None
* @return The current state of the never dirty bit.
*   @retval true If the never dirty bit is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsNeverDirty() {
  sync_self;
    if (pHead == NULL) return(true);
    if (pHead->neverdirty) return(true);
    else return(false);
  sync_end; // self
}

/*==============================================================*/
/** @fn IsReadOnly()
* @brief Check if the read-only bit is set.
*
* Check the read-only bit.  The read-only bit is a header bit 
* typically used to indicate that this page should be treated as
* read only.
*
* @param None
* @return The current state of the read-only bit.
*   @retval true If the never read-only is set.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::IsReadOnly() {
  sync_self;
    if (pHead == NULL) return(true);
    if (pHead->readonly) return(true);
    else return(false);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetTag()
* @brief Get the routing tag.
*
* Get the routing tag for this page.
*
* @param None
* @return The routing tag.
*   @retval 0 If the page header is null.
*/                                                             
unsigned int DAQBufferPage::GetTag() {
  sync_self;
    if (pHead == NULL) return(0);
    else return(pHead->tag);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetIP()
* @brief Get the routing IP.
*
* Get the routing IP for this page (origin host).
*
* @param None
* @return The routing IP.
*   @retval 0 If the page header is null.
*/                                                             
unsigned int DAQBufferPage::GetIP() {
  sync_self;
    if (pHead == NULL) return(0);
    else return(pHead->node.ipv4_addr.s_addr);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetOwner()
* @brief Get the page owner for this page.
*
* Get the process id of the owning process for this page.
*
* @param None
* @return The process id of the owning process.
*   @retval -1 If the page header is null.
*/                                                             
pid_t DAQBufferPage::GetOwner() {
  sync_self;
    if (pHead == NULL) return(-1);
    else return(pHead->owner);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetUser()
* @brief Get the user for this page.
*
* Get the user id of the owner user of this page.
*
* @param None
* @return The user id of the owning user.
*   @retval 0 If the page header is null.
*/                                                             
uid_t DAQBufferPage::GetUser() {
  sync_self;
    if (pHead == NULL) return(0);
    else return(pHead->user);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetPos()
* @brief Get the position within the parent object.
*
* Get the position of this page within the parent object 
* (e.g. buffer).
*
* @param None
* @return The position of this page.
*   @retval 0 If the page header is null.
*/                                                             
long DAQBufferPage::GetPos() {
  sync_self;
    if (pHead == NULL) return(0);
    else return(pHead->pos);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetCOS()
* @brief Get the class-of-service for routing this page.
*
* Get the class-of-service for routing this page.
*
* @param None
* @return The class-of-service associated with this page.
*/                                                             
int DAQBufferPage::GetCOS() {
  sync_self;
    return(clserv);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetClockTick()
* @brief Get the pseudo clock tick associated with this page.
*
* Get the pseudo clock tick associated with this page.
* Clock ticks are used for helping determine routing order.
*
* @param None
* @return The pseudo clock tick.
*/                                                             
DAQServClockTick_t DAQBufferPage::GetClockTick() {
  sync_self;
    return(clocktick);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetReqLen()
* @brief Get the request length of the parent object.
*
* Get the requested length of the parent object (e.g. buffer).  
* This length is in the native units used by the parent 
* (e.g. word, double word).
*
* @param None
* @return The requeted length of the parent object.
*   @retval 0 If the page header is null.
*/                                                             
long DAQBufferPage::GetReqLen() {
  sync_self;
    if (pHead == NULL) return(0);
    else return(pHead->reqlen);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetByteLen()
* @brief Get the byte length of the parent object.
*
* Get the byte length of the parent object (e.g., buffer).
*
* @param None
* @return The byte length.
*   @retval 0 If the page header is null.
*/                                                             
long DAQBufferPage::GetByteLen() {
  sync_self;
    if (pHead == NULL) return(0);
    else return(pHead->bytelen);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetUsedLen()
* @brief Get the used length of the parent object.
*
* Get the number of bytes used with respect to the parent object
* (e.g., buffer).
*
* @param None
* @return The number of bytes used.
*   @retval 0 If the page header is null.
*/                                                             
long DAQBufferPage::GetUsedLen() {
  sync_self;
    if (pHead == NULL) return(0);
    else return(pHead->usedlen);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetNode()
* @brief Get the node id where this page was created.
*
* Get the node id (network host) where this page was created.
*
* @param None
* @return The node id where this page was created.
*/                                                             
DAQNodeId DAQBufferPage::GetNode() {
  sync_self;
    DAQNodeId node;

    if (pHead != NULL) node = pHead->node;
    return(node);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetObjId()
* @brief Get the parent object id.
*
* Get the parent object (e.g., buffer) id that this page
* is associated with.
*
* @param None
* @return The parent object id.
*   @retval 0 If the page header is null.
*/                                                             
unsigned int DAQBufferPage::GetObjId() {
  sync_self;
    if (pHead == NULL) return(0);
    else return(pHead->id);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetDataLength()
* @brief Get the full length of this page.
*
* Get the data length of this page.  Used with the
* DAQCommMsgIface.
*
* @param None
* @return The data length of this page.
*/                                                             
int DAQBufferPage::GetDataLength() {
  sync_self;
    return(pagelength);
  sync_end; // self
}

/*==============================================================*/
/** @fn Dump(ostream& aStream,int aCnt)
* @brief Print the CharArray in hex and character.
*
* Print a specified number of CharArray values using a hex and
* character representation.
*
* @param aStream The PrintStream.
* @param aCnt The number of values to print.
* @return None
*/                                                             
void DAQBufferPage::Dump(ostream& aStream,int aCnt) {
  ios::fmtflags flags;
  unsigned char ch;
  unsigned short v;
  int i,j,cnt = 0,len;
  unsigned char *p,tmp[PAGE_DUMP_CHARCOUNT+1];
  int scnt = GetDataLength();
  char *vals = (char*)GetData();
   
  flags = aStream.flags();
  len = aCnt < scnt ? aCnt : scnt;
  p = (unsigned char *)vals;
  aStream << hex << setw(8) << setfill('0') << 0 << ": ";
    
  for (i = 0; i < len; i++) {
    if (cnt > PAGE_DUMP_CHARCOUNT) {
      aStream << endl << "          ";
    
      for (j = 0; j < cnt; j++) {
        ch = tmp[j];
    
        if (isprint(ch)&&(!iscntrl(ch))) aStream << " " << ch;
        else aStream << "  ";
      }
   
      aStream << endl << hex << setw(8) << setfill('0') << i << ": ";
      cnt = 0;
    }
  
    v = (*p);  
    aStream << hex << setw(2) << setfill('0') << v;
    tmp[cnt] = (*p);
    cnt++; p++;
  }
    
  if (cnt > 0) aStream << endl << "          ";

  for (j = 0; j < cnt; j++) {
    ch = tmp[j];
    
    if (isprint(ch)&&(!iscntrl(ch))) aStream << " " << ch;
    else aStream << "  ";
  }
   
  aStream << endl;
  aStream.flags(flags);
  aStream.flush();
}

/*==============================================================*/
/** @fn ResizeData(int aSize)
* @brief Pretend to resize this page.
*
* Pretend to resize this page (can't really do this).
* Used with the DAQCommMsgIface.  Pages can not be resized,
* but the DAQCommMsgIface requires that this method be implemented
* even if it does not do anything.
*
* @param aSize The desired size.
* @return None
*/                                                             
void DAQBufferPage::ResizeData(int aSize) {
}

/*==============================================================*/
/** @fn char *GetData()
* @brief Get the page data as a pointer to an array of char.
*
* Get the page data as a pointer to an array of char.
*
* @param None
* @return A pointer to the page data.
*/                                                             
const char *DAQBufferPage::GetData() {
  sync_self;
    if (headstart >= 0) return((char *)(&seg[pagestart]));
    else return(NULL);
  sync_end; // self
}

/*==============================================================*/
/** @fn void SetData(char *pData,int len)
* @brief Set the page data form character pointer.
*
* Set the page data from a character pointer.
*
* @param pData The data.
* @param len The data length.
* @return A pointer to the page data.
*/                                                             
void DAQBufferPage::SetData(char *pData,int len) {
  sync_self;
    if (headstart >= 0) {
      int l = (len < pagelength) ? len : pagelength;
      memcpy((char*)(&seg[pagestart]),pData,l);
    }
  sync_end; // self
}

/*==============================================================*/
/** @fn AddHeader(DAQBufferPageHeader& aHead)
* @brief Add a new page header to this page.
*
* Add a new, preconstructed page header to this page.
*
* @param aHead The new header.
* @return If assignment of the new page header was successful.
*   @retval true If assignment was successful.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::AddHeader(DAQBufferPageHeader& aHead) {
  sync_self;
    if (pHead == NULL) return(false);
 
    pHead->dirty = aHead.dirty;
    pHead->neverdirty = aHead.neverdirty;
    pHead->modified = aHead.modified;
    pHead->readonly = aHead.readonly;
    pHead->xmit = aHead.xmit;
    pHead->release = aHead.release;
    pHead->lastpage = aHead.lastpage;
    pHead->inuse = aHead.inuse;
    pHead->oob = aHead.oob;
    pHead->ref = aHead.ref;
    pHead->tag = aHead.tag;
    pHead->owner = aHead.owner;
    pHead->user = aHead.user;
    pHead->pos = aHead.pos;
    pHead->reqlen = aHead.reqlen;
    pHead->usedlen = aHead.usedlen;
    pHead->bytelen = aHead.bytelen;
    pHead->node = aHead.node;
    pHead->id = aHead.id;

    return(true);
  sync_end; // self
}

/*==============================================================*/
/** @fn GetHeader(DAQBufferPageHeader& aHead)
* @brief Get a copy of this page's page header. 
*
* Get a copy of this page's page header.
*
* @param aHead Target for the page header copy.
* @return If the copy was successful.
*   @retval true If the copy was successful.
*   @retval false Otherwise.
*/                                                             
bool DAQBufferPage::GetHeader(DAQBufferPageHeader& aHead) {
  sync_self;
    if (pHead == NULL) return(false);
 
    aHead.dirty = pHead->dirty;
    aHead.neverdirty = pHead->neverdirty;
    aHead.modified = pHead->modified;
    aHead.inuse = pHead->inuse;
    aHead.oob = pHead->oob;
    aHead.readonly = pHead->readonly;
    aHead.xmit = pHead->xmit;
    aHead.release = pHead->release;
    aHead.lastpage = pHead->lastpage;
    aHead.ref = pHead->ref;
    aHead.tag = pHead->tag;
    aHead.owner = pHead->owner;
    aHead.user = pHead->user;
    aHead.pos = pHead->pos;
    aHead.reqlen = pHead->reqlen;
    aHead.usedlen = pHead->usedlen;
    aHead.bytelen = pHead->bytelen;
    aHead.node = pHead->node;
    aHead.id = pHead->id;

    return(true);
  sync_end; // self
}

/*===================================================================*/
/** @fn ostream& operator << (ostream& aStream,DAQBufferPage& aPage)
* @brief Print the object on an ostream
*
* Print a Printable on an ostream.
*
* @param aStream An ostream on which to print
* @param aPage A buffer page.
* @return The ostream
*/                                                                  
ostream& operator << (ostream& aStream,DAQBufferPage& aPage)
{
  aStream << aPage.toString().c_str();
  return aStream;
}
