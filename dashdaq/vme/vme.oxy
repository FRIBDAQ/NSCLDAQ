/*!
	\page pg_VME  DASH VME support framework

        \section sec_vmeintro Introduction to the DASH VME support framework.

	DASH VME support recognizes that there are several competing VME
        bus interfaces on the market.  Each one has its own strengths and
        weaknesses.  Each one its own special capabilities.

	\subsection ssec_vmeclasses Major classes in DASH VME support

	The major classes in the DASH VME suport are as follows:
	- CVMESubsystem - This class consists of mostly static methods.
          it maintains an ordered list of VME interfaces that have been
          installed on the system.  It can return single VME interface objects
          which, in turn, allow you to access the services of that interface.
          The interface list is shared amongst all instances of this class in
          a process.
        - CVMEInterface - This is an abstract base class that defines the services
                          all VME interfaces must supply.  Instances of concrete
                          subclasses of CVMEInterface are what get stuck into 
                          the CVMESubsystem.
        - CVMEAddressRange - Represents a range of addresses that can be accessed
                          randomly.  For interfaces that support direct mapping
                          of the bus to process space, this can be the most
                          efficient way to access the bus.
        - CVMEList - Represents the list processor in VME interfaces, one of the
                     concrete subclasses, CSimulatedVMEList allows interfaces
                     without hardware intelligence to emulate this mode of operation.
        - CVMEPio  - Represents access to a VME interface that requires a driver
                     interaction for each operation.
        - CVmeDMATransfer - Represents sequential access to a block of vme address
                    space usually implemented via DMA block transfers.
        - CVMEInterfaceFactory - A singleton factory object that supports the
                   creation of objects from concrete classes derived from 
                   CVMEInterface given a description.  See
		   \ref ssec_supportingnewvme Building VME subsystems from configurations
                   for more information about this.
        - CVMEInterfaceCreator - An abstract base class defining the interface for
                  objects that tell the CVMEInterfaceFactory how to build and 
                  configure particular CVMEInterface objects.

        The idea is that you follow these steps to use the library:
  	-# Create CVMEInterface objects and populate the CVMESubsystem with them.
        -# Accessing a particular CVMEinterface object, use its object creational
          methods to create as appropriate CVMEAddressRange, CVMEList,
	  CVMEPio, and/or CVMEDMATransfer objects to access the appropriate VME
          busses.


        \subsection ssec_vmeconfiguration Building VME subsystems from configurations

	DASH VME support anticipates but does not require that VME subsystems
        will be built from configuration files.  The key to doing this is the
        CVMEInterfaceFactory and the CVMEInterfaceCreator objects registered
        with it to implement the strategies of creating and configuring specific
        interfaces.

        These coupled with the CVMESubsystem::processDescription and
        CVMESubsystem::ProcessDescriptionFile methods allow the VME subsystem
        to be built automatically from a configuration file.
        This works as follows:
	-# CVMEInterfaceCreator objects are instantiated for each
          of the VME interfaces supported by the system.  These are registered
          with the CVMEInterfaceFactory by calling CVMEInterfaceFactory::addCreator
        -# Open a description file and pass the open stream to 
          CVMESubsystem::ProcessDescriptionFile.

       Description files consist of lines of text.  Each line of text physically 
       ends in a newline.  Lines of text can logically end in a point (#) character.
       Blank logical lines are ignored.   Logical lines consist of an interface type
       name (used to select the appropriate CInterfaceCrator), and a configuration
       that is passed uninterpreted to the CInterfaceCreator and used to 
       configure an interface after it is created.

       Interface configurations are generally sets of keyword value pairs.
       See each CVMEInterfaceCreator class documentation page for more information
       about the format of the configuration file.
    

        \subsection ssec_supportingnewvme  Supporting a new VME interface type.

	To add support for a new VME interface to the DASH VME subsystem,
        you must write classes derived from the following base classes:
	- CVMEAddressRange to implement random access to a range of VME
          addresses under a single address modifier.
    	- CVMEList if your interface includes a list processor, this would
 	  provide support for it.  Note that if the interface does not support
	  list processing, or the interface's list processor does not have a good
    	  match to the capabilities assumed by CVMEList, you can use the
	  CSimulatedVMEList to implement support for immediate mode list processing.
        - CVMEDMATransfer to implement support for any block transfer capabilities
          your device has.
        - CVMEPio - to implement support for 'call at a time' VME access.
	- CVMEInterface to represent the interface, to provide capability
          information as well as to provide creators for the classes above.
        - CVMEInterfaceCreator - to provide a creational object for the
           CVMEInterfaceFactory for this interface type.

        At run time, if your application uses the CVMEInterfaceFactory
        directly, or through calls to CVMESubsystem::ProcessDescriptionFile
        or CVMESubsystem::ProcessDescription, you must register an instance of
        your interface creator with the factory via CVMEInterfaceFactory::addCreator

	\subsection ssec_vmecompiling Compiling and linking to DASH VME support.

   Building applications that use the DASH VME support class library require that 
you:
	-# Include appropriate headers in your source files.
	-# Tell the compiler how to locate the DASH VME Headers you have
           included
        -# Tell the linker how to link the DASH VME libraries to your
 	   application, and where to find the shared libraries at run-time.

  This section assumes that the DASH software is installed in 
/usr/opt/dash/current  If this is not the case, substitute the appropriate
top level directory for that in the examples on this page.

  The documentation page for each class describes the header that must be
included to access the class definition.   See, for example, 
CVMEInterface.  Once included, use the -I switch to indicate
where the DASH headers are installed when compiling.  For example:
\verbatim

g++ -c -I/usr/opt/dash/current/include myProgram.cpp

\endverbatim

When linking you need to tell the linker the location of the libraries, specify
the DASH VME library to link, and provide an appropriate \em rpath to the linker
so that the shared libraries are located at run time.

If, in the previous example, myProgram.cpp was  the only program file in your 
application, it could be linked via:

\verbatim

g++ -o myProgram -L/usr/opt/dash/current/lib myProgram.o -lVme 
\endverbatim

*/