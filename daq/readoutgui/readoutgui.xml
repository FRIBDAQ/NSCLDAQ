<!-- chapter utilities -->

<chapter>
    <title>Readout GUI (ReadoutShell)</title>
    <para>
        The  Readout GUI (installed as $DAQROOT/bin/ReadoutShell)
        is a graphical user interface that wraps around data source (Readout)
        software.  It allows you to:
    </para>
    <itemizedlist>
        <listitem>
            <para>
               Run data sources.
            </para>
        </listitem>
        <listitem>
            <para>
                Control your experiment runs via a simple graphical user
                interface
            </para>
        </listitem>
        <listitem>
            <para>
                Manage event files and ancillary data so that they remain
                together in a single package while providing an event file
                view.
            </para>
        </listitem>
        <listitem>
            <para>
                Customize the operation of the GUI program by adding
                Tcl scripted extensions that are called at specific times.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        For reference information see the
        <xref linkend="manpage_readoutshell" endterm="manpage_readoutshell_title" />
        man page in section 1daq.
    </para>
    <section>
        <title>Running and using the ReadoutShell</title>
        <para>
            The Readout GUI is installed as
            <filename>$DAQROOT/bin/ReadoutShell</filename> where
            <literal>$DAROOT</literal> is used as a placeholder for the top
            level of the ring buffer data acquisition installation directory.
        </para>
        <warning>
            <title>WARNING!</title>
            <para>
                You cannot use the readout gui of nscldaq versions earlier
                than 10.0 with the ring buffer data acquisition system.
            </para>
        </warning>
        <para>
            <command>ReadoutShell</command>  for NSCLDAQ-11.0 does not take
            any parameters.  The first time you run it (and optionally other
            times it is run), you must specify the set of data source types and
            data sources it will start.  This is done usig the
            <guimenu>Data Source</guimenu>-><guimenuitem>Add...</guimenuitem>,
            <guimenu>Data Source</guimenu>-><guimenuitem>Delete...</guimenuitem> and
            <guimenu>Data Source</guimenu>-><guimenuitem>Modify...</guimenuitem> menu entries.
            Each time the data source configuration is modified, Readout will save
            that configuration and restore it the next time it is started.
        </para>
        <para>
           By default, the system assumes data will be put in a ringbuffer on
           the same system as the readout program with a name the same as your
           username.  If, for example, your username is <literal>fox</literal>
           and your readoutis running in
           <literal>spdaq22.nscl.msu.edu</literal>, the default ring name is
           going to be <literal>tcp://spdaq22.nscl.msu.edu/fox</literal>.
        </para>
        <para>
           You can override the default ring name by setting the environment
           variable <literal>RINGNAME</literal> to the name of the ring in the
           system on which the readout is running.  If, in the example above,
           your readout software is putting data in the ring
           <literal>s800</literal>, you would: <command>export
           RINGNAME=s800</command> prior t running the GUI.
        </para>
        <para>
            When the readout GUI starts up it will not start the data sources.
            This must be done using the <guibutton>Start Data Source</guibutton>
            on the Readout GUI control panel.  If any data sources report
            failures at any time, all data sources will be asked to stop.  You can
            then use the Start button to restart them.  Until all data sources
            have reported they are running runs cannot be started.
        </para>
        <variablelist>
            <varlistentry>
                <term><guibutton>Begin</guibutton></term>
                <listitem>
                    <para>
                        Starts a new data taking run.  If the run is active,
                        this button is a <guibutton>End</guibutton> button and
                        ends the active run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><guilabel>Title</guilabel></term>
                <listitem>
                    <para>
                        This text entry is only enabled when the run is
                        inactive (the <guibutton>Begin</guibutton> button
                        is visible).  Type into this entry to provide a
                        title that will be used for the next run.
                        The title, truncated if necessary to 79 characters
                        is inserted into some of the ring items the run
                        produces.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><guilabel>Run Number</guilabel></term>
                <listitem>
                    <para>
                        This entry is only enabled when the run is inactive.
                        It is validated so that it must contain an integer
                        at all times.  The number in this entry will be the run
                        number of the next run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><guibutton>Record</guibutton></term>
                <listitem>
                    <para>
                        This check button is only enabled when the the run
                        is inactive.  When checked, the next run will be
                        recorded to disk.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><guimenu>File</guimenu>&#8594;<guimenuitem>New...</guimenuitem></term>
                <listitem>
                    <para>
                        This menu item allows you to choose a new readout
                        program and/or host.  Once this a new readout/host
                        have been selected you can use either
                        <guimenu>File</guimenu>&#8594;<guimenuitem>Restart...</guimenuitem>
                        or <guimenu>File</guimenu>&#8594;<guimenuitem>Start</guimenuitem>
                        to start it depending on whether or not a readout program
                        is already running.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
    <section>
        <title>
            Event file organization
        </title>
        <para>
            The Readout GUI works with the event logger to maintain
            a directory structure of event files and associated data.
            You can associate an arbitrary set of files and directory subtrees
            with each run.  Through heavy use of symbolic links, the
            Readout GUI provides you with two views of your data.
        </para>
        <formalpara>
            <title>Events view</title>
            <para>
                The events view presents all of the event files in a single
                directory.  This view allows you to sequentiall analyze
                several runs without the need to move around in the directory
                hierarchy.
            </para>
        </formalpara>
        <formalpara>
            <title>Runs view</title>
            <para>
                This view collects all of the data associated with each run
                into a single directory.
            </para>
        </formalpara>
        <para>
            The top of the directory subtree that is managed by Readout Gui is
            determined by a symbolic link; <filename>~/stagearea</filename>.
            <footnote>
                <para>
                    Environment variables can override this link however and are
                    useful in the event you are using a single account to do
                    multiple tests for which you want to segregate the data.
                </para>
            </footnote>
            This must be created by you when you set the account up for data taking.
        </para>
        <para>
            When Readout GUI runs the first time it will create the directory
            structure it need underneath the directory pointed to by
            <filename>~/stagearea</filename>.
        </para>
        <para>
            The directory tree created looks like this:
        </para>
        <figure>
            <title>Readout GUI Directory tree</title>
            <literallayout><![CDATA[
stagearea +
          +----> experiment+
          |                +---> current
          |                +---> run1
          |                +---> run2
          ...             ...
          +----> complete
          +----> current
            ]]>
            </literallayout>
        </figure>
        <para>
            Let's start with the <filename>~/stagearea/current</filename> directory.
            The Readout GUI arranges for the event file set currently being
            accumulated to be written in this directory.  Event files have the name
            <literal>run-nnnn-ss.evt</literal> where <literal>nnnn</literal> is a
            zero filled run number (e.g. <literal>0001</literal>), and
            <literal>ss</literal> is a zero filled event segment.
        </para>
        <para>
            The event data from each run are segmented into files that are no
            more than 2GBytes long.  The segments number from 00.
        </para>
        <para>
            The <filename>~/stagearea/experiment</filename> subdirectory tree
            provides the run view of the data.  Within that directory are
            subdirectories for each recorded run.  At the end of a run,
            the Readout GUI moves the event data files from the
            <filename>~/stagearea/current</filename> directory into the
            associated run directory.  The data in
            <filename>~stagearea/experiment/current</filename> is copied into
            the run directory as well.  Files or directories pointed to by
            symoblic links in the <filename>experiment/current</filename> subtree
            are copied rather than the links themselves.
        </para>
        <para>
            Finally, the <filename>complete</filename> directory provides the
            events view of the experiment.  At the end of a run, after the
            event file segments copied to <filename>~stagearea/experiment/runn</filename>,
            a symbolic link to each event file segment is created here.
        </para>
    </section>
    <section>
        <title>Customizing Readout Shell</title>
        <para>
            The readout gui is highly customizable.  You can provide Tcl
            code that is called by the Readout Shell and specific times to
            perform application specific operations. An API allows you to
            interact with the Readout GUI through these script extensions.
        </para>
        <para>
            Furthermore, a large number of environment variables allow you
            to configure how the ReadoutGUI operates.
        </para>
        <section>
            <title>ReadoutCallouts.tcl</title>
            <para>
                ReadoutCallouts is a script that you can supply.  When the Readout
                Gui starts it sources all scripts by this name in the following
                directories in order: <filename>~</filename>, <filename>~/experiment/current</filename>,
                and <filename>.</filename>.  The script is sourced at the global
                level.
            </para>
            <para>
                In addition to performing any desired operations as the script
                is initially sourced, if these script define any of the
                following <command>proc</command>s they will be called
                by the Readout GUI at the appropriate time.  Please note that
                Tcl does not support overloading <command>proc</command>names.
                If you want to chain to previously defined instances of those
                procs you'll need to use the <command>rename</command> command
                to rename the old ones and then manually chain to them from your
                code.
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>OnBegin</command> <parameter>runNumber</parameter></term>
                    <listitem>
                        <para>
                            This proc is called by Readout GUI when the run has been
                            started.  By the time this proc is called, the event logger
                            has already started, however the Readout program itself
                            has not yet been told to start the run.
                            As implied by the header above,  the proc receives
                            the current run number as a parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnEnd</command> <parameter>runNumber</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just after a run has neded.  The
                            Readout program has been asked to end the run,
                            however due to the lack of closed loop control
                            between the ReadoutGui and Readout, it is not yet known
                            that the Readout program actually has finished ending
                            the run and sent its end run item to the ring buffer.
                            The proc is parameterized by the number of the run'
                            that is ending.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnPause</command> <parameter>runNumber</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just after a run has paused.
                            The timing for this call is essentially the same as that for
                            <command>OnEnd</command>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnResume</command> <parameter>runNumber</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just after a run has resumed.
                            The timing for this is the same as that for
                            <command>OnStart</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnStart</command></term>
                    <listitem>
                        <para>
                            This proc is called when all data sources have
                            reported a successful start.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnDsFail</command> <parameter>dsId</parameter></term>
                    <listitem>
                        <para>
                            This proc is called when a data source has
                            exited unexpectedly. The proc is passed the
                            data source Id as a parameter.  See the data source
                            documentation and API documentation for more about
                            the data source Id and what it can be used for.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The toy extension below logs readout loads, and run state transitions
                to a file <filename>~/readout.log</filename>  The  file
                is opened and appended to for each log operation.
            </para>
            <example>
                <title>ReadoutCallouts.tcl sample extension</title>
                <programlisting>
set filename [file join ~ readout.log]

if {[info procs OnBegin] ne ""} {
    rename OnBegin PreLogger_OnBegin 
}

proc logToFile message {
   global filename
   
   set fd [open $filename "w+"]
   set timestamp [clock format [clock seconds]]
   puts $fd "$timestamp : $message"
   close $fd
}
proc OnBegin run {
   if {[info procs PreLogger_OnBegin] ne ""} {
        PreLogger_OnBegin $run
   }
   logToFile "Run $run Begun"
}
proc OnEnd run {
   logToFile "Run $run has ended"
}
proc OnPause run {
   logToFile "Run $run has been paused"
}
proc OnResume run {
   logToFile "Run $run has been resumed"
}
proc OnStart {} {
   logToFile "Readout program has been started"
}
                    
                </programlisting>
            </example>
            <para>
                The code at the top of the file and the code in
                <command>OnBegin</command> illustrate how to chain to a previously
                defined OnBegin.  As the script starts up, any existing OnBegin
                proc is renamed to <command>PreLogger_OnBegin</command>. If
                OnBegin detects the existence of this proc it is called.
                Obviously this can be extended to any and all of the callback
                functions.
            </para>
        </section>
        <section>
            <title>Environment and configuration variables</title>
            <para>
                ReadoutGUI looks for a large number of environment variables.
                Setting these overrides default values and symbolic links.
                This section describes the set of environment variables that
                are understood by Readout GUI.
            </para>
            <para>
                Readout GUI processes configuration files, then environment
                variables and finally command line parameters where appropriate.
                The cofiguration file is located in
                <filename>~/stagerea/.readoutconfig</filename>.  This contains
                static configuration as a set of Tcl Variables.
                <filename>~/.daqconfig</filename> can contain additional
                static configuration as can <filename>./.daqconfig</filename>.
                In the tables below, the <literal>parameter</literal> column is
                the global Tcl variable to set to modify this parameter in
                a configuration file.
            </para>
            <table frame="all">
                <title>Data Acquisition configuration parameters</title>
                <tgroup cols="3" colsep='1' rowsep='1'>
                    <thead>
                        <row>
                            <entry>Parameter</entry>
                            <entry>Environment variable</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>SourceHost</entry>
                            <entry>DAQHOST</entry>
                            <entry>Name of the system that runs the Readout program.</entry>
                        </row>
                        <row>
                            <entry>ReadoutPath</entry>
                            <entry>RDOFILE</entry>
                            <entry>File system path to the readout program</entry>
                        </row>
                        <row>
                            <entry>EventLogger</entry>
                            <entry>EVENTLOGGER</entry>
                            <entry>Path to an event logger that substitutes
                                for the standard event logger.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <table>
                <title>Directory root configuration parameters</title>
                <tgroup cols="3" colsep="1" rowsep="1">
                    <thead>
                        <row>
                           <entry>Parameter</entry>
                            <entry>Environment variable</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>StageArea</entry>
                            <entry>EVENTS</entry>
                            <entry>Overrides the symbolic link <filename>~stagearea</filename>
                            if set</entry>
                        </row>
                        <row>
                            <entry>Experiment</entry>
                            <entry>EXPDIRM</entry>
                            <entry>Overrides the root directory where the
                            experiment view is generated.  This defaults to
                            <filename>~/experiment</filename> which if it does
                            not initially exist is linked to an <filename>experiment</filename>
                            directory in the stage area.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <table>
                <title>State Parameters</title>
                <tgroup cols="3" colsep="1" rowsep="1">
                    <thead>
                        <row>
                           <entry>Parameter</entry>
                            <entry>Environment variable</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>RunTitle</entry>
                            <entry>EXPTITLE</entry>
                            <entry>The title of the run.  This is intended to allow
                            you to provide an initial run title.  It is usually overidden
                            by the value in <filename>.readoutconfig</filename> which
                            is rewritten at the start and end of each run</entry>
                        </row>
                        <row>
                            <entry>RunNumber</entry>
                            <entry>--</entry>
                            <entry>The current run number.  This is far too dynamic
                            to merit an environment variable.
                            </entry>
                        </row>
                        <row>
                            <entry>ScalerCount</entry>
                            <entry>SCALERS</entry>
                            <entry>
                                The value that will be used in the initial
                                <command>set scalers</command> command at the
                                start of the run. The intent of this variable
                                (not much used nowadays). is to allow experiment
                                specific code to bind to it and use its value
                                to determine the number of scalers to read out.
                            </entry>
                        </row>
                        <row>
                            <entry>ScalerInterval</entry>
                            <entry>SCALERINTERVAL</entry>
                            <entry>Value in the <command>set frequency</command>
                                command performed at the beginning of each run.
                                The original intent of this was to allow
                                users to bind to this value and use it to
                                dynamically set the scaler trigger period.
                            </entry>
                        </row>
                        <row>
                            <entry>Recording</entry>
                            <entry> --</entry>
                            <entry>Non zero when the recording checkbox is lit.
                            Like the run number this is too dynamic to merit an
                            environment variable.
                            </entry>
                        </row>
                        <row>
                            <entry>Timed</entry>
                            <entry> -- </entry>
                            <entry>Reflects the state of the timed run checkbox</entry>
                        </row>
                        <row>
                            <entry>TimedLength</entry>
                            <entry> -- </entry>
                            <entry>Number of seconds the time in the timed run
                            length entries reflects.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
    
        </section>
    </section>
    <section>
        <title>The run state machine</title>
        <para>
            With the introduction of data sources, the run state machine
            executed by the ReadoutGUI is somewhat more complex than that of
            NSCLDAQ-10.0 and prior releases.
        </para>
        <para>
            This section describes the new state machine, its states and
            what can cause transitions between the states.
        </para>
        <para>
            The main point is that in addition to the old state machine
            a new state <literal>Not ready</literal> has been introduced that
            the system is in when the data sources have not been started
            and an addtional state <literal>Starting</literal> that the
            system is in when the event sources are being started.
        </para>
        <para>
            The full state machine is shown below:
        </para>
        <figure id='rdoguifig-statemachine'>
            <title>ReadoutGUI state machine</title>
            <mediaobject>
               <imageobject>
                    <imagedata fileref='RunState.jpg' format='JPEG' />
                </imageobject>
               <imageobject>
                    <imagedata fileref='RunState.eps' format='EPS' />
               </imageobject>
            </mediaobject>
        </figure>

    </section>
    <section>
        <title>Data Sources</title>
        <para>
            A data source is a provider of data to the NSCL DAQ system.
            Simple experiments may only have a single data source (e.g. the
            SBS or VM/USB readout framework).  More complex experiments,
            using the NSCL event builder, may have several data sources.
            ReadoutGUI uses Data source providers to manage data sources.
            Several pre-written data source providers are part of the NSCLDAQ distribution.
            Data source providers can also be written to handle special circumstances.
        </para>
        <para>
            Data source providers are manipulated by users by the <guimenu>Data Source</guimenu>
            menu.
        </para>
        <para>
            A data source provider is a Tcl package with a name of the form
            <emphasis>SourceType_</emphasis><literal>provider</literal>. Where
            <emphasis>SourceType</emphasis> is the type of data source that is
            being provided.  In Tcl, packages are made known to the interpreter
            by:
            <orderedlist>
                <listitem>
                    <para>Issuing the <command>package provide</command>
                    command within the package itself.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Placing the Tcl code that provides the package in
                        a directory and using the tclsh command
                        <command>pkg_mkIndex</command> to produce a pacakge
                        index file.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Setting the <literal>TCLLIBPATH</literal> environment
                        variable to a space separated list of directories
                        that contain the packages and their indices
                    </para>
                </listitem>
            </orderedlist>
        </para>
        <example>
            <title>Creating a data provider for <literal>MySource</literal></title>
            <itemizedlist>
                <listitem>
                    <para>
                        Create a Tcl file with the <command>package provide</command> command
                    </para>
                    <programlisting>
                        package provide MySource_provider 1.0
                    </programlisting>
                </listitem>
                <listitem>
                    <para>
                        Put the script that is the provider into a directory
                        (let's call it <filename>~/myproviders</filename>).
                    </para>
                </listitem>
                <listitem>
                      <para>
                        Create a package index for the <filename>~/myproviders</filename>
                        directory.
                      </para>
                      <programlisting>
                        <userinput>tclsh</userinput>
                        <prompt>% </prompt><userinput>pkg_mkIndex ~/myproviders *.tcl</userinput>
                      </programlisting>
                </listitem>
            </itemizedlist>
        </example>
        <para>
            A data source provider is just a tcl script provided as a 
            Tcl package that provides a well defined set of procedures.
            In order to avoid conflicting with other data source providers,
            these procedures must be defined within a namespace that matches
            the name of the data source (e.g. <literal>::MySource::</literal> in
            the example above).
        </para>
        <para>
            The provider may provide the following <command>procs</command>. A
            provider only needs to define the set of <command>procs</command> it
            needs to operate. Reasonable default behavior occurs if the proc
            is not defined by the provider.  See the reference section
            3provider for information
            that describes each proc in detail.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <link linkend='provider3-parameters'>parameters</link>
                </term>
                <listitem>
                    <para>
                        Provides a description of additional parameters
                        required by the data source provider to describe
                        a specific data source instance.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend='provider3-start'>start</link>
                </term>
                <listitem>
                    <para>
                        Starts the data source.  If the data source is
                        started correctly, the proc should return a true boolean
                        value else false.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='provider3-check'>check</link></term>
                <listitem>
                    <para>
                        Tests to see if the data source is running,
                        returns true if so.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='provider3-stop'>stop</link></term>
                <listitem>
                    <para>
                        Stops the data source.  Returns true if the data source
                        was successfully stopped.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='provider3-begin'>begin</link></term>
                <listitem>
                    <para>
                        Called to start a run.  The begin proc is passed
                        the number of the new run and the title string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='provider3-pause'>pause</link></term>
                <listitem>
                    <para>
                        Called to pause a run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='provider3-resume'>resume</link></term>
                <listitem>
                    <para>
                        Called to resume a paused run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='provider3-end'>end</link></term>
                <listitem>
                    <para>
                        Called to end a paused run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link  linkend='provider3-capabilities'>capabilities</link></term>
                <listitem>
                    <para>
                        Returns a description of the data source's capabilities.
                        For example, some data sources are not capable of
                        pausing a run.  Those data sources cause the Paused state
                        to be removed from the run state machine (and make
                        the Pause button disappear).
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The readout GUI also provides mechanisms for ReadoutCallouts scripts
            to locate data source providers.  When a data source is added,
            it is assigned an id.  The following <command>proc</command>s are
            provided by the ReadoutGUI API that provide information about the
            run state machine and supply access to data source providers.
        </para>
        <variablelist>
            <varlistentry>
                <term><link linkend='rdogui3-getState'>getState</link></term>
                <listitem>
                <para>
                    Returns the current state of the run.  States are referred
                    to by name as described in the diagram above.
                </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='rdogui3-listSourceIds'>listSourceIds</link></term>
                <listitem>
                    <para>
                        Returns a list of the source ids that are currently
                        known.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='rdogui3-getSourceInfo'>getSourceInfo</link></term>
                <listitem>
                    <para>
                        Given a sourceid (from e.g. listSourceIds), returns
                        information about the source provider.  The information
                        returned includes the namespace the source provider uses
                        for its <command>proc</command>s and the parameterization
                        of the provider.
                    </para>
                    <para>
                        Note that this information allows ReadoutCallouts code
                        to invoke arbitrary <command>proc</command>s defined
                        by that provider in its namespace.  Each provider may,
                        of course define <command>proc</command>s in addition
                        to those required by the readout GUI.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='rdogui3-addSource'>addSource</link></term>
                <listitem>
                    <para>
                        Adds a data source to the readout GUI.  This
                        <command>proc</command> returns the data sourcd id.
                        See reference material for more information.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>

    </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3provider -->

      <refentry id='provider3-parameters'>
        <refmeta>
           <refentrytitle id='provider3-parameters-title'>parameters</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>parameters</refname>
           <refpurpose>Return information about data source parameterization</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
<replaceable>set parameterization </replaceable>[<replaceable>provider-namespace</replaceable>::parameters]
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Data source provider <command>proc</command> that must return
            information about the parameters used to connect a data source
            provider to a specific data source instance.  This information
            is prompted for and given to the providers's <command>start</command>
            <command>proc</command> by the ReadoutGui when adding a data
            source.  Note that this proc must be defined within the namespace
            of the provider e.g. <command>MyProvider::parameters</command>.
           </para>
           <para>
            The data must be returned in a Tcl <command>dict</command> the keys
            of the dict are the names of the parameters.  The values are either
            lists that are one or two elements long and contain:
           </para>
           <orderedlist>
            <listitem><para>
                Prompt string for the parameter.   This is required.
            </para></listitem>
            <listitem>
                <para>
                    Script that validates the parameter.  The script will have
                    the candidate parameter appended to it, and must return
                    a boolean true if the canidate parameter is valid.
                    This is optional and, if not provided, all parameter
                    values are considered legal.
                </para>
            </listitem>
           </orderedlist>
           <para>
            If a provider does not define this <command>proc</command> it is
            assumed not to require any parameters (e.g. it's a one of a kind
            data source provider).
           </para>
        </refsect1>
      </refentry>
      <refentry id="provider3-start">
        <refmeta>
           <refentrytitle id='provider3-start-title'>start</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>start</refname>
           <refpurpose>Start a data source instance</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
<replaceable>provider-namespace</replaceable>::start <replaceable>paramdict</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Requests that a data source provider start an instance of the data
            source types it can manage.   The data source parameterization
            was prompted for by the ReadoutGUI and loaded into the
            <parameter>paramdict</parameter>.  This dictionary has keys that
            are the parameter names and values that are the parameter values
            received by the prompt.  An additional key <literal>sourceid</literal>
            has a value that is a unique value over all data source instances.
            This can be used by the data source provider to keep track of state
            that is specific to an instance of a data source it manages.
           </para>
           <para>
            This proc must be defined by all data source providers.
           </para>
        </refsect1>
      </refentry>

      <refentry id="provider3-check">
        <refmeta>
           <refentrytitle>check</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>check</refname>
           <refpurpose>Check status of a data source</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
<replaceable>set status</replaceable> [<replaceable>ProviderNamespace</replaceable>::check <replaceable>sourceId</replaceable>]
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Called to check if a data source instance is still live and healthy.
            <parameter>sourceId</parameter> is the id that was assigned to the
            source id instance in the dict passed to <command>start</command>.
            The proc is required to return a boolean true value if the source is
            live and healthy, false otherwise.
           </para>
           <para>
            If the data source provider does not define this proc, the source
            is assumed to be alive.
           </para>
        </refsect1>

      </refentry>

      <refentry id="provider3-stop">
        <refmeta>
           <refentrytitle>stop</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>stop</refname>
           <refpurpose>stop a data source instance</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
<replaceable>ProviderNamespace</replaceable>::stop <replaceable>sourceId</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Asks the provider to stop the data source specified by
            <parameter>sourceId</parameter>.  <parameter>sourceId</parameter> was
            a source id passed in to the <command>start</command> proc.  Once the
            data source is stopped, the provider can destroy any state information
            it has about that data source instance.
           </para>
           <para>
            Note that the provider may get a request to stop a data source
            that failed (e.g. after a call to <command>check</command> returned
            false).  It is up to the provider to decide what to do in this case
            however;  it should not throw an error condition and it should
            ensure that all state information saved for the source is destroyed.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3-begin">
        <refmeta>
           <refentrytitle>begin</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>begin</refname>
           <refpurpose>Start a run</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
<replaceable>ProviderNamespace</replaceable>::begin <replaceable>sourceId runNum title</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Called to start a run.  The <parameter>sourceId</parameter> is a source
            id that identifies the data source instance.  <parameter>runNum</parameter>
            is the number of the run being started.  This may be ignored if there's
            no concept of a run number in the data source.  <parameter>title</parameter>
            is the current run title.  Again this can be ignored by data sources
            that don't have a concept of a run title.
           </para>
        </refsect1>

      </refentry>
      <refentry id="provider3-pause">
        <refmeta>
           <refentrytitle>pause</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>pause</refname>
           <refpurpose>Pause a data source's run</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
<replaceable>ProviderNamespace</replaceable>::pause <replaceable>sourceId</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Requests the data source provider to pause data taking in the data
            source instance identified by <parameter>sourceId</parameter>.  If
            the data source provider has indicated (via its <command>capabilities</command>
            command) it is unable to support run pauses, no <command>pause</command>
            operations will be attempted by the ReadoutGUI.   
           </para>
           <para>
            It is an error to report a capability to pause a run but not provide
            a <command>proc</command> that can do that.  That error is detected
            when the package is loaded.
           </para>
        </refsect1>

      </refentry>

      <refentry id="provider3-resume">
        <refmeta>
           <refentrytitle>resume</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>resume</refname>
           <refpurpose>Resume data taking for a source.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
<replaceable>ProviderNamespace</replaceable>::resume <replaceable>sourceId</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Called to request a data source provider resume a paused run.
            <parameter>sourceId</parameter> identifies which source instance
            should be resumed.  If the data source provider has indicated it is
            not capable of pausing (via its <command>capabilities</command> command),
            this will never be called for any data source as Pause/Resume will be
            disabled.
           </para>
        </refsect1>
      </refentry>

      <refentry id="provider3-end">
        <refmeta>
           <refentrytitle>end</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>end</refname>
           <refpurpose>end the run</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
<replaceable>ProviderNamespace</replaceable>::end <replaceable>sourceId</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Called to request the data source provider end data taking on
            the data source identified by <replaceable>sourceId</replaceable>.

           </para>
        </refsect1>
      </refentry>

      <refentry id="provider3-capabilities">
        <refmeta>
           <refentrytitle>capabilities</refentrytitle>
           <manvolnum>3provider</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>capabilities</refname>
           <refpurpose>Fetch provider capabilities</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
set <replaceable>aDict </replaceable>[<replaceable>ProviderNamespace</replaceable>::capabilities]
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Returns the capabilities of a data source provider.  These are returned
            as a <command>dict</command> with the following keys/values:
           </para>
           <variablelist>
            <varlistentry>
                <term>canpause</term>
                <listitem>
                    <para>
                        True if the class of data sources managed by this
                        provider supports paused runs.  False otherwise.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>runsHaveTitles</term>
                <listitem>
                    <para>
                        If true, the data source runs have titles.  If no data
                        source support titles, the user interface will not allow
                        you to set run titles.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>runsHaveNumbers</term>
                <listitem>
                    <para>
                        IF true, the data source runs have a run number.  If no
                        data sources support run numbers, the user interface
                        will not allow you to set run numbers.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>

<!-- /manpage -->

<!-- manpage 3rdogui --> <!-- Add full docs of ReadoutGUI API -->
      <refentry id="rdogui3-packages">
        <refmeta>
           <refentrytitle>ReadoutGUI API packages</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ReadoutGUI API packages</refname>
           <refpurpose>Packages into which the ReadoutGUI API is divided.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
<command>
package require ReadoutGui
</command>
<command>
package require ReadoutGUIPanel
</command>

          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
            <variablelist>
                <para>
                    The Readout GUI packages your script can use are:
                </para>
                <varlistentry>
                    <term>ReadoutState</term>
                    <listitem>
                        <para>
                            Provides the ability to manipulate and inquire
                            about the state of the system.
                        </para>
                    </listitem>
                </varlistentry>
                 <varlistentry>
                    <term>ReadoutGui</term>
                    <listitem>
                        <para>
                            Provides the ability to do things that the
                            GUI elements can cause to happen.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>ReadoutGUIPanel</term>
                    <listitem>
                        <para>
                            Provides access to the gui elements of the
                            user interface itself.  
                        </para>
                    </listitem>
                </varlistentry>
          </variablelist>

        </refsect1>

      </refentry>


      <refentry id="rdogui3-getState">
        <refmeta>
           <refentrytitle>getState</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>getState</refname>
           <refpurpose>Get current state</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
<command>
package require ReadoutState
</command>

<command>
package require ReadoutState
</command>
              <command>
<replaceable>set state </replaceable>[ReadoutState::getState]
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Returns the current state the ReadoutGui state machine is in.  The
            state machine diagram in <link linkend='rdoguifig-statemachine' /> is
            actually a simplification of the full state maching executed by the
            ReadoutGUI.  Since it can take a macroscopic time for any state
            transition, there are intermediate states in between all states
            after the system is started.
           </para>
           <para>
            The set of states this proc can return are:
           </para>
           <variablelist>
            <varlistentry>
                <term>NotReady</term>
                <listitem>
                    <para>
                        The data sources have not yet been started.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Starting</term>
                <listitem>
                    <para>
                        The data sources have been told to start but have not
                        yet finished starting.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Stopping</term>
                <listitem>
                    <para>
                        The data sources are shutting down.  This can either be
                        due to an explicit request for shutdown or because one
                        of the data sources has failed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Halted</term>
                <listitem>
                    <para>
                        The data sources are all running but no data taking is
                        being done.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Activating</term>
                <listitem>
                    <para>The data sources have been told to take data
                    (either a <command>begin</command> or a <command>resume</command>
                    can trigger this state) but are not all yet taking data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Active</term>
                <listitem>
                    <para>
                        The data sources are all taking data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Halting</term>
                <listitem>
                    <para>
                        Data taking in sources is shutting down to transition
                        to the <literal>Halted</literal> state.  This is
                        triggered by an <command>end</command> from either
                        of the <literal>Active</literal> or <literal>Paused</literal>
                        states.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Pausing</term>
                <listitem>
                    <para>The data sources have been asked to pause but
                    not all of them have paused yet.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Paused</term>
                <listitem>
                    <para>All data sources are in the paused state.</para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
      </refentry>

      <refentry id="rdogui3-listSourceIds">
        <refmeta>
           <refentrytitle>listSourceIds</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>listSourceIds</refname>
           <refpurpose>Get a list of the active data sources</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
<command>
package require ReadoutState
</command>

              <command>
<replaceable>set sources </replaceable>[ReadoutState::listSourceids]
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Returns a Tcl list of the source ids for the data sources that
            are currently either running or starting.  See
            <link linkend='rdogui3-getSourceInfo' endterm='rdogui3-getSourceInfo-title' />
            for how to get more information about a source instance.
           </para>
        </refsect1>

      </refentry>
      <refentry id="rdogui3-getSourceInfo">
        <refmeta>
           <refentrytitle id='rdogui3-getSourceInfo-title'>getSourceInfo</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>getSourceInfo</refname>
           <refpurpose>Get desription of a data source</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
<command>
package require ReadoutState
</command>

              <command>
<replaceable>set infodict</replaceable> [ReadoutState::getSourceInfo <replaceable>sourceId</replaceable>]
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Return information that is known about a data source given its
            <parameter>sourceId</parameter>.  The data are returned as a dict.
            Keys of the dict include the names of the source's parameters and
            their values.  The dict returned will have the following additional
            keys:
           </para>
           <variablelist>
            <varlistentry>
                <term>parameterization</term>
                <listitem>
                    <para>
                        The dict that defines the parameterizations for data
                        sources of this type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>provider</term>
                <listitem>
                    <para>The namespace the provider <command>proc</command>s are
                    defined within.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>state</term>
                <listitem>
                    <para>State of the data source provider.  This can have
                    any of the values <command>getState</command> can have.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>id</term>
                <listitem>
                    <para>The id of the source instance.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-addSource">
        <refmeta>
           <refentrytitle>addSource</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>addSource</refname>
           <refpurpose>Add a data source instance.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
<command>
package require ReadoutState
</command>

              <command>
ReadoutState::addSource <replaceable>providerName parameterDict</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Starts a new source under the management of the data source
            provider <parameter>providerName</parameter>.  <parameter>parameterDict</parameter>
            provides the parameters needed by the provider to create/connect
            to the data source.  A unique data source id will be assigned to the
            new data source and added to <parameter>parameterDict</parameter> which
            will then be passed to the <command>start</command> proc of the
            data source provider.
           </para>
           <para>
            <command>addSource</command> returns the source id that was assigned
            to this data source.
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-setTitle">
        <refmeta>
           <refentrytitle>setTitle</refentrytitle>
           <manvolnum>rdogui3</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>setTitle</refname>
           <refpurpose>Set the next run title</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
ReadoutState::setTitle <replaceable>newTitle</replaceable>
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                Sets the title string for the next run. Unlike
                the GUI, which does not allow title string
                changes until the run is halted, the software
                can change this string at any time and the new
                value will be reflected in the GUI. The Readout
                program, however, only receives a new title
                string just prior to the start of a run, and
                prior to the call to <command>OnBegin</command>.
                Therefore it is strongly suggested that your code only change the
            title when the run is not active or paused.
           </para>
           <para>
            The <parameter>newTitle</parameter> is the new title value.
           </para>
        </refsect1>
      </refentry>

      <refentry id="rdogui3-setRun">
        <refmeta>
           <refentrytitle id='rdogui3-setRun-title'>setRun</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>setRun</refname>
           <refpurpose>Set the run number of the next run.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require RunState
          </command>
              <command>
RunState::setRun <replaceable>new-run-number</replaceable>
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Sets the run number for the next run to
            <parameter>new-run-number</parameter>. See setTitle for for
            what this means and when the Readout
            program will actually see this setting.
           </para>
           <para>
            Unlike the GUI, the API allows you to set a new run number
            even during a run (state is <literal>Active</literal> or
            <literal>Paused</literal>).   This change is reflected in the
            GUI.  It is strongly suggested that your code only change the
            title when the run is not active or paused.
           </para>
        </refsect1>
      </refentry>
      <refentry id="rdogui3-getRun">
        <refmeta>
           <refentrytitle>getRun</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>getRun</refname>
           <refpurpose>Get the run number</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
<replaceable>set run [</replaceable>ReadoutState::getRun<replaceable>]</replaceable>
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Return the current value of the run number.  Note that the meaning
            of this value can be pathological if user extensions modify the
            run number (via <link linkend='rdogui3-setRun' endterm='rdogui3-setRun-title' />).
            Normally, if the run is in progress (<literal>Active</literal> or
            <literal>Paused</literal> and related states), The run number represents the
            run number of the current run.  On the other hand, if the run is not
            ongoing, the run number represents the run number that will be used
            for the next run.
           </para>
           <para>
             If <link linkend='rdogui3-setRun' endterm='rdogui3-setRun-title' />
             has been used to set the run number, then this returns
             the value sent to the most recent call of setRun.
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-incRun">
        <refmeta>
           <refentrytitle>incRun</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>incRun</refname>
           <refpurpose>Increment run number</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
ReadoutState
          </command>
              <command>
ReadoutState::incRun
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Increments the GUI run  number. Unlike the GUI, the API allows you
            to set a new run number
            even during a run (state is <literal>Active</literal> or
            <literal>Paused</literal>).   This change is reflected in the
            GUI.  It is strongly suggested that your code only change the
            title when the run is not active or paused.
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-getRecording">
        <refmeta>
           <refentrytitle>getRecording</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>getRecording</refname>
           <refpurpose>Get the recording state</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
<replaceable>set state [</replaceable>ReadoutState::getRecording<replaceable>]</replaceable>
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Returns the current recording state (the valueo ofthe record data
            check box).  This can return pathological values if this state
            variable was set while a run is on-going.  
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-enableRecording">
        <refmeta>
           <refentrytitle>enableRecording</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>enaleRecording</refname>
           <refpurpose>Enable event recording</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
ReadoutState::enableRecording
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Enables event recording.  This takes effect at the start of the
            next run.
           </para>
        </refsect1>

      </refentry>
      <refentry id="rdogui3-disableRecording">
        <refmeta>
           <refentrytitle>disableRecording</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>disableRecording</refname>
           <refpurpose>Disable event recording</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
ReadoutState::disableEventRecording
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Disable event recording. This takes effect at the start of the next
            data taking run.
           </para>
        </refsect1>
      </refentry>

      <refentry id="rdogui3-isTimedRun">
        <refmeta>
           <refentrytitle>isTimedRun</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>isTimedRun</refname>
           <refpurpose>Check if timed runs are requested</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
<replaceable>set timed [</replaceable>ReadoutState::isTimedRun<replaceable>]</replaceable>
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Returns a true boolean value if the Timed
            run checkbox is enabled.  If this has not been maniuplated
            programmatically by user code, this indicates that the active run
            is a timed run or, if the run is halted, that then ext run will be.
           </para>
        </refsect1>

      </refentry>
      <refentry id="rdogui3-TimedRun">
        <refmeta>
           <refentrytitle>TimedRun</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>TimedRun</refname>
           <refpurpose>Enable next run as timed.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
ReadoutState::TimedRun
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                Enables the next run to be a timed run. 
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-notTimedRun">
        <refmeta>
           <refentrytitle>notTimedRun</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>notTimedRun</refname>
           <refpurpose>Disable next run as timed</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
ReadoutState::notTimedRun
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Says that the next run will not be a timed
            run.
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-timedLength">
        <refmeta>
           <refentrytitle>timedLength</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>timedLength</refname>
           <refpurpose>Get length of a timed run</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
ReadoutState::timedLength
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Returns the length of a timed run. The
             length is returned as the number of seconds
             the run would last.
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-setTimedLength">
        <refmeta>
           <refentrytitle>setTimedLength</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>setTimedLength</refname>
           <refpurpose>Set length of timed run</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutState
          </command>
              <command>
ReadoutState::setTimedLength <replaceable>seconds</replaceable>
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Sets the length of the timed run in seconds.
             You must also enabled timed running in
             order for this to mean anything.
           </para>
        </refsect1>

      </refentry>
      <refentry id="rdogui3-isExecuting">
        <refmeta>
           <refentrytitle>isExecuting</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>isExecuting</refname>
           <refpurpose>Are all data sources alive?</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutControl
          </command>
              <command>
ReadoutControl::isExecuting
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This is a legacy API element and should not be used
            for new applciations.  <literal>true</literal> is
            returned if all data sources are running.
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-ExitReadoutProgram">
        <refmeta>
           <refentrytitle>ExitReadoutProgram</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ExitReadoutProgram</refname>
           <refpurpose>Shutdown data sources</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutControl
          </command>
              <command>
ReadoutControl::ExitReadoutProgram
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This is a legacy API element and should not be used by new
            applications.  If the run is active it is ended.  All data sources
            are then requested to terminate.  On successful completion, the
            system state should be <literal>NotReady</literal>.
           </para>
        </refsect1>
      </refentry>

      <refentry id="rdogui3-StartReadoutProgram">
        <refmeta>
           <refentrytitle>StartReadoutProgram</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>StartReadoutProgram</refname>
           <refpurpose>Transition to "Ready" state.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutControl
          </command>
              <command>
ReadoutControl::StartReadoutProgram
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This is a legacy API element and should not be used in new applications.
            The system is forced into the Ready state as follows:
            <itemizedlist>
                <listitem>
                    <para>If the system is taking data or paused, the
                    run is halted putting the system into the <literal>Halted</literal>
                    state.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        From the <literal>Halted</literal>state,
                        any live data sources are forced to stop utting the
                        system into the <literal>NotReady</literal> state.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        From the NotReady state all data sources are started.
                        On successful completion, the system should be in the
                        <literal>Halted</literal> state.
                    </para>
                </listitem>
            </itemizedlist>
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-Start">
        <refmeta>
           <refentrytitle>Start</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Start</refname>
           <refpurpose>Start data sources</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutGui
          </command>
              <command>
ReadoutGui::Start
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Activates the <guibutton>Start</guibutton> button.  This starts
            all data sources using the same code invoked by the
            <guibutton>Start</guibutton> button.  It is an error to invoke this
            unless the system state is <literal>NotReady</literal>.  Note
            that if some data sources are started and others not, only those
            that are not running are started (e.g. if one data source failed
            only the failed source is started.).
           </para>
        </refsect1>

      </refentry>
      <refentry id="rdogui3-Restart">
        <refmeta>
           <refentrytitle>Restart</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Restart</refname>
           <refpurpose>Restart data sources</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutGui
          </command>
              <command>
ReadoutGui::Restart
                </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Activates the ui elements to restart the data sources.  If
            the run is active or paused, this will make the run stop after
            which all running data sources will be stopped and then started
            again.  If this is all successful, the state of the system will
            be <literal>Halted</literal>.
           </para>
        </refsect1>
      </refentry>

      <refentry id="rdogui3-Begin">
        <refmeta>
           <refentrytitle>Begin</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Begin</refname>
           <refpurpose>Click the begin button</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
packagte require ReadoutGui
          </command>
              <command>
ReadoutGui::Begin
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Simulates a press of the Begin button. This
            attempts to start a run. Note that
            programmatically, there are no protections
            at this level against beginning a run that
            is already running. You should inquire the
            state of the system prior to attempting to
            start a run.            
           </para>
        </refsect1>
      </refentry>

      <refentry id="rdogui3-Pause">
        <refmeta>
           <refentrytitle>Pause</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Pause</refname>
           <refpurpose>Click the pause button.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutGui
          </command>
              <command>
ReadoutGui::Pause
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Simulates a press of the
            <guibutton>Pause</guibutton> button.
            as for <command>Begin</command> the state
            should be checked to ensure it is
            <literal>Active</literal> before invoking this.
           </para>
        </refsect1>

      </refentry>

      <refentry id="rdogui3-Resume">
        <refmeta>
           <refentrytitle>Resume</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Resume</refname>
           <refpurpose>Click the resume button</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutGui
          </command>
              <command>
ReadoutGui::Resume
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Simulates a click of the
            <guibutton>Resume</guibutton> button.
            The caller should ensure the state is <literal>Paused</literal>
            before invoking this.            
           </para>
        </refsect1>

      </refentry>
      <refentry id="rdogui3-End">
        <refmeta>
           <refentrytitle>End</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>End</refname>
           <refpurpose>Click the end button</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                Simulates a click of the
                <guibutton>End</guibutton> button. As before,
                ensure this is legal by checking the state and ensuring
                the transition requested is legal.
           </para>
        </refsect1>
      </refentry>
      <refentry id="rdogui3-addUserMenu">
        <refmeta>
           <refentrytitle>addUserMenu</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>addUserMenu</refname>
           <refpurpose>Add a user menu to the Readout GUI</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutGUIPanel
          </command>
              <command>
<replaceable>set menu [</replaceable> ReadoutGuiPanel::addUserMenu<replaceable>ident label]</replaceable>
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Adds a user menu to the menubar on the Readout GUI.
            <parameter>ident</parameter> is an identifier for the menu and
            will be used as the last part of the widget path for the menu you need
            to configure.  <parameter>label</parameter> will be the text that will
            appear in the menu bar that, when clicked, drops down you custom menu.
           </para>
           <para>
            <command>addUserMenu</command> returns the full path to the menu to
            which you can add commands and other menu items.  For more
            information on how to do that, see the Tcl/Tk <command>menu</command>
            manpage.
           </para>
        </refsect1>
        <refsect1>
           <title>
              EXAMPLES
           </title>
           <example>
            <title>Adding a user menu to the Readout GUI</title>
            <programlisting>
package require ReadoutGUIPanel
...
set menu [ReadoutGuiPanel::addUserMenu mymenu {Special Data Source}]
$menu add command -label {Source FPGA} -command mydatasource::boot
$menu add command -label {Set FPA parameters} -command mydatasource::setParameters

...
##
# Establish the existence of the ::mydatasource Namespace.
#
namespace eval ::mydatasource {

}

##
# ::mydatasource::boot
#
#    Load fpga firmware.  This proc might further prompt for a firmware
#    file and the interact with a data source to do the firmware load.
#
proc ::mydatasource::boot {} {
...
}
##
#  setParameters
#
#   set fpag fimrware parameters.  This proc might prompt for the
#   firmware settable parameters and then interact with some data source
#   provider to set the firmware parameters.
#
proc ::mydatasource::setParameters {} {
...
}
            </programlisting>
           </example>
        </refsect1>

      </refentry>
      <refentry id="rdogui3-addUserFrame">
        <refmeta>
           <refentrytitle>addUserFrame</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>addUserFrame</refname>
           <refpurpose>Add a frame to the Readout Gui for user controls/displays</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require ReadoutGUIPanel
          </command>
              <command>
<replaceable>set frame [</replaceable>ReadoutGUIPanel::addUserFrame <replaceable>ident]</replaceable>
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Adds a frame to the bottom of the panel
              (you can add as many user frames as you want).
              By frame we mean a Tk frame widget.
              <replaceable>ident</replaceable>
              is the last element of the frame's widget
              path. The full path will be returned.
          </para>
          <para>
              At this time, the frame will span the width
              of the Readout GUI toplevel widget. Once
              you have created this frame you can stock
              it with whatever widgets you want. 
        </para>
        </refsect1>
        <refsect1>
           <title>
              EXAMPLES
           </title>
            <example>
               <title>Adding and populating a Readout GUI user frame</title>
               <programlisting>
package require ReadoutGUIPanel
...
set frame [ReadoutGUIPanel::addUserFrame myframe]
button $frame.load -text {Load Micro} -command ::myframe::load
grid $frame.load
grid $frame
...
namespace eval ::myframe {

}
...
##
# Handle my frame's load micro button.
#
proc ::myframe::load {} {
...
}
               </programlisting>
            </example>
        </refsect1>
      </refentry>

      <refentry id="rdogui3-getSourceCount">
        <refmeta>
           <refentrytitle>getSourceCount</refentrytitle>
           <manvolnum>3rdogui</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>getSourceCount</refname>
           <refpurpose>Get number of data sources</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package provide Experiment
          </command>
              <command>
<replaceable>set sourceCount [</replaceable>Experiment::getSourceCount<replaceable>]</replaceable>
              </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Returns the number of event sources that have been defined.
           </para>
        </refsect1>

      </refentry>


<!-- /manpage -->

<!-- manpage 1daq -->
      <refentry id="manpage_readoutshell">
        <refmeta>
           <refentrytitle id="manpage_readoutshell_title">Readout Gui</refentrytitle>
           <manvolnum>1daq</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ReadoutShell</refname>
           <refpurpose>Encapsulate data sources in a graphical user interface</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
$DAQROOT/bin/ReadoutShell <optional><option>-host</option>=<replaceable>readout-host</replaceable></optional>
<optional><option>-path</option>=<replaceable>readout-program-path</replaceable></optional>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                Starts the readout GUI. All of the options on the command line are optional.
                If they are omitted, the program first attempts to fetch them from the
                configuration (see the section Configuration files and environment variables
                below for more information about configuration). If the required information
                cannot be retrieved from the configuration, dialogs will be launched to prompt
                for the host and readout path.
            </para>
            <para>
                The NSCL Data acquisition system uses a specific file directory
                tree to associate event data and any other data that may be
                germane to the run. The ReadoutGUI on startup creates this
                directory structure and enforces it during its operation.
            </para>
            <para>
                The ReadouGui on startup attempts to launch the readout program
                specified on the command line, in the configuration or via
                prompts to the user on the host system specified in the same
                way. It reports unexpected Readout program exits via a dialog
                box to the user.
           </para>
        </refsect1>

        <refsect1>
            <title>FILES</title>
            <para>
                Several files are read written to maintain both the
                static configuration (not changing from run to run) and the
                last known dynamic configuration (changing from run to run).
                Every effort is made to preserve state so that if you start
                the Readout GUI again after it has exited normally or abnomrally,
                it will return to the state it was when it exited.
            </para>
            <variablelist>
                <varlistentry>
                    <term><filename>~/stagearea/.readoutconfig</filename></term>
                    <listitem>
                        <para>
                            Contains state data for both static and dynamic
                            state.  This is rewritten as dynamic stat is modified.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>.daqconfig</filename></term>
                    <listitem>
                        <para>
                            This file is loaded both from the home directory ansd
                            from your current working directory.  It allows
                            you to finely tune the startup static state of the
                            readout gui.  See CONFIGURATION below for more
                            information about what can be put in this file.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>ReadoutCallouts.tcl</filename></term>
                    <listitem>
                        <para>
                            This file is loaded from the home directory,
                            the experiment view's <filename>current</filename>
                            directory and the current working directory.
                            See EXTENSION hooks below for more information
                            about what this file can contain.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>CONFIGURATION</title>
            <para>
                The ReadoutGUI has many configuration parameters, although
                normally the default values are suitable for your use.
                The program gets configuration from a combination of
                configuration files, environment variables and default values.
                See FILES above for the set of configuration files.
            </para>
            <para>
                The section below describes the configuration parameters,
                where appropriate the corresponding environment variables and
                the precedence.
            </para>
            <segmentedlist>
                <segtitle>Configuration Parameter</segtitle>
                <segtitle>Environment Variable</segtitle>
                <segtitle>Precedence</segtitle>
                <segtitle>Description</segtitle>
                <seglistitem>
                    <seg>SourceHost</seg>
                    <seg>DAQHOST</seg>
                    <seg>Command line, Environment variable, config files.</seg>
                    <seg>Provides the host in which the readout software is run.
                        This also determines the URL that will be generated to
                        describe to the clients Readout GUI runs where data
                        comes from.
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>ReadoutPath</seg>
                    <seg>RDOFILE</seg>
                    <seg>Command line, Environment variable, config files.</seg>
                    <seg>Absolute path to the Readout program.</seg>
                </seglistitem>
                <seglistitem>
                    <seg>StageArea</seg>
                    <seg>EVENTS</seg>
                    <seg>Environment, Config File</seg>
                    <seg>The root directory of the event data. This normally
                         defaults to <filename>~/stagearea</filename>.</seg>
                </seglistitem>
                <seglistitem>
                    <seg>Experiment</seg>
                    <seg>EXPDIR</seg>
                    <seg>Environment, config</seg>
                    <seg>The root of the directory where the run data are stored.
                    This defaults to <filename>~/experiment which,</filename>
                    if it does not initially exist is linked symbolically to
                    <filename>$StageArea/experiment</filename>
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>RunTitle</seg>
                    <seg>EXPTITLE</seg>
                    <seg>Config File, Environment</seg>
                    <seg>Title of the run.  This is normally only useful
                    to provide an initial title as it is overidden by any
                    changes the user makes in the GUI.
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>RunNumber</seg>
                    <seg>N/A</seg>
                    <seg>Gui, Config file</seg>
                    <seg>The run number of the current run if the run is active,
                    or the next run if the run is idle.</seg>
                </seglistitem>
                <seglistitem>
                    <seg>ScalerCount</seg>
                    <seg>SCALERS</seg>
                    <seg>GUI, Configuration file, Environment</seg>
                    <seg>Value set to the Readout's <varname>scalers</varname>
                    variable prior to starting run initialization.  This can be,
                    but need not be, used by the Readout program to determine how
                    many scaler channels are expected. Whether and how it is used
                    is entirely up tot he application developer(s).
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>ScalerInterval</seg>
                    <seg>SCALERINTERVAL</seg>
                    <seg>Gui, Config file, Environment</seg>
                    <seg>Determines the value set in the Readout program's
                    <varname>frequency</varname> variable prior to run initiaization.
                    This can be but need not be used to set the period of the
                    scaler readout trigger.  Whether and how it is used
                    is entirely  up to the application developer(s).
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>Recording</seg>
                    <seg>N/A</seg>
                    <seg>GUI, Config file</seg>
                    <seg>If the run is active,this non zero when event data
                    are being recorded. When the run is not active, this
                    variable reflects whether or not the next run will record
                    event data.</seg>
                </seglistitem>
                <seglistitem>
                    <seg>Timed</seg>
                    <seg> N/A</seg>
                    <seg>Gui, Config file</seg>
                    <seg>Reflects whether or not this run (or the next run if
                    idle) will be a timed run</seg>
                </seglistitem>
                <seglistitem>
                    <seg>TimedLength</seg>
                    <seg>N/A</seg>
                    <seg>Gui, Config file</seg>
                    <seg>If the configuration/state parameter <varname>Timed</varname>
                    is true, this variable is the number of seconds for which a
                    timed run should take data.</seg>
                </seglistitem>
            </segmentedlist>
        </refsect1>
        <refsect1>
            <title>EXTENSION HOOKS</title>
            <para>
                The Readout GUI can be extended by user supplied scripts.
                How to provide an extension script is described in
                FILES under the description of <filename>ReadoutCallouts.tcl</filename>.
                This section describes the callbacks ReadoutGUI makes to any
                extension that defines them and the API available to those
                scripts (see Programmatic Inteface below).
            </para>
            <para>
                In addition to executing arbitrary Tcl code at the global level
                when it is loaded, <filename>ReadoutCallouts.tcl</filename> can
                provide <command>proc</command>s that are called at well defined
                points in the execution of the Readout GUI.
            </para>
            <para>
                The callbacks the set of <filename>ReadoutCallouts</filename> can
                provide are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>OnStart</command></term>
                    <listitem>
                        <para>
                            Called when the readout program is started up.
                            At the time this is called, the Readout program
                            may not be sufficiently initialized to accept
                            commands.  if your script feeds commands you might
                            want to insert a short delay prior to doing this.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnBegin</command></term>
                    <listitem>
                        <para>
                            This proc is called just after the run has been
                            started. It is passed the run number of the run
                            that has just started. By the time <command>OnBegin</command>
                            is called, the Event Logging program (if recording
                            is enabled) is ready to run. The Readout program has
                            not yet, however, been told to start the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnEnd</command></term>
                    <listitem>
                        <para>
                           Called just after a run has ended. The Readout program
                           has been asked to end however it is not known yet
                           that the readout program has actually sent its end
                           of run buffer to the event distribution system.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnPause</command></term>
                    <listitem>
                        <para>
                            Called when a data taking run is being paused. This
                            is called at an analagous time to the OnEnd call.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnResume</command></term>
                    <listitem>
                        <para>
                            Called when a data taking run is being resumed.
                            This is called at an analgous time to the OnBegin
                            function.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <refsect2>
                <title>Programmatic Interface</title>
                <para>
                    Readout GUI extension scripts can also interact with well
                    defined interfaces to the Readout GUI.
                    This section describes those interfaces.
                </para>
                <para>
                    The Readout GUI is segmented into several packages.  Each
                    package is implemented as a Tcl package and you should use
                    <command>package require</command> to ensure the package is
                    loaded prior to invoking <command>proc</command>s from the
                    package.
                </para>
            </refsect2>
        </refsect1>
      </refentry>

<!-- /manpage -->