<!-- Chapter Libraries -->

<chapter>
    <title>
        Event builder client API
    </title>
    <para>
        The NSCL Event builder is made of of two distinct stages.  These
        stages:
        <orderedlist>
            <listitem>
                <para>
                    A fragment orderer which accepts chunks of event,
                    or <firstterm>fragments</firstterm> from the data sources
                    and produces as output fragments that are ordered
                    by timestamps that are associated with the fragments.
                </para>
            </listitem>
            <listitem>
                <para>
                    A builder stage that clumps event fragments with timestamps
                    that are within a coincidence window into events.
                </para>
            </listitem>
        </orderedlist>
    </para>
    <section>
        <title>C++ Client API</title>
        <para>
            This section provides tutorial information that describes the
            client C++ API to the event orderer/builder.
            <link linkend='daq3-eventorder' endterm='daq3-ceventorder-title' />
            provides reference material for the class we are discussing here.
        </para>
        <para>
            The interface is encapsulated in a single class named
            <classname>CEventOrderClient</classname>.  In the remainder of this
            chapter we will describe:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='evb-using-client'>Making <classname>CEventOrderClient</classname> available
                within your program.</link>
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='evb-connecting'>
                    How to form a connection with the event orderer.
                    </link>
                </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Incorporating the event builder client library</title>
            <para>
                Incorporating event builder client software in your program requires
                that you <literal>#include</literal> the event builder client
                header in source files that use <classname>CEventOrderClient</classname>.
                You must also:
                <itemizedlist>
                    <listitem>
                        <para>
                            Provide the appropriate <literal>-I</literal> switch so
                            that your compilations will locate the header.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Provide the appropriate linker switches so that your
                            program will link with the event builder client libraries
                            and so that the Linux dynamic loader can locate them
                            at run-time.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                As we have done throughout this manual, assume that <literal>DAQROOT</literal>
                is an environment variable that points to the root directory of the
                NSCLDAQ installation.
            </para>
            <para>
                The header for the event builder is named after the class as usual.
                Your source files will need a line like:
            </para>
            <informalexample>
                <programlisting>
    #include &lt;CEventOrderClient.h&gt;
                </programlisting>
            </informalexample>
            <para>
                To locate this, your compilations will need to specify
                <literal>-I$DAQROOT/include</literal>
            </para>
            <para>
                At link time you need to specify three switches:
                <literal>-L$DAQROOT/lib -lEventBuilder -Wl,"-rpath=$DAQROOT/lib"</literal>.
                The first of these adds the NSCLDAQ library directory to the linker
                library search path.  The second requests that
                <filename>libEventBuilder.so</filename> be searched to resolve
                undefined symbols.  The last adds the NSCLDAQ library to the list
                of libraries searched for loadable libraries when the program
                starts.
            </para>
            <para>
                If in fact you did define an environment variables DAQROOT, and this
                is used within a Makefile you should use
                <literal>$(DAQROOT)</literal> wherever <literal>$DAQROOT</literal>
                is used above.
            </para>
        </section>
        <section>
            <title>Connecting to the event builder.</title>
            <para>
                The code below shows how to connect to the event builder as
                a client:
            </para>
            <example>
                <title>
                    Connecting to the event builder as a data source.
                </title>
                <programlisting>
    #include &lt;CEventOrderClient&gt;                     <co id='evbc-connect-include' />
    ...
    std::string eventBuilderHost;                          <co id='evbc-connect-hostname' />
    ...
    unsigned int evbPort;                                  <co id='evbc-connect-getport' />
    try {
        evbPort = CEventOrderClient::Lookup(eventBuilderHost);
    }
    catch (CErrnoException&amp; e) {                      <co id='evbc-connect-lookuperr' />
    ...
    }
    
    CEventOrderClient evb(eventBuilderHost, evbPort);    <co id='evbc-connect-create' />
    try {
        evb.Connect();                                   <co id='evbc-connect-connect' />
    }
    catch (CErrnoException&amp; e) {                     <co id='evbc-connect-connecterr' />
    ...
    }
                </programlisting>            
            </example>
            <calloutlist>
                <callout arearefs='evbc-connect-include'>
                    <para>
                        As previously described, this <literal>#include</literal>
                        is required to define the client class.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-hostname'>
                    <para>
                        To connect to the event builder you will need to know
                        the host on which it was started.  For the sake of this
                        example, assume thie variable will be filled in later on
                        with the correct hostname.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-getport'>
                    <para>
                        This segment of code looks up the TCP/IP port
                        on which the event builder is listening for connections.
                        The event builder
                        obtains a service port via the NSCLDAQ Port manager.
                        The port manager, in turn, advertises the event buuilder service.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-lookuperr'>
                    <para>
                        If the port cannot be looked up an exception is thrown.
                        Normally you would fill in some error reporting code here.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-create'>
                    <para>
                        The connection to the event builder will be encapsulated
                        in a <classname>CEventOrderClient</classname> therefore
                        one of these is created.  Note that this does
                        <emphasis>not</emphasis> connect to the event builder.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-connect'>
                    <para>
                        The <methodname>Connect</methodname> method actually attempts
                        to perform the connection to the event builder.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-connecterr'>
                    <para>
                        As with <methodname>Lookup</methodname> an exception is
                        thrown if the connection could not be established.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Disconnecting from the event builder.</title>
            <para>
                The event builder defines a 'clean' disconnect protocol.  If the
                the client simply closes the socket without following this protocol,
                the event builder can consider this an abnormal client termination
                and report an alarm.
            </para>
            <para>
                The disconnect protocol is initiated by either
            </para>
            <itemizedlist>
                <listitem><para>
                    Destroying a connected <classname>CEventOrderClient</classname>
                    object or
                    </para></listitem>
                <listitem><para>
                    Invoking the <methodname>destroy</methodname> method on a
                    connected <classname>CEventOrderClient</classname> object.
                    </para></listitem>
            </itemizedlist>
            <para>
                The code snippet below illustrates the first of these methods.
                <varname>*pEvb</varname> is a pointer to a dynamically allocated
                connected
                <classname>CEventOrderClient</classname> at the start of the
                snippet.
            </para>
            <example>
                <title>Closing an event builder connection</title>
                <programlisting>
delete *pEvb;
                </programlisting>
            </example>
    </section>
    <section>
        <title>Sending data to the event builder.</title>
        <para>
            The event builder allows you to send <firstterm>chains</firstterm> of
            event fragments to it.  A chain is essentially a linked list of
            event fragments.  Each fragment itself consists of a
            header and a body. These data structures are all described in the
            <filename>&lt;fragment.h&gt;</filename> header file.
        </para>
        <para>
            The Event builder client API in turn contains several utilities
            that allow you to send data to the event builder from any of several
            internal representatinos.  In all cases these representations are
            converted to a chain which is then sent to the event builder.
        </para>
        <para>
            Regardless of the representation you choose, you will need
            to fill in the contents of each fragment header.  This data structure
            contains the following fields.
        </para>
        <variablelist>
            <varlistentry>
                <term><fieldsynopsis><type>uint64_t</type> <varname>s_timestamp</varname></fieldsynopsis></term>
                <listitem>
                    <para>
                        Each event must have an extracted timestamp. The
                        first stage of the event builder does an absolute
                        total time ordering of all input fragments by increasing
                        timestamp.
                    </para>
                    <para>
                        The timestamp must be synchronized between
                        all data sources to a high degree of accuracy if this
                        total ordering is going to represent a true time
                        ordering of fragments, since the second stage of the
                        event builder builds events by matching fragments that
                        live within a coincidence window.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><fieldsynopsis><type>uint32_t</type> <varname>s_sourceId</varname></fieldsynopsis></term>
                <listitem>
                    <para>
                        Each data source has a unique id chosen by the source
                        itself.  Furthermore, each client can represent several
                        data sources (all sourcdes system wide must be unique).
                        This field contains the source id that corresponds to the
                        fragment data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><fieldsynopsis>uint32_t</fieldsynopsis> <varname>s_size</varname></term>
                <listitem>
                    <para>
                        Contains the size of the fragment payload in bytes.
                        this size does not include the size of this fragment
                        header.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The <filename>&lt;fragment.h&gt;</filename> header also defines
            a <type>Fragment</type> type which contains
            the fields <varname>s_header</varname> which is a a
            <type>FragmentHeader</type> and a
            <fieldsynopsis><type>void*</type> <varname>s_pBody</varname></fieldsynopsis>
            which is a pointer to the body of the event described by
            <varname>s_header</varname>.
        </para>
        <para>
            Finally the <type>FragmentChain</type> contains the fields
            <varname>s_pNext</varname> which is a
            <type>pFragmentChain</type> and points to the next item in the
            chain, and <varname>s_pFragment</varname> which points to a single
            fragment. The last item in the chain has a
            <varname>s_pNext</varname> that is a null pointer.  Fragment chains
            are required to be in timestamp order by event source. 
        </para>
        <para>
            Several overloaded <methodname>submitFragments</methodname> are
            defined in the <classname>CEventOrderClient</classname> class:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
                        <methodparam><type>pFragmentChain</type>
                            <parameter>pChain</parameter></methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>pChain</parameter> is a pointer to the first
                        element of the fragment chain that will be sent to the
                        event builder
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis><type>void</type> <methodnanme>submitFragments</methodnanme>
                    <methodparam><type>size_t</type> <parameter>nFragments</parameter></methodparam>
                    <methodparam><type>pFragment</type> <parameter>ppFragments</parameter></methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>nFragmnents</parameter> is the number of
                        fragments to submit while <parameter>ppFragments</parameter>
                        is a pointer to the first element of an array
                        of <type>Fragment</type>s.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
                    <methodparam><type>FragmentPointerList</type> <parameter>fragments</parameter></methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>fragments</parameter> is an STL <type>list</type>
                        whose elements are <type>pFragment</type>, pointers to
                        <type>Fragment</type>s.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
    </section>
    <section>
        <title>The Event orderer/event builder API</title>
        <para>
            The event builder itself is a loadable Tcl package rather than
            a program.  This allows experiment designers to:
            <itemizedlist>
                <listitem><para>
                    Provide application dependent user interfaces on top of
                    and around those provided by the event builder.
                    </para></listitem>
                <listitem><para>
                    Tailor the operation of the event builder to meet application
                    specific requirements.
                    </para></listitem>
            </itemizedlist>
        </para>
        <section>
            <title>Starting the event builder/orderer</title>
            <para>
                The example below is a Tcl script fragment that shows
                how to start the event builder. The code assumes that the
                environment variable DAQROOT has been set to the
                top installation directory of the NSCLDAQ being used
                (version 10.2 or later).
            </para>
            <example>
                <title>Starting the event builder</title>
                <programlisting>
lappend auto_path [file join $::env(DAQROOT) TclLibs]   <co id='evb_start_ap' />
package require EventBuilder        <co id='evb_start_require' />

EVB::Start                          <co id='evb_start_start' />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='evb_start_ap'>
                    <para>
                        Adds the Tcl Library directory of the NSCLDAQ to the
                        list of directories searched for packages.  This could
                        also have been done by defining the
                        <literal>TCLLIBS</literal> environment variable.
                        <literal>TCLLIBS</literal> is a space separated list
                        of directories trees that will be added to
                        <varname>auto_path</varname> when
                        <application>tclsh</application> or
                        <application>wish</application> starts.
                    </para>
                </callout>
                <callout arearefs='evb_start_require'>
                    <para>
                        Loads the event builder Tcl package. This package defines
                        the <literal>::EVB::</literal> namespace.  The event
                        builder API lives in this namespace to prevent name
                        conflicts with your application variables and procs.
                    </para>
                </callout>
                <callout arearefs='evb_start_start' >
                    <para>
                        Starts the event builder.  The event builder will use
                        the DAQ Port manager to allocate a Tcp/IP server
                        port as well as to advertise itself to potential
                        clients.
                    </para>
                    <para>
                        When this proc has returned, the event builder is listening
                        for connections on that port and the client library will
                        be able to find the event builder.
                    </para>
                    <para>
                        This proc must be called prior to any other
                        procs in the <literal>EVB::</literal> namespace.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Callbacks</title>
            <para>
                The event builder supports wide variety of callbacks that allow
                user code to intervene when meaningful events occur.  This
                section describes these callbacks and how to set them up.
            </para>
            <section>
                <title>Connection callbacks</title>
                <para>
                    The connection callback invokes user code when a new client
                    has connected to the event builder as a source of event
                    fragments.
                </para>
                <para>
                    When you write the callback, keep in mind that the
                    script you provide will have the host and client
                    description appended to it.  This implies that
                    most event builder connection callbacks wil be
                    <command>proc</command>s
                </para>
                <example>
                    <title>Establishing the connection callback</title>
                    <programlisting>

proc Connection  {host description}  {          <co id="evb_connection_cb" />
    puts "$host just connected: $description"
}

EVB::setConnectionCallback Connection          <co id="evb_connection_cb_establish" />

                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs="evb_connection_cb">
                        <para>
                            This is a sample connection callback proc.  All it
                            does is output information about the connection
                            that was just processed.
                        </para>
                    </callout>
                    <callout arearefs='evb_connection_cb_establish'>
                        <para>
                            The connection callback is established using the
                            <function>EVB::setConnectionCallback</function>
                            procecedure.
                        </para>
                        <para>
                            Note that <function>EVB:Start</function> must have been
                            called prior to this cvall.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>Establishing the disconnect callback</title>
                <para>
                    The disconnect callback is invoked when a data source disconnects.
                    The callback is invoked for both normal and abnormal
                    disconnects (there is a disconnect protocol prior to closing
                    the link if the link closes without that protocol being followed,
                    it is considered an abnormal disconnect).
                </para>
                <para>
                    The disconnect callback is passed the host and description of the
                    source that has disconnected.
                </para>
                <example>
                    <title>Setting up the disconnect callback</title>
                    <programlisting>
proc disconnect {host description} {                    <co id='evb_disconnect_cb' />
    puts "$description disconnected ($host)"
}

EVB::setDisconnectCallback disconnect                   <co id='evb_disconnect_cb_establish' />
                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='evb_disconnect_cb'>
                        <para>
                            This is a simple sample disconnecdt callback.
                            It just prints information about the disconnect
                            on stdout.
                        </para>
                    </callout>
                    <callout arearefs='evb_disconnect_cb_establish'>
                        <para>
                            This call establishes the callback.  Note that
                            prior to invoking this command,
                            <function>EVT::Start</function> must have been
                            called.
                        </para>
                    </callout>
                </calloutlist>
        </section>
    </section>
</chapter>


<!-- manpage 3daq -->
<refentry id="daq3-ceventorder">
<refmeta>
 <refentrytitle id="daq3-ceventorder-title">CEventOrderClient</refentrytitle>
 <manvolnum>3daq</manvolnum>
</refmeta>
<refnamediv>
 <refname>CEventOrderClient</refname>
 <refpurpose>Client of the event orderer</refpurpose>
</refnamediv>

<refsynopsisdiv>

   <synopsis>
#include &lt;CEventOrderClient.h&gt;
#include &lt;fragment.h&gt;

class   <ooclass><classname>CEventOrderClient</classname></ooclass> {
  <constructorsynopsis>
 <methodname>CEventOrderClient</methodname>
 <methodparam><type>std::string</type> <parameter>node-name</parameter></methodparam>
 <methodparam><type>unsigned int</type> <parameter>port</parameter></methodparam>
  </constructorsynopsis>
  <methodsynopsis>
 <type>void</type>
    <methodname>Connect</methodname>
    <methodparam>
        <type>std::string</type><parameter>description</parameter>
    </methodparam>
    <exceptionname>CErrnoException</exceptionname>
  </methodsynopsis>
  <methodsynopsis>
    <type>void</type><methodname>disconnect</methodname>
    <void />
  </methodsynopsis>
    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
        <methodparam><type>pFragmentChain</type>
            <parameter>pChain</parameter></methodparam>
    </methodsynopsis>
    <methodsynopsis><type>void</type> <methodnanme>submitFragments</methodnanme>
    <methodparam><type>size_t</type> <parameter>nFragments</parameter></methodparam>
    <methodparam><type>pFragment</type> <parameter>ppFragments</parameter></methodparam>
    </methodsynopsis>
    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
    <methodparam><type>FragmentPointerList</type> <parameter>fragments</parameter></methodparam>
    </methodsynopsis>
     
  <methodsynopsis>
    <modifier>static</modifier>
    <type>int</type>
    <methodname>Lookup</methodname>
    <methodparam>
        <type>std::string</type><parameter>host</parameter>
    </methodparam>
  </methodsynopsis>
  <exceptionname>
    CErrnoException
  </exceptionname>
  
};
   </synopsis>
</refsynopsisdiv>
<refsect1>
 <title>DESCRIPTION</title>
 <para>
    Provides the client API to the event fragment orderer component of the
    event builder.  The normal operation sequence would be to use the
    <methodname>Lookup</methodname> static method to locate the event builder
    server port, create a <classname>CEventOrderClient</classname> instance
    and invoke <methodname>Connect</methodname> to connect to the event
    builder.
 </para>
 <para>
    Once connected, <methodname>submitFragments</methodname> would be used to send data to the
    server until it's time to disconnect at which time
    the connection is dropped either by destroying the object or by
    calling the <methodname>Disconnect</methodname> method.
 </para>
</refsect1>
<refsect1>
 <title>
METHODS
 </title>
 <variablelist>
    <varlistentry>
        <term>
            <constructorsynopsis>
                <methodname>CEventOrderClient</methodname>
                <methodparam><type>std::string</type> <parameter>node-name</parameter></methodparam>
                <methodparam><type>unsigned int</type> <parameter>port</parameter></methodparam>
            </constructorsynopsis>
        </term>
        <listitem>
            <para>
                Constructs an instance of an event order client object.
                The <parameter>node-name</parameter>
                and <parameter>port</parameter> define the Tcp/IP
                of the connection that will be made with the event builder.
            </para>
            <para>
                The connection is not actually made until the
                <methodname>Connect</methodname> method is invoked
                (see below).
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
              <type>void</type><methodname>disconnect</methodname>
              <void />
            </methodsynopsis>
        </term>
        <listitem>
            <para>
                Disconnect a connected client object.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>int</type>
                <methodname>Lookup</methodname>
                <methodparam>
                    <type>std::string</type><parameter>host</parameter>
                </methodparam>
              </methodsynopsis>
              <exceptionname>
                CErrnoException
              </exceptionname>
        </term>
        <listitem>
            <para>
                Attempts to look up the port on which an event builder for the
                current user is running.  This is done by contacting the
                NSCL port manager on the specified <parameter>host</parameter>.
            </para>
            <para>
                On failure, a <classname>CErrnoException</classname> is thrown
                which will describe the reason and context of the error.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
            <type>void</type>
               <methodname>Connect</methodname>
               <methodparam>
                   <type>std::string</type><parameter>description</parameter>
               </methodparam>
               <exceptionname>CErrnoException</exceptionname>
             </methodsynopsis>
        </term>
        <listitem>
            <para>
                Attempts to connect to the event builder described
                by the constructor parameters.
                <parameter>description</parameter> will be passed to the
                event builder as a description of the event source.
                The description will be used on the event builder GUI.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
         <term>
             <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
                 <methodparam><type>pFragmentChain</type>
                     <parameter>pChain</parameter></methodparam>
             </methodsynopsis>
         </term>
         <listitem>
             <para>
                 <parameter>pChain</parameter> is a pointer to the first
                 element of the fragment chain that will be sent to the
                 event builder
             </para>
         </listitem>
     </varlistentry>
     <varlistentry>
         <term>
             <methodsynopsis><type>void</type> <methodnanme>submitFragments</methodnanme>
             <methodparam><type>size_t</type> <parameter>nFragments</parameter></methodparam>
             <methodparam><type>pFragment</type> <parameter>ppFragments</parameter></methodparam>
             </methodsynopsis>
         </term>
         <listitem>
             <para>
                 <parameter>nFragmnents</parameter> is the number of
                 fragments to submit while <parameter>ppFragments</parameter>
                 is a pointer to the first element of an array
                 of <type>Fragment</type>s.
             </para>
         </listitem>
     </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
    <title>DATA STRUCTURES</title>
    <para>
        The <filename>fragment.h</filename> header defines several event
        fragment related data structures:
    </para>
    <para>
        The <type>FragmentHeader</type> data type is the main data type.
        It defines the struct that contains meta-data about an event fragment:
This data structure
            contains the following fields.
    </para>
    <variablelist>
        <varlistentry>
            <term><fieldsynopsis><type>uint64_t</type> <varname>s_timestamp</varname></fieldsynopsis></term>
            <listitem>
                <para>
                    Each event must have an extracted timestamp. The
                    first stage of the event builder does an absolute
                    total time ordering of all input fragments by increasing
                    timestamp.
                </para>
                <para>
                    The timestamp must be synchronized between
                    all data sources to a high degree of accuracy if this
                    total ordering is going to represent a true time
                    ordering of fragments, since the second stage of the
                    event builder builds events by matching fragments that
                    live within a coincidence window.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><fieldsynopsis><type>uint32_t</type> <varname>s_sourceId</varname></fieldsynopsis></term>
            <listitem>
                <para>
                    Each data source has a unique id chosen by the source
                    itself.  Furthermore, each client can represent several
                    data sources (all sourcdes system wide must be unique).
                    This field contains the source id that corresponds to the
                    fragment data.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><fieldsynopsis>uint32_t</fieldsynopsis> <varname>s_size</varname></term>
            <listitem>
                <para>
                    Contains the size of the fragment payload in bytes.
                    this size does not include the size of this fragment
                    header.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        The <filename>&lt;fragment.h&gt;</filename> header also defines
        a <type>Fragment</type> type which contains
        the fields <varname>s_header</varname> which is a a
        <type>FragmentHeader</type> and a
        <fieldsynopsis><type>void*</type> <varname>s_pBody</varname></fieldsynopsis>
        which is a pointer to the body of the event described by
        <varname>s_header</varname>.
    </para>
    <para>
        Finally the <type>FragmentChain</type> contains the fields
        <varname>s_pNext</varname> which is a
        <type>pFragmentChain</type> and points to the next item in the
        chain, and <varname>s_pFragment</varname> which points to a single
        fragment. The last item in the chain has a
        <varname>s_pNext</varname> that is a null pointer.  Fragment chains
        are required to be in timestamp order by event source. 
    </para>
</refsect1>
<refsect1>
    <title>EXCEPTIONS</title>
    <para>
        The following exception types can be thrown:
    </para>
    <variablelist>
        <varlistentry>
            <term>CErrnoException</term>
            <listitem>
                <para>
                    Reports Linux system service errors.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
 </refsect1>
</refentry>     
