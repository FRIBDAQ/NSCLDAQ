<!-- chapter libraries -->

<chapter id="chapter.ringformat">
    <title>Format of Event Data In Ring Buffers</title>
    <para>
        The NSCL Ring buffer based data distribution scheme ia a very flexible
        data distribution scheme that makes no restrictions on the format
        of the data it transmits.  This section describes the format of data
        that is placed in the ring buffer by NSCL DAQ readout software.
        These data are formatted in a consistent way so that consumer programs
        know what to expect and so that library functions can (and have been) be
        written that can select specific data record types in specific ways from
        the data stream.
    </para>
    <para>
        This chapter is divided into these sections:
        <itemizedlist>
            <listitem>
                <para>
                    A description of the data records that will be put in
                    ring buffers, and how to incorporate definitions of these
                    structures in your software.
                </para>
            </listitem>
            <listitem>
                <para>
                    A description of the mechanisms that are available to selectively
                    get data from ring buffers.
                </para>
            </listitem>
            <listitem>
                <para>
                    A description of the class library that helps you build and
                    decode items in the ring buffer in the format described in
                    this chapter.
                </para>
            </listitem>
            <listitem>
                <para>
                    A description of a simple library that allows you to
                    create ring items that may not wind up being placed in a ring.
                </para>
            </listitem>
        </itemizedlist>
    </para>
    <para>
        Reference material is provided in in the 3daq section that describes the
        class library.
    </para>

    <section>
        <title>The basic data formats</title>
        <para>
            Data placed in the ring buffer consists of 'items'.   Items have a
            header, which has the same shape from item type to item type and
            an item body whose format varies from type to type.
        </para>
        <para>
            The header <filename>DataFormat.h</filename> contains, among other
            things, the <literal>struct</literal> definitions that define
            the shapes of each item.  These structs are given typenames via
            the <literal>typedef</literal> statement.  The remaining
            discussion will use these typenames, rather than the names of the
            underlying structs.            <!-- added in 11.0 -->
            <funcsynopsis>
                <funcprototype><funcdef><type>pScalerItem</type>
                <function>formatNonIncrTSScalerItem</function></funcdef>
                <paramdef>
                    <parameter><type>unsigned</type> scalerCount</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>time_t</type> timestamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> btime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type>  etime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint64_t</type> eventTimestamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>void*</type> pCounters</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> timebaseDivisor</parameter>
                </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                <funcdef><type>pDataFormat</type><function>formatDataFormat</function>
                </funcdef>
                <void />
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef><type>pGlomParameters</type>
                        <function>formatGlomParameters</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> coincidenceWindow</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type>isBuilding</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type>timestampPolicy</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef><type>pEventBuilderFragment</type>
                        <function>formatEVBFragment</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> payloadSize</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const void*</type>
                        pPayload</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef><type>pEventBuilderFragment</type>
                        <function>formatEVBFragmentUnknown</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t timestamp</type></parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> payloadSize</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const void*</type> pPayload</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pPhysicsEventItem</type>
                        <function>formatTimestampedEventItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> payloadSize</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const void*</type> pPayload</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pPhysicsEventCountItem</type>
                        <function>formatTimestampedTriggerCountItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> runTime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> offsetDivisor</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>time_t</type> stamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> triggerCount</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pScalerItem</type>
                        <function>formatTimestampedScalerItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type>timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type> isIncremental</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> timeofday</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> btime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> etime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> nScalers</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>void*</type> pCounters</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pTextItem</type>
                        <function>formatTimestampedTextItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>unsigned</type> nStrings</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>time_t</type> stamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> runTime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const char**</type>pStrings</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type> type</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis> 
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pStateChangeItem</type>
                        <function>formatTimestampedStateChange</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>time_t</type> stamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> offset</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> runNumber</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> offsetDivisor</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const char*</type> pTitle</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type> type</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>void*</type> <function>bodyPointer</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>pRingItem</type> pItem</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>

            <!-- end of 11.0 additions -->

        </para>
        <para>
            The header of each item type is of type <structname>RingItemHeader</structname>
            for convenience, the type <structname>pRingItemHeader</structname> is defined
            to be a pointer to a <structname>RingItemHeader</structname>.  This is a
            common pattern in the <filename>DataFormat.h</filename> header.
        </para>
        <para>
            The header has the following fields:
            <variablelist>
                <varlistentry>
                    <term>uint32_t <structfield>s_size</structfield></term>
                    <listitem>
                        <para>Contains the size of the item in bytes.
                            <structfield>s_size</structfield> should include the
                            size of the header as well
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>uint32_t <structfield>s_type</structfield></term>
                    <listitem>
                        <para>
                            Contains a value that uniquely defines the type of
                            datain the item.  While this is a 32 bit field,
                            the actual type values a 16 bits wide, with the
                            remaining 16 bit set to zero.  This allows consumer
                            software to detect byte order differences between
                            systems that generate the data and consumer systems.
                        </para>
                        <para>
                            The NSCL DAQ reserves types 1 through 32767
                            for itself.  Type 0 is illegal, as it's byte order
                            is indeterminate.  Types
                            37678 through 65535 are available for user applications.
                            The constant <varname>FIRST_USER_ITEM_CODE</varname>
                            provides the symbolic value for the first item code
                            available for user applications.
                        </para>
                        <para>
                            The NSCL DAQ is currently using the following
                            item codes, defined in the <filename>DataFormat.h</filename>
                            header:
                        </para>
                        <variablelist>
                            <varlistentry>
                            <term><varname>BEGIN_RUN</varname></term>
                            <listitem>
                                <para>
                                    The item describes the beginning of a data
                                    taking run.
                                </para>
                            </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>END_RUN</varname></term>
                                <listitem>
                                    <para>
                                        The item descdribes the end of a data taking
                                        run.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>PAUSE_RUN</varname></term>
                                <listitem>
                                    <para>
                                        The item describes a temporary pause in
                                        data taking.  This item must be followed
                                        immediately by either a
                                        <varname>RESUME_RUN</varname> item,
                                        or an <varname>END_RUN</varname> item.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>RESUME_RUN</varname></term>
                                <listitem>
                                    <para>
                                        This item describes the resumption of
                                        data taking after a temporary pause.
                                        Barring user defined types that may
                                        follow a
                                        <varname>PAUSE_RUN</varname>, this
                                        item will always follow a
                                        <varname>PAUSE_RUN</varname> item.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>PACKET_TYPES</varname></term>
                                <listitem>
                                    <para>
                                        NSCL DAQ readout frameworks can package
                                        chunks of a physics event into packets.
                                        Packets have essentially the same
                                        format as ring buffer items.
                                        The frameworks also support documenting
                                        the packet types that can occur in a
                                        data taking run.  This item supplies that
                                        documentation to interested consumers.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>MONITORED_VARIABLES</varname></term>
                                <listitem>
                                    <para>
                                        Some readout frameworks support the creation
                                        of variables that can monitor external
                                        conditions such as EPICS channels.
                                        This item contains information about the
                                        latest state of a monitored variable.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>PERIODIC_SCALERS</varname></term>
                                <listitem>
                                    <para>
                                        NSCL DAQ readout frameworks support the
                                        periodic readout of counters.  These counters
                                        are called <firstterm>scalers</firstterm> by
                                        the experimental community and are used to
                                        monitor the rates of trigger components,
                                        detector systems, or system live-time.
                                        Data from these are put in
                                        <varname>INCREMENTAL_SCALERS</varname> items.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>RING_FORMAT</varname></term>
                                <listitem>
                                    <para>
                                        Describes the format level of the ring item.
                                        This is described in terms of the earliest
                                        NSCLDAQ major and minor versions that can
                                        transparently handle this data.  Readout
                                        frameworks output this item at the beginning
                                        of each run, prior to the begin run item.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>PHYSICS_EVENT</varname></term>
                                <listitem>
                                    <para>
                                        The purpose of NSCL DAQ readout frameworks,
                                        is to respond to event triggers and read out
                                        digitizer hardware that has captured the data
                                        from a nucleus-nucleus collision.
                                        These data are placed in
                                        <varname>PHYSICS_EVENT</varname> items.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>PHYSICS_EVENT_COUNT</varname></term>
                                <listitem>
                                    <para>
                                        Periodically emitted to tell clients how
                                        many <varname>PHYSICS_EVENT</varname>
                                        items have been inserted in the
                                        ring.  This is can be used to
                                        determine sampling efficiency for
                                        analysis consumers, as well as to
                                        compute event rates.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>EVB_FRAGMENT</varname></term>
                                <listitem>
                                    <para>
                                        An event fragment from the ordering phase of the
                                        event builder.  Fragments of this type
                                        are believed to contain ring items as their
                                        payloads.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>EVB_UNKNOWN_PAYLOAD</varname></term>
                                <listitem>
                                    <para>
                                        Same as <varname>EVB_FRAGMENT</varname>
                                        however it's pretty certain the payload
                                        of these items are not ring items.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><varname>EVB_GLOM_INFO</varname></term>
                                <listitem>
                                    <para>
                                        Emitted by the <application>glom</application>
                                        component of the event builder to
                                        describe the parameters it has been started
                                        with.
                                    </para>
                                    <para>
                                        One of these ring items is emitted
                                        one as glom is started.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </listitem>
                </varlistentry>
            </variablelist>
        </para>
        <para>
            These item types break down in to four distinct categories of
            item which will be described in the remaining subsections of this
            section.
        </para>
        <section>
            <title>State Change Items</title>
            <para>
                State change items are those with types
                <varname>BEGIN_RUN</varname>, <varname>END_RUN</varname>,
                <varname>PAUSE_RUN</varname>, and <varname>RESUME_RUN</varname>.
                As the type names imply, these signal state transitions in
                data taking. 
            </para>
            <para>
                State change items have the type
                <structname>StateChangeItem</structname>.  This item has the
                following fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term>uint32_t <structfield>s_runNumber</structfield></term>
                    <listitem>
                        <para>
                            Is the number of the run for which this state transition
                            is being documented.  Typically, run numbers are
                            unique, for recorded runs, as the run number is encoded
                            into the name of the run's event file.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>uint32_t <structfield>s_timeOffset</structfield></term>
                    <listitem>
                        <para>
                            Is the number of seconds the run has been active prior
                            to this state transition.  Clearly if the type of the
                            item is <varname>BEGIN_RUN</varname> this will be zero.
                            For the NSCLDAQ frameworks, the time offset only
                            counts seconds during which the run was active (time
                            during which the run was paused are not counted).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>uint32_t <structfield>s_Timestamp</structfield></term>
                    <listitem>
                        <para>
                            Is the absolute time at which the transition
                            occured. This is represented in seconds since
                            the Unix epoch of
                            <literal>00:00:00 UTC, January 1, 1970</literal>.
                            Once translated into the host's byte order, it can
                            be passed to any of the time formatting functions
                            (e.g. <function>asctime</function>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>char <structfield>s_title</structfield>[TITLE_MAXSIZE+1]</term>
                    <listitem>
                        <para>
                            Holds the run title.  Run titles are restricted in
                            size to <varname>TITLE_MAXSIZE</varname> characters,
                            with the <literal>+1</literal> to accomodate the
                            trailing <literal>'\0'</literal>.
                            <varname>TITLE_MAXSIZE</varname>
                            is also defined in
                            <filename>DataFormat.h</filename>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                All item types have a field
                <structfield>s_header</structfield> of type
                RingItemHeader that holds the item header.
            </para>
            <para>
                Beginning with NSCLDAQ version 11.0, the ring item body has
                been modified to allow it to include timestamp, event source
                and barrier information either emitted by or intended for the
                event building pipeline.
                This header is either a <type>uint32_t</type> containing zero,
                which indicates there is no header, or a structure of the
                following type:
            </para>
            <programlisting>
typedef struct _BodyHeader {
  uint32_t   s_size;		/* 0 or sizeof(DataSourceHeader) */
  uint64_t   s_timestamp;
  uint32_t   s_sourceId;
  uint32_t   s_barrier;   
} BodyHeader, *pBodyHeader;

            </programlisting>
            <para>
                The fields of this structure are as follows:
            </para>
            <variablelist>
                <varlistentry>
                    <term><varname>s_size</varname></term>
                    <listitem>
                        <para>
                            The size of the header.  This value includes the
                            <varname>s_size</varname> field.  Thus you can also
                            think of items that don't have a body header
                            as having a header size of zero.  We promise to maintain
                            backwards compatility by adding any new elements to the
                            end of the body header.  Thus you can use
                            <varname>s_size</varname> to determine where the
                            body header ends and the structure fields will not
                            move from version to version.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><varname>s_timestamp</varname></term>
                    <listitem>
                        <para>
                            The value of the event/globally synchronized
                            timestamp at the time this ring item was initially
                            formed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><varname>s_sourceId</varname></term>
                    <listitem>
                        <para>
                            Unique identifier of the source of this ring item.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><varname>s_barrier</varname></term>
                    <listitem>
                        <para>
                            If the item was part of a barrier synchronization amongst
                            the data sources, this field will be non-zero and
                            represent the type of the barrier.  If zero, this
                            item was not part of a barrier.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Text List Items</title>
            <para>
                Text list items contain a list of null terminated strings.
                They are usually used to provide metadata for the run.  At present,
                two types of text list items are defined.
                <varname>PACKET_TYPES</varname> and
                <varname>MONITORED_VARIABLES</varname>.
            </para>
            <para>
                <varname>PACKET_TYPES</varname> document the packets you might
                expect to find in a run's <varname>PHYSICS_EVENT</varname> items.
                Creating instances of the
                <classname>CDocumentedPacket</classname> object
                automatically generates these.  Each packet is documented with a
                single string.  The string consists of five colon separated fields.
                These fields contain, in order:
                <orderedlist>
                    <listitem>
                        <para>The Name the packet.</para>
                    </listitem>
                    <listitem>
                        <para>The id of the packet given as a hex string e.g.
                            "0x1234"
                        </para>
                    </listitem>
                    <listitem>
                        <para>A desription of the packet.</para>
                    </listitem>
                    <listitem>
                        <para>A version string for the packet.  Presumably this
                            will change if the packet with this type ever
                            changes 'shape'>
                        </para>
                    </listitem>
                    <listitem>
                        <para>The date and time at which the
                            <classname>CDocumentedPacket</classname> object
                            creating this entry was created.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
            <para>
                <varname>MONITORED_VARIABLES</varname> items contains a snapshot
                of the values of process variables that have been declared
                by the readout software.   Each variable takes up one string and is
                formatted like a Tcl <command>set</command> command that, if executed,
                would define that variable to the value it had when the item was created.
            </para>
            <para>
                String list items have type <structname>TextItem</structname>.
                This item has the following fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term>uint32_t <structfield>s_timeOffset</structfield></term>
                    <listitem>
                        <para>
                            The number of seconds of data taking that have gone on
                            in this run prior to the generation of this item.
                            This time offset does not count time in the paused
                            state.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>uint32_t<structfield>s_timestamp</structfield></term>
                    <listitem>
                        <para>
                            Is the absolute time at which the item was 
                            created. This is represented in seconds since
                            the Unix epoch of
                            <literal>00:00:00 UTC, January 1, 1970</literal>.
                            Once translated into the host's byte order, it can
                            be passed to any of the time formatting functions
                            (e.g. <function>asctime</function>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>uint32_t <structfield>s_stringCount</structfield></term>
                    <listitem>
                        <para>
                            Number of strings in the item.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>char <structfield>s_strings[]</structfield></term>
                    <listitem>
                        <para>
                            An array of characters large enough to hold all
                            the strings.  Each string is a null terminated set
                            of characters immediately followed by the next
                            string.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Scaler Items</title>
            <para>
                NSCLDAQ readout frameworks support periodically reading scaler
                data.  These data are represented as
                <structname>ScalerItem</structname> items in ring buffers.
                These items have the following fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term>uint32_t <structfield>s_intervalStartTime</structfield></term>
                    <listitem>
                        <para>
                            The number of seconds of active data taking prior
                            the start of the time period represented by the counts
                            in this scaler item.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>uint32_t <structfield>s_intervalEndTime</structfield></term>
                    <listitem>
                        <para>
                            The number of seconds of active data taking prior to
                            the end of the time period represented by the counts
                            in this scaler item.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>uint32_t  <structfield>s_timestamp</structfield></term>
                    <listitem>
                        <para>
                            Is the absolute time of the end of the
                            scaler counting period.
                            This is represented in seconds since
                            the Unix epoch of
                            <literal>00:00:00 UTC, January 1, 1970</literal>.
                            Once translated into the host's byte order, it can
                            be passed to any of the time formatting functions
                            (e.g. <function>asctime</function>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>uint32_t <structfield>s_scalerCount</structfield></term>
                    <listitem>
                        <para>
                            The number of scalers in the item.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>uint32_t <structfield>s_scalers</structfield>[]</term>
                    <listitem>
                        <para>
                            The array of scaler counts.  This contains
                            <structfield>s_scalerCount</structfield> elements.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Event Data Items</title>
            <para>
                These items are of type
                <varname>PHYSICS_EVENT</varname>.
                The contain the data read from the hardware.  Depending on the
                readout framework, this can be the response to one trigger or to
                a block of triggers. It is up to the analysis software to know
                which is which.
            </para>
            <para>
                This item is of type <structname>PhysicsEventItem</structname>
                and contains the field
                uint16_t <structfield>s_body</structfield> that is the data
                from the event.
            </para>

        </section>
        <section>
            <title>Event count items</title>
            <para>
                These items are of type <structname>PhysicsEventCountItem</structname>.
                <type>uint32_t</type> <structfield>s_timeOffset</structfield> is
                the number of seconds into the active run the event occured.
                <type>uint32_t</type> <structfield>s_timesamp</structfield>
                is the absolute timestamp indicating when this item was created.
                <type>uint64_t</type> <structfield>s_eventCount</structfield> is
                the total number of events that have been contributed to this
                ring for this run.
            </para>
        </section>
            
    </section>
    
    <section>
        <title>Selecting Data From a Ring Buffer</title>
        <para>
            Many data consumers are not interested in all of the
            item types that could be put in a ring buffer.   This section
            describes the infrastructure for selecting subsets of the data
            from ring buffers that are formatted as described in this chapter.
        </para>
        <para>
            The ring buffer low level access library provides
            two powerful mechanisms for manipulating ring buffers based
            the concept of <firstterm>predicates</firstterm>.
            A predicate is a function that implement the
            <methodname>operator()</methodname> method in a way that it returns
            a <literal>bool</literal>.
            Predicate objects can therefore be thought of as functions that can
            have state that persists between calls.
        </para>
        <para>
            <classname>CRingBuffer</classname> has two member functions
            <methodname>blockWhile</methodname> which periodically
            invokes a predicate until it returns <literal>false</literal>
            blocking for a settable time period between calls, and for a
            maximum timeout.
            <methodname>While</methodname> which simply repeatedly calls
            a predicate until it returns <literal>false</literal>.
            (like <methodname>blockWhile</methodname> but without blocking
            between calls to the predicate.
        </para>
        <para>
            Armed with predicates, these two member functions an an understanding
            that items in the ring will have the item format described in the
            previous section, it is possible to implement a scheme for selectively
            obtaining data from a ring buffer.
        </para>
        <para>
            The base class for this selectivity is
            <classname>CRingSelectionPredicate</classname>
            defined in
            <filename>CRingSelectionPredicate.h</filename>.  It provides
            base classes with the capability of specifying a list of item types
            called a <firstterm>selection  map</firstterm>.  Elements of this
            map consist of an item type and a flag.  The virtual function
            <methodname>selectThis</methodname> is given an item type peeked from
            the ring buffer and returns <literal>false</literal> if the item
            is acceptable.  Unacceptable items are skipped, and true is returned
            so that <methodname>While</methodname> continues to loop.
        </para>
        <para>
            If <methodname>selectThis</methodname> returns true, the framework
            insepcts the type's flag.  If false, the predicate as a whole
            returns true. I false, the predicate skips the item if it is not
            the last one in the ring.
        </para>
        <para>
            Two pre-packaged specific derivations of
            <classname>CRingSelectionPredicate</classname> have been built.
            In
            <classname>CDesiredTypesPredicate</classname>, any type not in the
            list is assumed to be undesirable and skipped.   In
            <classname>CAllButPredicate</classname>, the list of types define
            exceptiosn to the rule that all items are desired without sampling.
            Items in the list with the sample flag false, are assumed to be
            undesirable and are skipped.  items in the list with the sample flag
            true, are assumed to be wanted but only in sample mode.
        </para>
    </section>
    <section>
        <title>Incorporating the headers and libraries into your applications.</title>
        <para>
            NSCL DAQ provides a class library that allows you to encapsulate
            ring buffer data items in objects from which you can get/set data.
            Ring buffer item objects are intended both for producers and consumers
            of data.  See the 3daq section of the reference material for
            detailed per class documentation.
        </para>
        <para>
            Each class has a header file that is named the same as the
            class with a <filename>.h</filename> appended. Thus to incorporate
            the definitions for the
            <classname>CRingItem</classname> base class in your source code you would
            add the line:
        </para>
        <example>
            <title>Including a ring item class </title>
            <programlisting>
#include &lt;CRingItem.h&gt;
            </programlisting>
        </example>
        <para>
            To your source files.
        </para>
        <para>
            At compile time you would need to add a <literal>-I</literal> switch
            to tell the compiler where these headers are.  If the
            environment variable
            <literal>DAQROOT</literal>
            points to the top level of the NSCLDAQ installation tree you might
            do this as shown below:
        </para>
        <example>
            <title>Telling the compiler where to find Ring Item headers</title>
            <screen><command>
g++ -c -I$DAQROOT/include mymodule.cpp
            </command></screen>
        </example>
        <para>
            At link time you need to provide the location of the libraries as
            well as to specify the set of libraries that must be included.
            Note that as the example below shows, normally using the
            data format library implies you will need the data flow library as well:
        </para>
        <example>
            <title>Linking the ring item format libraries</title>
            <screen><command>
g++ -o myApplication src1.o src2.o ... -L$DAQROOT/lib \
        -ldataformat -lDataFlow -Wl,"-rpath=$DAQROOT/lib"
            </command></screen>
        </example>
        <para>
            The following classes manage data formatting:
        </para>
        <variablelist>
            <varlistentry>
                <term><link linkend="manpage.cringitem"><classname>CRingItem</classname></link></term>
                <listitem>
                    <para>
                        Base class for all the ring data item format classes.
                        This class also has the static member
                        <methodname>getFromRing</methodname> which accepts a
                        ring object reference and a
                        <classname>CRingSelectionPredicate</classname> reference,
                        and returns a pointer to the next ring item that matches
                        the predicate's match criteria.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.cringstatechangeitem"><classname>CRingStateChangeItem</classname></link></term>
                <listitem>
                    <para>
                        Represents a state change item.  Given a reference to
                        a <classname>CRingItem</classname> (e.g. one just gotten
                        from <classname>CRingItem</classname>::<methodname>getFromRing</methodname>),
                        one of the constructors constructs an equivalent ring state change object or
                        throws a <classname>std::bad_cast</classname> exception
                        if the item is not a valid state change.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.cringscaleritem"><classname>CRingScalerItem</classname></link></term>
                <listitem>
                    <para>
                        Represents a state change item.  Given a reference to a
                        <classname>CRingItem</classname> one of the constructors
                        can produce a <classname>CRingScalerItem</classname> object
                        or throw a <classname>std::bad_cast</classname> exception
                        if the item was not actually a scaler item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.cringtextitem"><classname>CRingTextItem</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates a text list item.  As with all the above
                        classes, a constructor exists that converts a
                        <classname>CRingItem</classname> to a
                        <classname>CRingTextItem</classname> or throws a
                        <classname>std::bad_cast</classname> if that's not legal.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cglomparameters'>
                    <classname>CGlomParameters</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates the glom parameter ring items.  This ring
                        item describes how the glom component of the event builder
                        pipeline has been started.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cphysicseventitem'>
                    <classname>CPhysicsEventItem</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates the data taken in response to a physics
                        trigger.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cringfragmentitem'>
                    <classname>CRingFragmentItem</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates items produced in the ordering phase of
                        the event builder pipeline.  Items of this type are
                        believed to have other ring items as their payloads.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cringphysicseventcountitem'>
                    <classname>CRingPhysicsEventCountItem</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates an item that gives information about the
                        number of triggers that have been processed by the system
                        (or by a single event source) during the run so far.
                        This both allows software to monitor trigger rates and
                        allows you to determine the percentage of data you are
                        sampling from an online ringbuffer in the event you are
                        sampling data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend='manpage.cunknownfragment'>
                <classname>CUnknownFragment</classname></link></term>
                <listitem>
                    <para>
                        Encapsulates an event fragment produced by the event
                        builder ordering stage for which there's good reason to
                        believe the payload is not a ring item.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <section>
           <title>Generic ring data sources</title>
           <para>
              You may want a program to work equally well when pointed at a 
              ring buffer and when pointed at a file of ring items, such as
              an event file created by the event logger.
           </para>
           <para>
              A set of data source classes and a data source factory allow you
              to easily write program like this.  The key point is that 
              ring data sources are specified by uniform resource identifiers
              (URIs).  The first part of a URI is called the 'protocol' and
              defines how a connection takes place.  For online rings we have
              seen that the protocol is <literal>tcp:</literal>  For offline
              event files, the protocol is <literal>file:</literal>.
            </para>
            <para>
              The data format library provides a generic base class;
              <classname>CDataSource</classname>.   Concrete subclasses include
              <classname>CRingDataSource</classname> and
              <classname>CFileDataSource</classname> provide data sources for
              online rings and offline files respectively.  The factory class
              is <classname>CDataSourceFactory</classname>.
            </para>
            <para>
                The data sources return generic ring items.  These can be
                upcast into specific ring item types by using methods in the
                <classname>CRingItemFactory</classname> class.
            </para>
            <para>
                Reference information on these classes is availabe at:
                <xref linkend="daq3_cdatasource" endterm="daq3_cdatasource_title" />,
                <xref linkend="daq3_cringdatasource" endterm="daq3_cringdatasource_title"  />,
                <xref linkend="daq3_cfiledatasource" endterm="daq3_cfiledatasource_title"  />,
                <xref linkend="daq3_cdatasourcefactory" endterm="daq3_cdatasourcefactory_title"  />,
                and
                <xref linkend="daq3_cringitemfactory" endterm="daq3_cringitemfactory_title"  />.
            </para>
        </section>
    </section>
    <section>
        <title>Creating ring items</title>
        <para>
            There are some cases where the librarires provided to create
            ring items are not well suited for the job. Specifically, sometimes
            you'd like to create ring items to be emitted on <filename>stdout</filename>.
        </para>
        <para>
            A simple set of functions that can be called by either C or C++
            programs allows you to format ring items that can be dealt with
            however you might wish.
        </para>
        <para>
            The functions provided are prototyped in <filename>DataFormat.h</filename>.
            The functions are also part of <filename>libdataformat.so</filename>.
        </para>
        <para>
            The reference section provides full documentation.  All functions
            return a pointer to storage allocated with <function>malloc(3)</function>
            that contains the ring item.  It is the caller's responsibility
            to invoke <function>free(3)</function> to release this storage.
        </para>
        <para>
            The functions defined in <filename>DataFormat.h</filename> are implemented
            in C and the header is written to be usable from both C and C++
            programs.  The functions are divided into two  sets of functions.
            The first set are intended to be used for compatiblity with
            pre nscldaq 11.0 applications.  With the exception of
            <function>formatNonIncrTSScalerItem</function>, which was introduced
            in NSLCDAQ-10.1-100 to support S800 scaler items that provide event
            timestamps, the functions below provide a body header of length
            zero (no body header).
        </para>
        <variablelist>
            <varlistentry>
                <term><function>formatEventItem</function></term>
                <listitem>
                    <para>
                        Formats the data read from a physics trigger into a
                        ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTriggerCountItem</function></term>
                <listitem>
                    <para>
                        Formats a trigger count item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatScalerItem</function></term>
                <listitem>
                    <para>
                        Creates an incremental scaler ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTextItem</function></term>
                <listitem>
                    <para>
                        Formats a text string item.  Text string items are
                        items whose payload contains, among other things,
                        a set of null terminated strings.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatStateChange</function></term>
                <listitem>
                    <para>
                        Creates a state change ring item.  State change
                        ring items indicate that the run state has changed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatNonIncrTSScalerItem</function></term>
                <listitem>
                    <para>
                        This is a convenience function that produces a
                        scaler item that has an event timestamp and has
                        the incremental flag cleared.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The functions that are new since NSCLDAQ-11.0 and, produce fully
            filled out body headers are listed below:
        </para>
        <variablelist>
            <varlistentry>
                <term><function>formatDataFormat</function></term>
                <listitem>
                    <para>
                        Creates a data format item for the format described in
                        the version of <filename>libdataformat.so</filename> your
                        application is <emphasis>linked to</emphasis>.
                        Each ring producer should emit one of these as the first
                        item it produces after attaching to the ring so that
                        consumers know what data format to expect.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatGlomParameters</function></term>
                <listitem>
                    <para>
                        Produces a glom parameters ring itme.  This is normally
                        only called by the <application>glom</application> stage
                        of the event builder pipeline.  If, however you have
                        replaced that stage of the pipeline with something different,
                        you might want to emit this or some user specific item
                        to describe the conditions being used to glue event fragments
                        together into events.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatEVBFragment</function></term>
                <listitem>
                    <para>
                        Normally this is only emitted to event builder monitor
                        rings by <application>teering</application>.  Formats
                        an event builder fragment when you have a good idea the
                        fragment contains a ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatEVBFragmentUnknown</function></term>
                <listitem>
                    <para>
                        Same as <function>formatEVBFragment</function> but
                        used when there's a pretty good idea the fragment payload
                        is not a ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedEventItem</function></term>
                <listitem>
                    <para>
                        Creates an evet ring item that has a timestamp (full
                        body header).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedTriggerCountItem</function></term>
                <listitem>
                    <para>
                        Formas a physics event count item with a full body header.
                        In addition, the ring items allows you to provide an
                        <firstterm>offsetdivisor</firstterm> for the run offset
                        which  supports run times with sub-second resolution.
                        The concept of the run time divisor which
                        (as of NSCLDAQ-11.0) is present in all ring item types that
                        have run time offsets is that if you take the run time
                        offset, and divide it by the run time divisor (floating
                        point arithmetic), you get the offset into the run
                        in seconds.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedScalerItem</function></term>
                <listitem>
                    <para>
                        Formats a periodic scaler item that has a full body
                        header.  Again, this version allows you to set the
                        run time offset divisor to something other than 1.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedTextItem</function></term>
                <listitem>
                    <para>
                        Formats a text array item that has a full body header.
                        The full body headder no only allows the emitter to
                        specify a timestamp at which the item was created, but also
                        to specify which data source created the item.  If the
                        text item should not have a timestamp, you should either
                        fill in the most recent timestamp emitted by that source or,
                        if that's not convenient, the value
                        <literal>NULL_TIMESTAMP</literal> which is defined in
                        the header <filename>fragment.h</filename>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>formatTimestampedStateChange</function></term>
                <listitem>
                    <para>
                        Formats a state change item that has a full body header and,
                        possible, value for the run time divisor other than 1.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>bodyPointer</function></term>
                <listitem>
                    <para>
                        Given a pointer to a ring item that comes from
                        NSCLDAQ-11.0 or later, returns a pointer to the
                        body payload of the item. The body payload is the
                        section of the ring item that is just after the
                        Body Header or, if the body header is not emitted, after
                        the zero longwords.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3daq -->

    <refentry id='manpage.cringitem'>
      <refmeta>
         <refentrytitle>CRingItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CRingItem</refname>
	 <refpurpose>Encapsulates an item in a ring buffer.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingItem.h&gt;
         </programlisting>
         <synopsis>
            <ooclass><classname>CRingITem</classname></ooclass>
            <constructorsynopsis>
                <methodname>CRingItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxBody</parameter>
                    <initializer>8192</initializer>
                </methodparam>
            </constructorsynopsis>
            
            <!-- new in 11.0 -->
            
            <constructorsynopsis>
                <methodname> CRingItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>uint64_t</type><parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>sourceId</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> barrierType</parameter>
                    <initializer>0</initializer>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter> maxBody</parameter>
                    <initializer>8192</initializer>
                </methodparam>
            </constructorsynopsis>
            <!-- end of 11.0 addition -->
            
            <constructorsynopsis>
                <methodname>CRingItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingItem</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>getStorageSize</methodname>
                                    <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>getBodySize</methodname>
                                    <void /><modifier> const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void*</type> <methodname>getBodyPointer</methodname>
                                   <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void*</type> <methodname> getBodyCursor</methodname>
                                   <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>_RingItem*</type>
                <methodname>getItemPointer</methodname> <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>type</methodname>
                                        <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setBodyCursor</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pNewCursor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>commitToRing</methodname>
                <methodparam>
                    <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>
                <methodname>mustSwap</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            
            <!-- New in 11.0 -->
            
            <methodsynopsis>
                <type>bool</type>
                <methodname> hasBodyHeader</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>uint64_t</type>
                <methodname> getEventTimestamp</methodname>
                <void />
                <exceptionname>std::string</exceptionname>
                <modifier>const</modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <type>uint32_t </type>
                <methodname>getSourceId</methodname>
                <void />
                <exceptionname>std::string</exceptionname>
                <modifier>const</modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <type>uint32_t </type>
                <methodname>getBarrierType</methodname>
                <void />
                <exceptionname>std::string</exceptionname>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setBodyHeader</methodname>
                <methodparam>
                    <type>uint64_t</type><parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>sourceId</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>barrierType</parameter>
                    <initializer>0</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::string </type>
                <methodname>typeName() </methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>std::string </type>
                <methodname>toString() </methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>  
             
            
            <!-- End of methods new in 11.0 -->
           
            <methodsynopsis>
                <modifier>static</modifier>
                <type>CRingItem*</type>
                <methodname>getFromRing</methodname>
                <methodparam>
                    <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            
                <methodparam>
                    <type>CRingSelectionPredicate&amp;</type> <parameter>predicate</parameter>
                </methodparam>
            </methodsynopsis>

         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CRingItem</classname> is the base class of a hierarchy
            of classes that encapsulate the format of items put in ring buffers
            by the NSCL DAQ readout frameworks.  
         </para>
         <para>
            The class hierarchy as a whole is intended both to help application
            writers format item to be submitted to a ring buffer and to
            fetch and decode items from a ring buffer.  The fetch logic works
            closely with the set of classes derived from
            <classname>CRingSelectionPredicate</classname>
            to support selective reception of data inserted by a producer program.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
             <methodname>CRingItem</methodname>
             <methodparam>
                 <type>uint16_t</type> <parameter>type</parameter>
             </methodparam>
             <methodparam>
                 <type>size_t</type> <parameter>maxBody</parameter>
                                     <initializer>8192</initializer>
             </methodparam>
         </constructorsynopsis>
        <para>
            Constructs a Ring Item.  <parameter>type</parameter> initializes the
            type field of the item, and maximum size of the body is
            set to be <parameter>maxBody</parameter>.
        </para>
        <para>
            The size of the actual ring buffer item placed in a ring
            via <methodname>commitToRing</methodname> is computed from the
            position of the <firstterm>body cursor</firstterm> as set by the
            last invocation of <methodname>setBodyCursor</methodname>.
        </para>
        <para>
            In order to reduce the amount of dynamic memory management required
            for ring buffer items, a static buffer of size
            <varname>CRingItemStaticBufferSize</varname> is carried by
            all objects.  Only if the maximum size is requested to be larger than
            that is a dynamically allocated body produced by the constructor
            and deleted by the destructor.
        </para>
        <!-- new in 11.0 -->
        
        <constructorsynopsis>
            <methodname> CRingItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>uint64_t</type><parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>sourceId</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> barrierType</parameter>
                <initializer>0</initializer>
            </methodparam>
            <methodparam>
                <type>size_t</type><parameter> maxBody</parameter>
                <initializer>8192</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a ring item with a full body header.  The
            <parameter>timestamp</parameter>, <parameter>sourceId</parameter>
            and <parameter>barriereType</parameter> parameters set the corresponding
            fields in the body header.  The default <parameter>barrierType</parameter>
            of 0 indicates a non-barrier item.
        </para>
        <!-- end of 11.0 addition -->

         <constructorsynopsis>
             <methodname>CRingItem</methodname>
             <methodparam>
                 <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
             </methodparam>
         </constructorsynopsis>
         <para>
            Constructs a ring item by creating a functional copy of
            <parameter>rhs</parameter> (copy construction).
         </para>

         <methodsynopsis>
             <type>CRingItem&amp;</type>
             <methodname>operator=</methodname>
             <methodparam>
                 <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Makes the current object (on the left hand side of an assignment statement)
            a functional equivalent of <parameter>rhs</parameter>.
         </para>
         <methodsynopsis>
             <type>int</type> <methodname>operator==</methodname>
             <methodparam>
                 <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
             </methodparam>
             <modifier>const</modifier>
         </methodsynopsis>
         <para>
            Compares the object on the left hand side of an <literal>==</literal>
            to <parameter>rhs</parameter> for functional equivalence.
            If the two objects reasonably represent the same ring item, returns
            nonzero, else returns zero.
         </para>
         <methodsynopsis>
             <type>int</type> <methodname>operator!=</methodname>
             <methodparam>
                 <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
             </methodparam>
             <modifier>const</modifier>
         </methodsynopsis>
         <para>
            Computes the logical inverse of <methodname>operator==</methodname>
         </para>
         <methodsynopsis>
             <type>size_t</type> <methodname>getStorageSize</methodname>
                                 <void /><modifier>const</modifier>
         </methodsynopsis>
         <para>
            Returns the total size available for the ring item, header and body
            together.
         </para>
         <methodsynopsis>
             <type>size_t</type> <methodname>getBodySize</methodname>
                                 <void /><modifier> const</modifier>
         </methodsynopsis>
         <para>
            Returns the amount of data in the body of the ring.
         </para>
         <methodsynopsis>
             <type>void*</type> <methodname>getBodyPointer</methodname>
                                <void />
         </methodsynopsis>
         <para>
            Returns a pointer to the start of the body.  Note that this returns
            a pointer to the body payload, that is the first byte after the
            Body Header if one is present or the byte after the zero indicating
            there is no body header if one is not.
         </para>
         <methodsynopsis>
             <type>void*</type> <methodname> getBodyCursor</methodname>
                                <void />
         </methodsynopsis>
         <para>
            Returns the last stored body cursor.  This is intended to allow you
            (along with <methodname>setBodyCursor</methodname>) to keep track of
            where you should next add information to a ring item.
         </para>
         <methodsynopsis>
             <type>_RingItem*</type>
             <methodname>getItemPointer</methodname> <void />
         </methodsynopsis>
         <para>
            Returns a pointer to the items storage.  This should be a
            <type>RingItemHeader</type> followed by whatever has been
            put in the body.
         </para>
         <methodsynopsis>
             <type>uint32_t</type> <methodname>type</methodname>
                                     <void /> <modifier>const</modifier>
         </methodsynopsis>
         <para>
            Returns the type of the item encapsulated by the object.
            This member does account for byte order mismatches in the event the
            generating system had a different byte order than the system running
            the object.
         </para>
         <methodsynopsis>
             <type>void</type> <methodname>setBodyCursor</methodname>
             <methodparam>
                 <type>void*</type> <parameter>pNewCursor</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Items have a <firstterm>bodyCursor</firstterm>.  This is intended
            to allow software that is building up an item to keep track of
            the next free hunk of memory in the item.  The cusor can be
            fetched via <methodname>getBodyCursor</methodname> and stored
            back via <methodname>setBodyCursor</methodname> which sets the
            body cursor to <parameter>pNewCursor</parameter>
         </para>
         <para>
            This is intended as  a performance compromise that enables
            data such as physics events to insert data into items with no
            penalty other than a pointer dereference.  The
            body cursor is also used to compute the size of an item when it
            is requested, and when or if it is committed to a ring buffer.
         </para>
         <methodsynopsis>
             <type>void</type>
             <methodname>commitToRing</methodname>
             <methodparam>
                 <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Inserts the item that is encapsulated by the object into the
            ring buffer represented by the object <parameter>ring</parameter>.
            At this time, the body cursor must point to the first unused
            byte following the body, as it is used to calculate the size field
            of the item.
        </para>
        <para>
            This call may block indefinitely if space is not available in the ring.
        </para>
         <methodsynopsis>
             <type>bool</type>
             <methodname>mustSwap</methodname>
             <void /><modifier>const</modifier>
         </methodsynopsis>
         <para>
            Returns true if the byte order of the object is the opposite of the
            running system.  Two assumptions are used to derive this result.
            First, that all ring items that are formatted in the local host
            will have local host byte ordering and therefore should return
            <literal>false</literal>
            for <methodname>mustSwap</methodname>.
            Second, that the top 16 bits of the data type are always zero
            and that this can be used to determine the byte ordering of an item.
         </para>

            <!-- New in 11.0 -->
            
        <methodsynopsis>
            <type>bool</type>
            <methodname> hasBodyHeader</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns <literal>true</literal> if the ring item has a body header.
            Returns <literal>false</literal> if not.  Note that the condition
            for returning true is that the length of the body header is non zero.
        </para>
        <methodsynopsis>
            <modifier></modifier>
            <type>uint64_t</type>
            <methodname> getEventTimestamp</methodname>
            <void />
            <exceptionname>std::string</exceptionname>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the timestamp from the items' body header. If
            <methodname>hasBodyHeader</methodname> would return <literal>false</literal>
            a string exception containing an explanatory error message is
            thrown as an exception.
        </para>
        <methodsynopsis>
            <type>uint32_t </type>
            <methodname>getSourceId</methodname>
            <void />
            <exceptionname>std::string</exceptionname>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the source id from the item's body header.
            If
            <methodname>hasBodyHeader</methodname> would return <literal>false</literal>
            a string exception containing an explanatory error message is
            thrown as an exception.
        </para>
        <methodsynopsis>
            <type>uint32_t </type>
            <methodname>getBarrierType</methodname>
            <void />
            <exceptionname>std::string</exceptionname>
            <modifier>const</modifier>
        </methodsynopsis>  
        <para>
            Returns the barrier type of the item.
            If
            <methodname>hasBodyHeader</methodname> would return <literal>false</literal>
            a string exception containing an explanatory error message is
            thrown as an exception.
        </para>
 
        <methodsynopsis>
            <type>void</type>
            <methodname>setBodyHeader</methodname>
            <methodparam>
                <type>uint64_t</type><parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>sourceId</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>barrierType</parameter>
                <initializer>0</initializer>
            </methodparam>
        </methodsynopsis>
        <para>
            If the item does not yet have a BodyHeader the body contents are
            moved to make room and the <parameter>timestramp</parameter>
            <parameter>sourceId</parameter> and <parameter>barrierType</parameter>
            parameters are used to fill in the corresponding fields of the
            Body Header.  If the item already has a body header, the parameters
            replace the contents of the body header in place.
        </para>
        <para>
            Naturally if you have an event item witha potentially large body,
            it is more efficient to construct it with a body header, even with
            nonsensical values and then invoke <methodname>setBodyHeader</methodname>
            than it is to construct the item without a body header, fill it in
            and then invoke <methodname>setBodyHeader</methodname>.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>std::string </type>
            <methodname>typeName() </methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            This virtual method is intended to be overriden in subclasses
            to provide a textual name of the item type.  This method along
            with <methodname>toString</methodname> below are intended to provide
            support for creating human readable dumps of ring items.  If not
            overriden, the method will produce string like:
            <literal>Unknown (<replaceable>hex-type</replaceable>)</literal>
            where <replaceable>hex-type</replaceable> is the hexadecimal value
            of the item type code  in the ring item header.
        </para>
        <methodsynopsis>
            <modifier>virtual </modifier>
            <type>std::string </type>
            <methodname>toString() </methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>          
        <para>
            This virtual method is inteded to be overridden in the subclasses
            to provide a human readable string representation of the item.
            If not overridden, the body header formatted and the body payload
            is simply dumped as hexadecimal bytes.
        </para>
        <note>
            <title>Note</title>
            <para>
                The protected method <methodname>bodyHeaderToString</methodname>
                will produce a string that both describes whether or not
                an item has a body header and the contents of that header if it
                does.  Since that method is protected, base classes may use
                it to include a formatted body header to their output.
            </para>
        </note>
        
        <!-- End of 11.0 additions -->

         <methodsynopsis>
             <modifier>static</modifier>
             <type>CRingItem*</type>
             <methodname>getFromRing</methodname>
             <methodparam>
                 <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
             </methodparam>
             <methodparam>
                 <type>CRingSelectionPredicate&amp;</type> <parameter>predicate</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Returns a pointer to a dynamically allocated ring item that was
            fetched from the ring buffer <parameter>ring</parameter>.
            The item must satisfy the selection criteria defined by
            <parameter>predicate</parameter>.
            If you want all items, simply pass in an un-reconfigured
            <classname>CAllButPredicate</classname> object.
         </para>
        <para>
            Predicates provide a powerful mechanism for selecting and sampling
            data from ring buffers.  For more information about them,
            see the chapter
            <link linkend="chapter.ringformat">Ring Format</link>
            which provides background information about ring buffer predicates.
            For reference information, see the reference pages for:
            <link linkend="manpage.cringselectionpredicate"><classname>CRingSelectionPredicate</classname></link>,
            <link linkend="manpage.callbutpredicate"><classname>CAllButPredicate</classname></link>,
            and
            <link linkend="manpage.cdesiredtypespredicate"><classname>CDesiredTypesPredicate</classname></link>.
            Note that you may also construct your own predicate classes should
            these not be sufficient to meet your needs.
        </para>
        <para>
            The caller is responsible for deleting the object.
        </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            While not explicitly referenced in the public interfaces
            of
            <classname>CRingItem</classname>, if you use this class directly,
            you should be familiar with the data types defined in the header
            <filename>DataFormat.h</filename>.  These are described fully in
            the chapter:
            <link linkend="chapter.ringformat">Ring Format</link>.
         </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            The code fragment below shows how to sample the next physics buffer
            from a ring which is represented by the object <varname>ring</varname>
         </para>
         <example>
            <title>Selecting sampled event from a ring.</title>
            <programlisting>
#include &lt;DataFormat.h&gt;                            <co id="cringitem.include" />
...
CDesiredTypesPredicate sampledEventsOnly;                <co id="cringitem.predicate" />
sampledEventsOnly.addDesiredType(PHYSICS_EVENT, true);   <co id="cringitem.addtype" />
CRingItem* item = CRingItem::getFromRing(ring, sampledEventsOnly); <co id="cringitem.get" />

// work with the item...
                                                        <co id="cringitem.process" />
//  Done with the item.

delete item;                                           <co id="cringitem.delete" />
            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs="cringitem.include">
                <para>
                    This <literal>#include</literal> obtains the data type and
                    constant definitions for ring items.  Specifically, we wil
                    need at least the <literal>PHYSICS_EVENT</literal>
                    constant.
                </para>
            </callout>
            <callout arearefs="cringitem.predicate">
                <para>
                    We will limit the ring items processed to the most recently
                    inserted physics event items.  This requires a predicate
                    that will select those items.  The simplest one to use
                    is the <classname>CDesiredTypesPredicate</classname> which
                    selects only the types we tell it to in the mode requested.
                </para>
            </callout>
            <callout arearefs="cringitem.addtype">
                <para>
                    This line informs the predicate that we want to select
                    ring items of type
                    <literal>PHYSICS_EVENT</literal> only and in sampled mode
                    meaning the predicate will skip all but the most recently
                    inserted physics event.
                </para>
            </callout>
            <callout arearefs="cringitem.get">
                <para>
                    This gets a pointer to the ring item that satisfies our
                    selection criteria.  Note that given our predicate,
                    we are assured that
                    <literal>item->type()</literal> would return
                    <literal>PHYSICS_EVENT</literal>.
                </para>
            </callout>
            <callout arearefs="cringitem.process">
                <para>
                    I'm omitting what you do to process the item as that's application
                    dependent.
                </para>
            </callout>
            <callout arearefs="cringitem.delete">
                <para>
                    Once you are done processing the ring item, it's storage
                    must be deleted or else eventually the memory leak
                    you would introduce will cause your program to fail.
                </para>
            </callout>
         </calloutlist>
      </refsect1>
   </refentry>
    <refentry id="manpage.cringscaleritem">
      <refmeta>
         <refentrytitle>CRingScalerItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CRingScalerItem</refname>
	 <refpurpose>Encapsulate ring buffer scaler items.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingScaleritem.h&gt;
         </programlisting>
         <synopsis>
            <ooclass><classname>CRingScalerItem</classname></ooclass>
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <type>size_t</type> <parameter>numScalers</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>startTime</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>stopTime</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type>   <parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;uint32_t&gt;</type> <parameter>scalers</parameter>
                </methodparam>
            </constructorsynopsis>
            
            <!-- NSCLDAQ-11.0 addition -->
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <type>uint64_t</type><parameter> eventTimestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> source</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>barrier</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>startTime</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>stopTime</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type><parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;uint32_t&gt;</type>
                    <parameter>scalers</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>timeDivisor</parameter>
                    <initializer>1</initializer>
                </methodparam>
            </constructorsynopsis>
            <!-- end of 11.0 addition -->
            
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingScalerItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingScalerItem</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingScalerItem&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                                                        <modifier>const</modifier>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setStartTime</methodname>
                <methodparam><type>uint32_t</type> <parameter>startTime</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getStartTime</methodname>
                                      <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setEndTime</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>endTime</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getEndTime</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setTimestamp</methodname>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>time_t</type> <methodname>getTimestamp</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setScaler</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>channel</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
                <exceptionname>CRangeError</exceptionname>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type>
                <methodname>getScaler</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>channel</parameter>
                </methodparam>
                <exceptionname>CRangeError</exceptionname>
                <modifier>const</modifier>
            </methodsynopsis>
            
            <methodsynopsis>
                <type>std::vector&lt;uint32_t&gt;</type> <methodname>getScalers</methodname>
                                                         <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getScalerCount</methodname>
                                      <void /> <modifier>const</modifier>
            </methodsynopsis>
            <!-- 11.0 additions -->
            
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type> std::string</type>
                <methodname>toString</methodname><modifier>const</modifier>
            </methodsynopsis>
            
            <!-- end of 11.0 additions -->
            
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CRingScalerItem</classname> encapsulates scaler items
            that either have been gotten from a ring or are being formatted
            to be inserted into a ring.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <type>size_t</type> <parameter>numScalers</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructor for a ring scaler item that will hold
            <parameter>numScalers</parameter>
            incremental scaler values.
            The interval start and stop times are set to zero and the
            timestamp to the current time. Scaler values are not initialized
            (specifically don't assume they are zero).
        </para>
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>startTime</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>stopTime</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type>   <parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;uint32_t&gt;</type> <parameter>scalers</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Full constructor for a scaler ring item.
            <parameter>startTime</parameter>
            is the number of seconds of active run time at the start of the
            interval measured by these scalers, and
            <parameter>stopTime</parameter> the end.
            <parameter>timestamp</parameter> is the absolute time of the end of
            the measurement interval (or more accurately, the time at which
            the scaler item was formatted).
            <parameter>sclaers</parameter> are a vector of scaler values.
        </para>
        <!-- NSCLDAQ-11.0 addition -->
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <type>uint64_t</type><parameter> eventTimestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> source</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>barrier</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>startTime</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>stopTime</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type><parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;uint32_t&gt;</type>
                <parameter>scalers</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>timeDivisor</parameter>
                <initializer>1</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a ring scaler item with a full body header described
            by the <parameter>eventTimestamp</parameter>, <parameter>source</parameter>
            and <parameter>barrier</parameter> parameters.  If the optional
            <parameter>timeDivisor</parameter> parameter is supplied, it
            will set the time divisor that is used to provide sub-second
            granularity to the interval start and end times.
        </para>
        <!-- end of 11.0 addition -->
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
        </constructorsynopsis>
        <para>
            Constructs a scaler item from an existing ring item
            <parameter>rhs</parameter>.
            If <parameter>rsh</parameter>'s type is not
            <literal>INCREMENTAL_SCALERS</literal>,
            a <type>std::bad_cast</type> exception is thrown.
        </para>
        <constructorsynopsis>
            <methodname>CRingScalerItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a functional duplicate of the scaler item
            <parameter>rhs</parameter> (copy construction).
        </para>
        <methodsynopsis>
            <type>CRingScalerItem&amp;</type> <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Assigns to this object from <parameter>rhs</parameter>.
            The object will become a functional equivalent of <parameter>rhs</parameter>.
            If later compared to <parameter>rhs</parameter> equality will be true.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier><type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Compares <parameter>rhs</parameter> with the object for
            functional equivalency.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingScalerItem&amp;</type> <parameter>rhs</parameter>
                                                    <modifier>const</modifier>
            </methodparam>
        </methodsynopsis>
        <para>
            Compares the item for functional equivalency and returns the
            logical inverse of the result.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>setStartTime</methodname>
            <methodparam><type>uint32_t</type> <parameter>startTime</parameter></methodparam>
        </methodsynopsis>
        <para>
            Sets the interval start time offset to
            <parameter>startTime</parameter>.  This is supposed to be the
            time into the run at which this set of scalers started counting.
            Inactive run time is not  counted.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getStartTime</methodname>
                                  <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the counting interval start time.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setEndTime</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>endTime</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the intervale end time to
            <parameter>endTime</parameter>.
            This is supposed to be the number of seconds in to the run
            at which the scalers for this item were read and cleared.
            Note that only active seconds are acounted.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getEndTime</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the time offset into the run at which the scalers were read.
            For a properly formatted item, this value should be larger than
            that returned by <methodname>getStartTime</methodname>.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>setTimestamp</methodname>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the timestamp for the item.  This should be the time at which
            the buffer was formatted.  It is a <type>time_t</type> as described
            in documentation of the unix <function>time</function> function.
        </para>
        <methodsynopsis>
            <type>time_t</type> <methodname>getTimestamp</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the timestamp for an item.  This is supopsed to be
            compatible for the argument to e.g. <function>ctime</function>
            in the byte order of the creating system.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setScaler</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>channel</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
            <exceptionname>CRangeError</exceptionname>
        </methodsynopsis>
        <para>
            Sets the value of scaler number <parameter>channel</parameter>
            to <parameter>value</parameter>.  If <parameter>channel</parameter>
            is larger than the number of scalers the item was constructed with,
            <type>CRangError</type> is thrown.
        </para>
        <methodsynopsis>
            <type>uint32_t</type>
            <methodname>getScaler</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>channel</parameter>
            </methodparam>
            <exceptionname>CRangeError</exceptionname>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the scaler channel <parameter>channel</parameter>.
            If the <parameter>channel</parameter> is too large a
            <type>CRangeError</type> is thrown.
        </para>
        <methodsynopsis>
            <type>std::vector&lt;uint32_t&gt;</type> <methodname>getScalers</methodname>
                                                     <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a vector that consists of the values of all of the incremental
            scalers in the item.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getScalerCount</methodname>
                                  <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the number of scalers in the item.
        </para>
        <!-- 11.0 additions -->
        
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>typeName</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides a textual string that describes the scaler item type.
            This overrides the base class method with code that returns the
            string <literal>Scaler:</literal>.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier><type> std::string</type>
            <methodname>toString</methodname><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Overrides the base class method with code that returns a formatted
            dump of the scaler values and scaler rates over the period in which
            the scalers were acquired.  Note that the rate is only produced
            for incremental scalers.
        </para>
        <!-- end of 11.0 additions -->

      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            See the <type>ScalerItem</type> type in
            <filename>&lt;DataFormat.h&gt;</filename>.
         </para>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <variablelist>
            <varlistentry>
                <term><type>std::bad_cast</type></term>
                <listitem>
                    <para>This is thrown in the event an attempt is made
                        to construct a
                        <classname>CRingScalerItem</classname> object
                        from a
                        <classname>CRingItem</classname> whose type is not
                        <literal>INCREMENTAL_SCALERS</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>CRangeError</type></term>
                <listitem>
                    <para>
                        Thrown in the event an effort is made to access a scaler
                        channel that does not exist.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            In the following example, an item is gotten from a ring buffer.
            If it is a scaler item, it is used to construct a new scaler
            item.  <literal>ring</literal> is assumed to be a
            <classname>CRingBuffer</classname>
            object or a reference to one.
         </para>
         <example>
            <title>Constructing a scaler item from an item gotten from a ring</title>
            <programlisting>
#include &lt;DataFormat.h&gt;
#include &lt;CRingItem.h&gt;
#include &lt;CRingScalerItem&gt;
...

CAllButPredicate  all;                                        <co id="scaler.allpred" />
CRingItem*        pItem = CRingItem::getFromRing(ring, all);  <co id="scaler.get" />

if (pItem->type() == INCREMENTAL_SCALERS) {                   <co id="scaler.isscaler" />
   CRingScalerItem scalers(*pItem);                           <co id="scaler.construct" />
   ...
}
else {
...
}
delete pItem;                                                <co id="scaler.delete" />
 
            </programlisting>
         </example>
         <calloutlist>
            <callout arearefs="scaler.allpred">
                <para>
                    This predicate accepts all ring buffer item types without
                    sampling.  The
                    <classname>CAllButPredicate</classname> accepts all ring
                    types without sampling except those explicitly defined.
                </para>
            </callout>
            <callout arearefs="scaler.get">
                <para>
                    Gets the next item from the ring, regardless of type.
                </para>
            </callout>
            <callout arearefs="scaler.isscaler">
                <para>
                    Before constructing a
                    <classname>CRingScalerItem</classname> object, it's important
                    to ensure the object is atually a scaler item.  Without this
                    check it would be necessary to wrap this code in a
                    <literal>try/catch</literal> block for <type>std::bad_cast</type>.
                </para>
            </callout>
            <callout arearefs="scaler.construct">
                <para>
                    If the item is a scaler item, it is converted into a
                    <classname>CScalerItem</classname>
                    and processed.
                </para>
            </callout>
            <callout arearefs="scaler.delete">
                <para>
                    Regardless, the original
                    <classname>CRingItem</classname> object must be deleted.
                </para>
            </callout>
         </calloutlist>
      </refsect1>
   </refentry>
    <refentry id="manpage.cringstatechangeitem">
      <refmeta>
         <refentrytitle>CRingStateChangeItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CRingStateChangeItem</refname>
	 <refpurpose>Encapsulate a ring buffer state change item.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingStateChangeItem&gt;
         </programlisting>
         <synopsis>
            <ooclass><classname>CRingStateChangeItem</classname></ooclass>
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>reason</parameter><initializer> BEGIN_RUN</initializer>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>reason</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>runNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>timeOffset</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type> <parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>title</parameter>
                </methodparam>
                <exceptionname>CRangeError</exceptionname>
            </constructorsynopsis>
            
            <!-- 11.0 additions -->
            
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>eventTimestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>sourceId</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>barrierType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>reason</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>runNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>timeOffset</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type><parameter> timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type><parameter> title</parameter>
                </methodparam>
            </constructorsynopsis>
            
            <!-- end of 11.0 additions -->
            
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>item</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingStateChangeItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingStateChangeItem</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingStateChangeItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setRunNumber</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>run</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getRunNumber</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setElapsedTime</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>offset</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getElapsedTime</methodname>
                                      <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTitle</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>title</parameter>
                </methodparam>
                <exceptionname>CRangeError</exceptionname>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>getTitle</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTimestamp</methodname>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>time_t</type> <methodname>getTimestamp</methodname>
                                    <void /> <modifier>const</modifier>
            </methodsynopsis>
    
            <!-- 11.0 additions -->
            
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            
            <!-- end of 11.0 additions -->

         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Encapsulates a ring buffer item for the ring items that represent
            changes in state of a data taking run.  These are specifically
            ring items of the type:
            <literal>BEGIN_RUN</literal>,
            <literal>END_RUN</literal>,
            <literal>PAUSE_RUN</literal>,
            and <literal>RESUME_RUN</literal>.
         </para>
         <para>
            In a ring buffer, these items take the form of a
            <type>StateChangeItem</type> as defined in
            <filename>&lt;DataFormat.h&gt;</filename>.
         </para>
         <para>
            The class can be used both to format state change items for later
            insertion into a ring, or to decode existing state change items.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>reason</parameter><initializer> BEGIN_RUN</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a state change item with the type <parameter>reason</parameter>.
            The run number, and time offset will be set to zero.  The
            timestamp will be set to the current time, and the title will be
            empty.
        </para>
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <type>uint16_tM</type> <parameter>reason</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>runNumber</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>timeOffset</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type> <parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>title</parameter>
            </methodparam>
            <exceptionname>CRangeError</exceptionname>
        </constructorsynopsis>
        <para>
            Constructs a run state change item in a fully specified way.
            <parameter>reason</parameter> is the actual type of the item.
            <parameter>runNumber</parameter> will be stored in the item as
            the number of the run undergoing state change.
            <parameter>timeOffset</parameter> should be the time in the run
            at which the state change occured in seconds.  This time should not
            include time spent in the paused state, and the begin run is always
            emitted at <parameter>timeOffset</parameter> zero.
            <parameter>timestamp</parameter> is an absolute time at which the
            transition occured.  This can be gotten via the POSIX
            <function>time(2)</function> function.
            <parameter>title</parameter> is the title string.
        </para>
        <para>
            The <parameter>title</parameter> string must be at most
            <literal>TITLE_MAXSIZE</literal> characters long.  If it is longer
            than that, a <classname>CRangeError</classname> will be thrown.

        </para>
        <!-- 11.0 additions -->
        
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <type>uint64_t</type> <parameter>eventTimestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>sourceId</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>barrierType</parameter>
            </methodparam>
            <methodparam>
                <type>uint16_t</type> <parameter>reason</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>runNumber</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>timeOffset</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type><parameter> timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type><parameter> title</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a ring state change item that has a full body header.
            The contents of the body header are determined by
            <parameter>eventTimestamp</parameter>, <parameter>sourceId</parameter>
            and <parameter>barrierType</parameter>.
        </para>
        
        <!-- end of 11.0 additions. -->
            
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>item</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
        </constructorsynopsis>
        <para>
            Attempts to construct a <classname>CRingStateChangeItem</classname>
            from a reference to an existing
            <classname>CRingItem</classname>; <parameter>item</parameter>.
            If <parameter>item</parameter> is not a value state change
            item, a
            <type>std::bad_cast</type> exception will be thrown.
        </para>
        <constructorsynopsis>
            <methodname>CRingStateChangeItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs an object that is a functional copy of
            <parameter>rhs</parameter>.
        </para>
        <methodsynopsis>
            <type>CRingStateChangeItem&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides assignment to <classname>CRingStateChangeItem</classname> objects
            from other <classname>CRingStateChangeItem</classname>s.
            After assignment is done the object on the left side of the
            <literal>=</literal> is a functional equivalent of
            <parameter>rhs</parameter>.
        </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Compares the object on the left hand side of the
            <literal>==</literal> for functional equivalence with the
            <parameter>rhs</parameter> object.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingStateChangeItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Compares the object for functional equivalence with
            <parameter>rhs</parameter>.
            Returns the logical inverse of the comparison.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>setRunNumber</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>run</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the run number of the item to
            <parameter>run</parameter>.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getRunNumber</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the current value of the run number.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setElapsedTime</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>offset</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Set the elapsed time for the item to <parameter>offset</parameter>.
            This value is supposed to represent the number of active seconds
            into the run at which the state transition occured.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getElapsedTime</methodname>
                                  <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the object's current elapsed run time value.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTitle</methodname>
            <methodparam>
                <type>std::string</type> <parameter>title</parameter>
            </methodparam>
            <exceptionname>CRangeError</exceptionname>
        </methodsynopsis>
        <para>
            Sets a new value for the title of the run.
            If the title is longer than
            <literal>TITLE_MAXSIZE</literal> characters,
            a <classname>CRangeError</classname> will be thrown.
        </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>getTitle</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the title string.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTimestamp</methodname>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the absolute time of the state transition to
            <parameter>stamp</parameter>.
            This is a value that might be gotten via the
            Unix <function>time(2)</function> function
        </para>
        <methodsynopsis>
            <type>time_t</type> <methodname>getTimestamp</methodname>
                                <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the absolute run time.
        </para>
        <!-- 11.0 additions -->
        
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>typeName</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Overrides the base class method.
            Returns a textual description of the type of the ring item
            (e.g. <literal>Begin Run</literal>).
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>toString</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Overrides the base class method to produce a text string that describes
            the state change item.
        </para>
        <!-- end of 11.0 additions -->
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            The underlying item encapsulated by this class is a
            <type>StateChangeItem</type> which is defined in
            <filename>&lt;DataFormat.h&gt;</filename>.
         </para>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <variablelist>
            <varlistentry>
                <term><type>std::bad_cast</type></term>
                <listitem>
                    <para>
                        Called if an attempt is made to construct from
                        a <classname>CRingItem</classname> that is not
                        a valid run state transition item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>CRangeError</classname></term>
                <listitem>
                    <para>
                        Thrown if an attempt is made to provide a title string
                        that is longer than allowed by run-state transition
                        items.  The maximum title string length is
                        <literal>TITLE_MAXSIZE</literal>.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            The example below creates a begin run and informs a ring about this.
         </para>
         <example>
            <title>Creating a begin run state transition item</title>
            <programlisting>
#include &lt;DataFormat.h&gt;
#include &lt;CRingStateChange.h&gt;

CRingStateChange item;
item.setTitle(string("This is the run title"));
item.setRunNumber(1234);

item.commitToRing(aring);

            </programlisting>
         </example>
      </refsect1>
   </refentry>

    <refentry id="manpage.cringtextitem">
      <refmeta>
         <refentrytitle>CRingTextItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CRingTextItem</refname>
	 <refpurpose>Encapsulate ring items that are lists of text strings.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingTextItem&gt;
         </programlisting>
         <synopsis>
            <ooclass><classname>CRingTextItem</classname></ooclass>
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;std::string&gt;</type> <parameter>theStrings</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;std::string&gt;</type> <parameter>theStrings</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>offsetTime</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type> <parameter>timestamp</parameter>
                </methodparam>
            </constructorsynopsis>
            
            <!-- 11.0 additions -->
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>uint64_t</type><parameter>eventTimestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>source</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> barrier</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;std::string&gt;</type>
                    <parameter>theStrings</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> offsetTime</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type><parameter> timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>offsetDivisor</parameter>
                    <initializer>1</initializer>
                </methodparam>
            </constructorsynopsis>
            <!-- end of 11.0 additions -->
            
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingTextItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CRingTextItem</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingTextItem&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;std::string&gt;</type>
                <methodname>getStrings</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTimeOffset</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>offset</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getTimeOffset</methodname>
                                      <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTimestamp</methodname>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>time_t</type> <methodname>getTimestamp</methodname>
                                    <void /><modifier>const</modifier>
            </methodsynopsis>
            
            <!-- 11.0 additions -->
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname><void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            <!-- end 11.0 additions -->
            
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Text string items contain lists of null terminated documentation strings.
            These are stored in ring buffers in structures of the type:
            <type>TextItem</type>.  These items have a type code of
            <literal>PACKET_TYPES</literal> or
            <literal>MONITORED_VARIABLES</literal>.  These items are used to
            document the set of packets you can expect to see in
            a <literal>PHYSICS_EVENT</literal> and provide the value of monitored
            process variables respectively.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;std::string&gt;</type> <parameter>theStrings</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a ring text item of the type specified by
            <parameter>type</parameter>.  The text strings will be filled in with
            the values of the individual strings in <parameter>theStrings</parameter>.
        </para>
        <para>
            The run offset time will be initialized to zero, and the
            absolute timestamp to the construction time of the object.
        </para>
        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;std::string&gt;</type> <parameter>theStrings</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>offsetTime</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type> <parameter>timestamp</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a text item in a fully specified way.
            In addition to <parameter>type</parameter> and <parameter>theStrings</parameter>
            providing the item type and the strings for the item respectively,
            <parameter>offsetTime</parameter>, and <parameter>timestamp</parameter>
            provide the run time offset and absolute timestamp values respectively.
        </para>
                <!-- 11.0 additions -->
        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>uint64_t</type><parameter>eventTimestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>source</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> barrier</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;std::string&gt;</type>
                <parameter>theStrings</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> offsetTime</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type><parameter> timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>offsetDivisor</parameter>
                <initializer>1</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a text item with  a full body header. The contents of the
            header are determined by the values of <parameter>eventTimestamp</parameter>
            <parameter>source</parameter> and <parameter>barrier</parameter>.
            The <parameter>offsetDivisor</parameter> parameter is optional and
            defaults to 1.  It represents the granularity of the <parameter>offsetTime</parameter>
            in seconds.  To get the actual time into the run in seconds compute:
            <literal>(float)offsetTime/offsetDivisor</literal>.
        </para>
            
            <!-- end of 11.0 additions -->
            

        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
        </constructorsynopsis>
        <para>
            Constructs a text item from a reference to an existing ring item;
            <parameter>rhs</parameter>.
            If the ring item is not of an appropriate type for a text item,
            a <type>std::bad_cast</type> exception is thrown.
        </para>
        <constructorsynopsis>
            <methodname>CRingTextItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a functional copy of of an existing text ring item;
            <parameter>rhs</parameter>.
        </para>
        <methodsynopsis>
            <type>CRingTextItem&amp;</type> <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides for assignment between ring text items.  When done, the object
            that is acted on will be a functional copy of the
            <parameter>rhs</parameter>  object.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides for comparison for functional equivalence between two
            ring text items.  The item is compared with
            <parameter>rhs</parameter>.
            The comparison returns non zero if there is functioal equivalence.
        </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingTextItem&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the logical inverse  of
            <methodname>operator==</methodname>.
        </para>
        <methodsynopsis>
            <type>std::vector&lt;std::string&gt;</type>
            <methodname>getStrings</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the strings in the string list as a vector of strings.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTimeOffset</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>offset</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the time offset at which the item was created to
            <parameter>offset</parameter>.  
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getTimeOffset</methodname>
                                  <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the most recently set time offset for the item.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTimestamp</methodname>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets an absolute timestamp for the item.
        </para>
        <methodsynopsis>
            <type>time_t</type> <methodname>getTimestamp</methodname>
                                <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the item's absolute timestamp.
        </para>
        <!-- 11.0 additions -->
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>typeName</methodname><void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a text string that describes the item type. For example if
            the ring item type is <literal>PACKET_TYPES</literal> the string
            <literal>Packet types:</literal> is returned.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>toString</methodname><void />
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a string that is a human readable dump of the
            ring item.  This incluces a list of the strings in the item.
        </para>
        <!-- end 11.0 additions -->
        
      </refsect1>
      <refsect1>
        <title>Exceptions</title>
        <para>
            Construction from a list item can throw a
            <type>std::bad_cast</type> exception if the underlying
            ring item is not either a
            <literal>PACKET_TYPES</literal> or
            <literal>MONITORED_VARIABLES</literal> item.
        </para>
      </refsect1>

   </refentry>
    <refentry id="manpage.cphysicseventitem">
      <refmeta>
         <refentrytitle>CPhysicsEventItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CPhysicsEventitem</refname>
         <refpurpose>Response to trigger.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include &lt;CPhysicsEventItem.h&gt;
        </programlisting>
       <synopsis>
        
           <ooclass><classname>CPhysicsEventItem</classname></ooclass> : public CRingItem {
           <constructorsynopsis>
            <methodname>CPhysicsEventItem</methodname>
            <methodparam>
                <type>size_t</type><parameter>maxBody</parameter>
                <initializer>8192</initializer>
            </methodparam>
           </constructorsynopsis>
           <constructorsynopsis>
            <methodname>CPhysicsEventItem</methodname>
            <methodparam>
                <type>uint64_t</type><parameter>timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> source</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> barrier</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type><parameter>maxBody</parameter>
                <initializer>8192</initializer>
            </methodparam>
           </constructorsynopsis>
           <constructorsynopsis>
            <methodname>CPhysicsEventItem</methodname>
            <methodparam>
                <modifier>const</modifier><type>CPhysicsEventItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            </constructorsynopsis>
           <destructorsynopsis>
            <modifier>virtual</modifier><methodname> ~CPhysicsEventItem</methodname>
            <void />
           </destructorsynopsis>
           <methodsynopsis>
            <type>CPhysicsEventItem&amp;</type><methodname> operator=</methodname>
            <methodparam>
                <modifier>const</modifier><type>CPhysicsEventItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
           </methodsynopsis>
           <methodsynopsis>
            <type>int</type><methodname> operator==</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CPhysicsEventItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
           </methodsynopsis>
           <methodsynopsis>
            <type>int</type><methodname> operator!=</methodname>
            <methodparam>
                <modifier>const</modifier><type> CPhysicsEventItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
           <methodsynopsis>
            <modifier>virtual</modifier><type> std::string</type>
            <methodname>typeName</methodname>
            <void /><modifier>const</modifier>
           </methodsynopsis>
           <methodsynopsis>
            <modifier>virtual</modifier> <type>std::string</type>
            <methodname>toString</methodname><void /><modifier>const</modifier>
           </methodsynopsis>

};
       </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
            Encapsulates the data read by a readout program in response to a
            trigger.  Note the actual meaning of this data depends on which ring
            you are looking at.  For example, if an experiment consists of
            several readout programs operating in parallel, there may be rings
            whose events are really fragments of full events (and an event
            builder data source that turns those events into fragments that
            are input to an event building pipeline).  In the same situation
            the ring to which the output of the glom stage of the event builder
            goes would have complete events (unless one is doing a mulitlevel
            build).
         </para>
      </refsect1>
      <refsect1>
         <title>
        METHODS
         </title>
         <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                     <methodname>CPhysicsEventItem</methodname>
                     <methodparam>
                         <type>size_t</type><parameter>maxBody</parameter>
                         <initializer>8192</initializer>
                     </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a physics item with the specified maximum
                        body size.  You are then responsible for obtaining the
                        body cursor, inserting data, updating the body cursor and
                        sizeo fht item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                     <methodname>CPhysicsEventItem</methodname>
                     <methodparam>
                         <type>uint64_t</type><parameter>timestamp</parameter>
                     </methodparam>
                     <methodparam>
                         <type>uint32_t</type><parameter> source</parameter>
                     </methodparam>
                     <methodparam>
                         <type>uint32_t</type><parameter> barrier</parameter>
                     </methodparam>
                     <methodparam>
                         <type>size_t</type><parameter>maxBody</parameter>
                         <initializer>8192</initializer>
                     </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates an empty physics event item with a full body
                        header whose contents are described by
                        <parameter>timestamp</parameter>, <parameter>source</parameter>
                        and <parameter>barrier</parameter>.
                        As before  you must still fill in the event data itself.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                     <methodname>CPhysicsEventItem</methodname>
                     <methodparam>
                         <modifier>const</modifier><type>CPhysicsEventItem&amp;</type>
                         <parameter>rhs</parameter>
                     </methodparam>
                     </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Copy constructor.  Creates a copy of the object
                        <parameter>rhs</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <type>CPhysicsEventItem&amp;</type><methodname> operator=</methodname>
                     <methodparam>
                         <modifier>const</modifier><type>CPhysicsEventItem&amp;</type>
                         <parameter>rhs</parameter>
                     </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assigns <parameter>rhs</parameter> to this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <type>int</type><methodname> operator==</methodname>
                     <methodparam>
                         <modifier>const</modifier>
                         <type>CPhysicsEventItem&amp;</type>
                         <parameter>rhs</parameter>
                     </methodparam>
                     <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Compares <parameter>rhs</parameter> for equality
                        with this object.  If the two objects are
                        equal, a non zero result is returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <type>int</type><methodname> operator!=</methodname>
                     <methodparam>
                         <modifier>const</modifier><type> CPhysicsEventItem&amp;</type>
                         <parameter>rhs</parameter>
                     </methodparam>
                     <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns nonzero if <methodname>operator==</methodname>
                        would have returned zero.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>virtual</modifier><type> std::string</type>
                     <methodname>typeName</methodname>
                     <void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a string that provides a human with the
                        type of this ring item.  The string returned is:
                        <literal>Event </literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>virtual</modifier> <type>std::string</type>
                     <methodname>toString</methodname><void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Converts the ring item into a human readable string.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
    </refentry>     
    <refentry id="manpage.cringphysicseventcountitem">
      <refmeta>
         <refentrytitle>CRingPhysicsEventCountItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CRingPhysicsEventCountItem</refname>
	 <refpurpose>Provides statistics regarding the number of events produced.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingPhysicsEventCountItem.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CRingPhysicsEventCountItem</classname></ooclass>
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>count</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>timeOffset</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>count</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>timeoffset</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </constructorsynopsis>
            
            <!-- 11.0 additions -->
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <type>uint64_t</type><parameter> timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>source</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter> barrier</parameter>
                </methodparam>
                <methodparam>
                    <type>uint64_t</type><parameter> count</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>timeoffset</parameter>
                </methodparam>
                <methodparam>
                    <type>time_t</type><parameter>stamp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>divisor</parameter>
                    <initializer>1</initializer>
                </methodparam>
            </constructorsynopsis>
            
            <!-- end of 11.0 additions -->
            
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingPhysicsEventCountItem</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingPhysicsEventCountItem</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingPhysicsEventCountItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint32_t</type> <methodname>getTimeOffset</methodname>
                                      <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setTimeOffset</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>offset</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>time_t</type>   <methodname>getTimestamp</methodname>
                                      <void />
                                      <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>     <methodname>setTimestamp</methodname>
                <methodparam>
                    <type>time_t</type> <parameter>stamp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint64_t</type> <methodname>getEventCount</methodname>
                                      <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>     <methodname>setEventCount</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>count</parameter>
                </methodparam>
            </methodsynopsis>

            <!-- 11.0 additions -->
            
            <methodsynopsis>
                <modifier>virtual</modifier><type> std::string</type>
                <methodname>typeName</methodname><void /><modifier> const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type> std::string</type>
                <methodname>toString</methodname><void /> <modifier>const</modifier>
            </methodsynopsis>

            <!-- end of 11.0 additions -->

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class encapsulates the
            <type>PhysicsEventCountItem</type> ring item.  That item is used
            to indicate how many events have been acquired so far this run.
            Timestamps and run time offset allow this to be used to compute
            trigger rates.   Clients that need to know the fraction of
            <varname>PHYSICS_EVENT</varname> items they are receiving
            can also use this.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <void />
        </constructorsynopsis>
        <para>
            Default constructor.  The event count and time offset will be
            zeroed.  The timestamp will be the time the constructor was called.
        </para>
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <type>uint64_t</type> <parameter>count</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>timeOffset</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs an event count item which is initialized with the
            specified <parameter>count</parameter> of triggers and is
            said to have occured <parameter>timeOffset</parameter> seconds
            into the run.
        </para>
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <type>uint64_t</type> <parameter>count</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>timeoffset</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Same as the previous constructor with the added initialization of
            the item's timestamp to <parameter>stamp</parameter>.
        </para>
        <!-- 11.0 additions -->
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <type>uint64_t</type><parameter> timestamp</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>source</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter> barrier</parameter>
            </methodparam>
            <methodparam>
                <type>uint64_t</type><parameter> count</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type><parameter>timeoffset</parameter>
            </methodparam>
            <methodparam>
                <type>time_t</type><parameter>stamp</parameter>
            </methodparam>
            <methodparam>
                <type>int</type><parameter>divisor</parameter>
                <initializer>1</initializer>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a physics event count item with a full body header.
            The contents of the body header are determined by the values
            of <parameter>timestamp</parameter>, <parameter>source</parameter>
            and <parameter>barrier</parameter>.  The <parameter>divisor</parameter>
            optional parameter provides support for run time intervals that
            are less than one second.  The actual time in seconds into the
            run is <programlisting>(float)timeoffset/divisor</programlisting>.
        </para>
        <!-- end of 11.0 additions -->
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
        </constructorsynopsis>
        <para>
            Constructs an event count item from an existing ring item;
            <parameter>rhs</parameter>.
            If <parameter>rhs</parameter> is not of type
            <literal>PHYSICS_EVENT_COUNT</literal>, a
            <classname>std::bad_cast</classname> exception is thrown.
        </para>
        <constructorsynopsis>
            <methodname>CRingPhysicsEventCountItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Provides support for copy construction.
        </para>
        <methodsynopsis>
            <type>CRingPhysicsEventCountItem&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides support for assignment of another event count item,
            <parameter>rhs</parameter> to the object.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides support for comparing two event count items to each other
            for functional equality.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingPhysicsEventCountItem&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Compares two items for functional equality and returns the logical
            inverse of the result.
        </para>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>getTimeOffset</methodname>
                                  <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the current value of the time offset field of the item.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setTimeOffset</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>offset</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the value of the time offset field of the item to
            <parameter>offset</parameter>.
        </para>
        <methodsynopsis>
            <type>time_t</type>   <methodname>getTimestamp</methodname>
                                  <void />
                                  <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the current timestamp of the item.
        </para>
        <methodsynopsis>
            <type>void</type>     <methodname>setTimestamp</methodname>
            <methodparam>
                <type>time_t</type> <parameter>stamp</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the object's absolute timestamp to <parameter>stamp</parameter>.
        </para>
        <methodsynopsis>
            <type>uint64_t</type> <methodname>getEventCount</methodname>
                                  <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the count of the number of eveents that have been
            accepted in the run so far (according to this item).
        </para>
        <methodsynopsis>
            <type>void</type>     <methodname>setEventCount</methodname>
            <methodparam>
                <type>uint64_t</type> <parameter>count</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Sets the event count field of the item to <parameter>count</parameter>.
        </para>
        <!-- 11.0 additions -->
        
        <methodsynopsis>
            <modifier>virtual</modifier><type> std::string</type>
            <methodname>typeName</methodname><void /><modifier> const</modifier>
        </methodsynopsis>
        <para>
            Returns a text version of the ring item type field. This consists of
            the text <literal>Trigger count:</literal>.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier><type> std::string</type>
            <methodname>toString</methodname><void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a human readable string representation of the item.
        </para>
        <!-- end of 11.0 additions -->
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            <type>std::bad_cast</type> is thrown on an attempt to construct
            an event count item out of an item that is not of type
            <literal>PHYSICS_EVENT_COUNT</literal>.
         </para>
      </refsect1>
   </refentry>
    <refentry id="manpage.cringfragmentitem">
      <refmeta>
         <refentrytitle id='manpage.cringfragmentitem.title'>CRingFragmentItem</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CRingFragmentItem</refname>
         <refpurpose>Encapsulate a <literal>EVB_FRAGMENT</literal> ring item
         </refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <programlisting>
#include &lt;CRingFragmentItem.h&gt;
        </programlisting>
        <synopsis>
       <classsynopsis>
           <ooclass><classname>CRingFragmentItem</classname></ooclass>
       </classsynopsis> : public CRingItem {}
          <constructorsynopsis>
         <methodname>CRingFragmentItem</methodname>
         <methodparam>
            <type>uint64_t</type> <parameter>timestamp</parameter>
         </methodparam>
         <methodparam>
            <type>uint32_t</type> <parameter>source</parameter>
         </methodparam>
         <methodparam>
            <type>uint32_t</type> <parameter>payloadSize</parameter>
         </methodparam>
         <methodparam>
            <modifier>const</modifier> <type>void*</type> <parameter>pBody</parameter>
         </methodparam>
         <methodparam>
            <type>uint32_t</type> <parameter>barrier</parameter>
            <initializer>0</initializer>
         </methodparam>
          </constructorsynopsis>
          
         <constructorsynopsis>
            <methodname>CRingFragmentItem</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <exceptionname>std::bad_cast</exceptionname>
         </constructorsynopsis>
         
         <constructorsynopsis>
            <methodname>CRingFragmentItem</methodname>
            <methodparam>
                <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </constructorsynopsis>
         
         <destructorsynopsis>
            <modifier>virtual</modifier>
            <methodname>~CRingFragmentItem</methodname>
            <void />
         </destructorsynopsis>
         
         <methodsynopsis>
            <type>CRingFragmentItem&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </methodsynopsis>
         
         <methodsynopsis>
            <type>int</type><methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CRingFragmentItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
         </methodsynopsis>
         
         <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
         </methodsynopsis>
         
         // accessors.
         
        <methodsynopsis>
            <type>uint64_t</type>
            <methodname>timestamp</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        
        <methodsynopsis>
            <type>uint32_t</type>
            <methodname>source</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        
        <methodsynopsis>
            <type>size_t</type>
            <methodname>payloadSize</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        
        <methodsynopsis>
            <modifier>const</modifier>
            <type>void*</type>
            <methodname>payloadPointer</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        
        <methodsynopsis>
            <type>uint32_t</type> <methodname>barrierType</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        
        <!-- 11.0 additions -->
        
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>typeName</methodname><void />
            <modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>virtual</modifier><type>std::string</type>
            <methodname>toString</methodname>
            <modifier>const</modifier>
        </methodsynopsis>
        
        <!-- end of 11.0 additions -->
       };
        </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
            Objects of this class encapsulate a <literal>EVB_FRAGMENT</literal>
            ring item.  These items are intended to be strung together into
            events by an event builder.  Placing them in a ring allows
            for a test point.
         </para>
         <para>
            Since this class is derived from
            <link linkend='manpage.cringitem'>CRingItem</link>,
            you can create ring items and then commit them to an existing
            ring via calls to
            <classname>CRingItem</classname>::<methodname>commitToRing</methodname>.
            Similarly calls to
            <classname>CRingItem</classname>::<methodname>getFromRing</methodname>.
            allow you to get a ring item and then, when you determine from the
            item type this is an event fragment, construct a
            <classname>CRingFragmentItem</classname> from that item.
         </para>
         <para>
            For a full description of the methods available, see
            both <link linkend='manpage.cringitem'>CRingItem</link>'s manpage, and
            the METHODS section below.
         </para>
      </refsect1>
      <refsect1>
         <title>
        METHODS
         </title>
         <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                    <methodname>CRingFragmentItem</methodname>
                    <methodparam>
                       <type>uint64_t</type> <parameter>timestamp</parameter>
                    </methodparam>
                    <methodparam>
                       <type>uint32_t</type> <parameter>source</parameter>
                    </methodparam>
                    <methodparam>
                       <type>uint32_t</type> <parameter>payloadSize</parameter>
                    </methodparam>
                    <methodparam>
                       <modifier>const</modifier> <type>void*</type> <parameter>pBody</parameter>
                    </methodparam>
                    <methodparam>
                       <type>uint32_t</type> <parameter>barrier</parameter>
                       <initializer>0</initializer>
                    </methodparam>
                     </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Construct an event fragment ring item.  This constructor
                        is normally used prior to inserting  fragment item
                        into a ring buffer via
                        <classname>CRingItem</classname>::<methodname>commitToRing</methodname>.
                    </para>
                    <para>
                        The parameters are pretty much self explanatory.
                        The default on the <parameter>barrier</parameter>
                        parameter is correct for fragments that are not part
                        of barrier synchronization.
                    </para>
                    <para>
                        The <parameter>timestamp</parameter> parameter is the
                        timestamp that will be associated with the fragment.
                        The <parameter>source</parameter> parameter identifies
                        the source of the fragment.  The <parameter>payloadSize</parameter>
                        parameter is the number of bytes of payload data that
                        will be copied into the ring item from
                        <parameter>pBody</parameter>.  <parameter>barrier</parameter>
                        is non-zero for barrier fragments and zero if
                        'normal' non-barrier fragments.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CRingFragmentItem</methodname>
                       <methodparam>
                           <modifier>const</modifier> <type>CRingItem&amp;</type>
                           <parameter>rhs</parameter>
                       </methodparam>
                       <exceptionname>std::bad_cast</exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a fragment ring item from a
                        <classname>CRingItem</classname>.  This is normally
                        used after a call from
                        <classname>CRingItem</classname>::<methodname>getFromRing</methodname>
                        that returned a <classname>CRingItem</classname> object
                        whose type is <literal>EVB_FRAGMENT</literal>.
                    </para>
                    <para>
                        The construction then allows your software to get the
                        values of fields of the fragment ring item via
                        the accessor methods described later in this ssection.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CRingFragmentItem</methodname>
                       <methodparam>
                           <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                           <parameter>rhs</parameter>
                       </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Copy constructor for ring fragment items.  If you find
                        yourself doing a lot of copy construction, you should
                        re-think your code and possibly have
                        <classname>CRingFragmentItem</classname> objects
                        passed by pointer or reference to your functions/methods.
                    </para>
                </listitem>
            </varlistentry>
            
            
            
            <varlistentry>
                <term>
            <destructorsynopsis>
               <modifier>virtual</modifier>
               <methodname>~CRingFragmentItem</methodname>
               <void />
            </destructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Destroys a <classname>CRingFragmentItem</classname>
                        and frees any dynamic storage that's associated with
                        it.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                <methodsynopsis>
                   <type>CRingFragmentItem&amp;</type>
                   <methodname>operator=</methodname>
                   <methodparam>
                       <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                       <parameter>rhs</parameter>
                   </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assigns the <parameter>rhs</parameter> to
                        <varname>*this</varname>.  Any dynamic storage associated
                        with <varname>this</varname> prior to the assignment
                        is disposed of and it is possible that additional dynamic
                        storage will be allocated to satisfy the needs of the
                        assignment.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                <methodsynopsis>
                   <type>int</type><methodname>operator==</methodname>
                   <methodparam>
                       <modifier>const</modifier> <type>CRingFragmentItem&amp;</type>
                       <parameter>rhs</parameter>
                   </methodparam>
                   <modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Tests for equality.  The payload is not included
                        in the test.  If the timestamp, event source
                        barrier type and payload size are equal the
                        ring items are assumed to be equal.  This is
                        because there are real problems with an experimental
                        setup that allows more than one fragment to have
                        the same timestamp (except for barriers and non
                        timestamped other items).
                    </para>
                </listitem>
             </varlistentry>
            
            <varlistentry>
                <term>
                <methodsynopsis>
                   <type>int</type> <methodname>operator!=</methodname>
                   <methodparam>
                       <modifier>const</modifier><type>CRingFragmentItem&amp;</type>
                       <parameter>rhs</parameter>
                   </methodparam>
                   <modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>true</literal> if
                        <methodname>operator==</methodname> returns
                        <literal>false</literal> and vica versa.
                    </para>
                </listitem>
             </varlistentry>
            
           <varlistentry>
            <term>
                <methodsynopsis>
                    <type>uint64_t</type>
                    <methodname>timestamp</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                <para>
                    Accessor method that returns the value of the item's timestamp.
                </para>
            </listitem>
        </varlistentry>
        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <type>uint32_t</type>
                    <methodname>source</methodname>
                    <void /><modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                 <para>
                     Accessor method that returns the value of the item's
                     source id.
                </para>
            </listitem>
        </varlistentry>
       
        <varlistentry>
            <term>
                <methodsynopsis>
                    <type>size_t</type>
                    <methodname>payloadSize</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                 <para>
                    Accessor mehthod that returns the size of the item's
                    payload. Using this and <methodname>payloadPointer</methodname>
                    allows complete access to the object's payload.
                </para>
            </listitem>
        </varlistentry>
        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>const</modifier>
                    <type>void*</type>
                    <methodname>payloadPointer</methodname>
                    <void /><modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                 <para>
                    Accessor method that returns a pointer to the item's
                    payload.  With this method and
                    <methodname>payloadSize</methodname> you can access the
                    contents of the payload.
                </para>
            </listitem>
         </varlistentry>
         
         <varlistentry>
            <term>
           <methodsynopsis>
               <type>uint32_t</type> <methodname>barrierType</methodname>
               <void /><modifier>const</modifier>
                </methodsynopsis>
                </term>
                <listitem>
                 <para>
                     Accessor method that returns the barrier type field
                     of the item.
                 </para>
            </listitem>
        </varlistentry>
              
        <!-- 11.0 additions -->
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a stringified version of the ring item type.  This
                    is <literal>Event fragment</literal>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname>
                <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a stringified version of the event fragment.
                    This includes inormation in the body h eader and a
                    formatted dump of the payload.  If the payload is recognizable
                    as a ring item it is dumped as a formatted ring item, otherwise
                    a straight byte by byte hex dump of the payload is performed.
                </para>
            </listitem>
        </varlistentry>
        
        <!-- end of 11.0 additions -->

                
         </variablelist>
      </refsect1>
    </refentry>
	 <refentry id="manpage.cunknownfragment">
       <refmeta>
          <refentrytitle>CUnknownFragment</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CUnknownFragment</refname>
          <refpurpose>Event fragment likley not containing a ring item</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
#include &lt;CUnknownFragment.h&gt;
        </programlisting>
        <synopsis>

            <ooclass><classname>CRingFragment</classname></ooclass> : public <classname>CRingFragmentItem</classname>
            <constructorsynopsis>
                <methodname>CUnknownFragment</methodname>
                <methodparam>
                    <type>uint64_t</type><parameter>timestamp</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>sourceid</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>barrier</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type><parameter>size</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type><parameter>pPayload</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CUnknownFragment</methodname>
                <void />
            </destructorsynopsis>
            <constructorsynopsis>
                <methodname>CUnknownFragment</methodname>
                <methodparam>
                    <modifier>const</modifier><type> CUnknownFragment&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CUnknownFragment</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CRingItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <methodsynopsis>
                <type>CUnknownFragment&amp;</type><methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CUnknownFragment&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type><methodname> operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CUnknownFragment&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type><methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CUnknownFragment&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type><methodname>typeName</methodname>
                <void /><modifier> const</modifier>
            </methodsynopsis>
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class is a thin wrapper that derived from
            <link linkend='manpage.cringfragmentitem'>
                <classname>CRingFragmentItem</classname></link>.
                There are only two differences between that class and this:
          </para>
          <orderedlist>
            <listitem>
                <para>
                    The ring item type is set to <literal>EVB_UNKNOWN_PAYLOAD</literal>
                </para>
            </listitem>
            <listitem>
                <para>
                    The <methodname>typeName</methodname> method returns the string:
                    <literal>Fragment with unknown payload</literal>
                </para>
            </listitem>
          </orderedlist>
                    
       </refsect1>
     </refentry>     
	 <refentry id="manpage.cdataformatitem">
       <refmeta>
          <refentrytitle>CDataFomatItem</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CDataFomatItem</refname>
          <refpurpose>Describe the format of a stream of ringitems.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
#include &lt;CRingFormatItem.h&gt;
        </programlisting>
        <synopsis>
            <ooclass><classname>CRingFormatItem</classname></ooclass> : public CRingItem
            <constructorsynopsis>
                <methodname>CDataFormatItem</methodname><void />
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CDataFormatItem</methodname><void />
            </destructorsynopsis>
            <constructorsynopsis>
                <methodname>CDataFormatItem</methodname>
                <methodparam>
                    <modifier>const</modifier><type> CDataFormatItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CDataFormatItem</methodname>
                <methodparam>
                    <modifier>const</modifier><type> CRingItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <methodsynopsis>
                <type>CDataFormatItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CDataFormatItem&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CRingItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint16_t</type><methodname>major</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint16_t</type><methodname>minor</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>typeName</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname><void /><modifier>const</modifier>
            </methodsynopsis>
    };
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <note>
            <title>NOTE:</title>
            <para>This item is new as of version 11.0</para>
          </note>
          <para>
            The <classname>CDataFormatItem</classname> encapsulates a
            Ring item of type <literal>RING_FORMAT</literal>.  This ring item
            provides information about the format of the stream of ring items to
            follow.  It should be emitted by producers at the beginning of each
            coherent stream (run), so that downstream clients know how to parse
            the ring items that follow.
          </para>
          <para>
            The item contains the major and minor version of the least recently
            released version of NSCDAQ capable of processing the item completely.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CDataFormatItem</methodname><void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a ring format item.  The major and minor versions
                        of the format are set to the values of
                        <varname>FORMAT_MAJOR</varname> and
                        <varname>FORMAT_MINOR</varname> in <filename>DataFormat.h</filename>
                        for the version of the
                        <filename>libdataformat.so</filename>
                        library the program has loaded.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <destructorsynopsis>
                        <modifier>virtual</modifier>
                        <methodname>~CDataFormatItem</methodname><void />
                    </destructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Destructor
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CDataFormatItem</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> CDataFormatItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Copy constructs another <classname>CDataForamtItem</classname>
                        making an object that is identical to
                        <parameter>rhs</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CDataFormatItem</methodname>
                        <methodparam>
                            <modifier>const</modifier><type> CRingItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <exceptionname>std::bad_cast</exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CDataFormatItem</classname>
                        by copying a <classname>CRingItem</classname> that is
                        the <parameter>rhs</parameter> parameter.  If
                        <parameter>rhs</parameter> is not a
                        <literal>RING_FORMAT</literal> type ring item a
                        <classname>std::bad_cast</classname> exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>CDataFormatItem&amp;</type>
                        <methodname>operator=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assignment operator.  This allows one <classname>CDataFormatItem</classname>
                        to be assigned from another right hand side (<parameter>rhs</parameter>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>CDataFormatItem&amp;</type>
                        <methodname>operator=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CRingItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <exceptionname>std::bad_cast</exceptionname>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assignment operator from a <parameter>rhs</parameter> operand
                        that is an undifferentiated <classname>CRingItem</classname>.
                        If the <parameter>rhs</parameter>'s type is no
                        <literal>RING_FORMAT</literal>,
                        a <classname>std::bad_cast</classname> exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>int</type>
                        <methodname>operator==</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Equality comparison.  The <parameter>rhs</parameter> must
                        be bit by bit equal to <varname>*this</varname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>int</type>
                        <methodname>operator!=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CDataFormatItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns nonzero if <methodname>operator==</methodname> returns
                        <literal>0</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint16_t</type><methodname>major</methodname><void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the major version number field of the ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint16_t</type><methodname>minor</methodname><void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the minor version number field of the ring item.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier><type>std::string</type>
                        <methodname>typeName</methodname><void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a text string that represents the item type
                        of the ring itme.  This is
                        <literal>Ring Item format version</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier><type>std::string</type>
                        <methodname>toString</methodname><void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Return a textual, human readable bit of text that
                        dumps information about the ring item.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>         
	 <refentry id="manpage.cglomparameters">
       <refmeta>
          <refentrytitle>CGlomParameters</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CGlomParameters</refname>
          <refpurpose>Reports event building parameters.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <programlisting>
#include &lt;CGlomParameters.h&gt;
            </programlisting>
        
        <synopsis>
            <ooclass><classname>CGlomParameters</classname></ooclass> : public CRingItem {
            <constructorsynopsis>
                <methodname>CGlomParameters</methodname>
                <methodparam>
                    <type>uint64_t</type> <parameter>interval</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>isBuilding</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>tsPolicy</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CGlomParameters</methodname>
                <void />
            </destructorsynopsis>
            <constructorsynopsis>
                <methodname>CGlomParameters</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CGlomParameters&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CGlomParameters</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CRingItem&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <exceptionname>std::bad_cast</exceptionname>
            </constructorsynopsis>
            <methodsynopsis>
                <type>CGlomParameters&amp;</type><methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CGlomParameters&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type><methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CGlomParameters&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type><methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier><type>CGlomParameters&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>uint64_t</type><methodname>coincidenceTicks</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type><methodname>isBuilding</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>TimestampPolicy</type><methodname>timestampPolicy</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>std::string</type>
                <methodname>typeName</methodname> <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier><type>std::string</type>
                <methodname>toString</methodname><void />
                <modifier>const</modifier>
            </methodsynopsis>

};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <application>glom</application> is a stage in the event builder pipeline
            that actually glues event fragments in close temporal proximity
            together into events.  It is important for consumers of data to know
            the parameters that <application>glom</application> uses to know
            how it should operate.  Therefore <application>glom</application> emits
            a ring item of type<literal>EVB_GLOM_INFO</literal> describing this information.
            The <classname>CGlomParameters</classname> class provides a C++
            class the wraps this ring item.
          </para>
          <para>
            See METHODS for detailed information about how to use this class.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <type>uint64_t</type> <parameter>interval</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool</type> <parameter>isBuilding</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CGlomParameters::TimestampPolicy</type>
                            <parameter>timestampPolicy</parameter> 
                            <modifier>const</modifier>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the ring item. object.  The contents of
                        the ring item are goverend by <parameter>isBuilding</parameter>
                        which should be true if glom is running in builder mode,
                        and <parameter>interval</parameter>, which is only
                        meaningful in build mode and represents the event
                        coincidence interval in timestamp ticks.  That is
                        given and event fragment a time t, All fragments
                        up until <literal>t+interval</literal> will be
                        glommed into a single event at which point glom
                        will start again with the next event found.
                    </para>
                    <para>
                        <application>glom</application> can also run in
                        non-building mode.  That mode means that each
                        fragment results in its own output event.
                    </para>
                    <para>
                        The <parameter>timestampPolicy</parameter> argument sets the
                        timestamp policy used by this version of glom and
                        can be one of <literal>CGlomParameters::first</literal>,
                        <literal>CGlomParametesr::last</literal> or
                        <literal>CGlomParameters::average</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <destructorsynopsis>
                        <modifier>virtual</modifier>
                        <methodname>~CGlomParameters</methodname>
                        <void />
                    </destructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Destructor
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CGlomParameters&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Copy constructor of a glom object.   Constructs a new object
                        that is an exact duplicate of <parameter>rhs</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CRingItem&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <exceptionname>std::bad_cast</exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a <classname>CRingItem</classname> that is a
                        duplicate of the arbitrary ring item <parameter>rhs</parameter>.
                        If <parameter>rhs</parameter> is not in fact a
                        <classname>CGLomParameters</classname> object a
                        <classname>std::bad_cast</classname> exception will
                        be thron.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>CGlomParameters&amp;</type><methodname>operator=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CGlomParameters&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Assignment operator.  The object on the left hand
                        side of an assignment becomes an exact duplicate of
                        <parameter>rhs</parameter> (the right hand side object).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>int</type><methodname>operator==</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CGlomParameters&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Compares the object on the left hand side of the
                        <literal>==</literal> operator to <parameter>rhs</parameter>.
                        A nonzero value is returned if the two objects can be
                        said to be equal.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>int</type><methodname>operator!=</methodname>
                        <methodparam>
                            <modifier>const</modifier><type>CGlomParameters&amp;</type>
                            <parameter>rhs</parameter>
                        </methodparam>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns nonzero if <methodname>operator==</methodname> would
                        return zero.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint64_t</type><methodname>coincidenceTicks</methodname>
                        <void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of ticks that define a coincidence
                        interval for building an event.  This only has meaning
                        if <methodname>isBuilding</methodname> returns
                        <literal>true</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>bool</type><methodname>isBuilding</methodname>
                        <void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>true</literal> if
                        <application>glom</application> was in event building
                        mode <literal>false</literal> otherwise.  The
                        value returned from <methodname>coincidenceTicks</methodname>
                        is only meaningful if this method returns
                        <literal>true</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodsynopsis>
                    <type>CGlomParametrs::TimestampPolicy</type>
                    <methodname>timestampPolicy</methodname>
                    <void /><modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the timestamp policy field.  This will
                        See the documentation of the constructor for information
                        about the possible values this can have.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier> <type>std::string</type>
                        <methodname>typeName</methodname> <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a string version of the ring item type
                        associated with this item.  This is:
                        <literal>Glom Parameters</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier><type>std::string</type>
                        <methodname>toString</methodname><void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a human readable string representation
                        of the object.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     
    <refentry id="manpage.cringselectionpredicate">
      <refmeta>
         <refentrytitle>CRingSelectionPredicate</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CRingSelectionPredicate</refname>
	 <refpurpose>Base class for predicates that select items from
            ring buffers.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CRingSelectionPredicate.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CRingSelectionPredicate</classname></ooclass>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool*</type> <parameter>sample</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CRingSelectionPredicate</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CRingSelectionPredicate&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                                             <methodname>operator()</methodname>
                <methodparam>
                    <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                                             <methodname>selectThis</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <modifier>= 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>selectItem</methodname>
                <methodparam><type>CRingBuffer&amp;</type><parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>void</type> <methodname>addSelectionItem</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>sample</parameter><initializer> false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>SelectionMapIterator</type> <methodname>find</methodname>
                <methodparam><type>uint32_t</type> <parameter>type</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>SelectionMapIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>uint32_t</type> <methodname>longswap</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>input</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>void</type> <methodname>addSelectionItems</methodname>
                <methodparam>
                    <type>std::vector&lt;ItemType&gt;</type> <parameter>selections</parameter>
                </methodparam>
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CRingSelectionPredicate</classname> is an abstract base
            class that can be subclassed to create specific predicates to selectively
            grab items from a ring buffer via
            <classname>CRingItem</classname>::<methodname>getFromRing</methodname>.
         </para>
         <para>
            The base class provides a set of item types and flags, and functions
            to maintain that set.  The meaning of those are up to the specific concrete
            predicate.  The <methodname>operator()</methodname> is provided that
            is sufficient for predicates that treat the flag as a request to
            sample data of that type by checking if a type is acceptable or not
            via the pure virtual function <methodname>selectThis</methodname>.
         </para>
      </refsect1>
      <refsect1>
         <title>
           Member functions
         </title>
         <refsect2>
            <title>Public members</title>
           <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <void />
            </constructorsynopsis>
            <para>
                Default constructor for a the base class, the list of
                type/flag pairs remains empty.
            </para>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs the base class with
                <parameter>nType</parameter> type/flag pairs where
                <parameter>types</parameter> is an array of types and all of
                the flags are set to be <literal>false</literal>.
            </para>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool*</type> <parameter>sample</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs a base class as above, however the state of the
                flag that corresponds to each <parameter>type</parameter>
                is specfied in the corresponding element of <parameter>sample</parameter>.
            </para>
            <constructorsynopsis>
                <methodname>CRingSelectionPredicate</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Provides support for copy construction of an object derived
                from <classname>CRingSelectionPredicate</classname> by copying the
                type/flag pairs from <parameter>rhs</parameter>.
            </para>

            <methodsynopsis>
                <type>CRingSelectionPredicate&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Provides support for assignment in selection predicates, by
                assigning the type/flag set of <parameter>rhs</parameter> to
                those of the object.
            </para>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Provides support for equality comparison of
                selection predicates by comparing the type/flag pairs of
                <parameter>rhs</parameter> to those of the object.
            </para>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CRingSelectionPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Provides support for inequality comparisons of selection predicates
                by comparing for equality and returning the boolean inverse of
                the result.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                                             <methodname>operator()</methodname>
                <methodparam>
                    <type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Provides a default predicate call for
                <classname>CRingBuffer</classname>::<methodname>blockWhile</methodname>.
                The default action is to block until an item is in the ring.
                when an item is in the ring, its type is retrieved and passed to
                <methodname>selectThis</methodname>.  If that function returns
                <literal>true</literal> the item is skipped.  If
                <literal>false</literal> is returned, and either the item type
                is not in the item list or is in the item list but with its flag
                false, then <literal>false</literal> is returned, ending the
                block and allowing the caller to retrieve the selected item.
                If the item is in the list an has a true flag, the item is skipped
                if it is not the most recently inserted item in the ring, otherwise
                blocking is terminated.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                                             <methodname>selectThis</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <modifier>= 0</modifier>
            </methodsynopsis>
            <para>
                This is a pure virtual member that must be implemented by
                concrete classes.  <parameter>type</parameter> is the item type
                of an item in the ring buffer.  The function should return
                <literal>true</literal> to skip the item,and
                <literal>false</literal> if the item is of an acceptable type.
                See, however the description of
                <methodname>operator()</methodname>
                to see how that item type's flag can modify the interpretation
                of this return value.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>selectItem</methodname>
                <methodparam><type>CRingBuffer&amp;</type> <parameter>ring</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                This member function interacts with the ring buffer
                <parameter>ring</parameter> to block the caller, skipping
                items inserted in the ring until one that matches the predicate
                is available. 
            </para>
            <para>
                Normally, this is intended to be called from
                <classname>CRingItem</classname>::<methodname>getFromRing</methodname>.
            </para>
         </refsect2>
         <refsect2>
            <title>Protected members</title>
            <para>
                Protected member functions are utilities that area
                available to derived classes.  Note that since the
                <classname>CRingSelectionPredicate</classname> class is
                an abstract base class, there can never be instances of it.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>void</type> <methodname>addSelectionItem</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>sample</parameter><initializer> false</initializer>
                </methodparam>
            </methodsynopsis>
            <para>
                Adds an item <parameter>type</parameter> and <parameter>sample</parameter>
                flag to the set of type/flag pairs maintained by this base class.
                As the actual interpretation of this list is partially up to
                the <methodname>selectThis</methodname> method, this is not exposed
                to the public. Concrete class implementations are expected to provide
                an appropriately named member function that delegates to this.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>SelectionMapIterator</type> <methodname>find</methodname>
                <methodparam><type>uint32_t</type> <parameter>type</parameter></methodparam>
            </methodsynopsis>
            <para>
                Locates <parameter>type</parameter> in the list of type/flag pairs.
                Returns a pointer like object <type>SelectionMapIterator</type>.
                This 'points' to a <type>std::pair&lt;uint32_t, ItemType&gt;</type>.
                If the item is not found, the iterator will compare as
                <literal>==</literal> to the value returned from
                <methodname>end</methodname>.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>SelectionMapIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns the value that <methodname>find</methodname> returns if
                the item type searched for is not found.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>uint32_t</type> <methodname>longswap</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>input</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Swaps bytes in the longword <parameter>input</parameter> and
                returns the result.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>void</type> <methodname>addSelectionItems</methodname>
                <methodparam>
                    <type>std::vector&lt;ItemType&gt;</type> <parameter>selections</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Calls <methodname>addSelectionItem</methodname> once for each item
                in <parameter>selections</parameter>.
            </para>
         </refsect2>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            While the class does not export any public data or data types,
            it does provide several protected data types that are important
            to know about if you are deriving a class from
            <classname>CRingSelectionPredicate</classname>.  All of the type
            names are in the scope of <classname>CRingSelectionPredicate</classname>::.
         </para>
         <variablelist>
            <varlistentry>
                <term><structname>ItemType</structname></term>
                <listitem>
                    <para>
                        This is the structure that holds type/value pairs.
                        It contains the fields
                        <structfield>s_sampled</structfield>, which is the flag, and
                        <structfield>s_itemType</structfield>, which is the item
                        type.
                    </para>
                    <para>
                        While <structfield>s_sampled</structfield> is intended
                        to convey that tiems of that <structfield>s_itemType</structfield>
                        should be sampled, this is not required if the concrete class
                        overrides <methodname>operator()</methodname>
                    </para>
                    <para>
                        This struct supports equality and inequality comparision.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>SelectionMap</type></term>
                <listitem>
                    <para>
                        This is a typedef for
                        <type>std::map&lt;uint32_t, ItemType&gt;</type>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>SelectionMapIterator</type></term>
                <listitem>
                    <para>
                        This is a typedef for
                        <type>SelectionMap::iterator</type>.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
   </refentry>
    <refentry id="manpage.callbutpredicate">
      <refmeta>
         <refentrytitle>CAllButPredicate</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CAllButPredicate</refname>
	 <refpurpose>Select all ring items except some.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CAllButPredicate&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CAllButPredicate</classname></ooclass>
            <constructorsynopsis>
                <methodname>CAllButPredicate</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CAllButPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CAllButPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
                <methodparam>
                    <type>bool*</type> <parameter>sample</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CAllButPredicate</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CAllButPredicate</methodname> <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CAllButPredicate&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CAllButPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addExceptionType</methodname>
                <methodparam>
                    <type>uint32_t</type>
                    <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>sample</parameter><initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type> <methodname>selectThis</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CAllButPredicate</classname> is a ring selection predicate
            whose list of type/flag pairs are treated as exceptions to the rule
            that all types are wanted with no sampling.
         </para>
         <para>
            If an item is in the exception list and has the flag false, it will
            be skipped by the predicate when encountered in the ring buffe while
            blocking on the predicate.  If an item is in the exception ilst, but
            the flag is true, the item will be skipped unless it's the last one
            in the ring buffer.  Any item not in the list is accepted.
         </para>
      </refsect1>
      <refsect1>
        <title>
            Public member functions
        </title>
            <constructorsynopsis>
               <methodname>CAllButPredicate</methodname>
               <void />
           </constructorsynopsis>
            <para>
                Constructs the predicate.  When constructed in this way,
                all ring buffer item types are accepted without sampling unless
                the application makes a subsequent call to
                <methodname>addExceptionType</methodname>.
            </para>
           <constructorsynopsis>
               <methodname>CAllButPredicate</methodname>
               <methodparam>
                   <type>unsigned int</type> <parameter>nType</parameter>
               </methodparam>
               <methodparam>
                   <type>uint32_t*</type> <parameter>types</parameter>
               </methodparam>
           </constructorsynopsis>
           <para>
            Constructs the predicate so that the <parameter>nType</parameter>
            parameters in the array <parameter>types</parameter> of item types
            are not skipped by the predicate.
           </para>
           <constructorsynopsis>
               <methodname>CAllButPredicate</methodname>
               <methodparam>
                   <type>unsigned int</type> <parameter>nType</parameter>
               </methodparam>
               <methodparam>
                   <type>uint32_t*</type> <parameter>types</parameter>
               </methodparam>
               <methodparam>
                   <type>bool*</type> <parameter>sample</parameter>
               </methodparam>
           </constructorsynopsis>
           <para>
            Constructs the predicate so that the <parameter>nType</parameter>
            exceptions described by <parameter>types</parameter> and
            <parameter>sample</parameter> are either skipped (if their
            <parameter>sample</parameter> element is <literal>false</literal>,
            or sampled if their <parameter>sample</parameter> element is true.
           </para>
           <constructorsynopsis>
               <methodname>CAllButPredicate</methodname>
               <methodparam>
                   <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
               </methodparam>
           </constructorsynopsis>
           <para>
            Supports copy construction of the predicate.
           </para>
           <methodsynopsis>
               <type>CAllButPredicate&amp;</type>
               <methodname>operator=</methodname>
               <methodparam>
                   <modifier>const</modifier> <type>CAllButPredicate&amp;</type>
                                              <parameter>rhs</parameter>
               </methodparam>
           </methodsynopsis>
           <para>
            Supports assignment of the predicate.
           </para>
           <methodsynopsis>
               <type>int</type> <methodname>operator==</methodname>
               <methodparam>
                   <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
               </methodparam>
               <modifier>const</modifier>
           </methodsynopsis>
           <para>
            Supports testing for equality of the predicate with another.
           </para>
           <methodsynopsis>
               <type>int</type> <methodname>operator!=</methodname>
               <methodparam>
                   <modifier>const</modifier> <type>CAllButPredicate&amp;</type> <parameter>rhs</parameter>
               </methodparam>
               <modifier>const</modifier>
           </methodsynopsis>
           <para>
            Supports testing for inequality between the predicate and another.
           </para>
           <methodsynopsis>
               <type>void</type> <methodname>addExceptionType</methodname>
               <methodparam>
                   <type>uint32_t</type>
                   <parameter>type</parameter>
               </methodparam>
               <methodparam>
                   <type>bool</type> <parameter>sample</parameter><initializer>false</initializer>
               </methodparam>
           </methodsynopsis>
            <para>
                Adds an excpetion to the list of exceptions to the rule that
                all item types are accepted without sampling.  If
                <parameter>sample</parameter> is <literal>false</literal>,
                ring items of type <parameter>type</parameter> will be skipped.
                If <parameter>sample</parameter> is <literal>true</literal>
                Items of that type will be sampled.
            </para>
            <para>
                Specifying a type already in the exculsion list will
                overwrite the existing definition (e.g. you can change
                the state of the sampling flag).  It is not possible, however
                to remove an entry from the exception list.
            </para>
      </refsect1>

   </refentry>
    <refentry id="manpage.cdesiredtypespredicate">
      <refmeta>
         <refentrytitle>CDesiredTypesPredicate</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CDesiredTypesPredicate</refname>
	 <refpurpose>Only accept specified ring item types.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CDesiredTypesPredicate&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CDesiredTypesPredicate</classname></ooclass>
            <constructorsynopsis>
                <methodname>CDesiredTypesPredicate</methodname> <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CDesiredTypesPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CDesiredTypesPredicate</methodname>
                <methodparam>
                    <type>unsigned int</type> <parameter>nType</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t*</type> <parameter>types</parameter>
                </methodparam>
                <methodparam>
                    <type>bool*</type> <parameter>sample</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CDesiredTypesPredicate</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CDesiredTypesPredicate</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CDesiredTypesPredicate&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CDesiredTypesPredicate&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>addDesiredType</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>sample</parameter><initializer>false</initializer>
                </methodparam>
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The <classname>CDesiredTypes</classname> predicate is a ring item
            type selector that skips all ring item types except those in its
            item/flag list.  The flag determines if the data for that item type are
            sampled (if <literal>true</literal>) or if all items of that type are
            accepted (if <literal>false</literal>).
         </para>
         <para>
            <methodname>addDesiredType</methodname> is used to build up the list
            of desired item types. 
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CDesiredTypesPredicate</methodname> <void />
        </constructorsynopsis>
        <para>
            Constructs the predicate with an empty list of desired types.
            If no types are added via <methodname>addDesiredType</methodname>,
            the predicate will skip all of the data in the ring
            (not very useful).
        </para>  
        <constructorsynopsis>
            <methodname>CDesiredTypesPredicate</methodname>
            <methodparam>
                <type>unsigned int</type> <parameter>nType</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t*</type> <parameter>types</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs the predicate with <parameter>nType</parameter> types
            in its acceptance list.  These types are specified in the
            array <parameter>types</parameter>.  The sample flags on all of these
            types is set to <literal>false</literal>
            so that all items of these types are accepted.
        </para>
        <constructorsynopsis>
            <methodname>CDesiredTypesPredicate</methodname>
            <methodparam>
                <type>unsigned int</type> <parameter>nType</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t*</type> <parameter>types</parameter>
            </methodparam>
            <methodparam>
                <type>bool*</type> <parameter>sample</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Same as the previous constructor, however the sample flags for
            each item type are explicitly specified by the
            <parameter>sample</parameter>
            array.
        </para>
        <constructorsynopsis>
            <methodname>CDesiredTypesPredicate</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Provides support for creating a new predicate by copying a previously
            existing one.
        </para>
        <methodsynopsis>
            <type>CDesiredTypesPredicate&amp;</type> <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                                           <parameter>rhs</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides support for replacing the acceptance list of an existing
            object with the acceptance list of <parameter>rhs</parameter>.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CDesiredTypesPredicate&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides a mechanism for comparing two predicates for equality.
        </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDesiredTypesPredicate&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
            <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Provides the mechanism for comparing two predicates for inequality.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>addDesiredType</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>sample</parameter><initializer>false</initializer>
            </methodparam>
        </methodsynopsis>
        <para>
            Adds a type to the set of item types that  may be accepteed by the
            predicate.  <parameter>type</parameter> is the type id, and
            <parameter>sample</parameter> the flag that determines if the types
            are accepted in sampled mode.
        </para>
      </refsect1>
   </refentry>
    	 <refentry id="ref-dataformat">
           <refmeta>
              <refentrytitle id='ref-dataformat-title'>DataFormat.h</refentrytitle>
              <manvolnum>3daq</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>DataFormat.h</refname>
              <refpurpose>Format of ring items.</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>


<programlisting>
    
#include &lt;DataFormat.h&gt;

typedef struct _RingItemHeader {
  uint32_t     s_size;
  uint32_t     s_type;
} RingItemHeader, *pRingItemHeader;


typedef struct _BodyHeader {
  uint32_t   s_size;		
  uint64_t   s_timestamp;
  uint32_t   s_sourceId;
  uint32_t   s_barrier;   
} BodyHeader, *pBodyHeader;




typedef struct _RingItem {
  RingItemHeader s_header;
  union {
    struct {
      uint32_t s_mbz;
      uint8_t  s_body[1];
    } u_noBodyHeader;
    struct {
        BodyHeader s_bodyHeader;
        uint8_t s_body[];
    } u_hasBodyHeader;
  } s_body;
} RingItem, *pRingItem;


typedef struct _StateChangeItemBody {
  uint32_t        s_runNumber;
  uint32_t        s_timeOffset;
  uint32_t        s_Timestamp;
  uint32_t        s_offsetDivisor;
  char            s_title[TITLE_MAXSIZE+1];
} StateChangeItemBody, *pStateChangeItemBody;

typedef struct _StateChangeItem  {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t            s_mbz;      
            StateChangeItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader          s_bodyHeader;
            StateChangeItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
    
} StateChangeItem, *pStateChangeItem;


typedef struct _ScalerItemBody {
  uint32_t        s_intervalStartOffset;
  uint32_t        s_intervalEndOffset;
  uint32_t        s_timestamp;
  uint32_t        s_intervalDivisor; 
  uint32_t        s_scalerCount;
  uint32_t        s_isIncremental;   
  uint32_t        s_scalers[1];
} ScalerItemBody, *pScalerItemBody;

typedef struct _ScalerItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t       s_mbz;          
            ScalerItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader     s_bodyHeader;
            ScalerItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
} ScalerItem, *pScalerItem;

typedef struct _TextItemBody {
  uint32_t       s_timeOffset;
  uint32_t       s_timestamp;
  uint32_t       s_stringCount;
  uint32_t       s_offsetDivisor;
  char           s_strings[];
} TextItemBody, *pTextItemBody;

typedef struct _TextItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t       s_mbz; 
            TextItemBody   s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader     s_bodyHeader;
            TextItemBody   s_body;
        } u_hasBodyHeader;
    } s_body;
} TextItem, *pTextItem;



typedef struct _PhysicsEventItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t      s_mbz;
            uint16_t      s_body[];  
        } u_noBodyHeader;
        struct {
            BodyHeader    s_bodyHeader;
            uint16_t      s_body[];
        } u_hasBodyHeader;
    } s_body;
} PhysicsEventItem, *pPhysicsEventItem;


typedef struct __PhysicsEventCountItemBody {
  uint32_t       s_timeOffset;
  uint32_t       s_offsetDivisor;
  uint32_t       s_timestamp;
  uint64_t       s_eventCount;
} PhysicsEventCountItemBody, *pPhysicsEventCountItemBody;

typedef struct _PhysicsEventCountItem {
    RingItemHeader   s_header;
    union {
        struct {
            uint32_t             s_mbz; 
            PhysicsEventCountItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader           s_bodyHeader;
            PhysicsEventCountItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
} PhysicsEventCountItem, *pPhysicsEventCountItem;


typedef struct _EventBuilderFragment {
  RingItemHeader s_header;
  BodyHeader     s_bodyHeader;
  uint8_t       s_body[];
} EventBuilderFragment, *pEventBuilderFragment;


typedef struct _DataFormat {
    RingItemHeader s_header;
    uint32_t       s_mbz;   
    uint16_t       s_majorVersion;
    uint16_t       s_minorVersion;
} DataFormat, *pDataFormat;

typedef struct _GlomParameters  {
    RingItemHeader s_header;
    uint32_t       s_mbz;
    uint64_t       s_coincidenceTicks;
    uint16_t       s_isBuilding;
    uint16_t       s_timestampPolicy;
    
} GlomParameters, *pGlomParameters;

  pPhysicsEventItem  formatEventItem(size_t nWords, void* pPayload);
  pPhysicsEventCountItem formatTriggerCountItem(uint32_t runTime, time_t stamp, uint64_t triggerCount);
  pScalerItem         formatScalerItem(unsigned scalerCount, time_t timestamp, 
				      uint32_t btime, uint32_t etime, void* pCounters);
  pScalerItem         formatNonIncrTSScalerItem(unsigned scalerCount, time_t timestamp, 
						       uint32_t btime, uint32_t etime, 
						       uint64_t eventTimestamp, void* pCounters,
						       uint32_t timebaseDivisor);
  pTextItem          formatTextItem(unsigned nStrings, time_t stamp, uint32_t runTime,
				    const char** pStrings, int type);
  pStateChangeItem   formatStateChange(time_t stamp, uint32_t offset, uint32_t runNumber,
				       const char* pTitle, int type);
  
  pDataFormat           formatDataFormat();
  pGlomParameters       formatGlomParameters(uint64_t coincidenceWindow, int isBuilding,
                            int timestampPolicy);
  
  pEventBuilderFragment formatEVBFragment(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    uint32_t payloadSize, const void* pPayload
  );
  pEventBuilderFragment formatEVBFragmentUnknown (
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    uint32_t payloadSize, const void* pPayload
  );
  pPhysicsEventItem formatTimestampedEventItem(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    uint32_t payloadSize, const void* pPayload    
  );
  pPhysicsEventCountItem formatTimestampedTriggerCountItem (
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    uint32_t runTime, uint32_t offsetDivisor, time_t stamp, uint64_t triggerCount  
  );
  pScalerItem formatTimestampedScalerItem(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    int isIncremental, uint32_t timeIntervalDivisor, uint32_t timeofday,
    uint32_t btime, uint32_t etime, uint32_t nScalers, void* pCounters
  );
  pTextItem formatTimestampedTextItem(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    unsigned nStrings, time_t stamp, uint32_t runTime,
    const char**pStrings, int type,
    uint32_t timeIntervalDivisor
  );
  pStateChangeItem formatTimestampedStateChange(
    uint64_t timestamp, uint32_t sourceId, uint32_t barrier,
    time_t stamp, uint32_t offset, uint32_t runNumber, uint32_t offsetDivisor,
    const char* pTitle, int type
  );
  void* bodyPointer(pRingItem pItem);

</programlisting>

           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
                This header describes the format of data placed in NSCL ring
                buffers.  Each item consists of an envelope and a payload.
                The envelope, 
                <type>RingItemHeader</type> contains a size:
                <fieldsynopsis><type>uint32_t</type> <varname>s_size</varname></fieldsynopsis>
                which is the total size of the item (inlcuding the header) in
                bytes, and an item type
                <fieldsynopsis><type>uint32_t</type> <varname>s_type</varname></fieldsynopsis>
                which indicates what the item contains.  The payload immediately
                follows the header and varies in structure depending on the
                value in <varname>s_type</varname>.
              </para>
              <para>
                Items are placed in rings in native machine byte ordering.
                While the data type is 32 bits long, only the least significant
                16 bits are nonzero.  This allows a determination of
                the endianness of the system that generated the item.
              </para>
              <para>
                Starting with NSCLDAQ 11.0, ring items may have an additional
                <type>BodyHeader</type>.  The first field of this
                is the size of the body header (allowing for future expansion).
                If the body header size is <literal>0</literal> there is no
                body header.  The body header is intended to carry information
                relevant to data that requires an event builder for assembly.
              </para>
              <para>
                STRUCTURES below describes each of the ring items defined
                at this time.  CONSTANTS defines the set of values that
                <varname>s_type</varname> can take (once converted to
                the localh host's endian-ness).
              </para>
           </refsect1>
           <refsect1>
              <title>STRUCTURES</title>
              <para>
                The following ring items have been defined:
              </para>
              <refsect2>
                <title>RingItemHeader</title>
                <para>
                    This structure appears at beginning of each ring item.
                    The type <type>pRingItemHeader</type> represents a pointer
                    to a <type>RingItemHeader</type>.
                    <type>RingItemHeader</type> structs contain the following fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <type>uint32_t</type><structfield> s_size</structfield>
                        </term>
                        <listitem>
                            <para>
                                The size in bytes of the entire ring item.  The
                                size includes the size of the <type>RingItemHeader</type>
                                as well.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>uint32_t</type><structfield>s_type</structfield>
                        </term>
                        <listitem>
                            <para>
                                Contains the ring item type.  See the section
                                CONSTANTS below for valid ring item types. While
                                the <structfield>s_type</structfield> field is
                                <type>uint32_t</type>, the most significant 16
                                bits of this field are always zero, and the least
                                significant bits are always non-zero allowing
                                code to determinethe endianness of data  in this
                                item (including the size).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
              </refsect2>
              <refsect2>
                <title><type>BodyHeader</type></title>
                <para>
                    Contains data about the event as a fragment of a larger event.
                    The type <type>pBodyHeader</type> represents a pointer to this
                    type.
                </para>
                <para>
                    The body header has the following fiels:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>uint32_t</type><structfield>s_size</structfield></term>
                        <listitem>
                            <para>
                                Contains the size of the ring item header.  note that
                                if this field is <literal>0</literal> there are no
                                more fields (the item has no body header).
                                This possibility in general means that ring items
                                are described best by <type>union</type>s.
                                See the documentation about the remaining ring
                                item structures for more information.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>uint64_t</type><structfield>s_timestamp</structfield></term>
                        <listitem>
                            <para>
                                The timestamp of the event in ticks of the clock
                                that defines event building.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>uint32_t</type><structfield>s_sourceId</structfield></term>
                        <listitem>
                            <para>
                                The id of the source that produced this item.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>uint32_t</type><structfield>s_barrier; </structfield>
                        </term>
                        <listitem>
                            <para>
                                If nonzero, this item is part of a barrier
                                synchronization event.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
              </refsect2>
              <refsect2>
                <title>RingItem</title>
                <para>
                    This is a generic ring item.  The type <type>pRingItem</type>
                    defines a pointer to a ring item.   This item has the
                    following structure:
                </para>
                <programlisting>
typedef struct _RingItem {
  RingItemHeader s_header;
  union {
    struct {
      uint32_t s_mbz;
      uint8_t  s_body[1];
    } u_noBodyHeader;
    struct {
        BodyHeader s_bodyHeader;
        uint8_t s_body[];
    } u_hasBodyHeader;
  } s_body;
} RingItem, *pRingItem;
                </programlisting>
                <para>
                    The <structfield>s_header</structfield> is the
                    <type>RingItemHeader</type> decribed above.  The
                    union that follows provides support for ring items
                    that have (<structfield>u_hasBodyHeader</structfield>)
                    and do not have (<structfield>u_noBodyHeader</structfield>)
                    body headers.
                </para>
                <para>
                    The <structfield>s_mbz</structfield> field is zero indicating
                    that the item has not body header.
                </para>
                <para>
                    The <structfield>s_bodyHeader</structfield> is the
                    full body header.
                </para>
                <para>
                    In both branches of the union, the field
                    <structfield>s_body</structfield> is where the actual
                    payload (body) of the ring item actually
                    is.
                </para>
              </refsect2>
              <refsect2>
                <title>StateChangeItem</title>
                <para>
                    These contain information about a run state change.
                    They have the following form:
                </para>
                <programlisting>
typedef struct _StateChangeItem  {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t            s_mbz;       /* Must be zero - no body header*/
            StateChangeItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader          s_bodyHeader;
            StateChangeItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
    
} StateChangeItem, *pStateChangeItem;
                </programlisting>
                <para>
                    As you can see this is a union whose inner struture
                    depends on whether or not there is a body header
                    (<structfield>u_hasBodyHeader</structfield>) or
                    not (<structfield>u_noBodyHeader</structfield>).
                    You can tell which version of the union to use by examining
                    the <structfield>s_mbz</structfield> field.  If this is
                    zero use <structfield>u_noBodyHeader</structfield> otherwise
                    use <structfield>u_hasBodyHeader</structfield>
                </para>
                <para>
                    The <structfield>s_header</structfield> field is the
                    ring item header.  If there is a Body header is  is
                    <structfield>s_bodyHeader</structfield>
                </para>
                <para>
                    Regardless of which branch of the union you select, the
                    payload of the ring item is a <type>StateChangeItemBody</type>
                    in <structfield>s_body</structfield> which has the following
                    structure:
                </para>
                <programlisting>
typedef struct _StateChangeItemBody {
  uint32_t        s_runNumber;
  uint32_t        s_timeOffset;
  uint32_t        s_Timestamp;
  uint32_t        s_offsetDivisor;
  char            s_title[TITLE_MAXSIZE+1];
} StateChangeItemBody, *pStateChangeItemBody;
                </programlisting>
                <para>
                    <structfield>s_runNumber</structfield> is the number of the
                    run that is undergoig a transition.  <structfield>s_timeoffset</structfield>
                    together with <structfield>s_offsetDivisor</structfield>
                    determine when relative to the start of the run this state change
                    occured.  <structfield>s_timeoffset</structfield> is a time
                    offset in unites of 1/<structfield>s_offsetDivisor</structfield>
                    seconds.
                </para>
                <para>
                    The unix <type>time_t</type> for the absolute time at
                    which this occured is truncated to 32 bits and stored
                    in <structfield>s_Timestamp</structfield> (note that
                    on 64 bit systems  <type>time_t</type> is 64 bits
                    but on 32 bit systems 32 bits making it intrinsically
                    non-portable).  This 32 bit time is good into the year
                    2038.  <structfield>s_offsetDivisor</structfield>
                    stores the units of <structfield>s_Timestamp</structfield>
                    in 1/seconds.  Thus <structfield>s_Timestamp/s_offsetDivisor</structfield>
                    is the offset in to the run in floating point seconds
                    (floating point values are also not as portable as fixed
                    length integers).
                </para>
                <para>
                    <structfield>s_title</structfield> is the run title.
                    The title string is a null terminated string at most
                    <literal>TITLE_MAXSIZE</literal> non null characters long.
                    The additional <type>char</type> allocated ensures the
                    title has a null terminator.  See <literal>CONSTANTS</literal>
                    below for more information about <literal>TITLE_MAXSIZE</literal>.
                </para>
              </refsect2>
              <refsect2>
                <title><type>ScalerItem</type></title>
                <para>
                    The <type>ScalerItem</type> item contains a set of periodically
                    read scaler items.  Starting in NSCLDAQ-11.0 these may or may
                    not be incremental and may have interval start/stop
                    time values that have a sub-second resolution.
                </para>
                <para>
                    As with most ring item data, the actual structure of this is
                    represented as a union:
                </para>
                <programlisting>
typedef struct _ScalerItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t       s_mbz;              /* Must be zero .. no header */
            ScalerItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader     s_bodyHeader;
            ScalerItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
} ScalerItem, *pScalerItem;
                </programlisting>
                <para>
                    The union has the standard branches that most <type>RingItem</type>s
                    have, <structfield>u_noBodyHeader</structfield> when
                    <structfield>s_mbz</structfield> is zero indicating a lack
                    of a body header and
                    <structfield>s_hasBodyHeader</structfield> when it is
                    the size of an action <type>BodyHeader</type> struct.
                </para>
                <para>
                    Regardless, <structfield>s_body</structfield> has the
                    actual scaler data body and looks like this:
                </para>
                <programlisting>
 typedef struct _ScalerItemBody {
  uint32_t        s_intervalStartOffset;
  uint32_t        s_intervalEndOffset;
  uint32_t        s_timestamp;
  uint32_t        s_intervalDivisor;  /* 11.0 sub second time intervals */
  uint32_t        s_scalerCount;
  uint32_t        s_isIncremental;    /* 11.0 non-incremental scaler flag */
  uint32_t        s_scalers[1];
} ScalerItemBody, *pScalerItemBody;
                </programlisting>
                <para>
                    The fields <structfield>s_intervalStartOffset</structfield>,
                    <structfield>s_intervalEndOffset</structfield> and
                    <structfield>s_intervalDivisor</structfield> allow you to
                    determine the time relative to the beginning of the run at which
                    the counting interval started and ended.  Dividing the offsets
                    by the divisor produces seconds (if done in floating point
                    arithmetic).
                </para>
                <para>
                    <structfield>s_timetamp </structfield> provides the unix
                    time of day (trucated <type>time_t</type>) of the end of the
                    counting interval.
                </para>
                <para>
                    The <structfield>s_isIncremental</structfield> is non-zero
                    if the the scalers are zeroed at the start of each interval.
                    Otherwise it is assumed that history is required to be able
                    to compute rates.
                </para>
                <para>
                    Finally <structfield>s_scalerCount</structfield> is the
                    number of scalers in item and <structfield>s_scales</structfield>
                    is the location of the first element of the array of 32
                    bit wide scalers.
                </para>
              </refsect2>
              <refsect2>
                <title><type>TextItem</type></title>
                <para>
                    <type>TextItem</type> items contain a set of text strings
                    that are used for documentation purposes or to allow
                    the data acquisition system to track a set of slow controls
                    parameters.  As with almost all ringt items, the top level
                    structure is a union:
                </para>
                <programlisting>
 typedef struct _TextItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t       s_mbz;            /* Must be zero (no body header) */
            TextItemBody   s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader     s_bodyHeader;
            TextItemBody   s_body;
        } u_hasBodyHeader;
    } s_body;
} TextItem, *pTextItem;
                </programlisting>
                <para>
                    The <type>TextItemBody</type> has the following shape:
                </para>
                <programlisting>
typedef struct _TextItemBody {
  uint32_t       s_timeOffset;
  uint32_t       s_timestamp;
  uint32_t       s_stringCount;
  uint32_t       s_offsetDivisor;
  char           s_strings[];
} TextItemBody, *pTextItemBody;
                </programlisting>
                <para>
                    The <structfield>s_timeOffset</structfield> and
                    <structfield>s_offsetDivisor</structfield> are used to
                    represent the time at which this item was emitted relative
                    to the start of the run.  <structfield>s_timeOffset</structfield>
                    is the offset.  Doing a floating point by <structfield>s_offsetDivisor</structfield>
                    produces the seconds into the run at which the item was emitted.
                </para>
                <para>
                    <structfield>s_timestamp</structfield> is the truncated
                    <type>time_t</type> that represents the absolute time at
                    which this item was emitted.
                </para>
                <para>
                    <structfield>s_stringCount</structfield> is the number
                    of strings in the body. <structfield>s_strings</structfield>
                    points to the first byte of an array of bytes that contain
                    the null terminated strings carried by the item.  The
                    format of these strings is entirely up to the emitter.
                </para>
              </refsect2>
              <refsect2>
                <title><type>PhysicsEventItem</type></title>
                <para>
                    This item represents the response of a readout subsystem
                    to a trigger.  This may be passed as an event fragment
                    to an event building pipeline.  The struture of the item is
                    the normal union shape:
                </para>
                <programlisting>
typedef struct _PhysicsEventItem {
    RingItemHeader s_header;
    union {
        struct {
            uint32_t      s_mbz;
            uint16_t      s_body[];      /* Aribrtary length body */
        } u_noBodyHeader;
        struct {
            BodyHeader    s_bodyHeader;
            uint16_t      s_body[];
        } u_hasBodyHeader;
    } s_body;
} PhysicsEventItem, *pPhysicsEventItem;
                </programlisting>
                <para>
                    <structfield>s_body</structfield> is the first word of the
                    event body.  The size of the body can be determined from the
                    <structfield>s_size</structfield> field of the
                    <structfield>s_header</structfield> ring item header.
                    Typically, the readout frameworks place a word or longword
                    into the <structfield>s_body</structfield> that contains
                    the length of the event.
                </para>
              </refsect2>
              <refsect2>
                <title><type>DataFormat</type></title>
                <para>
                    This ring item (new starting in NSCLDAQ-11.0) describes
                    the oldest version of NSCLDAQ that is capable of handling
                    this form of data in the ring buffer.  The structure
                    of this item is:
                </para>
                <programlisting>
typedef struct _DataFormat {
    RingItemHeader s_header;
    uint32_t       s_mbz;              /* No body header */
    uint16_t       s_majorVersion;     /* FORMAT_MAJOR */
    uint16_t       s_minorVersion;     /* FORMAT_MINOR */
} DataFormat, *pDataFormat;
                </programlisting>
                <para>
                    As the <structfield>s_mbz</structfield> implies,
                    This item does not have a body header.  All data submitted
                    to a single ring buffer is assumed to be in a compatible
                    format.  The <structfield>s_majorVersion</structfield> and
                    <structfield>s_minorVersion</structfield> fields are the
                    major and minor versions of the oldest NSCLDAQ that can
                    deal with this data.  For example for NSCLDAQ-11.0
                    <structfield>s_majorVersion</structfield> is <literal>11</literal>
                    while <structfield>s_minorVersion</structfield> is
                    <literal>0</literal>
                </para>
              </refsect2>
              <refsect2>
                <title><type>PhysicsEventCountItem</type></title>
                <para>
                    This ring item provides counts of the number of
                    triggers a readout subsystem has responded to.
                    This can be used to keep track of trigger rates and,
                    for software that samples data, the fraction of data that
                    has ben seen.
                </para>
                <para>
                    The structure of this data item is the usual union:
                </para>
                <programlisting>
typedef struct _PhysicsEventCountItem {
    RingItemHeader   s_header;
    union {
        struct {
            uint32_t             s_mbz;      /* Must be zero - no body header*/
            PhysicsEventCountItemBody s_body;
        } u_noBodyHeader;
        struct {
            BodyHeader           s_bodyHeader;
            PhysicsEventCountItemBody s_body;
        } u_hasBodyHeader;
    } s_body;
} PhysicsEventCountItem, *pPhysicsEventCountItem;
                </programlisting>
                <para>
                    The union is used so that individual contributors of fragments
                    to the event builder can create uniquely identifiable
                    trigger count items.
                </para>
                <para>
                    The <structfield>s_body</structfield> field of both branches
                    of the union has the following shape:
                </para>
                <programlisting>
typedef struct __PhysicsEventCountItemBody {
  uint32_t       s_timeOffset;
  uint32_t       s_offsetDivisor;
  uint32_t       s_timestamp;
  uint64_t       s_eventCount;	/* Maybe 4Gevents is too small ;-) */
} PhysicsEventCountItemBody, *pPhysicsEventCountItemBody;
                </programlisting>
                <para>
                    The time into the run is determined in the usual way
                    from <structfield>s_timeOffset</structfield> and
                    <structfield>s_offsetDivisor</structfield>. Furthermore,
                    <structfield>s_timestamp</structfield> provides the
                    truncated <type>time_t</type> value that identifies the
                    absolute time at which this item was emitted.
                </para>
                <para>
                    <structfield>s_eventCount</structfield> are the number
                    of triggers that have been responded to since the start
                    of the run.
                </para>
              </refsect2>
              <refsect2>
                <title><type>EventBuilderFragment</type></title>
                <para>
                    An event builder fragment item is produced in event builder
                    monitor rings.  These rings allow users to monitor the ordered
                    data data from the ordering stage of the event builder pipeline.
                    These data are produced by the <application>teering</application>
                    program, and are also inputs to <application>glom</application>.
                </para>
                <para>
                    Since the event builder operates on timestamps and
                    needs to know about barriers and event sources all
                    event fragments have a body header:
                </para>
                <programlisting>
typedef struct _EventBuilderFragment {
  RingItemHeader s_header;
  BodyHeader     s_bodyHeader;
  uint8_t       s_body[];	/* Really s_payload bytes of data.. */
} EventBuilderFragment, *pEventBuilderFragment;
                </programlisting>
                <para>
                    <structfield>s_body</structfield> is the first byte of
                    the payload of the fragment.  The size of the fragment
                    can be determined from <structfield>s_header.s_size</structfield>
                    (specifically
                    <literal>s_header.s_size - sizeof(RingItemHeader) - sizeof(BodyHeader))</literal>).
                </para>
                <para>
                    It is also not unusual for the structure of the body to
                    describe the size of the <structfield>s_body</structfield> independent
                    of the rest of the item..
                </para>
              </refsect2>
              <refsect2>
                <title><type>GlomParameters</type></title>
                <para>
                    This item type is produced by the <application>glom</application>
                    stage of the event building pipeline.  <application>glom</application>
                    is the stage that can glue (or glom) ordered event fragments
                    into full events.
                </para>
                <para>
                    This event item captures the values of the run time parameters
                    handed to ghlom at startup time so that consumers of this
                    data know what they mean,
                </para>
                <programlisting>
typedef struct _GlomParameters  {
    RingItemHeader s_header;
    uint32_t       s_mbz;
    uint64_t       s_coincidenceTicks;
    uint16_t       s_isBuilding;
    uint16_t       s_timestampPolicy;
    
} GlomParameters, *pGlomParameters;
                </programlisting>
                <para>
                    As you can see by the <structfield>s_mbz</structfield> field,
                    this item does not have a ring body header.  The
                    <structfield>s_isBuilding</structfield>, is non zero if
                    glom is gluing events together and zero otherwise.
                    <structfield>s_coincidenceTicks</structfield> is therefore
                    only meaningful if <structfield>s_isBuilding</structfield>
                    is nonzero.  It represents the timestamp interval that
                    glom considers defines a fragment coincidence window.
                    Finally the <structfield>s_timestampPolicy</structfield>
                    contains the timestamp policy that glom used to determine                    
                    how timestamp fields in body headers of built events should
                    be chosen.  This is one of <literal>GLOM_TIMESTAMP_FIRST</literal>,
                    <literal>GLOM_TIMESTAMP_LAST</literal> or <literal>GLOM_TIMESTAMP_AVERAGE</literal>.
                </para>
              </refsect2>
              
              
           </refsect1>
            <refsect1>
               <title>CONSTANTS</title>
               <para>
                    <filename>DataFormat.h</filename> provides constant definitions
                    for the possible item type values as well as other definitions:
               </para>
               <variablelist>
                <varlistentry>
                    <term><fieldsynopsis>
                        <modifier>static const</modifier><type>uint16_t</type>
                        <varname>FORMAT_MAJOR</varname><initializer>11</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This is the value that should normally be put in the
                            <varname>s_majorVersion</varname> member of the
                            <type>DataFormat</type> ringitems.
                            At the time of writing the value is as shown above,
                            however check the <filename>DataFormat.h</filename>
                            file you are using in case this has been updated.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint16_t</type>
                            <varname>FORMAT_MINOR</varname><initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This is the value that should normally be put in the
                            <varname>s_majorVersion</varname> member of the
                            <type>DataFormat</type> ringitems.
                            At the time of writing the value is as shown above.
                            Since data format changes require a change in the major
                            version number of NSCLDAQ I would expect this value
                            to be zero.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>BEGIN_RUN</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a state change item
                            that documents the start of a run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>END_RUN</varname><initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a state change item
                            that documents the end of a run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>PAUSE_RUN</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a state change item
                            that documents a pause in a run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>RESUME_RUN</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a state change item
                            that documents a resume from a paused run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>PACKET_TYPES</varname>
                            <initializer>10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a text list ring item
                            that contains information about the types of
                            packets that may appear in events.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>MONITORED_VARIABLES</varname>
                            <initializer>11</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a text list ring item
                            that contains a set of monitored variable values.
                            Each string in items of this type will be a
                            Tcl set command that will recreate the value of
                            the variable at the time the item was created.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>RING_FORMAT</varname>
                            <initializer>12</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>DataFormat</type> ring item.  These items
                            describe the format of the items in the ring in terms
                            of the first version of NSCLDAQ capable of decoding
                            them.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>PERIODIC_SCALERS</varname>
                            <initializer>20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>ScalerItem</type> ring item.  These items
                            contain data from periodically read scalers.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type><varname>PHYSICS_EVENT</varname>
                            <initializer>30</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>PhysicsEventItem</type> ring item.
                            These items contain physics event data.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type>
                            <varname>PHYSICS_EVENT_COUNT</varname>
                            <initializer>31</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>PhysicsEventCountItem</type> ring item.
                            these items contain information about the number
                            of triggers that have been accepted thus far into
                            the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type>
                            <varname>EVB_FRAGMENT</varname>
                            <initializer>40</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>EventBuilderFragment</type> ring item.
                            These are used to encapsulate event fragments
                            that have been ordered by the time ordering phase
                            of the event builder pipeline.  Note that
                            These are typically only visible in the
                            order monitoring ring.
                        </para>
                        <para>
                            Items of this type are believed to have
                            payloads that look like ring items.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint32_t</type>
                            <varname>EVB_UNKNOWN_PAYLOAD</varname>
                            <initializer>41</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>EventBuilderFragment</type> whose payload
                            looks like it probably is not a ring item.
                            Note that form of the payload of
                            an event builder fragment
                            can only be guessed at not known with certainty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                        <modifier>static const</modifier><type>uint32_t</type>
                        <varname>EVB_GLOM_INFO</varname>
                        <initializer>42</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <varname>s_type</varname> value in the
                            <type>RingItemHeader</type> of a
                            <type>GlomParameters</type> ring item.  This type
                            of ring item is used by the <firstterm>glomming</firstterm>
                            phase of the event builder to describe the
                            parameters being used to build events.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                        <modifier>static const</modifier>
                        <type>uint32_t</type><varname>FIRST_USER_ITEM_CODE</varname>
                        <initializer>32768</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            There is nothing sacred about the specifific set of
                            ring items defined by <filename>DataFormat.h</filename>
                            users can define application specific ring items.
                            In order to do so without present and future
                            collisions in ring item types with standardf
                            values, users should allocate ring item types from
                            types that are no less than
                            <varname>FIRST_USER_ITEM_CODE</varname>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint16_t</type><varname>GLOM_TIMESTAMP_FIRST</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A possible value for the timestamp policy of the
                            glom format ring item.  This value means the
                            output event timestamps are filled  in from the
                            fragment with the smallest timestamp value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint16_t</type><varname>GLOM_TIMESTAMP_LAST</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A possible value for the timestamp policy of the
                            glom format ring item.  This value means the
                            output event timestamps are filled  in from the
                            fragment with the largest timestamp value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>
                            <type>uint16_t</type><varname>GLOM_TIMESTAMP_AVERAGE</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A possible value for the timestamp policy of the
                            glom format ring item.  This value means the
                            output event timestamps are filled  in from the
                            average of all timestamps in fragments in the event.
                        </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term>
                        <literal>#define TITLE_MAXSIZE 80</literal></term>
                    <listitem>
                        <para>
                            Defines the maximum number of characters in a
                            Run State change item's title field.
                        </para>
                    </listitem>
                </varlistentry>
               </variablelist>
            </refsect1>
         </refentry>
        <refentry id="dataformat3-formatfunctions">
          <refmeta>
             <refentrytitle>format  Functions</refentrytitle>
             <manvolnum>3dataformat</manvolnum>
          </refmeta>
          <refnamediv>
             <refname>format Functions</refname>
             <refpurpose>Functions to create ring items.</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
            <programlisting>
#include &lt;DataFormat.h&gt;
            </programlisting>
            <funcsynopsis>
            <funcprototype><funcdef><type>pPhysicsEventItem</type> <function>formatEventitem</function></funcdef>
            <paramdef>
              <parameter><type>size_t</type> nWords</parameter></paramdef>
            <paramdef>
                <parameter><type>void*</type> pPayload</parameter>
            </paramdef>
            </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
               <funcprototype><funcdef><type>pPhysicsEventCountItem</type> <function>formatTriggerCountItem </function></funcdef>
               <paramdef>
                  <parameter><type>uint32_t </type>runTime</parameter>
               </paramdef>
               <paramdef>
                <parameter><type>time_t</type>timeStamp</parameter>
               </paramdef>
               <paramdef>
                <parameter><type>uint64_t</type>triggerCount</parameter>
               </paramdef>
               </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
            	<funcprototype><funcdef><type>pScalerItem</type> <function>
                    formatScalerItem
                </function></funcdef>
                <paramdef>
                   <parameter><type>unsigned  </type>scalerCount </parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>time_t</type>timestamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> btime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32</type>etime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>void*</type> pCounters</parameter>
                </paramdef>
               </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype><funcdef><type>pTextItem</type> <function>formatTextItem </function></funcdef>
                <paramdef>
                   <parameter><type>unsigned  </type>nStrings </parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>time_t</type> stamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> runTime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>const char**</type> pStrings</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>int</type> type</parameter>
                </paramdef>
               </funcprototype>
            </funcsynopsis> 
            <funcsynopsis>
                <funcprototype><funcdef><type>pStateChangeItem</type>
                <function>formatStateChange </function></funcdef>
                <paramdef>
                   <parameter><type>time_t  </type>stamp </parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> offset</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t </type> runNumber</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>const char*</type> pTitle</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uin32_t</type> type</parameter>
                </paramdef>
                
                </funcprototype>
            </funcsynopsis>
   
            <!-- added in 11.0 -->
            <funcsynopsis>
                <funcprototype><funcdef><type>pScalerItem</type>
                <function>formatNonIncrTSScalerItem</function></funcdef>
                <paramdef>
                    <parameter><type>unsigned</type> scalerCount</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>time_t</type> timestamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> btime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type>  etime</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint64_t</type> eventTimestamp</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>void*</type> pCounters</parameter>
                </paramdef>
                <paramdef>
                    <parameter><type>uint32_t</type> timebaseDivisor</parameter>
                </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                <funcdef><type>pDataFormat</type><function>formatDataFormat</function>
                </funcdef>
                <void />
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef><type>pGlomParameters</type>
                        <function>formatGlomParameters</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> coincidenceWindow</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type>isBuilding</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type>timestampPolicy</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef><type>pEventBuilderFragment</type>
                        <function>formatEVBFragment</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> payloadSize</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const void*</type>
                        pPayload</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef><type>pEventBuilderFragment</type>
                        <function>formatEVBFragmentUnknown</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t timestamp</type></parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> payloadSize</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const void*</type> pPayload</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pPhysicsEventItem</type>
                        <function>formatTimestampedEventItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> payloadSize</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const void*</type> pPayload</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pPhysicsEventCountItem</type>
                        <function>formatTimestampedTriggerCountItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> runTime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> offsetDivisor</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>time_t</type> stamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> triggerCount</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pScalerItem</type>
                        <function>formatTimestampedScalerItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type>timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type> isIncremental</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> timeofday</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> btime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> etime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> nScalers</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>void*</type> pCounters</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pTextItem</type>
                        <function>formatTimestampedTextItem</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>unsigned</type> nStrings</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>time_t</type> stamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> runTime</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const char**</type>pStrings</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type> type</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis> 
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>pStateChangeItem</type>
                        <function>formatTimestampedStateChange</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>uint64_t</type> timestamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> sourceId</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> barrier</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>time_t</type> stamp</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> offset</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> runNumber</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>uint32_t</type> offsetDivisor</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>const char*</type> pTitle</parameter>
                    </paramdef>
                    <paramdef>
                        <parameter><type>int</type> type</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>
            <funcsynopsis>
                <funcprototype>
                    <funcdef>
                        <type>void*</type> <function>bodyPointer</function>
                    </funcdef>
                    <paramdef>
                        <parameter><type>pRingItem</type> pItem</parameter>
                    </paramdef>
                </funcprototype>
            </funcsynopsis>

            <!-- end of 11.0 additions -->
   
   

          </refsynopsisdiv>
          <refsect1>
             <title>
            DESCRIPTION
             </title>
             <para>
                These functions produce dynamically allocated ring items
                that reflect the parameters that have been passed to them.
                All functions that create ring items use
                <literal>malloc(3)</literal> to allocate storage.  When you
                no longer need an item you must <literal>free(3)</literal>
                the item to prevent memory leaks.
             </para>
             <variablelist>
                <varlistentry>
                    <term>
                        <funcsynopsis>
                        <funcprototype><funcdef><type>pPhysicsEventItem</type> <function>formatEventitem</function></funcdef>
                        <paramdef>
                          <parameter><type>size_t</type> nWords</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>void*</type> pPayload</parameter>
                        </paramdef>
                        </funcprototype>
                        </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a <literal>PHYSICS_EVENT</literal> ring item.
                            <parameter>nWords</parameter> is the number of
                            <type>uint16_t</type> objects that are in the event
                            data pointed to by <parameter>pPayload</parameter>.
                            When the ring item is created, a <type>uint32_t</type>
                            containing <literal>nWords + 2</literal> is inserted
                            prior to the payload to conform to NSCL standards
                            for the payload contents.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis>
                           <funcprototype><funcdef><type>pPhysicsEventCountItem</type> <function>formatTriggerCountItem </function></funcdef>
                           <paramdef>
                              <parameter><type>uint32_t </type>runTime</parameter>
                           </paramdef>
                           <paramdef>
                            <parameter><type>time_t</type>timeStamp</parameter>
                           </paramdef>
                           <paramdef>
                            <parameter><type>uint64_t</type>triggerCount</parameter>
                           </paramdef>
                           </funcprototype>
                        </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a <literal>PHYSICS_EVENT_COUNT</literal> ring
                            item.  <parameter>runTime</parameter> should be the
                            number of seconds into the run the items is emitted.
                            <parameter>timeStamp</parameter> should be the unix
                            <function>time(2)</function> at which the event
                            count is being submittted and <parameter>triggerCount</parameter>
                            is the total number of event triggers that have been
                            created by this point in the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis>
                            <funcprototype><funcdef><type>pScalerItem</type> <function>
                                formatScalerItem
                            </function></funcdef>
                            <paramdef>
                               <parameter><type>unsigned  </type>scalerCount </parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>time_t</type>timestamp</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32_t</type> btime</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32</type>etime</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>void*</type> pCounters</parameter>
                            </paramdef>
                           </funcprototype>
                        </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a scaler ring item (<literal>INCREMENTAL_SCALERS</literal>).
                            <parameter>scalerCount</parameter> is the number of
                            scalers read out and <parameter>pCounters</parameter>
                            points to an array of <type>uint32_t</type> scalers.
                            <parameter>btime</parameter> and <parameter>etime</parameter>
                            are respectively the beginning and end run offsets
                            over which the scalers counted.
                        </para>
                        <para>
                            <parameter>timestamp</parameter> is the time at which the
                            scaler data was read.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis>
                        <funcprototype><funcdef><type>pTextItem</type> <function>formatTextItem </function></funcdef>
                        <paramdef>
                           <parameter><type>unsigned  </type>nStrings </parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>time_t</type> stamp</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>uint32_t</type> runTime</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>const char**</type> pStrings</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>int</type> type</parameter>
                        </paramdef>
                       </funcprototype>
                    </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates a text ring item.  The type of the
                            ring items is provided by the <parameter>type</parameter>
                            argument however this should be one of
                            <literal>PACKET_TYPES</literal> or
                            <literal>MONITORED_VARIABLES</literal>
                            or a user type that is larger than
                            <literal>FIRST_USER_ITEM_CODE</literal>.
                        </para>
                        <para>
                            The number of strings put in the item are
                            <parameter>nStrings</parameter> and
                            <parameter>pStrings</parameter> is a pointer to an
                            array of pointers to the null terminated strings that
                            are put in the <varname>s_strings</varname> storage
                            of the ring item.
                        </para>
                        <para>
                            <parameter>stamp</parameter> is the unix
                            <function>time(2)</function> at which the
                            item was created and <parameter>runTime</parameter>
                            the number of seconds into the run at which this time
                            was created.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <funcsynopsis>
                        <funcprototype><funcdef><type>pStateChangeItem</type>
                        <function>formatStateChange </function></funcdef>
                        <paramdef>
                           <parameter><type>time_t  </type>stamp </parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>uint32_t</type> offset</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>uint32_t </type> runNumber</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>const char*</type> pTitle</parameter>
                        </paramdef>
                        <paramdef>
                            <parameter><type>uin32_t</type> type</parameter>
                        </paramdef>
                        
                        </funcprototype>
                    </funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Formats and returns a state change item.
                            State change items reflect a change in the run state.
                            While the <parameter>type</parameter> parameter
                            provides the item type, this should normally be one of
                            <literal>BEGIN_RUN</literal>,
                            <literal>END_RUN</literal>,
                            <literal>PAUSE_RUN</literal> or
                            <literal>RESUME_RUN</literal>.
                        </para>
                        <para>
                            <parameter>runNumber</parameter> should be a
                            unique run number for the run and
                            <parameter>pTitle</parameter> should point to a
                            null terminated title string.
                        </para>
                        <para>
                            <parameter>offset</parameter> is the time into the
                            run at which the state change took place in seconds.
                            This will be <literal>0</literal> for
                            <literal>BEGIN_RUN</literal> and the number of
                            seconds the run was active for
                            <literal>END_RUN</literal>
                        </para>
                        <para>
                            Finally <parameter>stamp</parameter> is the unix
                            absolute timestamp from <function>time(2)</function>
                            at which the state change occured.
                        </para>
                    </listitem>
                </varlistentry>
                        <!-- added in 11.0 -->
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype><funcdef><type>pScalerItem</type>
                            <function>formatNonIncrTSScalerItem</function></funcdef>
                            <paramdef>
                                <parameter><type>unsigned</type> scalerCount</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>time_t</type> timestamp</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32_t</type> btime</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32_t</type>  etime</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint64_t</type> eventTimestamp</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>void*</type> pCounters</parameter>
                            </paramdef>
                            <paramdef>
                                <parameter><type>uint32_t</type> timebaseDivisor</parameter>
                            </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Formats a scaler ring item
                                (<type>ScalerItem</type>) into dynamically
                                allocated data and returns a pointer to the
                                formatted item.  The item will be created with
                                the <varname>s_incremental</varname> flag of
                                the body turned off.  This is intended for
                                compatibility with code written for NSCLDAQ
                                11.1-100.
                                New code should just use
                                <function>formatTimestampedScalerItem</function>
                            </para>
                            <para>
                                The scalers are defined by
                                <parameter>scalerCount</parameter> which
                                provides the number of scalers and
                                <parameter>pCounters</parameter> which is
                                a pointer to an array of scaler values.
                                The <parameter>timestamp</parameter>,
                                <parameter>btime</parameter> and
                                <parameter>etime</parameter> values have
                                the same meaning as for
                                <function>formatScalerItem</function>
                            </para>
                            <para>
                                <parameter>eventTimestamp</parameter>
                                associates an event timestamp value with the
                                scaler item, forcing the creation of a
                                body header.  The source id and barrier type
                                of that header are both set to zero.
                            </para>
                            <para>
                                <parameter>timebaseDivisor</parameter> supports
                                <parameter>btime</parameter> and
                                <parameter>etime</parameter> parameters that have
                                resolutions less than one second.
                                The run time in seconds is gotten by
                                doing a floating point division of either of the
                                time parameters by <parameter>timebaseDivisor</parameter>
                                For example, if <parameter>btime</parameter> is
                                <literal>10</literal> and
                                <parameter>timebaseDivisor</parameter> is 4,
                                the run time is <literal>2.5</literal> seconds>
                            </para>
                            <para>
                                Note that as with all of these functions,
                                the resulting pointer is to dynamically allocated
                                memor that must be released via a call to
                                <literal>free(3)</literal>,
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                            <funcdef><type>pDataFormat</type><function>formatDataFormat</function>
                            </funcdef>
                            <void />
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Formats a <type>DataFormat</type> ring item
                                into dynamically allocated memory. A pointer
                                to the resulting ring item is returned as the
                                function value.  The caller must
                                <literal>free(3)</literal>
                            </para>
                            <para>
                                The function takes the values to put in this
                                data item from the <constant>FORMAT_MAJOR</constant>
                                and <constant>FORMAT_MINOR</constant> constant
                                values defined in <filename>DataFormat.h</filename>
                                at the time it was compiled.
                                </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef><type>pGlomParameters</type>
                                    <function>formatGlomParameters</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> coincidenceWindow</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type>isBuilding</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type> timestampPolicy</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Dynamically creates a <type>GlomParameters</type>
                                ring item and returns a pointer to it.
                                The <parameter>coincidenceWindow</parameter>
                                parameter determines the value of the
                                <varname>s_coincidenceTicks</varname> field
                                and the <parameter>isBuilding</parameter>
                                parameter determiens the value
                                of the <varname>s_isBuilding</varname> field.
                                <parameter>timestampPolicy</parameter> is used to
                                fill in the <varname>s_timestampPolicy</varname> field.
                            </para>
                            <para>
                                The item must be released by the caller
                                via a call to <literal>free(3)</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef><type>pEventBuilderFragment</type>
                                    <function>formatEVBFragment</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> payloadSize</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const void*</type>
                                    pPayload</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Formats an event builder frragment item with
                                type <constant>EVB_FRAGMENT</constant>.
                                The item is dynamically allocated and must be
                                passed to <literal>free(3)</literal> to be
                                released.
                            </para>
                            <para>
                                The contents of the ring item are as follows:
                                The ring item body header is filled in from
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>.
                                The event fragment payload size in bytes is
                                <parameter>payloadSize</parameter> and the
                                payload itself is copied in from
                                <parameter>pPayload</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef><type>pEventBuilderFragment</type>
                                    <function>formatEVBFragmentUnknown</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t timestamp</type></parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> payloadSize</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const void*</type> pPayload</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This performs the same operation as
                                <function>formatEVBFragment</function> however
                                the ring item is given the type
                                <literal>EVB_UNKNOWN_PAYLOAD</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pPhysicsEventItem</type>
                                    <function>formatTimestampedEventItem</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> payloadSize</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const void*</type> pPayload</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates an event ring item that has a full body
                                header.  The body header contents are determined
                                by the <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter> parameters.
                                The contents of the event are <parameter>payloadSize</parameter>
                                words (16 bit words) long and are pointed to by
                                <parameter>pPayload</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pPhysicsEventCountItem</type>
                                    <function>formatTimestampedTriggerCountItem</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> runTime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> offsetDivisor</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>time_t</type> stamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> triggerCount</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates a trigger count ring item that has a full
                                body header.  The body header allows trigger counts
                                to be accumulated from several event sources.
                                The body header is filled in from
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>
                            </para>
                            <para>
                                The <parameter>runTime</parameter> and
                                <parameter>offsetDivisor</parameter> provide
                                for sub-second timing information. The
                                offset into the run in floating point seconds
                                is given by the expression
                                <literal>runTime/offsetDivisor</literal>
                            </para>
                            <para>
                                <parameter>stamp</parameter> is the unix
                                <type>time_t</type> that describes the absolute
                                time at which this item was created.  The
                                <parameter>triggerCount</parameter> item is the
                                total number of triggers the <parameter>sourceId</parameter>
                                has responded to since the beginnin of the run
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pScalerItem</type>
                                    <function>formatTimestampedScalerItem</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type>timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type> isIncremental</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> timeofday</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> btime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> etime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> nScalers</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>void*</type> pCounters</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates a scaler ring item with a full body header.
                                Scaler readout can be incremental or not and
                                the time offsets for the start and end times
                                (<parameter>btime</parameter>> and <parameter>etime</parameter>)
                                of the counting interval use
                                <parameter>timeIntervalDivisor</parameter> to
                                supply sub-second time resolution.
                            </para>
                            <para>
                                The body header values are determined by
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>.
                            </para>
                            <para>
                                If <parameter>isIncremental</parameter>
                                is true (nonzero), the scaler values are incremental.
                                Incremental scaler values represent the number
                                of counts during the <parameter>btime</parameter>
                                <parameter>etime</parameter> interval only.
                            </para>
                            <para>
                                If <parameter>isIncremental</parameter>
                                is false (zero), the scaler values are
                                cumulative and represent the total number of
                                counts since the start of the run. 
                            </para>
                            <para>
                                The scalers themselves are pointed to by
                                <parameter>pCounters</parameter> and
                                <parameter>nScalers</parameter> tells you how
                                many there are.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pTextItem</type>
                                    <function>formatTimestampedTextItem</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>unsigned</type> nStrings</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>time_t</type> stamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> runTime</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const char**</type>pStrings</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type> type</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> timeIntervalDivisor</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates a text list item with a full body header.
                                The type of the ring item is determined by
                                <parameter>type</parameter>.  It should be one
                                of <literal>PACKET_TYPES</literal>,
                                <literal>MONITORED_VARIABLES</literal> or a
                                user defined type.
                            </para>
                            <para>
                                The body header contents are determined
                                by
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>
                            </para>
                            <para>
                                The time into the run at which this item
                                was emitted in in floating point seconds is
                                <parameter>runTime</parameter>/<parameter>timeIntervalDivisor</parameter>.
                                The absolute time at which the item was created
                                is <parameter>stamp</parameter> which is a
                                Unix <type>time_t</type> value.
                            </para>
                            <para>
                                The number of strings is <parameter>nStrings</parameter>.
                                <parameter>pStrings</parameter> is an array
                                of pointers to each string, which must be
                                null terminated like all Unix strings.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>pStateChangeItem</type>
                                    <function>formatTimestampedStateChange</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>uint64_t</type> timestamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> sourceId</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> barrier</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>time_t</type> stamp</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> offset</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> runNumber</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>uint32_t</type> offsetDivisor</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>const char*</type> pTitle</parameter>
                                </paramdef>
                                <paramdef>
                                    <parameter><type>int</type> type</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Creates a state change item that has a complete
                                body header.  The <parameter>type</parameter>
                                parameter is the ring item type and should be
                                any of <literal>BEGIN_RUN</literal>,
                                <literal>END_RUN</literal>,
                                <literal>PAUSE_RUN</literal> or
                                <literal>RESUME_RUN</literal> or a user
                                defined ring item type if appropriate.
                            </para>
                            <para>
                                The body header is determine by
                                <parameter>timestamp</parameter>,
                                <parameter>sourceId</parameter> and
                                <parameter>barrier</parameter>
                            </para>
                            <para>
                                The Offset into the run at which this item
                                was emitted in seconds is:
                                <parameter>offset/offsetDivisor</parameter>.
                                The <parameter>stamp</parameter> parameter
                                is the Unix <type>time_t</type> that specifies
                                the absolute time at which the item was emitted.
                            </para>
                            <para>
                                Information about the run is also provided.
                                <parameter>runNumber</parameter> is the number
                                of the run and <parameter>pTitle</parameter>
                                points to the null terminated title string.
                            </para>
                            
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis>
                            <funcprototype>
                                <funcdef>
                                    <type>void*</type> <function>bodyPointer</function>
                                </funcdef>
                                <paramdef>
                                    <parameter><type>pRingItem</type> pItem</parameter>
                                </paramdef>
                            </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The pointer to the actual body of an item
                                depends on whether or not a body header is present
                                in the item.  This function will return a pointer
                                to the body of a ring item <parameter>pItem</parameter>
                                taking this into account.
                            </para>
                        </listitem>
                    </varlistentry>
                        <!-- end of 11.0 additions -->
                              
                         </variablelist>
          </refsect1>
          <refsect1>
            <title>RETURNS</title>
            <para>
                Pointers to dynamically allocated storage which has been
                filled in with the requested ring item.
                When the caller is done with the item it should pass it to 
                <function>free(3)</function> to release the storage.
            </para>
            <para>
                If storage could not be allocated for the ring  item
                <literal>NULL</literal> is returned instead.
            </para>
          </refsect1>
        </refentry>
	 <refentry id="daq3_cdatasource">
       <refmeta>
          <refentrytitle id='daq3_cdatasource_title'>CDataSource</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CDataSource</refname>
          <refpurpose>Abstract base class of data source for ring items.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <programlisting>
#include &lt;CDataSource.h&gt;
            </programlisting>
        <synopsis>
            <ooclass><classname>CDataSource</classname></ooclass>
           <constructorsynopsis>
          <methodname>CDataSource</methodname>
          <void />

           </constructorsynopsis>
           <methodsynopsis>
          <type>CRingItem*</type>
             <methodname>getItem</methodname>
             <void />
           </methodsynopsis>
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Abstract base class for a data source that returns ring items.
            This class cannot be instantiated because the public method
            <methodname>getItem</methodname> is pure virtual.  Normally
            one gets a pointer to a <classname>CDataSource</classname> object
            when creating a data source via
            <xref endterm='daq3_cdatasourcefactory' linkend='daq3_cdatasourcefactory_title' />.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
            <term>
                <methodsynopsis>
               <type>CRingItem*</type>
                  <methodname>getItem</methodname>
                  <void />
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This interface method will, for a concrete class, return a
                    pointer to an item received from the data source.  In the event
                    of an error, a <literal>NULL</literal> pointer will be
                    returned or alternatively an integer exception will be thrown.
                    If an integer exception is thrown its value will be a legitimate
                    error number from <literal>&lt;errno.h&gt;</literal>.
                    If a <literal>NULL</literal> is returned, the
                    <varname>errno</varname> variable should be checked to
                    determine if an end of data source condition or some other
                    error occured.  For an end of source condition, the
                    <varname>errno</varname> value will be <literal>ESUCCESS</literal>
                </para>
            </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     

	 <refentry id="daq3_cringdatasource">
       <refmeta>
          <refentrytitle id="daq3_cringdatasource_title">CRingDataSource</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CRingDataSource</refname>
          <refpurpose>Ringbuffer data source for ring items.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <programlisting>
#include &lt;CRingDataSource.h&gt;
            </programlisting>
        <synopsis>
            <ooclass><classname>CRingDataSource</classname></ooclass>
           <constructorsynopsis>
          <methodname>CRingDataSource</methodname>
          <methodparam>
            <type>URL&amp;</type> <parameter>url</parameter>
          </methodparam>
          <methodparam>
            <type>std::vector&lt;uint16_t&gt;</type>
            <parameter>exclusionList</parameter>
          </methodparam>
          <methodparam>
            <type>std::vector&lt;uint16_t&gt;</type>
            <parameter>sampleList</parameter>
          </methodparam>
           </constructorsynopsis>
           <methodsynopsis>
          <type>CRingItem*</type>
             <methodname>getItem</methodname>
             <void />
           </methodsynopsis>
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Concrete <classname>CDataSource</classname> class that implements
            a source of ring items from a live ring.  See the <literal>METHODS</literal>
            section below for more information about how to create and use
            this data source directly.  Note that a more convenient mechanism
            for generating these data sources is via the
            <classname>CDataSourceFactory</classname> class.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                   <methodname>CRingDataSource</methodname>
                   <methodparam>
                     <type>URL&amp;</type> <parameter>url</parameter>
                   </methodparam>
                   <methodparam>
                     <type>std::vector&lt;uint16_t&gt;</type>
                     <parameter>exclusionList</parameter>
                   </methodparam>
                   <methodparam>
                     <type>std::vector&lt;uint16_t&gt;</type>
                     <parameter>sampleList</parameter>
                   </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CRingDataSource</classname> object.
                        <parameter>url</parameter> specifies the ring from which
                        data is desired.  This can be a local or remote ring.
                        The url protocol must be a <literal>tcp:</literal>.
                    </para>
                    <para>
                        <parameter>exclusionList</parameter> specifies a
                        list of ring item types that will not be passed to the
                        client via <methodname>getItem</methodname>
                    </para>
                    <para>
                        <parameter>sampleList</parameter> speicfies a list
                        of ring item types that will be sampled from the ring.
                        Item types in this vector may be skipped if the client
                        application falls behind in processing the ring buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                   <type>CRingItem*</type>
                      <methodname>getItem</methodname>
                      <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the next suitable item from the ring.  This method
                        will block until a suitable item is available.  Suitability
                        is defined by the <parameter>exclusionList</parameter>
                        and <parameter>sampleList</parameter> of item types
                        provided whent he data source was constructed taken with
                        the ring backlog.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     

      <refentry id="daq3_cfiledatasource">
       <refmeta>
          <refentrytitle id="daq3_cfiledatasource_title">CFileDataSource</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CFileDataSource</refname>
          <refpurpose>Ring item data source from a file</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <classsynopsis>
            <ooclass><classname>CFileDataSource</classname></ooclass>
           <constructorsynopsis>
          <methodname>CFileDataSource</methodname>
          <methodparam>
            <type>URL&amp;</type> <parameter>url</parameter>
          </methodparam>
          <methodparam>
            <type>std::vector&lt;uint16_t&gt;</type> <parameter>exclusionList</parameter>
          </methodparam>
          
           </constructorsynopsis>
           <methodsynopsis>
          <type>CRingItem*</type>
             <methodname>getItem</methodname>
             <void />
           </methodsynopsis>
        </classsynopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Provides a source of ring items from a file.  For information about
            how to directly create and use this object see <literal>METHODS</literal>
            below.  The normal way to create a data source object, however is to
            use <classname>CDataSourceFactory</classname> to create the correct
            type of data source from a URI
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                      <methodname>CFileDataSource</methodname>
                      <methodparam>
                        <type>URL&amp;</type> <parameter>url</parameter>
                      </methodparam>
                      <methodparam>
                        <type>std::vector&lt;uint16_t&gt;</type> <parameter>exclusionList</parameter>
                      </methodparam>                    
                     </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a file data source.
                        <parameter>url</parameter> determines which file data
                        will be read from.  The url must have a
                        <literal>file:</literal> protocol specified.
                    </para>
                    <para>
                        <parameter>exclusionList</parameter> is a list of data
                        item types that will not be passed to the caller
                        by <methodname>getItem</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                    <type>CRingItem*</type>
                       <methodname>getItem</methodname>
                       <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Gets the next ring item from the file whose type is not
                        a type in the constructor's <parameter>exclusionList</parameter>.
                    </para>
                </listitem>
            </varlistentry>             
          </variablelist>
       </refsect1>
     </refentry>
      
     <refentry id="daq3_cdatasourcefactory">
       <refmeta>
          <refentrytitle id="daq3_cdatasourcefactory_title">CDataSourceFactory"</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CDataSourceFactory</refname>
          <refpurpose>Create data sources given a URI</refpurpose>
       </refnamediv>
       <refsynopsisdiv>
            <programlisting>
#include &lt;CDataSourceFactory&gt;
            </programlisting>
        <synopsis>
            <ooclass><classname>CDataSourceFactory</classname></ooclass>
           <methodsynopsis>
            <modifier>static</modifier>
            <type>CDataSource*</type>
             <methodname>makeSource</methodname>
             <methodparam>
                <type>std::string</type>
                <parameter>uri</parameter>
             </methodparam>
             <methodparam>
                <type>std::vector&lt;uint16_t&gt;</type>
                <parameter>sample</parameter>
             </methodparam>
             <methodparam>
                <type>std::vector&lt;uint16_t&gt;</type>
                <parameter>exclude</parameter>
             </methodparam>
           </methodsynopsis>
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This factory class contains a static method to create a ring item
            data source given a URI.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>static</modifier>
                     <type>CDataSource*</type>
                      <methodname>makeSource</methodname>
                      <methodparam>
                         <type>std::string</type>
                         <parameter>uri</parameter>
                      </methodparam>
                      <methodparam>
                         <type>std::vector&lt;uint16_t&gt;</type>
                         <parameter>sample</parameter>
                      </methodparam>
                      <methodparam>
                         <type>std::vector&lt;uint16_t&gt;</type>
                         <parameter>exclude</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new data source object and returns a pointer
                        to it.  The <classname>CDataSource</classname> object
                        created is dynamically allocated and needs to be
                        deleted by the caller.
                    </para>
                    <para>
                        <literal>uri</literal> describes the data source.
                        For a live ring this should be of the form
                        <literal>tcp://hostname/ringname</literal>
                        For a file ring this shouild be of the form
                        <literal>file:///path/to/the/file</literal>.
                    </para>
                    <para>
                        <parameter>sample</parameter> is a vector of ring item
                        types.  Ring data sources are free to skip items of this
                        type depending on circumstances.
                    </para>
                    <para>
                        <parameter>exclde</parameter> is a vector of
                        ring item types the caller does not want to get from the
                        data source.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>
    <refentry id="daq3_cringitemfactory">
       <refmeta>
          <refentrytitle id="daq3_cringitemfactory_title">CRingItemFactory</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CRingItemFactory</refname>
          <refpurpose>Upcast ring items to specific ring item objects.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <programlisting>
#include &lt;CRingItemFactory.h&gt;
            </programlisting>
        <synopsis>
            <ooclass><classname>CRingItemFactory</classname></ooclass>
           <methodsynopsis>
            <modifier>static</modifier>
            <type>CRingItem*</type>
             <methodname>createRingItem</methodname>
             <methodparam>
                <modifier>const</modifier><type>CRingItem&amp;</type>
                <parameter>item</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>CRingItem*</type>
                <methodname>createRingItem</methodname>
                <methodparam>
                    <modifier>static</modifier><type>void*</type>
                    <parameter>pItem</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type>
                <methodname>
                    isKnownItemType
                </methodname>
                <methodparam>
                   <modifier>const</modifier>
                   <type>void*</type>
                   <parameter>pItem</parameter>
                </methodparam>
             </methodsynopsis>
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
             <classname>CRingItem</classname>
             provides a set of static methods that
             allow you to upcast ring items to actual
             underlying ring item types.  In general you
             will validate the item type via
             <methodname>isKnownItemType</methodname>
             and then invoke one o f the 
             <methodname>createRingItem</methodname>
             methods.   Finally if you need to
             use an item specific methods, you would do a
             <literal>reinterpret_cast</literal> to 
             the correct subclass of <classname>CRingItem</classname>.
          </para>
          <para>
             See <literal>METHODS</literal> below for more
             information about these functions.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
             <varlistentry>
                <term>
           <methodsynopsis>
            <modifier>static</modifier>
            <type>CRingItem*</type>
             <methodname>createRingItem</methodname>
             <methodparam>
                <modifier>const</modifier><type>CRingItem&amp;</type>
                <parameter>item</parameter>
             </methodparam>
            </methodsynopsis>
                 </term>
                 <listitem>
                    <para>
                       Creates the appropriate ring item
                       given a reference to a base class
                       ring item.  A pointer is returned
                       to the resulting object.  The
                       object is dynamically allocated
                       and therefore must be 
                       deleted by the caller.
                    </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>CRingItem*</type>
                <methodname>createRingItem</methodname>
                <methodparam>
                    <modifier>static</modifier><type>void*</type>
                    <parameter>pItem</parameter>
                </methodparam>
            </methodsynopsis>
                   </term>
                   <listitem>
                      <para>
                          Creates the appropriet ring item
                          given a pointer to storage that
                          is believed to contain a 
                          <type>RingItem</type> struct
                          as defined in 
                          <filename>DataFormat.h</filename>
                      </para>
                      <para>
                          The only difference between this
                          and the previous method is the
                          parameter type.
                      </para>
                   </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type>
                <methodname>
                    isKnownItemType
                </methodname>
                <methodparam>
                   <modifier>const</modifier>
                   <type>void*</type>
                   <parameter>pItem</parameter>
                </methodparam>
             </methodsynopsis>
                    </term>
                    <listitem>
                       <para>
                           If <parameter>pItem</parameter>
                           points to a 
                           <type>RingItem</type>
                           of a type known to the factory,
                           this method returns
                           <literal>true</literal>,
                           otherwise, <literal>false</literal>
                        </para>
                        <para>
                           The creational methods of the
                           factory will return a generic
                           ring item if they don't recognize
                           the ring type.
                        </para>
                      </listitem>
                  </varlistentry>
          </variablelist>
       </refsect1>

     </refentry>        

<!-- /manpage  -->